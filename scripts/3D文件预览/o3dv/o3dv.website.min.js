var OV = (()=>{
    var fx = Object.create;
    var Fu = Object.defineProperty;
    var dx = Object.getOwnPropertyDescriptor;
    var px = Object.getOwnPropertyNames;
    var mx = Object.getPrototypeOf
      , gx = Object.prototype.hasOwnProperty;
    var vx = (r,e)=>()=>(e || r((e = {
        exports: {}
    }).exports, e),
    e.exports)
      , mg = (r,e)=>{
        for (var t in e)
            Fu(r, t, {
                get: e[t],
                enumerable: !0
            })
    }
      , gg = (r,e,t,n)=>{
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of px(e))
                !gx.call(r, i) && i !== t && Fu(r, i, {
                    get: ()=>e[i],
                    enumerable: !(n = dx(e, i)) || n.enumerable
                });
        return r
    }
    ;
    var yx = (r,e,t)=>(t = r != null ? fx(mx(r)) : {},
    gg(e || !r || !r.__esModule ? Fu(t, "default", {
        value: r,
        enumerable: !0
    }) : t, r))
      , xx = r=>gg(Fu({}, "__esModule", {
        value: !0
    }), r);
    var Wy = vx((ed,Zm)=>{
        (function(r, e) {
            typeof ed == "object" && typeof Zm == "object" ? Zm.exports = e() : typeof define == "function" && define.amd ? define([], e) : typeof ed == "object" ? ed.Pickr = e() : r.Pickr = e()
        }
        )(self, function() {
            return (()=>{
                "use strict";
                var r = {
                    d: (P,C)=>{
                        for (var L in C)
                            r.o(C, L) && !r.o(P, L) && Object.defineProperty(P, L, {
                                enumerable: !0,
                                get: C[L]
                            })
                    }
                    ,
                    o: (P,C)=>Object.prototype.hasOwnProperty.call(P, C),
                    r: P=>{
                        typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(P, Symbol.toStringTag, {
                            value: "Module"
                        }),
                        Object.defineProperty(P, "__esModule", {
                            value: !0
                        })
                    }
                }
                  , e = {};
                r.d(e, {
                    default: ()=>B
                });
                var t = {};
                function n(P, C, L, F, U={}) {
                    C instanceof HTMLCollection || C instanceof NodeList ? C = Array.from(C) : Array.isArray(C) || (C = [C]),
                    Array.isArray(L) || (L = [L]);
                    for (let W of C)
                        for (let K of L)
                            W[P](K, F, {
                                capture: !1,
                                ...U
                            });
                    return Array.prototype.slice.call(arguments, 1)
                }
                r.r(t),
                r.d(t, {
                    adjustableInputNumbers: ()=>u,
                    createElementFromString: ()=>o,
                    createFromTemplate: ()=>a,
                    eventPath: ()=>l,
                    off: ()=>s,
                    on: ()=>i,
                    resolveElement: ()=>c
                });
                let i = n.bind(null, "addEventListener")
                  , s = n.bind(null, "removeEventListener");
                function o(P) {
                    let C = document.createElement("div");
                    return C.innerHTML = P.trim(),
                    C.firstElementChild
                }
                function a(P) {
                    let C = (F,U)=>{
                        let W = F.getAttribute(U);
                        return F.removeAttribute(U),
                        W
                    }
                      , L = (F,U={})=>{
                        let W = C(F, ":obj")
                          , K = C(F, ":ref")
                          , re = W ? U[W] = {} : U;
                        K && (U[K] = F);
                        for (let oe of Array.from(F.children)) {
                            let j = C(oe, ":arr")
                              , w = L(oe, j ? {} : re);
                            j && (re[j] || (re[j] = [])).push(Object.keys(w).length ? w : oe)
                        }
                        return U
                    }
                    ;
                    return L(o(P))
                }
                function l(P) {
                    let C = P.path || P.composedPath && P.composedPath();
                    if (C)
                        return C;
                    let L = P.target.parentElement;
                    for (C = [P.target, L]; L = L.parentElement; )
                        C.push(L);
                    return C.push(document, window),
                    C
                }
                function c(P) {
                    return P instanceof Element ? P : typeof P == "string" ? P.split(/>>/g).reduce((C,L,F,U)=>(C = C.querySelector(L),
                    F < U.length - 1 ? C.shadowRoot : C), document) : null
                }
                function u(P, C=L=>L) {
                    function L(F) {
                        let U = [.001, .01, .1][Number(F.shiftKey || 2 * F.ctrlKey)] * (F.deltaY < 0 ? 1 : -1)
                          , W = 0
                          , K = P.selectionStart;
                        P.value = P.value.replace(/[\d.]+/g, (re,oe)=>oe <= K && oe + re.length >= K ? (K = oe,
                        C(Number(re), U, W)) : (W++,
                        re)),
                        P.focus(),
                        P.setSelectionRange(K, K),
                        F.preventDefault(),
                        P.dispatchEvent(new Event("input"))
                    }
                    i(P, "focus", ()=>i(window, "wheel", L, {
                        passive: !1
                    })),
                    i(P, "blur", ()=>s(window, "wheel", L))
                }
                let {min: h, max: f, floor: m, round: g} = Math;
                function v(P, C, L) {
                    C /= 100,
                    L /= 100;
                    let F = m(P = P / 360 * 6)
                      , U = P - F
                      , W = L * (1 - C)
                      , K = L * (1 - U * C)
                      , re = L * (1 - (1 - U) * C)
                      , oe = F % 6;
                    return [255 * [L, K, W, W, re, L][oe], 255 * [re, L, L, K, W, W][oe], 255 * [W, W, re, L, L, K][oe]]
                }
                function p(P, C, L) {
                    let F = (2 - (C /= 100)) * (L /= 100) / 2;
                    return F !== 0 && (C = F === 1 ? 0 : F < .5 ? C * L / (2 * F) : C * L / (2 - 2 * F)),
                    [P, 100 * C, 100 * F]
                }
                function d(P, C, L) {
                    let F = h(P /= 255, C /= 255, L /= 255), U = f(P, C, L), W = U - F, K, re;
                    if (W === 0)
                        K = re = 0;
                    else {
                        re = W / U;
                        let oe = ((U - P) / 6 + W / 2) / W
                          , j = ((U - C) / 6 + W / 2) / W
                          , w = ((U - L) / 6 + W / 2) / W;
                        P === U ? K = w - j : C === U ? K = 1 / 3 + oe - w : L === U && (K = 2 / 3 + j - oe),
                        K < 0 ? K += 1 : K > 1 && (K -= 1)
                    }
                    return [360 * K, 100 * re, 100 * U]
                }
                function x(P, C, L, F) {
                    return C /= 100,
                    L /= 100,
                    [...d(255 * (1 - h(1, (P /= 100) * (1 - (F /= 100)) + F)), 255 * (1 - h(1, C * (1 - F) + F)), 255 * (1 - h(1, L * (1 - F) + F)))]
                }
                function y(P, C, L) {
                    C /= 100;
                    let F = 2 * (C *= (L /= 100) < .5 ? L : 1 - L) / (L + C) * 100
                      , U = 100 * (L + C);
                    return [P, isNaN(F) ? 0 : F, U]
                }
                function _(P) {
                    return d(...P.match(/.{2}/g).map(C=>parseInt(C, 16)))
                }
                function S(P) {
                    P = P.match(/^[a-zA-Z]+$/) ? function(U) {
                        if (U.toLowerCase() === "black")
                            return "#000";
                        let W = document.createElement("canvas").getContext("2d");
                        return W.fillStyle = U,
                        W.fillStyle === "#000" ? null : W.fillStyle
                    }(P) : P;
                    let C = {
                        cmyk: /^cmyk[\D]+([\d.]+)[\D]+([\d.]+)[\D]+([\d.]+)[\D]+([\d.]+)/i,
                        rgba: /^((rgba)|rgb)[\D]+([\d.]+)[\D]+([\d.]+)[\D]+([\d.]+)[\D]*?([\d.]+|$)/i,
                        hsla: /^((hsla)|hsl)[\D]+([\d.]+)[\D]+([\d.]+)[\D]+([\d.]+)[\D]*?([\d.]+|$)/i,
                        hsva: /^((hsva)|hsv)[\D]+([\d.]+)[\D]+([\d.]+)[\D]+([\d.]+)[\D]*?([\d.]+|$)/i,
                        hexa: /^#?(([\dA-Fa-f]{3,4})|([\dA-Fa-f]{6})|([\dA-Fa-f]{8}))$/i
                    }, L = U=>U.map(W=>/^(|\d+)\.\d+|\d+$/.test(W) ? Number(W) : void 0), F;
                    e: for (let U in C) {
                        if (!(F = C[U].exec(P)))
                            continue;
                        let W = K=>!!F[2] == (typeof K == "number");
                        switch (U) {
                        case "cmyk":
                            {
                                let[,K,re,oe,j] = L(F);
                                if (K > 100 || re > 100 || oe > 100 || j > 100)
                                    break e;
                                return {
                                    values: x(K, re, oe, j),
                                    type: U
                                }
                            }
                        case "rgba":
                            {
                                let[,,,K,re,oe,j] = L(F);
                                if (K > 255 || re > 255 || oe > 255 || j < 0 || j > 1 || !W(j))
                                    break e;
                                return {
                                    values: [...d(K, re, oe), j],
                                    a: j,
                                    type: U
                                }
                            }
                        case "hexa":
                            {
                                let[,K] = F;
                                K.length !== 4 && K.length !== 3 || (K = K.split("").map(j=>j + j).join(""));
                                let re = K.substring(0, 6)
                                  , oe = K.substring(6);
                                return oe = oe ? parseInt(oe, 16) / 255 : void 0,
                                {
                                    values: [..._(re), oe],
                                    a: oe,
                                    type: U
                                }
                            }
                        case "hsla":
                            {
                                let[,,,K,re,oe,j] = L(F);
                                if (K > 360 || re > 100 || oe > 100 || j < 0 || j > 1 || !W(j))
                                    break e;
                                return {
                                    values: [...y(K, re, oe), j],
                                    a: j,
                                    type: U
                                }
                            }
                        case "hsva":
                            {
                                let[,,,K,re,oe,j] = L(F);
                                if (K > 360 || re > 100 || oe > 100 || j < 0 || j > 1 || !W(j))
                                    break e;
                                return {
                                    values: [K, re, oe, j],
                                    a: j,
                                    type: U
                                }
                            }
                        }
                    }
                    return {
                        values: null,
                        type: null
                    }
                }
                function N(P=0, C=0, L=0, F=1) {
                    let U = (K,re)=>(oe=-1)=>re(~oe ? K.map(j=>Number(j.toFixed(oe))) : K)
                      , W = {
                        h: P,
                        s: C,
                        v: L,
                        a: F,
                        toHSVA() {
                            let K = [W.h, W.s, W.v, W.a];
                            return K.toString = U(K, re=>`hsva(${re[0]}, ${re[1]}%, ${re[2]}%, ${W.a})`),
                            K
                        },
                        toHSLA() {
                            let K = [...p(W.h, W.s, W.v), W.a];
                            return K.toString = U(K, re=>`hsla(${re[0]}, ${re[1]}%, ${re[2]}%, ${W.a})`),
                            K
                        },
                        toRGBA() {
                            let K = [...v(W.h, W.s, W.v), W.a];
                            return K.toString = U(K, re=>`rgba(${re[0]}, ${re[1]}, ${re[2]}, ${W.a})`),
                            K
                        },
                        toCMYK() {
                            let K = function(re, oe, j) {
                                let w = v(re, oe, j)
                                  , b = w[0] / 255
                                  , E = w[1] / 255
                                  , T = w[2] / 255
                                  , H = h(1 - b, 1 - E, 1 - T);
                                return [100 * (H === 1 ? 0 : (1 - b - H) / (1 - H)), 100 * (H === 1 ? 0 : (1 - E - H) / (1 - H)), 100 * (H === 1 ? 0 : (1 - T - H) / (1 - H)), 100 * H]
                            }(W.h, W.s, W.v);
                            return K.toString = U(K, re=>`cmyk(${re[0]}%, ${re[1]}%, ${re[2]}%, ${re[3]}%)`),
                            K
                        },
                        toHEXA() {
                            let K = function(oe, j, w) {
                                return v(oe, j, w).map(b=>g(b).toString(16).padStart(2, "0"))
                            }(W.h, W.s, W.v)
                              , re = W.a >= 1 ? "" : Number((255 * W.a).toFixed(0)).toString(16).toUpperCase().padStart(2, "0");
                            return re && K.push(re),
                            K.toString = ()=>`#${K.join("").toUpperCase()}`,
                            K
                        },
                        clone: ()=>N(W.h, W.s, W.v, W.a)
                    };
                    return W
                }
                let I = P=>Math.max(Math.min(P, 1), 0);
                function O(P) {
                    let C = {
                        options: Object.assign({
                            lock: null,
                            onchange: ()=>0,
                            onstop: ()=>0
                        }, P),
                        _keyboard(W) {
                            let {options: K} = C
                              , {type: re, key: oe} = W;
                            if (document.activeElement === K.wrapper) {
                                let {lock: j} = C.options
                                  , w = oe === "ArrowUp"
                                  , b = oe === "ArrowRight"
                                  , E = oe === "ArrowDown"
                                  , T = oe === "ArrowLeft";
                                if (re === "keydown" && (w || b || E || T)) {
                                    let H = 0
                                      , Y = 0;
                                    j === "v" ? H = w || b ? 1 : -1 : j === "h" ? H = w || b ? -1 : 1 : (Y = w ? -1 : E ? 1 : 0,
                                    H = T ? -1 : b ? 1 : 0),
                                    C.update(I(C.cache.x + .01 * H), I(C.cache.y + .01 * Y)),
                                    W.preventDefault()
                                } else
                                    oe.startsWith("Arrow") && (C.options.onstop(),
                                    W.preventDefault())
                            }
                        },
                        _tapstart(W) {
                            i(document, ["mouseup", "touchend", "touchcancel"], C._tapstop),
                            i(document, ["mousemove", "touchmove"], C._tapmove),
                            W.cancelable && W.preventDefault(),
                            C._tapmove(W)
                        },
                        _tapmove(W) {
                            let {options: K, cache: re} = C
                              , {lock: oe, element: j, wrapper: w} = K
                              , b = w.getBoundingClientRect()
                              , E = 0
                              , T = 0;
                            if (W) {
                                let X = W && W.touches && W.touches[0];
                                E = W ? (X || W).clientX : 0,
                                T = W ? (X || W).clientY : 0,
                                E < b.left ? E = b.left : E > b.left + b.width && (E = b.left + b.width),
                                T < b.top ? T = b.top : T > b.top + b.height && (T = b.top + b.height),
                                E -= b.left,
                                T -= b.top
                            } else
                                re && (E = re.x * b.width,
                                T = re.y * b.height);
                            oe !== "h" && (j.style.left = `calc(${E / b.width * 100}% - ${j.offsetWidth / 2}px)`),
                            oe !== "v" && (j.style.top = `calc(${T / b.height * 100}% - ${j.offsetHeight / 2}px)`),
                            C.cache = {
                                x: E / b.width,
                                y: T / b.height
                            };
                            let H = I(E / b.width)
                              , Y = I(T / b.height);
                            switch (oe) {
                            case "v":
                                return K.onchange(H);
                            case "h":
                                return K.onchange(Y);
                            default:
                                return K.onchange(H, Y)
                            }
                        },
                        _tapstop() {
                            C.options.onstop(),
                            s(document, ["mouseup", "touchend", "touchcancel"], C._tapstop),
                            s(document, ["mousemove", "touchmove"], C._tapmove)
                        },
                        trigger() {
                            C._tapmove()
                        },
                        update(W=0, K=0) {
                            let {left: re, top: oe, width: j, height: w} = C.options.wrapper.getBoundingClientRect();
                            C.options.lock === "h" && (K = W),
                            C._tapmove({
                                clientX: re + j * W,
                                clientY: oe + w * K
                            })
                        },
                        destroy() {
                            let {options: W, _tapstart: K, _keyboard: re} = C;
                            s(document, ["keydown", "keyup"], re),
                            s([W.wrapper, W.element], "mousedown", K),
                            s([W.wrapper, W.element], "touchstart", K, {
                                passive: !1
                            })
                        }
                    }
                      , {options: L, _tapstart: F, _keyboard: U} = C;
                    return i([L.wrapper, L.element], "mousedown", F),
                    i([L.wrapper, L.element], "touchstart", F, {
                        passive: !1
                    }),
                    i(document, ["keydown", "keyup"], U),
                    C
                }
                function M(P={}) {
                    P = Object.assign({
                        onchange: ()=>0,
                        className: "",
                        elements: []
                    }, P);
                    let C = i(P.elements, "click", L=>{
                        P.elements.forEach(F=>F.classList[L.target === F ? "add" : "remove"](P.className)),
                        P.onchange(L),
                        L.stopPropagation()
                    }
                    );
                    return {
                        destroy: ()=>s(...C)
                    }
                }
                let R = {
                    variantFlipOrder: {
                        start: "sme",
                        middle: "mse",
                        end: "ems"
                    },
                    positionFlipOrder: {
                        top: "tbrl",
                        right: "rltb",
                        bottom: "btrl",
                        left: "lrbt"
                    },
                    position: "bottom",
                    margin: 8
                }
                  , q = (P,C,L)=>{
                    let {container: F, margin: U, position: W, variantFlipOrder: K, positionFlipOrder: re} = {
                        container: document.documentElement.getBoundingClientRect(),
                        ...R,
                        ...L
                    }
                      , {left: oe, top: j} = C.style;
                    C.style.left = "0",
                    C.style.top = "0";
                    let w = P.getBoundingClientRect()
                      , b = C.getBoundingClientRect()
                      , E = {
                        t: w.top - b.height - U,
                        b: w.bottom + U,
                        r: w.right + U,
                        l: w.left - b.width - U
                    }
                      , T = {
                        vs: w.left,
                        vm: w.left + w.width / 2 + -b.width / 2,
                        ve: w.left + w.width - b.width,
                        hs: w.top,
                        hm: w.bottom - w.height / 2 - b.height / 2,
                        he: w.bottom - b.height
                    }
                      , [H,Y="middle"] = W.split("-")
                      , X = re[H]
                      , ce = K[Y]
                      , {top: J, left: ae, bottom: ie, right: me} = F;
                    for (let ve of X) {
                        let be = ve === "t" || ve === "b"
                          , fe = E[ve]
                          , [te,Ee] = be ? ["top", "left"] : ["left", "top"]
                          , [Le,D] = be ? [b.height, b.width] : [b.width, b.height]
                          , [A,G] = be ? [ie, me] : [me, ie]
                          , [ne,Q] = be ? [J, ae] : [ae, J];
                        if (!(fe < ne || fe + Le > A))
                            for (let he of ce) {
                                let de = T[(be ? "v" : "h") + he];
                                if (!(de < Q || de + D > G))
                                    return C.style[Ee] = de - b[Ee] + "px",
                                    C.style[te] = fe - b[te] + "px",
                                    ve + he
                            }
                    }
                    return C.style.left = oe,
                    C.style.top = j,
                    null
                }
                ;
                function k(P, C, L) {
                    return C in P ? Object.defineProperty(P, C, {
                        value: L,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }) : P[C] = L,
                    P
                }
                class B {
                    constructor(C) {
                        k(this, "_initializingActive", !0),
                        k(this, "_recalc", !0),
                        k(this, "_nanopop", null),
                        k(this, "_root", null),
                        k(this, "_color", N()),
                        k(this, "_lastColor", N()),
                        k(this, "_swatchColors", []),
                        k(this, "_setupAnimationFrame", null),
                        k(this, "_eventListener", {
                            init: [],
                            save: [],
                            hide: [],
                            show: [],
                            clear: [],
                            change: [],
                            changestop: [],
                            cancel: [],
                            swatchselect: []
                        }),
                        this.options = C = Object.assign({
                            ...B.DEFAULT_OPTIONS
                        }, C);
                        let {swatches: L, components: F, theme: U, sliders: W, lockOpacity: K, padding: re} = C;
                        ["nano", "monolith"].includes(U) && !W && (C.sliders = "h"),
                        F.interaction || (F.interaction = {});
                        let {preview: oe, opacity: j, hue: w, palette: b} = F;
                        F.opacity = !K && j,
                        F.palette = b || oe || j || w,
                        this._preBuild(),
                        this._buildComponents(),
                        this._bindEvents(),
                        this._finalBuild(),
                        L && L.length && L.forEach(Y=>this.addSwatch(Y));
                        let {button: E, app: T} = this._root;
                        this._nanopop = ((Y,X,ce)=>{
                            let J = typeof Y != "object" || Y instanceof HTMLElement ? {
                                reference: Y,
                                popper: X,
                                ...ce
                            } : Y;
                            return {
                                update(ae=J) {
                                    let {reference: ie, popper: me} = Object.assign(J, ae);
                                    if (!me || !ie)
                                        throw new Error("Popper- or reference-element missing.");
                                    return q(ie, me, J)
                                }
                            }
                        }
                        )(E, T, {
                            margin: re
                        }),
                        E.setAttribute("role", "button"),
                        E.setAttribute("aria-label", this._t("btn:toggle"));
                        let H = this;
                        this._setupAnimationFrame = requestAnimationFrame(function Y() {
                            if (!T.offsetWidth)
                                return requestAnimationFrame(Y);
                            H.setColor(C.default),
                            H._rePositioningPicker(),
                            C.defaultRepresentation && (H._representation = C.defaultRepresentation,
                            H.setColorRepresentation(H._representation)),
                            C.showAlways && H.show(),
                            H._initializingActive = !1,
                            H._emit("init")
                        })
                    }
                    _preBuild() {
                        let {options: C} = this;
                        for (let L of ["el", "container"])
                            C[L] = c(C[L]);
                        this._root = (L=>{
                            let {components: F, useAsButton: U, inline: W, appClass: K, theme: re, lockOpacity: oe} = L.options
                              , j = T=>T ? "" : 'style="display:none" hidden'
                              , w = T=>L._t(T)
                              , b = a(`
      <div :ref="root" class="pickr">

        ${U ? "" : '<button type="button" :ref="button" class="pcr-button"></button>'}

        <div :ref="app" class="pcr-app ${K || ""}" data-theme="${re}" ${W ? 'style="position: unset"' : ""} aria-label="${w("ui:dialog")}" role="window">
          <div class="pcr-selection" ${j(F.palette)}>
            <div :obj="preview" class="pcr-color-preview" ${j(F.preview)}>
              <button type="button" :ref="lastColor" class="pcr-last-color" aria-label="${w("btn:last-color")}"></button>
              <div :ref="currentColor" class="pcr-current-color"></div>
            </div>

            <div :obj="palette" class="pcr-color-palette">
              <div :ref="picker" class="pcr-picker"></div>
              <div :ref="palette" class="pcr-palette" tabindex="0" aria-label="${w("aria:palette")}" role="listbox"></div>
            </div>

            <div :obj="hue" class="pcr-color-chooser" ${j(F.hue)}>
              <div :ref="picker" class="pcr-picker"></div>
              <div :ref="slider" class="pcr-hue pcr-slider" tabindex="0" aria-label="${w("aria:hue")}" role="slider"></div>
            </div>

            <div :obj="opacity" class="pcr-color-opacity" ${j(F.opacity)}>
              <div :ref="picker" class="pcr-picker"></div>
              <div :ref="slider" class="pcr-opacity pcr-slider" tabindex="0" aria-label="${w("aria:opacity")}" role="slider"></div>
            </div>
          </div>

          <div class="pcr-swatches ${F.palette ? "" : "pcr-last"}" :ref="swatches"></div>

          <div :obj="interaction" class="pcr-interaction" ${j(Object.keys(F.interaction).length)}>
            <input :ref="result" class="pcr-result" type="text" spellcheck="false" ${j(F.interaction.input)} aria-label="${w("aria:input")}">

            <input :arr="options" class="pcr-type" data-type="HEXA" value="${oe ? "HEX" : "HEXA"}" type="button" ${j(F.interaction.hex)}>
            <input :arr="options" class="pcr-type" data-type="RGBA" value="${oe ? "RGB" : "RGBA"}" type="button" ${j(F.interaction.rgba)}>
            <input :arr="options" class="pcr-type" data-type="HSLA" value="${oe ? "HSL" : "HSLA"}" type="button" ${j(F.interaction.hsla)}>
            <input :arr="options" class="pcr-type" data-type="HSVA" value="${oe ? "HSV" : "HSVA"}" type="button" ${j(F.interaction.hsva)}>
            <input :arr="options" class="pcr-type" data-type="CMYK" value="CMYK" type="button" ${j(F.interaction.cmyk)}>

            <input :ref="save" class="pcr-save" value="${w("btn:save")}" type="button" ${j(F.interaction.save)} aria-label="${w("aria:btn:save")}">
            <input :ref="cancel" class="pcr-cancel" value="${w("btn:cancel")}" type="button" ${j(F.interaction.cancel)} aria-label="${w("aria:btn:cancel")}">
            <input :ref="clear" class="pcr-clear" value="${w("btn:clear")}" type="button" ${j(F.interaction.clear)} aria-label="${w("aria:btn:clear")}">
          </div>
        </div>
      </div>
    `)
                              , E = b.interaction;
                            return E.options.find(T=>!T.hidden && !T.classList.add("active")),
                            E.type = ()=>E.options.find(T=>T.classList.contains("active")),
                            b
                        }
                        )(this),
                        C.useAsButton && (this._root.button = C.el),
                        C.container.appendChild(this._root.root)
                    }
                    _finalBuild() {
                        let C = this.options
                          , L = this._root;
                        if (C.container.removeChild(L.root),
                        C.inline) {
                            let F = C.el.parentElement;
                            C.el.nextSibling ? F.insertBefore(L.app, C.el.nextSibling) : F.appendChild(L.app)
                        } else
                            C.container.appendChild(L.app);
                        C.useAsButton ? C.inline && C.el.remove() : C.el.parentNode.replaceChild(L.root, C.el),
                        C.disabled && this.disable(),
                        C.comparison || (L.button.style.transition = "none",
                        C.useAsButton || (L.preview.lastColor.style.transition = "none")),
                        this.hide()
                    }
                    _buildComponents() {
                        let C = this
                          , L = this.options.components
                          , F = (C.options.sliders || "v").repeat(2)
                          , [U,W] = F.match(/^[vh]+$/g) ? F : []
                          , K = ()=>this._color || (this._color = this._lastColor.clone())
                          , re = {
                            palette: O({
                                element: C._root.palette.picker,
                                wrapper: C._root.palette.palette,
                                onstop: ()=>C._emit("changestop", "slider", C),
                                onchange(oe, j) {
                                    if (!L.palette)
                                        return;
                                    let w = K()
                                      , {_root: b, options: E} = C
                                      , {lastColor: T, currentColor: H} = b.preview;
                                    C._recalc && (w.s = 100 * oe,
                                    w.v = 100 - 100 * j,
                                    w.v < 0 && (w.v = 0),
                                    C._updateOutput("slider"));
                                    let Y = w.toRGBA().toString(0);
                                    this.element.style.background = Y,
                                    this.wrapper.style.background = `
                        linear-gradient(to top, rgba(0, 0, 0, ${w.a}), transparent),
                        linear-gradient(to left, hsla(${w.h}, 100%, 50%, ${w.a}), rgba(255, 255, 255, ${w.a}))
                    `,
                                    E.comparison ? E.useAsButton || C._lastColor || T.style.setProperty("--pcr-color", Y) : (b.button.style.setProperty("--pcr-color", Y),
                                    b.button.classList.remove("clear"));
                                    let X = w.toHEXA().toString();
                                    for (let {el: ce, color: J} of C._swatchColors)
                                        ce.classList[X === J.toHEXA().toString() ? "add" : "remove"]("pcr-active");
                                    H.style.setProperty("--pcr-color", Y)
                                }
                            }),
                            hue: O({
                                lock: W === "v" ? "h" : "v",
                                element: C._root.hue.picker,
                                wrapper: C._root.hue.slider,
                                onstop: ()=>C._emit("changestop", "slider", C),
                                onchange(oe) {
                                    if (!L.hue || !L.palette)
                                        return;
                                    let j = K();
                                    C._recalc && (j.h = 360 * oe),
                                    this.element.style.backgroundColor = `hsl(${j.h}, 100%, 50%)`,
                                    re.palette.trigger()
                                }
                            }),
                            opacity: O({
                                lock: U === "v" ? "h" : "v",
                                element: C._root.opacity.picker,
                                wrapper: C._root.opacity.slider,
                                onstop: ()=>C._emit("changestop", "slider", C),
                                onchange(oe) {
                                    if (!L.opacity || !L.palette)
                                        return;
                                    let j = K();
                                    C._recalc && (j.a = Math.round(100 * oe) / 100),
                                    this.element.style.background = `rgba(0, 0, 0, ${j.a})`,
                                    re.palette.trigger()
                                }
                            }),
                            selectable: M({
                                elements: C._root.interaction.options,
                                className: "active",
                                onchange(oe) {
                                    C._representation = oe.target.getAttribute("data-type").toUpperCase(),
                                    C._recalc && C._updateOutput("swatch")
                                }
                            })
                        };
                        this._components = re
                    }
                    _bindEvents() {
                        let {_root: C, options: L} = this
                          , F = [i(C.interaction.clear, "click", ()=>this._clearColor()), i([C.interaction.cancel, C.preview.lastColor], "click", ()=>{
                            this.setHSVA(...(this._lastColor || this._color).toHSVA(), !0),
                            this._emit("cancel")
                        }
                        ), i(C.interaction.save, "click", ()=>{
                            !this.applyColor() && !L.showAlways && this.hide()
                        }
                        ), i(C.interaction.result, ["keyup", "input"], U=>{
                            this.setColor(U.target.value, !0) && !this._initializingActive && (this._emit("change", this._color, "input", this),
                            this._emit("changestop", "input", this)),
                            U.stopImmediatePropagation()
                        }
                        ), i(C.interaction.result, ["focus", "blur"], U=>{
                            this._recalc = U.type === "blur",
                            this._recalc && this._updateOutput(null)
                        }
                        ), i([C.palette.palette, C.palette.picker, C.hue.slider, C.hue.picker, C.opacity.slider, C.opacity.picker], ["mousedown", "touchstart"], ()=>this._recalc = !0, {
                            passive: !0
                        })];
                        if (!L.showAlways) {
                            let U = L.closeWithKey;
                            F.push(i(C.button, "click", ()=>this.isOpen() ? this.hide() : this.show()), i(document, "keyup", W=>this.isOpen() && (W.key === U || W.code === U) && this.hide()), i(document, ["touchstart", "mousedown"], W=>{
                                this.isOpen() && !l(W).some(K=>K === C.app || K === C.button) && this.hide()
                            }
                            , {
                                capture: !0
                            }))
                        }
                        if (L.adjustableNumbers) {
                            let U = {
                                rgba: [255, 255, 255, 1],
                                hsva: [360, 100, 100, 1],
                                hsla: [360, 100, 100, 1],
                                cmyk: [100, 100, 100, 100]
                            };
                            u(C.interaction.result, (W,K,re)=>{
                                let oe = U[this.getColorRepresentation().toLowerCase()];
                                if (oe) {
                                    let j = oe[re]
                                      , w = W + (j >= 100 ? 1e3 * K : K);
                                    return w <= 0 ? 0 : Number((w < j ? w : j).toPrecision(3))
                                }
                                return W
                            }
                            )
                        }
                        if (L.autoReposition && !L.inline) {
                            let U = null
                              , W = this;
                            F.push(i(window, ["scroll", "resize"], ()=>{
                                W.isOpen() && (L.closeOnScroll && W.hide(),
                                U === null ? (U = setTimeout(()=>U = null, 100),
                                requestAnimationFrame(function K() {
                                    W._rePositioningPicker(),
                                    U !== null && requestAnimationFrame(K)
                                })) : (clearTimeout(U),
                                U = setTimeout(()=>U = null, 100)))
                            }
                            , {
                                capture: !0
                            }))
                        }
                        this._eventBindings = F
                    }
                    _rePositioningPicker() {
                        let {options: C} = this;
                        if (!C.inline && !this._nanopop.update({
                            container: document.body.getBoundingClientRect(),
                            position: C.position
                        })) {
                            let L = this._root.app
                              , F = L.getBoundingClientRect();
                            L.style.top = (window.innerHeight - F.height) / 2 + "px",
                            L.style.left = (window.innerWidth - F.width) / 2 + "px"
                        }
                    }
                    _updateOutput(C) {
                        let {_root: L, _color: F, options: U} = this;
                        if (L.interaction.type()) {
                            let W = `to ${L.interaction.type().getAttribute("data-type")}`;
                            L.interaction.result.value = typeof F[W] == "function" ? F[W]().toString(U.outputPrecision) : ""
                        }
                        !this._initializingActive && this._recalc && this._emit("change", F, C, this)
                    }
                    _clearColor(C=!1) {
                        let {_root: L, options: F} = this;
                        F.useAsButton || L.button.style.setProperty("--pcr-color", "rgba(0, 0, 0, 0.15)"),
                        L.button.classList.add("clear"),
                        F.showAlways || this.hide(),
                        this._lastColor = null,
                        this._initializingActive || C || (this._emit("save", null),
                        this._emit("clear"))
                    }
                    _parseLocalColor(C) {
                        let {values: L, type: F, a: U} = S(C)
                          , {lockOpacity: W} = this.options
                          , K = U !== void 0 && U !== 1;
                        return L && L.length === 3 && (L[3] = void 0),
                        {
                            values: !L || W && K ? null : L,
                            type: F
                        }
                    }
                    _t(C) {
                        return this.options.i18n[C] || B.I18N_DEFAULTS[C]
                    }
                    _emit(C, ...L) {
                        this._eventListener[C].forEach(F=>F(...L, this))
                    }
                    on(C, L) {
                        return this._eventListener[C].push(L),
                        this
                    }
                    off(C, L) {
                        let F = this._eventListener[C] || []
                          , U = F.indexOf(L);
                        return ~U && F.splice(U, 1),
                        this
                    }
                    addSwatch(C) {
                        let {values: L} = this._parseLocalColor(C);
                        if (L) {
                            let {_swatchColors: F, _root: U} = this
                              , W = N(...L)
                              , K = o(`<button type="button" style="--pcr-color: ${W.toRGBA().toString(0)}" aria-label="${this._t("btn:swatch")}"/>`);
                            return U.swatches.appendChild(K),
                            F.push({
                                el: K,
                                color: W
                            }),
                            this._eventBindings.push(i(K, "click", ()=>{
                                this.setHSVA(...W.toHSVA(), !0),
                                this._emit("swatchselect", W),
                                this._emit("change", W, "swatch", this)
                            }
                            )),
                            !0
                        }
                        return !1
                    }
                    removeSwatch(C) {
                        let L = this._swatchColors[C];
                        if (L) {
                            let {el: F} = L;
                            return this._root.swatches.removeChild(F),
                            this._swatchColors.splice(C, 1),
                            !0
                        }
                        return !1
                    }
                    applyColor(C=!1) {
                        let {preview: L, button: F} = this._root
                          , U = this._color.toRGBA().toString(0);
                        return L.lastColor.style.setProperty("--pcr-color", U),
                        this.options.useAsButton || F.style.setProperty("--pcr-color", U),
                        F.classList.remove("clear"),
                        this._lastColor = this._color.clone(),
                        this._initializingActive || C || this._emit("save", this._color),
                        this
                    }
                    destroy() {
                        cancelAnimationFrame(this._setupAnimationFrame),
                        this._eventBindings.forEach(C=>s(...C)),
                        Object.keys(this._components).forEach(C=>this._components[C].destroy())
                    }
                    destroyAndRemove() {
                        this.destroy();
                        let {root: C, app: L} = this._root;
                        C.parentElement && C.parentElement.removeChild(C),
                        L.parentElement.removeChild(L),
                        Object.keys(this).forEach(F=>this[F] = null)
                    }
                    hide() {
                        return !!this.isOpen() && (this._root.app.classList.remove("visible"),
                        this._emit("hide"),
                        !0)
                    }
                    show() {
                        return !this.options.disabled && !this.isOpen() && (this._root.app.classList.add("visible"),
                        this._rePositioningPicker(),
                        this._emit("show", this._color),
                        this)
                    }
                    isOpen() {
                        return this._root.app.classList.contains("visible")
                    }
                    setHSVA(C=360, L=0, F=0, U=1, W=!1) {
                        let K = this._recalc;
                        if (this._recalc = !1,
                        C < 0 || C > 360 || L < 0 || L > 100 || F < 0 || F > 100 || U < 0 || U > 1)
                            return !1;
                        this._color = N(C, L, F, U);
                        let {hue: re, opacity: oe, palette: j} = this._components;
                        return re.update(C / 360),
                        oe.update(U),
                        j.update(L / 100, 1 - F / 100),
                        W || this.applyColor(),
                        K && this._updateOutput(),
                        this._recalc = K,
                        !0
                    }
                    setColor(C, L=!1) {
                        if (C === null)
                            return this._clearColor(L),
                            !0;
                        let {values: F, type: U} = this._parseLocalColor(C);
                        if (F) {
                            let W = U.toUpperCase()
                              , {options: K} = this._root.interaction
                              , re = K.find(oe=>oe.getAttribute("data-type") === W);
                            if (re && !re.hidden)
                                for (let oe of K)
                                    oe.classList[oe === re ? "add" : "remove"]("active");
                            return !!this.setHSVA(...F, L) && this.setColorRepresentation(W)
                        }
                        return !1
                    }
                    setColorRepresentation(C) {
                        return C = C.toUpperCase(),
                        !!this._root.interaction.options.find(L=>L.getAttribute("data-type").startsWith(C) && !L.click())
                    }
                    getColorRepresentation() {
                        return this._representation
                    }
                    getColor() {
                        return this._color
                    }
                    getSelectedColor() {
                        return this._lastColor
                    }
                    getRoot() {
                        return this._root
                    }
                    disable() {
                        return this.hide(),
                        this.options.disabled = !0,
                        this._root.button.classList.add("disabled"),
                        this
                    }
                    enable() {
                        return this.options.disabled = !1,
                        this._root.button.classList.remove("disabled"),
                        this
                    }
                }
                return k(B, "utils", t),
                k(B, "version", "1.8.2"),
                k(B, "I18N_DEFAULTS", {
                    "ui:dialog": "color picker dialog",
                    "btn:toggle": "toggle color picker dialog",
                    "btn:swatch": "color swatch",
                    "btn:last-color": "use previous color",
                    "btn:save": "Save",
                    "btn:cancel": "Cancel",
                    "btn:clear": "Clear",
                    "aria:btn:save": "save and close",
                    "aria:btn:cancel": "cancel and close",
                    "aria:btn:clear": "clear and close",
                    "aria:input": "color input field",
                    "aria:palette": "color selection area",
                    "aria:hue": "hue selection slider",
                    "aria:opacity": "selection slider"
                }),
                k(B, "DEFAULT_OPTIONS", {
                    appClass: null,
                    theme: "classic",
                    useAsButton: !1,
                    padding: 8,
                    disabled: !1,
                    comparison: !0,
                    closeOnScroll: !1,
                    outputPrecision: 0,
                    lockOpacity: !1,
                    autoReposition: !0,
                    container: "body",
                    components: {
                        interaction: {}
                    },
                    i18n: {},
                    swatches: null,
                    inline: !1,
                    sliders: null,
                    default: "#42445a",
                    defaultRepresentation: null,
                    position: "bottom-middle",
                    adjustableNumbers: !0,
                    showAlways: !1,
                    closeWithKey: "Escape"
                }),
                k(B, "create", P=>new B(P)),
                e = e.default
            }
            )()
        })
    }
    );
    var IA = {};
    mg(IA, {
        Engine: ()=>cg,
        RegisterHeaderPlugin: ()=>SA,
        RegisterToolbarPlugin: ()=>wA,
        SetWebsiteEventHandler: ()=>EA,
        StartEmbed: ()=>CA,
        StartWebsite: ()=>AA,
        UI: ()=>MA
    });
    var ku = null
      , vg = new Set;
    function uc(r) {
        ku = r
    }
    function _o(r) {
        return ku === null ? null : ku + "/" + r
    }
    function Ar(r) {
        return new Promise((e,t)=>{
            if (ku === null) {
                t();
                return
            }
            if (vg.has(r)) {
                e();
                return
            }
            let n = document.createElement("script");
            n.type = "text/javascript",
            n.src = _o(r),
            n.onload = ()=>{
                vg.add(r),
                e()
            }
            ,
            n.onerror = ()=>{
                t()
            }
            ,
            document.head.appendChild(n)
        }
        )
    }
    var yg = 1e-8
      , hc = 1e-4
      , Uu = 57.29577951308232
      , Cr = .017453292519943;
    function To(r) {
        return Math.abs(r) < 1e-8
    }
    function oa(r, e) {
        return e - r > 1e-8
    }
    function Bu(r, e) {
        return r - e > 1e-8
    }
    function aa(r, e) {
        return e - r > -1e-8
    }
    function la(r, e) {
        return r - e > -1e-8
    }
    function Ot(r, e) {
        return Math.abs(e - r) < 1e-8
    }
    function fc(r, e, t) {
        return Math.abs(e - r) < t
    }
    function zi(r) {
        return r > 1e-8
    }
    function ts(r) {
        return r < -1e-8
    }
    var lt = {
        X: 1,
        Y: 2,
        Z: 3
    };
    var ze = class {
        constructor(e, t, n) {
            this.x = e,
            this.y = t,
            this.z = n
        }
        Length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
        }
        MultiplyScalar(e) {
            return this.x *= e,
            this.y *= e,
            this.z *= e,
            this
        }
        Normalize() {
            let e = this.Length();
            return e > 0 && this.MultiplyScalar(1 / e),
            this
        }
        Offset(e, t) {
            let n = e.Clone().Normalize();
            return this.x += n.x * t,
            this.y += n.y * t,
            this.z += n.z * t,
            this
        }
        Rotate(e, t, n) {
            let i = e.Clone().Normalize()
              , s = i.x
              , o = i.y
              , a = i.z
              , l = this.x - n.x
              , c = this.y - n.y
              , u = this.z - n.z
              , h = Math.sin(t)
              , f = Math.cos(t);
            return this.x = -s * (-s * l - o * c - a * u) * (1 - f) + l * f + (-a * c + o * u) * h,
            this.y = -o * (-s * l - o * c - a * u) * (1 - f) + c * f + (a * l - s * u) * h,
            this.z = -a * (-s * l - o * c - a * u) * (1 - f) + u * f + (-o * l + s * c) * h,
            this.x += n.x,
            this.y += n.y,
            this.z += n.z,
            this
        }
        Clone() {
            return new ze(this.x,this.y,this.z)
        }
    }
    ;
    function Ci(r, e) {
        return Ot(r.x, e.x) && Ot(r.y, e.y) && Ot(r.z, e.z)
    }
    function Gu(r, e) {
        return new ze(r.x + e.x,r.y + e.y,r.z + e.z)
    }
    function vn(r, e) {
        return new ze(r.x - e.x,r.y - e.y,r.z - e.z)
    }
    function ti(r, e) {
        return Math.sqrt((r.x - e.x) * (r.x - e.x) + (r.y - e.y) * (r.y - e.y) + (r.z - e.z) * (r.z - e.z))
    }
    function dc(r, e) {
        return r.x * e.x + r.y * e.y + r.z * e.z
    }
    function Vu(r, e) {
        let t = r.Clone().Normalize()
          , n = e.Clone().Normalize();
        if (Ci(t, n))
            return 0;
        let i = dc(t, n);
        return Math.acos(i)
    }
    function nr(r, e) {
        let t = new ze(0,0,0);
        return t.x = r.y * e.z - r.z * e.y,
        t.y = r.z * e.x - r.x * e.z,
        t.z = r.x * e.y - r.y * e.x,
        t
    }
    function ca(r, e, t) {
        return Math.sqrt(r * r + e * e + t * t)
    }
    function Ns(r) {
        return new ze(r[0],r[1],r[2])
    }
    var rt = class {
        constructor(e, t, n) {
            this.r = e,
            this.g = t,
            this.b = n
        }
        Set(e, t, n) {
            this.r = e,
            this.g = t,
            this.b = n
        }
        Clone() {
            return new rt(this.r,this.g,this.b)
        }
    }
      , Nn = class {
        constructor(e, t, n, i) {
            this.r = e,
            this.g = t,
            this.b = n,
            this.a = i
        }
        Set(e, t, n, i) {
            this.r = e,
            this.g = t,
            this.b = n,
            this.a = i
        }
        Clone() {
            return new Nn(this.r,this.g,this.b,this.a)
        }
    }
    ;
    function yn(r) {
        return parseInt(Math.round(r * 255), 10)
    }
    function ns(r) {
        return r / 255
    }
    function Ii(r, e, t) {
        return new rt(yn(r),yn(e),yn(t))
    }
    function Ir(r) {
        return r < .04045 ? r * .0773993808 : Math.pow(r * .9478672986 + .0521327014, 2.4)
    }
    function bo(r) {
        return r < .0031308 ? r * 12.92 : 1.055 * Math.pow(r, .41666) - .055
    }
    function Cn(r) {
        let e = parseInt(r, 10).toString(16);
        for (; e.length < 2; )
            e = "0" + e;
        return e
    }
    function ci(r) {
        let e = Cn(r.r)
          , t = Cn(r.g)
          , n = Cn(r.b);
        return e + t + n
    }
    function pc(r) {
        let e = Cn(r.r)
          , t = Cn(r.g)
          , n = Cn(r.b)
          , i = Cn(r.a);
        return e + t + n + i
    }
    function xg(r) {
        if (r.length !== 6)
            return null;
        let e = parseInt(r.substring(0, 2), 16)
          , t = parseInt(r.substring(2, 4), 16)
          , n = parseInt(r.substring(4, 6), 16);
        return new rt(e,t,n)
    }
    function _g(r) {
        if (r.length !== 6 && r.length !== 8)
            return null;
        let e = parseInt(r.substring(0, 2), 16)
          , t = parseInt(r.substring(2, 4), 16)
          , n = parseInt(r.substring(4, 6), 16)
          , i = 255;
        return r.length === 8 && (i = parseInt(r.substring(6, 8), 16)),
        new Nn(e,t,n,i)
    }
    function Tg(r) {
        return new rt(r[0],r[1],r[2])
    }
    function is(r, e) {
        return r.r === e.r && r.g === e.g && r.b === e.b
    }
    var un = {
        Perspective: 1,
        Orthographic: 2
    }
      , Hi = class {
        constructor(e, t, n, i) {
            this.eye = e,
            this.center = t,
            this.up = n,
            this.fov = i
        }
        Clone() {
            return new Hi(this.eye.Clone(),this.center.Clone(),this.up.Clone(),this.fov)
        }
    }
    ;
    function zu(r, e) {
        return Ci(r.eye, e.eye) && Ci(r.center, e.center) && Ci(r.up, e.up) && Ot(r.fov, e.fov)
    }
    var Pt = class {
        constructor(e, t) {
            this.x = e,
            this.y = t
        }
        Clone() {
            return new Pt(this.x,this.y)
        }
    }
    ;
    function ir(r, e) {
        return Ot(r.x, e.x) && Ot(r.y, e.y)
    }
    function bg(r, e) {
        return new Pt(r.x + e.x,r.y + e.y)
    }
    function mc(r, e) {
        return new Pt(r.x - e.x,r.y - e.y)
    }
    function gc(r, e) {
        return Math.sqrt((r.x - e.x) * (r.x - e.x) + (r.y - e.y) * (r.y - e.y))
    }
    var ui = class {
        constructor() {
            this.name = null,
            this.mimeType = null,
            this.buffer = null,
            this.offset = new Pt(0,0),
            this.scale = new Pt(1,1),
            this.rotation = 0
        }
        IsValid() {
            return this.name !== null && this.buffer !== null
        }
        HasTransformation() {
            return !ir(this.offset, new Pt(0,0)) || !ir(this.scale, new Pt(1,1)) || !Ot(this.rotation, 0)
        }
        IsEqual(e) {
            return !(this.name !== e.name || this.mimeType !== e.mimeType || !ir(this.offset, e.offset) || !ir(this.scale, e.scale) || !Ot(this.rotation, e.rotation))
        }
    }
    ;
    function Ds(r, e) {
        return r === null && e === null ? !0 : r === null || e === null ? !1 : r.IsEqual(e)
    }
    var nn = {
        Phong: 1,
        Physical: 2
    }
      , vc = class {
        constructor(e) {
            this.type = e,
            this.isDefault = !1,
            this.name = "",
            this.color = new rt(0,0,0),
            this.vertexColors = !1
        }
        IsEqual(e) {
            return !(this.type !== e.type || this.isDefault !== e.isDefault || this.name !== e.name || !is(this.color, e.color) || this.vertexColors !== e.vertexColors)
        }
    }
      , ua = class extends vc {
        constructor(e) {
            super(e),
            this.emissive = new rt(0,0,0),
            this.opacity = 1,
            this.transparent = !1,
            this.diffuseMap = null,
            this.bumpMap = null,
            this.normalMap = null,
            this.emissiveMap = null,
            this.alphaTest = 0,
            this.multiplyDiffuseMap = !1
        }
        IsEqual(e) {
            return !(!super.IsEqual(e) || !is(this.emissive, e.emissive) || !Ot(this.opacity, e.opacity) || this.transparent !== e.transparent || !Ds(this.diffuseMap, e.diffuseMap) || !Ds(this.bumpMap, e.bumpMap) || !Ds(this.normalMap, e.normalMap) || !Ds(this.emissiveMap, e.emissiveMap) || !Ot(this.alphaTest, e.alphaTest) || this.multiplyDiffuseMap !== e.multiplyDiffuseMap)
        }
    }
      , xn = class extends ua {
        constructor() {
            super(nn.Phong),
            this.ambient = new rt(0,0,0),
            this.specular = new rt(0,0,0),
            this.shininess = 0,
            this.specularMap = null
        }
        IsEqual(e) {
            return !(!super.IsEqual(e) || !is(this.ambient, e.ambient) || !is(this.specular, e.specular) || !Ot(this.shininess, e.shininess) || !Ds(this.specularMap, e.specularMap))
        }
    }
      , Os = class extends ua {
        constructor() {
            super(nn.Physical),
            this.metalness = 0,
            this.roughness = 1,
            this.metalnessMap = null
        }
        IsEqual(e) {
            return !(!super.IsEqual(e) || !Ot(this.metalness, e.metalness) || !Ot(this.roughness, e.roughness) || !Ds(this.metalnessMap, e.metalnessMap))
        }
    }
    ;
    function Mg(r, e) {
        return !(r.name !== e.name || r.mimeType !== e.mimeType || !ir(r.offset, e.offset) || !ir(r.scale, e.scale) || !Ot(r.rotation, e.rotation))
    }
    var yc = class {
        constructor() {}
        VertexCount() {
            return 0
        }
        VertexColorCount() {
            return 0
        }
        NormalCount() {
            return 0
        }
        TextureUVCount() {
            return 0
        }
        TriangleCount() {
            return 0
        }
        EnumerateVertices(e) {}
        EnumerateTriangleVertexIndices(e) {}
        EnumerateTriangleVertices(e) {}
    }
      , Rr = class extends yc {
        constructor() {
            super(),
            this.name = "",
            this.propertyGroups = []
        }
        GetName() {
            return this.name
        }
        SetName(e) {
            this.name = e
        }
        PropertyGroupCount() {
            return this.propertyGroups.length
        }
        AddPropertyGroup(e) {
            return this.propertyGroups.push(e),
            this.propertyGroups.length - 1
        }
        GetPropertyGroup(e) {
            return this.propertyGroups[e]
        }
        CloneProperties(e) {
            for (let t of this.propertyGroups)
                e.AddPropertyGroup(t.Clone())
        }
    }
    ;
    var $t = class extends Rr {
        constructor() {
            super(),
            this.vertices = [],
            this.vertexColors = [],
            this.normals = [],
            this.uvs = [],
            this.triangles = []
        }
        VertexCount() {
            return this.vertices.length
        }
        VertexColorCount() {
            return this.vertexColors.length
        }
        NormalCount() {
            return this.normals.length
        }
        TextureUVCount() {
            return this.uvs.length
        }
        TriangleCount() {
            return this.triangles.length
        }
        AddVertex(e) {
            return this.vertices.push(e),
            this.vertices.length - 1
        }
        SetVertex(e, t) {
            this.vertices[e] = t
        }
        GetVertex(e) {
            return this.vertices[e]
        }
        AddVertexColor(e) {
            return this.vertexColors.push(e),
            this.vertexColors.length - 1
        }
        SetVertexColor(e, t) {
            this.vertexColors[e] = t
        }
        GetVertexColor(e) {
            return this.vertexColors[e]
        }
        AddNormal(e) {
            return this.normals.push(e),
            this.normals.length - 1
        }
        SetNormal(e, t) {
            this.normals[e] = t
        }
        GetNormal(e) {
            return this.normals[e]
        }
        AddTextureUV(e) {
            return this.uvs.push(e),
            this.uvs.length - 1
        }
        SetTextureUV(e, t) {
            this.uvs[e] = t
        }
        GetTextureUV(e) {
            return this.uvs[e]
        }
        AddTriangle(e) {
            return this.triangles.push(e),
            this.triangles.length - 1
        }
        GetTriangle(e) {
            return this.triangles[e]
        }
        EnumerateVertices(e) {
            for (let t of this.vertices)
                e(t)
        }
        EnumerateTriangleVertexIndices(e) {
            for (let t of this.triangles)
                e(t.v0, t.v1, t.v2)
        }
        EnumerateTriangleVertices(e) {
            for (let t of this.triangles) {
                let n = this.vertices[t.v0]
                  , i = this.vertices[t.v1]
                  , s = this.vertices[t.v2];
                e(n, i, s)
            }
        }
        Clone() {
            let e = new $t;
            e.SetName(this.GetName()),
            this.CloneProperties(e);
            for (let t = 0; t < this.VertexCount(); t++) {
                let n = this.GetVertex(t);
                e.AddVertex(n.Clone())
            }
            for (let t = 0; t < this.VertexColorCount(); t++) {
                let n = this.GetVertexColor(t);
                e.AddVertexColor(n.Clone())
            }
            for (let t = 0; t < this.NormalCount(); t++) {
                let n = this.GetNormal(t);
                e.AddNormal(n.Clone())
            }
            for (let t = 0; t < this.TextureUVCount(); t++) {
                let n = this.GetTextureUV(t);
                e.AddTextureUV(n.Clone())
            }
            for (let t = 0; t < this.TriangleCount(); t++) {
                let n = this.GetTriangle(t);
                e.AddTriangle(n.Clone())
            }
            return e
        }
    }
    ;
    var jt = class {
        constructor(e, t, n) {
            this.v0 = e,
            this.v1 = t,
            this.v2 = n,
            this.c0 = null,
            this.c1 = null,
            this.c2 = null,
            this.n0 = null,
            this.n1 = null,
            this.n2 = null,
            this.u0 = null,
            this.u1 = null,
            this.u2 = null,
            this.mat = null,
            this.curve = null
        }
        HasVertices() {
            return this.v0 !== null && this.v1 !== null && this.v2 !== null
        }
        HasVertexColors() {
            return this.c0 !== null && this.c1 !== null && this.c2 !== null
        }
        HasNormals() {
            return this.n0 !== null && this.n1 !== null && this.n2 !== null
        }
        HasTextureUVs() {
            return this.u0 !== null && this.u1 !== null && this.u2 !== null
        }
        SetVertices(e, t, n) {
            return this.v0 = e,
            this.v1 = t,
            this.v2 = n,
            this
        }
        SetVertexColors(e, t, n) {
            return this.c0 = e,
            this.c1 = t,
            this.c2 = n,
            this
        }
        SetNormals(e, t, n) {
            return this.n0 = e,
            this.n1 = t,
            this.n2 = n,
            this
        }
        SetTextureUVs(e, t, n) {
            return this.u0 = e,
            this.u1 = t,
            this.u2 = n,
            this
        }
        SetMaterial(e) {
            return this.mat = e,
            this
        }
        SetCurve(e) {
            return this.curve = e,
            this
        }
        Clone() {
            let e = new jt(this.v0,this.v1,this.v2);
            return e.SetVertexColors(this.c0, this.c1, this.c2),
            e.SetNormals(this.n0, this.n1, this.n2),
            e.SetTextureUVs(this.u0, this.u1, this.u2),
            e.SetMaterial(this.mat),
            e.SetCurve(this.curve),
            e
        }
    }
    ;
    var Dp = "152";
    var _x = 0
      , Eg = 1
      , Tx = 2;
    var uv = 1
      , bx = 2
      , hs = 3
      , qi = 0
      , Mn = 1
      , On = 2;
    var zs = 0
      , Pa = 1
      , Sg = 2
      , wg = 3
      , Ag = 4
      , Mx = 5
      , Ca = 100
      , Ex = 101
      , Sx = 102
      , Cg = 103
      , Ig = 104
      , wx = 200
      , Ax = 201
      , Cx = 202
      , Ix = 203
      , hv = 204
      , fv = 205
      , Rx = 206
      , Px = 207
      , Lx = 208
      , Nx = 209
      , Dx = 210
      , Ox = 0
      , Fx = 1
      , kx = 2
      , Zd = 3
      , Ux = 4
      , Bx = 5
      , Gx = 6
      , Vx = 7
      , Uh = 0
      , zx = 1
      , Hx = 2
      , fs = 0
      , Wx = 1
      , Xx = 2
      , jx = 3
      , qx = 4
      , Yx = 5
      , dv = 300
      , Fa = 301
      , ka = 302
      , Pc = 303
      , Jd = 304
      , Bh = 306
      , rn = 1e3
      , Zt = 1001
      , Ua = 1002
      , Tn = 1003
      , Rg = 1004;
    var md = 1005;
    var bn = 1006
      , Kx = 1007;
    var lr = 1008;
    var Lo = 1009
      , Zx = 1010
      , Jx = 1011
      , pv = 1012
      , $x = 1013
      , Co = 1014
      , Vs = 1015
      , Lc = 1016
      , Qx = 1017
      , e_ = 1018
      , La = 1020
      , t_ = 1021
      , Xi = 1023
      , n_ = 1024
      , i_ = 1025
      , Io = 1026
      , Ba = 1027
      , r_ = 1028
      , s_ = 1029
      , o_ = 1030
      , a_ = 1031
      , l_ = 1033
      , gd = 33776
      , vd = 33777
      , yd = 33778
      , xd = 33779
      , Pg = 35840
      , Lg = 35841
      , Ng = 35842
      , Dg = 35843
      , c_ = 36196
      , Og = 37492
      , Fg = 37496
      , kg = 37808
      , Ug = 37809
      , Bg = 37810
      , Gg = 37811
      , Vg = 37812
      , zg = 37813
      , Hg = 37814
      , Wg = 37815
      , Xg = 37816
      , jg = 37817
      , qg = 37818
      , Yg = 37819
      , Kg = 37820
      , Zg = 37821
      , _d = 36492
      , u_ = 36283
      , Jg = 36284
      , $g = 36285
      , Qg = 36286;
    var xh = 2300
      , _h = 2301
      , Td = 2302
      , e0 = 2400
      , t0 = 2401
      , n0 = 2402
      , h_ = 2500;
    var mv = 3e3
      , Ro = 3001
      , f_ = 3200
      , d_ = 3201
      , Gh = 0
      , p_ = 1
      , Po = ""
      , ct = "srgb"
      , di = "srgb-linear"
      , gv = "display-p3";
    var bd = 7680;
    var m_ = 519
      , i0 = 35044;
    var r0 = "300 es"
      , $d = 1035
      , Ws = class {
        addEventListener(e, t) {
            this._listeners === void 0 && (this._listeners = {});
            let n = this._listeners;
            n[e] === void 0 && (n[e] = []),
            n[e].indexOf(t) === -1 && n[e].push(t)
        }
        hasEventListener(e, t) {
            if (this._listeners === void 0)
                return !1;
            let n = this._listeners;
            return n[e] !== void 0 && n[e].indexOf(t) !== -1
        }
        removeEventListener(e, t) {
            if (this._listeners === void 0)
                return;
            let i = this._listeners[e];
            if (i !== void 0) {
                let s = i.indexOf(t);
                s !== -1 && i.splice(s, 1)
            }
        }
        dispatchEvent(e) {
            if (this._listeners === void 0)
                return;
            let n = this._listeners[e.type];
            if (n !== void 0) {
                e.target = this;
                let i = n.slice(0);
                for (let s = 0, o = i.length; s < o; s++)
                    i[s].call(this, e);
                e.target = null
            }
        }
    }
      , Yn = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"]
      , s0 = 1234567
      , Na = Math.PI / 180
      , Ga = 180 / Math.PI;
    function ys() {
        let r = Math.random() * 4294967295 | 0
          , e = Math.random() * 4294967295 | 0
          , t = Math.random() * 4294967295 | 0
          , n = Math.random() * 4294967295 | 0;
        return (Yn[r & 255] + Yn[r >> 8 & 255] + Yn[r >> 16 & 255] + Yn[r >> 24 & 255] + "-" + Yn[e & 255] + Yn[e >> 8 & 255] + "-" + Yn[e >> 16 & 15 | 64] + Yn[e >> 24 & 255] + "-" + Yn[t & 63 | 128] + Yn[t >> 8 & 255] + "-" + Yn[t >> 16 & 255] + Yn[t >> 24 & 255] + Yn[n & 255] + Yn[n >> 8 & 255] + Yn[n >> 16 & 255] + Yn[n >> 24 & 255]).toLowerCase()
    }
    function Vn(r, e, t) {
        return Math.max(e, Math.min(t, r))
    }
    function Op(r, e) {
        return (r % e + e) % e
    }
    function g_(r, e, t, n, i) {
        return n + (r - e) * (i - n) / (t - e)
    }
    function v_(r, e, t) {
        return r !== e ? (t - r) / (e - r) : 0
    }
    function wc(r, e, t) {
        return (1 - t) * r + t * e
    }
    function y_(r, e, t, n) {
        return wc(r, e, 1 - Math.exp(-t * n))
    }
    function x_(r, e=1) {
        return e - Math.abs(Op(r, e * 2) - e)
    }
    function __(r, e, t) {
        return r <= e ? 0 : r >= t ? 1 : (r = (r - e) / (t - e),
        r * r * (3 - 2 * r))
    }
    function T_(r, e, t) {
        return r <= e ? 0 : r >= t ? 1 : (r = (r - e) / (t - e),
        r * r * r * (r * (r * 6 - 15) + 10))
    }
    function b_(r, e) {
        return r + Math.floor(Math.random() * (e - r + 1))
    }
    function M_(r, e) {
        return r + Math.random() * (e - r)
    }
    function E_(r) {
        return r * (.5 - Math.random())
    }
    function S_(r) {
        r !== void 0 && (s0 = r);
        let e = s0 += 1831565813;
        return e = Math.imul(e ^ e >>> 15, e | 1),
        e ^= e + Math.imul(e ^ e >>> 7, e | 61),
        ((e ^ e >>> 14) >>> 0) / 4294967296
    }
    function w_(r) {
        return r * Na
    }
    function A_(r) {
        return r * Ga
    }
    function Qd(r) {
        return (r & r - 1) === 0 && r !== 0
    }
    function vv(r) {
        return Math.pow(2, Math.ceil(Math.log(r) / Math.LN2))
    }
    function yv(r) {
        return Math.pow(2, Math.floor(Math.log(r) / Math.LN2))
    }
    function C_(r, e, t, n, i) {
        let s = Math.cos
          , o = Math.sin
          , a = s(t / 2)
          , l = o(t / 2)
          , c = s((e + n) / 2)
          , u = o((e + n) / 2)
          , h = s((e - n) / 2)
          , f = o((e - n) / 2)
          , m = s((n - e) / 2)
          , g = o((n - e) / 2);
        switch (i) {
        case "XYX":
            r.set(a * u, l * h, l * f, a * c);
            break;
        case "YZY":
            r.set(l * f, a * u, l * h, a * c);
            break;
        case "ZXZ":
            r.set(l * h, l * f, a * u, a * c);
            break;
        case "XZX":
            r.set(a * u, l * g, l * m, a * c);
            break;
        case "YXY":
            r.set(l * m, a * u, l * g, a * c);
            break;
        case "ZYZ":
            r.set(l * g, l * m, a * u, a * c);
            break;
        default:
            console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i)
        }
    }
    function Ec(r, e) {
        switch (e.constructor) {
        case Float32Array:
            return r;
        case Uint16Array:
            return r / 65535;
        case Uint8Array:
            return r / 255;
        case Int16Array:
            return Math.max(r / 32767, -1);
        case Int8Array:
            return Math.max(r / 127, -1);
        default:
            throw new Error("Invalid component type.")
        }
    }
    function hi(r, e) {
        switch (e.constructor) {
        case Float32Array:
            return r;
        case Uint16Array:
            return Math.round(r * 65535);
        case Uint8Array:
            return Math.round(r * 255);
        case Int16Array:
            return Math.round(r * 32767);
        case Int8Array:
            return Math.round(r * 127);
        default:
            throw new Error("Invalid component type.")
        }
    }
    var Wn = {
        DEG2RAD: Na,
        RAD2DEG: Ga,
        generateUUID: ys,
        clamp: Vn,
        euclideanModulo: Op,
        mapLinear: g_,
        inverseLerp: v_,
        lerp: wc,
        damp: y_,
        pingpong: x_,
        smoothstep: __,
        smootherstep: T_,
        randInt: b_,
        randFloat: M_,
        randFloatSpread: E_,
        seededRandom: S_,
        degToRad: w_,
        radToDeg: A_,
        isPowerOfTwo: Qd,
        ceilPowerOfTwo: vv,
        floorPowerOfTwo: yv,
        setQuaternionFromProperEuler: C_,
        normalize: hi,
        denormalize: Ec
    }
      , Ie = class {
        constructor(e=0, t=0) {
            Ie.prototype.isVector2 = !0,
            this.x = e,
            this.y = t
        }
        get width() {
            return this.x
        }
        set width(e) {
            this.x = e
        }
        get height() {
            return this.y
        }
        set height(e) {
            this.y = e
        }
        set(e, t) {
            return this.x = e,
            this.y = t,
            this
        }
        setScalar(e) {
            return this.x = e,
            this.y = e,
            this
        }
        setX(e) {
            return this.x = e,
            this
        }
        setY(e) {
            return this.y = e,
            this
        }
        setComponent(e, t) {
            switch (e) {
            case 0:
                this.x = t;
                break;
            case 1:
                this.y = t;
                break;
            default:
                throw new Error("index is out of range: " + e)
            }
            return this
        }
        getComponent(e) {
            switch (e) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            default:
                throw new Error("index is out of range: " + e)
            }
        }
        clone() {
            return new this.constructor(this.x,this.y)
        }
        copy(e) {
            return this.x = e.x,
            this.y = e.y,
            this
        }
        add(e) {
            return this.x += e.x,
            this.y += e.y,
            this
        }
        addScalar(e) {
            return this.x += e,
            this.y += e,
            this
        }
        addVectors(e, t) {
            return this.x = e.x + t.x,
            this.y = e.y + t.y,
            this
        }
        addScaledVector(e, t) {
            return this.x += e.x * t,
            this.y += e.y * t,
            this
        }
        sub(e) {
            return this.x -= e.x,
            this.y -= e.y,
            this
        }
        subScalar(e) {
            return this.x -= e,
            this.y -= e,
            this
        }
        subVectors(e, t) {
            return this.x = e.x - t.x,
            this.y = e.y - t.y,
            this
        }
        multiply(e) {
            return this.x *= e.x,
            this.y *= e.y,
            this
        }
        multiplyScalar(e) {
            return this.x *= e,
            this.y *= e,
            this
        }
        divide(e) {
            return this.x /= e.x,
            this.y /= e.y,
            this
        }
        divideScalar(e) {
            return this.multiplyScalar(1 / e)
        }
        applyMatrix3(e) {
            let t = this.x
              , n = this.y
              , i = e.elements;
            return this.x = i[0] * t + i[3] * n + i[6],
            this.y = i[1] * t + i[4] * n + i[7],
            this
        }
        min(e) {
            return this.x = Math.min(this.x, e.x),
            this.y = Math.min(this.y, e.y),
            this
        }
        max(e) {
            return this.x = Math.max(this.x, e.x),
            this.y = Math.max(this.y, e.y),
            this
        }
        clamp(e, t) {
            return this.x = Math.max(e.x, Math.min(t.x, this.x)),
            this.y = Math.max(e.y, Math.min(t.y, this.y)),
            this
        }
        clampScalar(e, t) {
            return this.x = Math.max(e, Math.min(t, this.x)),
            this.y = Math.max(e, Math.min(t, this.y)),
            this
        }
        clampLength(e, t) {
            let n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
        }
        floor() {
            return this.x = Math.floor(this.x),
            this.y = Math.floor(this.y),
            this
        }
        ceil() {
            return this.x = Math.ceil(this.x),
            this.y = Math.ceil(this.y),
            this
        }
        round() {
            return this.x = Math.round(this.x),
            this.y = Math.round(this.y),
            this
        }
        roundToZero() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
            this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
            this
        }
        negate() {
            return this.x = -this.x,
            this.y = -this.y,
            this
        }
        dot(e) {
            return this.x * e.x + this.y * e.y
        }
        cross(e) {
            return this.x * e.y - this.y * e.x
        }
        lengthSq() {
            return this.x * this.x + this.y * this.y
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        }
        manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y)
        }
        normalize() {
            return this.divideScalar(this.length() || 1)
        }
        angle() {
            return Math.atan2(-this.y, -this.x) + Math.PI
        }
        angleTo(e) {
            let t = Math.sqrt(this.lengthSq() * e.lengthSq());
            if (t === 0)
                return Math.PI / 2;
            let n = this.dot(e) / t;
            return Math.acos(Vn(n, -1, 1))
        }
        distanceTo(e) {
            return Math.sqrt(this.distanceToSquared(e))
        }
        distanceToSquared(e) {
            let t = this.x - e.x
              , n = this.y - e.y;
            return t * t + n * n
        }
        manhattanDistanceTo(e) {
            return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
        }
        setLength(e) {
            return this.normalize().multiplyScalar(e)
        }
        lerp(e, t) {
            return this.x += (e.x - this.x) * t,
            this.y += (e.y - this.y) * t,
            this
        }
        lerpVectors(e, t, n) {
            return this.x = e.x + (t.x - e.x) * n,
            this.y = e.y + (t.y - e.y) * n,
            this
        }
        equals(e) {
            return e.x === this.x && e.y === this.y
        }
        fromArray(e, t=0) {
            return this.x = e[t],
            this.y = e[t + 1],
            this
        }
        toArray(e=[], t=0) {
            return e[t] = this.x,
            e[t + 1] = this.y,
            e
        }
        fromBufferAttribute(e, t) {
            return this.x = e.getX(t),
            this.y = e.getY(t),
            this
        }
        rotateAround(e, t) {
            let n = Math.cos(t)
              , i = Math.sin(t)
              , s = this.x - e.x
              , o = this.y - e.y;
            return this.x = s * n - o * i + e.x,
            this.y = s * i + o * n + e.y,
            this
        }
        random() {
            return this.x = Math.random(),
            this.y = Math.random(),
            this
        }
        *[Symbol.iterator]() {
            yield this.x,
            yield this.y
        }
    }
      , vt = class {
        constructor() {
            vt.prototype.isMatrix3 = !0,
            this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]
        }
        set(e, t, n, i, s, o, a, l, c) {
            let u = this.elements;
            return u[0] = e,
            u[1] = i,
            u[2] = a,
            u[3] = t,
            u[4] = s,
            u[5] = l,
            u[6] = n,
            u[7] = o,
            u[8] = c,
            this
        }
        identity() {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
            this
        }
        copy(e) {
            let t = this.elements
              , n = e.elements;
            return t[0] = n[0],
            t[1] = n[1],
            t[2] = n[2],
            t[3] = n[3],
            t[4] = n[4],
            t[5] = n[5],
            t[6] = n[6],
            t[7] = n[7],
            t[8] = n[8],
            this
        }
        extractBasis(e, t, n) {
            return e.setFromMatrix3Column(this, 0),
            t.setFromMatrix3Column(this, 1),
            n.setFromMatrix3Column(this, 2),
            this
        }
        setFromMatrix4(e) {
            let t = e.elements;
            return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
            this
        }
        multiply(e) {
            return this.multiplyMatrices(this, e)
        }
        premultiply(e) {
            return this.multiplyMatrices(e, this)
        }
        multiplyMatrices(e, t) {
            let n = e.elements
              , i = t.elements
              , s = this.elements
              , o = n[0]
              , a = n[3]
              , l = n[6]
              , c = n[1]
              , u = n[4]
              , h = n[7]
              , f = n[2]
              , m = n[5]
              , g = n[8]
              , v = i[0]
              , p = i[3]
              , d = i[6]
              , x = i[1]
              , y = i[4]
              , _ = i[7]
              , S = i[2]
              , N = i[5]
              , I = i[8];
            return s[0] = o * v + a * x + l * S,
            s[3] = o * p + a * y + l * N,
            s[6] = o * d + a * _ + l * I,
            s[1] = c * v + u * x + h * S,
            s[4] = c * p + u * y + h * N,
            s[7] = c * d + u * _ + h * I,
            s[2] = f * v + m * x + g * S,
            s[5] = f * p + m * y + g * N,
            s[8] = f * d + m * _ + g * I,
            this
        }
        multiplyScalar(e) {
            let t = this.elements;
            return t[0] *= e,
            t[3] *= e,
            t[6] *= e,
            t[1] *= e,
            t[4] *= e,
            t[7] *= e,
            t[2] *= e,
            t[5] *= e,
            t[8] *= e,
            this
        }
        determinant() {
            let e = this.elements
              , t = e[0]
              , n = e[1]
              , i = e[2]
              , s = e[3]
              , o = e[4]
              , a = e[5]
              , l = e[6]
              , c = e[7]
              , u = e[8];
            return t * o * u - t * a * c - n * s * u + n * a * l + i * s * c - i * o * l
        }
        invert() {
            let e = this.elements
              , t = e[0]
              , n = e[1]
              , i = e[2]
              , s = e[3]
              , o = e[4]
              , a = e[5]
              , l = e[6]
              , c = e[7]
              , u = e[8]
              , h = u * o - a * c
              , f = a * l - u * s
              , m = c * s - o * l
              , g = t * h + n * f + i * m;
            if (g === 0)
                return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
            let v = 1 / g;
            return e[0] = h * v,
            e[1] = (i * c - u * n) * v,
            e[2] = (a * n - i * o) * v,
            e[3] = f * v,
            e[4] = (u * t - i * l) * v,
            e[5] = (i * s - a * t) * v,
            e[6] = m * v,
            e[7] = (n * l - c * t) * v,
            e[8] = (o * t - n * s) * v,
            this
        }
        transpose() {
            let e, t = this.elements;
            return e = t[1],
            t[1] = t[3],
            t[3] = e,
            e = t[2],
            t[2] = t[6],
            t[6] = e,
            e = t[5],
            t[5] = t[7],
            t[7] = e,
            this
        }
        getNormalMatrix(e) {
            return this.setFromMatrix4(e).invert().transpose()
        }
        transposeIntoArray(e) {
            let t = this.elements;
            return e[0] = t[0],
            e[1] = t[3],
            e[2] = t[6],
            e[3] = t[1],
            e[4] = t[4],
            e[5] = t[7],
            e[6] = t[2],
            e[7] = t[5],
            e[8] = t[8],
            this
        }
        setUvTransform(e, t, n, i, s, o, a) {
            let l = Math.cos(s)
              , c = Math.sin(s);
            return this.set(n * l, n * c, -n * (l * o + c * a) + o + e, -i * c, i * l, -i * (-c * o + l * a) + a + t, 0, 0, 1),
            this
        }
        scale(e, t) {
            return this.premultiply(Md.makeScale(e, t)),
            this
        }
        rotate(e) {
            return this.premultiply(Md.makeRotation(-e)),
            this
        }
        translate(e, t) {
            return this.premultiply(Md.makeTranslation(e, t)),
            this
        }
        makeTranslation(e, t) {
            return this.set(1, 0, e, 0, 1, t, 0, 0, 1),
            this
        }
        makeRotation(e) {
            let t = Math.cos(e)
              , n = Math.sin(e);
            return this.set(t, -n, 0, n, t, 0, 0, 0, 1),
            this
        }
        makeScale(e, t) {
            return this.set(e, 0, 0, 0, t, 0, 0, 0, 1),
            this
        }
        equals(e) {
            let t = this.elements
              , n = e.elements;
            for (let i = 0; i < 9; i++)
                if (t[i] !== n[i])
                    return !1;
            return !0
        }
        fromArray(e, t=0) {
            for (let n = 0; n < 9; n++)
                this.elements[n] = e[n + t];
            return this
        }
        toArray(e=[], t=0) {
            let n = this.elements;
            return e[t] = n[0],
            e[t + 1] = n[1],
            e[t + 2] = n[2],
            e[t + 3] = n[3],
            e[t + 4] = n[4],
            e[t + 5] = n[5],
            e[t + 6] = n[6],
            e[t + 7] = n[7],
            e[t + 8] = n[8],
            e
        }
        clone() {
            return new this.constructor().fromArray(this.elements)
        }
    }
      , Md = new vt;
    function xv(r) {
        for (let e = r.length - 1; e >= 0; --e)
            if (r[e] >= 65535)
                return !0;
        return !1
    }
    function Nc(r) {
        return document.createElementNS("http://www.w3.org/1999/xhtml", r)
    }
    var o0 = {};
    function Ac(r) {
        r in o0 || (o0[r] = !0,
        console.warn(r))
    }
    function Da(r) {
        return r < .04045 ? r * .0773993808 : Math.pow(r * .9478672986 + .0521327014, 2.4)
    }
    function Ed(r) {
        return r < .0031308 ? r * 12.92 : 1.055 * Math.pow(r, .41666) - .055
    }
    var I_ = new vt().fromArray([.8224621, .0331941, .0170827, .177538, .9668058, .0723974, -1e-7, 1e-7, .9105199])
      , R_ = new vt().fromArray([1.2249401, -.0420569, -.0196376, -.2249404, 1.0420571, -.0786361, 1e-7, 0, 1.0982735]);
    function P_(r) {
        return r.convertSRGBToLinear().applyMatrix3(R_)
    }
    function L_(r) {
        return r.applyMatrix3(I_).convertLinearToSRGB()
    }
    var N_ = {
        [di]: r=>r,
        [ct]: r=>r.convertSRGBToLinear(),
        [gv]: P_
    }, D_ = {
        [di]: r=>r,
        [ct]: r=>r.convertLinearToSRGB(),
        [gv]: L_
    }, Li = {
        enabled: !0,
        get legacyMode() {
            return console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."),
            !this.enabled
        },
        set legacyMode(r) {
            console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."),
            this.enabled = !r
        },
        get workingColorSpace() {
            return di
        },
        set workingColorSpace(r) {
            console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")
        },
        convert: function(r, e, t) {
            if (this.enabled === !1 || e === t || !e || !t)
                return r;
            let n = N_[e]
              , i = D_[t];
            if (n === void 0 || i === void 0)
                throw new Error(`Unsupported color space conversion, "${e}" to "${t}".`);
            return i(n(r))
        },
        fromWorkingColorSpace: function(r, e) {
            return this.convert(r, this.workingColorSpace, e)
        },
        toWorkingColorSpace: function(r, e) {
            return this.convert(r, e, this.workingColorSpace)
        }
    }, ha, No = class {
        static getDataURL(e) {
            if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
                return e.src;
            let t;
            if (e instanceof HTMLCanvasElement)
                t = e;
            else {
                ha === void 0 && (ha = Nc("canvas")),
                ha.width = e.width,
                ha.height = e.height;
                let n = ha.getContext("2d");
                e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height),
                t = ha
            }
            return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e),
            t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png")
        }
        static sRGBToLinear(e) {
            if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
                let t = Nc("canvas");
                t.width = e.width,
                t.height = e.height;
                let n = t.getContext("2d");
                n.drawImage(e, 0, 0, e.width, e.height);
                let i = n.getImageData(0, 0, e.width, e.height)
                  , s = i.data;
                for (let o = 0; o < s.length; o++)
                    s[o] = Da(s[o] / 255) * 255;
                return n.putImageData(i, 0, 0),
                t
            } else if (e.data) {
                let t = e.data.slice(0);
                for (let n = 0; n < t.length; n++)
                    t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[n] = Math.floor(Da(t[n] / 255) * 255) : t[n] = Da(t[n]);
                return {
                    data: t,
                    width: e.width,
                    height: e.height
                }
            } else
                return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),
                e
        }
    }
    , Th = class {
        constructor(e=null) {
            this.isSource = !0,
            this.uuid = ys(),
            this.data = e,
            this.version = 0
        }
        set needsUpdate(e) {
            e === !0 && this.version++
        }
        toJSON(e) {
            let t = e === void 0 || typeof e == "string";
            if (!t && e.images[this.uuid] !== void 0)
                return e.images[this.uuid];
            let n = {
                uuid: this.uuid,
                url: ""
            }
              , i = this.data;
            if (i !== null) {
                let s;
                if (Array.isArray(i)) {
                    s = [];
                    for (let o = 0, a = i.length; o < a; o++)
                        i[o].isDataTexture ? s.push(Sd(i[o].image)) : s.push(Sd(i[o]))
                } else
                    s = Sd(i);
                n.url = s
            }
            return t || (e.images[this.uuid] = n),
            n
        }
    }
    ;
    function Sd(r) {
        return typeof HTMLImageElement < "u" && r instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && r instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && r instanceof ImageBitmap ? No.getDataURL(r) : r.data ? {
            data: Array.from(r.data),
            width: r.width,
            height: r.height,
            type: r.data.constructor.name
        } : (console.warn("THREE.Texture: Unable to serialize Texture."),
        {})
    }
    var O_ = 0
      , En = class extends Ws {
        constructor(e=En.DEFAULT_IMAGE, t=En.DEFAULT_MAPPING, n=Zt, i=Zt, s=bn, o=lr, a=Xi, l=Lo, c=En.DEFAULT_ANISOTROPY, u=Po) {
            super(),
            this.isTexture = !0,
            Object.defineProperty(this, "id", {
                value: O_++
            }),
            this.uuid = ys(),
            this.name = "",
            this.source = new Th(e),
            this.mipmaps = [],
            this.mapping = t,
            this.channel = 0,
            this.wrapS = n,
            this.wrapT = i,
            this.magFilter = s,
            this.minFilter = o,
            this.anisotropy = c,
            this.format = a,
            this.internalFormat = null,
            this.type = l,
            this.offset = new Ie(0,0),
            this.repeat = new Ie(1,1),
            this.center = new Ie(0,0),
            this.rotation = 0,
            this.matrixAutoUpdate = !0,
            this.matrix = new vt,
            this.generateMipmaps = !0,
            this.premultiplyAlpha = !1,
            this.flipY = !0,
            this.unpackAlignment = 4,
            typeof u == "string" ? this.colorSpace = u : (Ac("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
            this.colorSpace = u === Ro ? ct : Po),
            this.userData = {},
            this.version = 0,
            this.onUpdate = null,
            this.isRenderTargetTexture = !1,
            this.needsPMREMUpdate = !1
        }
        get image() {
            return this.source.data
        }
        set image(e=null) {
            this.source.data = e
        }
        updateMatrix() {
            this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
        }
        clone() {
            return new this.constructor().copy(this)
        }
        copy(e) {
            return this.name = e.name,
            this.source = e.source,
            this.mipmaps = e.mipmaps.slice(0),
            this.mapping = e.mapping,
            this.channel = e.channel,
            this.wrapS = e.wrapS,
            this.wrapT = e.wrapT,
            this.magFilter = e.magFilter,
            this.minFilter = e.minFilter,
            this.anisotropy = e.anisotropy,
            this.format = e.format,
            this.internalFormat = e.internalFormat,
            this.type = e.type,
            this.offset.copy(e.offset),
            this.repeat.copy(e.repeat),
            this.center.copy(e.center),
            this.rotation = e.rotation,
            this.matrixAutoUpdate = e.matrixAutoUpdate,
            this.matrix.copy(e.matrix),
            this.generateMipmaps = e.generateMipmaps,
            this.premultiplyAlpha = e.premultiplyAlpha,
            this.flipY = e.flipY,
            this.unpackAlignment = e.unpackAlignment,
            this.colorSpace = e.colorSpace,
            this.userData = JSON.parse(JSON.stringify(e.userData)),
            this.needsUpdate = !0,
            this
        }
        toJSON(e) {
            let t = e === void 0 || typeof e == "string";
            if (!t && e.textures[this.uuid] !== void 0)
                return e.textures[this.uuid];
            let n = {
                metadata: {
                    version: 4.5,
                    type: "Texture",
                    generator: "Texture.toJSON"
                },
                uuid: this.uuid,
                name: this.name,
                image: this.source.toJSON(e).uuid,
                mapping: this.mapping,
                channel: this.channel,
                repeat: [this.repeat.x, this.repeat.y],
                offset: [this.offset.x, this.offset.y],
                center: [this.center.x, this.center.y],
                rotation: this.rotation,
                wrap: [this.wrapS, this.wrapT],
                format: this.format,
                internalFormat: this.internalFormat,
                type: this.type,
                colorSpace: this.colorSpace,
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
                flipY: this.flipY,
                generateMipmaps: this.generateMipmaps,
                premultiplyAlpha: this.premultiplyAlpha,
                unpackAlignment: this.unpackAlignment
            };
            return Object.keys(this.userData).length > 0 && (n.userData = this.userData),
            t || (e.textures[this.uuid] = n),
            n
        }
        dispose() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
        transformUv(e) {
            if (this.mapping !== dv)
                return e;
            if (e.applyMatrix3(this.matrix),
            e.x < 0 || e.x > 1)
                switch (this.wrapS) {
                case rn:
                    e.x = e.x - Math.floor(e.x);
                    break;
                case Zt:
                    e.x = e.x < 0 ? 0 : 1;
                    break;
                case Ua:
                    Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
                    break
                }
            if (e.y < 0 || e.y > 1)
                switch (this.wrapT) {
                case rn:
                    e.y = e.y - Math.floor(e.y);
                    break;
                case Zt:
                    e.y = e.y < 0 ? 0 : 1;
                    break;
                case Ua:
                    Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
                    break
                }
            return this.flipY && (e.y = 1 - e.y),
            e
        }
        set needsUpdate(e) {
            e === !0 && (this.version++,
            this.source.needsUpdate = !0)
        }
        get encoding() {
            return Ac("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
            this.colorSpace === ct ? Ro : mv
        }
        set encoding(e) {
            Ac("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
            this.colorSpace = e === Ro ? ct : Po
        }
    }
    ;
    En.DEFAULT_IMAGE = null;
    En.DEFAULT_MAPPING = dv;
    En.DEFAULT_ANISOTROPY = 1;
    var Lt = class {
        constructor(e=0, t=0, n=0, i=1) {
            Lt.prototype.isVector4 = !0,
            this.x = e,
            this.y = t,
            this.z = n,
            this.w = i
        }
        get width() {
            return this.z
        }
        set width(e) {
            this.z = e
        }
        get height() {
            return this.w
        }
        set height(e) {
            this.w = e
        }
        set(e, t, n, i) {
            return this.x = e,
            this.y = t,
            this.z = n,
            this.w = i,
            this
        }
        setScalar(e) {
            return this.x = e,
            this.y = e,
            this.z = e,
            this.w = e,
            this
        }
        setX(e) {
            return this.x = e,
            this
        }
        setY(e) {
            return this.y = e,
            this
        }
        setZ(e) {
            return this.z = e,
            this
        }
        setW(e) {
            return this.w = e,
            this
        }
        setComponent(e, t) {
            switch (e) {
            case 0:
                this.x = t;
                break;
            case 1:
                this.y = t;
                break;
            case 2:
                this.z = t;
                break;
            case 3:
                this.w = t;
                break;
            default:
                throw new Error("index is out of range: " + e)
            }
            return this
        }
        getComponent(e) {
            switch (e) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            case 3:
                return this.w;
            default:
                throw new Error("index is out of range: " + e)
            }
        }
        clone() {
            return new this.constructor(this.x,this.y,this.z,this.w)
        }
        copy(e) {
            return this.x = e.x,
            this.y = e.y,
            this.z = e.z,
            this.w = e.w !== void 0 ? e.w : 1,
            this
        }
        add(e) {
            return this.x += e.x,
            this.y += e.y,
            this.z += e.z,
            this.w += e.w,
            this
        }
        addScalar(e) {
            return this.x += e,
            this.y += e,
            this.z += e,
            this.w += e,
            this
        }
        addVectors(e, t) {
            return this.x = e.x + t.x,
            this.y = e.y + t.y,
            this.z = e.z + t.z,
            this.w = e.w + t.w,
            this
        }
        addScaledVector(e, t) {
            return this.x += e.x * t,
            this.y += e.y * t,
            this.z += e.z * t,
            this.w += e.w * t,
            this
        }
        sub(e) {
            return this.x -= e.x,
            this.y -= e.y,
            this.z -= e.z,
            this.w -= e.w,
            this
        }
        subScalar(e) {
            return this.x -= e,
            this.y -= e,
            this.z -= e,
            this.w -= e,
            this
        }
        subVectors(e, t) {
            return this.x = e.x - t.x,
            this.y = e.y - t.y,
            this.z = e.z - t.z,
            this.w = e.w - t.w,
            this
        }
        multiply(e) {
            return this.x *= e.x,
            this.y *= e.y,
            this.z *= e.z,
            this.w *= e.w,
            this
        }
        multiplyScalar(e) {
            return this.x *= e,
            this.y *= e,
            this.z *= e,
            this.w *= e,
            this
        }
        applyMatrix4(e) {
            let t = this.x
              , n = this.y
              , i = this.z
              , s = this.w
              , o = e.elements;
            return this.x = o[0] * t + o[4] * n + o[8] * i + o[12] * s,
            this.y = o[1] * t + o[5] * n + o[9] * i + o[13] * s,
            this.z = o[2] * t + o[6] * n + o[10] * i + o[14] * s,
            this.w = o[3] * t + o[7] * n + o[11] * i + o[15] * s,
            this
        }
        divideScalar(e) {
            return this.multiplyScalar(1 / e)
        }
        setAxisAngleFromQuaternion(e) {
            this.w = 2 * Math.acos(e.w);
            let t = Math.sqrt(1 - e.w * e.w);
            return t < 1e-4 ? (this.x = 1,
            this.y = 0,
            this.z = 0) : (this.x = e.x / t,
            this.y = e.y / t,
            this.z = e.z / t),
            this
        }
        setAxisAngleFromRotationMatrix(e) {
            let t, n, i, s, l = e.elements, c = l[0], u = l[4], h = l[8], f = l[1], m = l[5], g = l[9], v = l[2], p = l[6], d = l[10];
            if (Math.abs(u - f) < .01 && Math.abs(h - v) < .01 && Math.abs(g - p) < .01) {
                if (Math.abs(u + f) < .1 && Math.abs(h + v) < .1 && Math.abs(g + p) < .1 && Math.abs(c + m + d - 3) < .1)
                    return this.set(1, 0, 0, 0),
                    this;
                t = Math.PI;
                let y = (c + 1) / 2
                  , _ = (m + 1) / 2
                  , S = (d + 1) / 2
                  , N = (u + f) / 4
                  , I = (h + v) / 4
                  , O = (g + p) / 4;
                return y > _ && y > S ? y < .01 ? (n = 0,
                i = .707106781,
                s = .707106781) : (n = Math.sqrt(y),
                i = N / n,
                s = I / n) : _ > S ? _ < .01 ? (n = .707106781,
                i = 0,
                s = .707106781) : (i = Math.sqrt(_),
                n = N / i,
                s = O / i) : S < .01 ? (n = .707106781,
                i = .707106781,
                s = 0) : (s = Math.sqrt(S),
                n = I / s,
                i = O / s),
                this.set(n, i, s, t),
                this
            }
            let x = Math.sqrt((p - g) * (p - g) + (h - v) * (h - v) + (f - u) * (f - u));
            return Math.abs(x) < .001 && (x = 1),
            this.x = (p - g) / x,
            this.y = (h - v) / x,
            this.z = (f - u) / x,
            this.w = Math.acos((c + m + d - 1) / 2),
            this
        }
        min(e) {
            return this.x = Math.min(this.x, e.x),
            this.y = Math.min(this.y, e.y),
            this.z = Math.min(this.z, e.z),
            this.w = Math.min(this.w, e.w),
            this
        }
        max(e) {
            return this.x = Math.max(this.x, e.x),
            this.y = Math.max(this.y, e.y),
            this.z = Math.max(this.z, e.z),
            this.w = Math.max(this.w, e.w),
            this
        }
        clamp(e, t) {
            return this.x = Math.max(e.x, Math.min(t.x, this.x)),
            this.y = Math.max(e.y, Math.min(t.y, this.y)),
            this.z = Math.max(e.z, Math.min(t.z, this.z)),
            this.w = Math.max(e.w, Math.min(t.w, this.w)),
            this
        }
        clampScalar(e, t) {
            return this.x = Math.max(e, Math.min(t, this.x)),
            this.y = Math.max(e, Math.min(t, this.y)),
            this.z = Math.max(e, Math.min(t, this.z)),
            this.w = Math.max(e, Math.min(t, this.w)),
            this
        }
        clampLength(e, t) {
            let n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
        }
        floor() {
            return this.x = Math.floor(this.x),
            this.y = Math.floor(this.y),
            this.z = Math.floor(this.z),
            this.w = Math.floor(this.w),
            this
        }
        ceil() {
            return this.x = Math.ceil(this.x),
            this.y = Math.ceil(this.y),
            this.z = Math.ceil(this.z),
            this.w = Math.ceil(this.w),
            this
        }
        round() {
            return this.x = Math.round(this.x),
            this.y = Math.round(this.y),
            this.z = Math.round(this.z),
            this.w = Math.round(this.w),
            this
        }
        roundToZero() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
            this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
            this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
            this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w),
            this
        }
        negate() {
            return this.x = -this.x,
            this.y = -this.y,
            this.z = -this.z,
            this.w = -this.w,
            this
        }
        dot(e) {
            return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
        }
        lengthSq() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
        }
        manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
        }
        normalize() {
            return this.divideScalar(this.length() || 1)
        }
        setLength(e) {
            return this.normalize().multiplyScalar(e)
        }
        lerp(e, t) {
            return this.x += (e.x - this.x) * t,
            this.y += (e.y - this.y) * t,
            this.z += (e.z - this.z) * t,
            this.w += (e.w - this.w) * t,
            this
        }
        lerpVectors(e, t, n) {
            return this.x = e.x + (t.x - e.x) * n,
            this.y = e.y + (t.y - e.y) * n,
            this.z = e.z + (t.z - e.z) * n,
            this.w = e.w + (t.w - e.w) * n,
            this
        }
        equals(e) {
            return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
        }
        fromArray(e, t=0) {
            return this.x = e[t],
            this.y = e[t + 1],
            this.z = e[t + 2],
            this.w = e[t + 3],
            this
        }
        toArray(e=[], t=0) {
            return e[t] = this.x,
            e[t + 1] = this.y,
            e[t + 2] = this.z,
            e[t + 3] = this.w,
            e
        }
        fromBufferAttribute(e, t) {
            return this.x = e.getX(t),
            this.y = e.getY(t),
            this.z = e.getZ(t),
            this.w = e.getW(t),
            this
        }
        random() {
            return this.x = Math.random(),
            this.y = Math.random(),
            this.z = Math.random(),
            this.w = Math.random(),
            this
        }
        *[Symbol.iterator]() {
            yield this.x,
            yield this.y,
            yield this.z,
            yield this.w
        }
    }
      , ds = class extends Ws {
        constructor(e=1, t=1, n={}) {
            super(),
            this.isWebGLRenderTarget = !0,
            this.width = e,
            this.height = t,
            this.depth = 1,
            this.scissor = new Lt(0,0,e,t),
            this.scissorTest = !1,
            this.viewport = new Lt(0,0,e,t);
            let i = {
                width: e,
                height: t,
                depth: 1
            };
            n.encoding !== void 0 && (Ac("THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."),
            n.colorSpace = n.encoding === Ro ? ct : Po),
            this.texture = new En(i,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.colorSpace),
            this.texture.isRenderTargetTexture = !0,
            this.texture.flipY = !1,
            this.texture.generateMipmaps = n.generateMipmaps !== void 0 ? n.generateMipmaps : !1,
            this.texture.internalFormat = n.internalFormat !== void 0 ? n.internalFormat : null,
            this.texture.minFilter = n.minFilter !== void 0 ? n.minFilter : bn,
            this.depthBuffer = n.depthBuffer !== void 0 ? n.depthBuffer : !0,
            this.stencilBuffer = n.stencilBuffer !== void 0 ? n.stencilBuffer : !1,
            this.depthTexture = n.depthTexture !== void 0 ? n.depthTexture : null,
            this.samples = n.samples !== void 0 ? n.samples : 0
        }
        setSize(e, t, n=1) {
            (this.width !== e || this.height !== t || this.depth !== n) && (this.width = e,
            this.height = t,
            this.depth = n,
            this.texture.image.width = e,
            this.texture.image.height = t,
            this.texture.image.depth = n,
            this.dispose()),
            this.viewport.set(0, 0, e, t),
            this.scissor.set(0, 0, e, t)
        }
        clone() {
            return new this.constructor().copy(this)
        }
        copy(e) {
            this.width = e.width,
            this.height = e.height,
            this.depth = e.depth,
            this.scissor.copy(e.scissor),
            this.scissorTest = e.scissorTest,
            this.viewport.copy(e.viewport),
            this.texture = e.texture.clone(),
            this.texture.isRenderTargetTexture = !0;
            let t = Object.assign({}, e.texture.image);
            return this.texture.source = new Th(t),
            this.depthBuffer = e.depthBuffer,
            this.stencilBuffer = e.stencilBuffer,
            e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
            this.samples = e.samples,
            this
        }
        dispose() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }
      , bh = class extends En {
        constructor(e=null, t=1, n=1, i=1) {
            super(null),
            this.isDataArrayTexture = !0,
            this.image = {
                data: e,
                width: t,
                height: n,
                depth: i
            },
            this.magFilter = Tn,
            this.minFilter = Tn,
            this.wrapR = Zt,
            this.generateMipmaps = !1,
            this.flipY = !1,
            this.unpackAlignment = 1
        }
    }
    ;
    var ep = class extends En {
        constructor(e=null, t=1, n=1, i=1) {
            super(null),
            this.isData3DTexture = !0,
            this.image = {
                data: e,
                width: t,
                height: n,
                depth: i
            },
            this.magFilter = Tn,
            this.minFilter = Tn,
            this.wrapR = Zt,
            this.generateMipmaps = !1,
            this.flipY = !1,
            this.unpackAlignment = 1
        }
    }
    ;
    var Sn = class {
        constructor(e=0, t=0, n=0, i=1) {
            this.isQuaternion = !0,
            this._x = e,
            this._y = t,
            this._z = n,
            this._w = i
        }
        static slerpFlat(e, t, n, i, s, o, a) {
            let l = n[i + 0]
              , c = n[i + 1]
              , u = n[i + 2]
              , h = n[i + 3]
              , f = s[o + 0]
              , m = s[o + 1]
              , g = s[o + 2]
              , v = s[o + 3];
            if (a === 0) {
                e[t + 0] = l,
                e[t + 1] = c,
                e[t + 2] = u,
                e[t + 3] = h;
                return
            }
            if (a === 1) {
                e[t + 0] = f,
                e[t + 1] = m,
                e[t + 2] = g,
                e[t + 3] = v;
                return
            }
            if (h !== v || l !== f || c !== m || u !== g) {
                let p = 1 - a
                  , d = l * f + c * m + u * g + h * v
                  , x = d >= 0 ? 1 : -1
                  , y = 1 - d * d;
                if (y > Number.EPSILON) {
                    let S = Math.sqrt(y)
                      , N = Math.atan2(S, d * x);
                    p = Math.sin(p * N) / S,
                    a = Math.sin(a * N) / S
                }
                let _ = a * x;
                if (l = l * p + f * _,
                c = c * p + m * _,
                u = u * p + g * _,
                h = h * p + v * _,
                p === 1 - a) {
                    let S = 1 / Math.sqrt(l * l + c * c + u * u + h * h);
                    l *= S,
                    c *= S,
                    u *= S,
                    h *= S
                }
            }
            e[t] = l,
            e[t + 1] = c,
            e[t + 2] = u,
            e[t + 3] = h
        }
        static multiplyQuaternionsFlat(e, t, n, i, s, o) {
            let a = n[i]
              , l = n[i + 1]
              , c = n[i + 2]
              , u = n[i + 3]
              , h = s[o]
              , f = s[o + 1]
              , m = s[o + 2]
              , g = s[o + 3];
            return e[t] = a * g + u * h + l * m - c * f,
            e[t + 1] = l * g + u * f + c * h - a * m,
            e[t + 2] = c * g + u * m + a * f - l * h,
            e[t + 3] = u * g - a * h - l * f - c * m,
            e
        }
        get x() {
            return this._x
        }
        set x(e) {
            this._x = e,
            this._onChangeCallback()
        }
        get y() {
            return this._y
        }
        set y(e) {
            this._y = e,
            this._onChangeCallback()
        }
        get z() {
            return this._z
        }
        set z(e) {
            this._z = e,
            this._onChangeCallback()
        }
        get w() {
            return this._w
        }
        set w(e) {
            this._w = e,
            this._onChangeCallback()
        }
        set(e, t, n, i) {
            return this._x = e,
            this._y = t,
            this._z = n,
            this._w = i,
            this._onChangeCallback(),
            this
        }
        clone() {
            return new this.constructor(this._x,this._y,this._z,this._w)
        }
        copy(e) {
            return this._x = e.x,
            this._y = e.y,
            this._z = e.z,
            this._w = e.w,
            this._onChangeCallback(),
            this
        }
        setFromEuler(e, t) {
            let n = e._x
              , i = e._y
              , s = e._z
              , o = e._order
              , a = Math.cos
              , l = Math.sin
              , c = a(n / 2)
              , u = a(i / 2)
              , h = a(s / 2)
              , f = l(n / 2)
              , m = l(i / 2)
              , g = l(s / 2);
            switch (o) {
            case "XYZ":
                this._x = f * u * h + c * m * g,
                this._y = c * m * h - f * u * g,
                this._z = c * u * g + f * m * h,
                this._w = c * u * h - f * m * g;
                break;
            case "YXZ":
                this._x = f * u * h + c * m * g,
                this._y = c * m * h - f * u * g,
                this._z = c * u * g - f * m * h,
                this._w = c * u * h + f * m * g;
                break;
            case "ZXY":
                this._x = f * u * h - c * m * g,
                this._y = c * m * h + f * u * g,
                this._z = c * u * g + f * m * h,
                this._w = c * u * h - f * m * g;
                break;
            case "ZYX":
                this._x = f * u * h - c * m * g,
                this._y = c * m * h + f * u * g,
                this._z = c * u * g - f * m * h,
                this._w = c * u * h + f * m * g;
                break;
            case "YZX":
                this._x = f * u * h + c * m * g,
                this._y = c * m * h + f * u * g,
                this._z = c * u * g - f * m * h,
                this._w = c * u * h - f * m * g;
                break;
            case "XZY":
                this._x = f * u * h - c * m * g,
                this._y = c * m * h - f * u * g,
                this._z = c * u * g + f * m * h,
                this._w = c * u * h + f * m * g;
                break;
            default:
                console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o)
            }
            return t !== !1 && this._onChangeCallback(),
            this
        }
        setFromAxisAngle(e, t) {
            let n = t / 2
              , i = Math.sin(n);
            return this._x = e.x * i,
            this._y = e.y * i,
            this._z = e.z * i,
            this._w = Math.cos(n),
            this._onChangeCallback(),
            this
        }
        setFromRotationMatrix(e) {
            let t = e.elements
              , n = t[0]
              , i = t[4]
              , s = t[8]
              , o = t[1]
              , a = t[5]
              , l = t[9]
              , c = t[2]
              , u = t[6]
              , h = t[10]
              , f = n + a + h;
            if (f > 0) {
                let m = .5 / Math.sqrt(f + 1);
                this._w = .25 / m,
                this._x = (u - l) * m,
                this._y = (s - c) * m,
                this._z = (o - i) * m
            } else if (n > a && n > h) {
                let m = 2 * Math.sqrt(1 + n - a - h);
                this._w = (u - l) / m,
                this._x = .25 * m,
                this._y = (i + o) / m,
                this._z = (s + c) / m
            } else if (a > h) {
                let m = 2 * Math.sqrt(1 + a - n - h);
                this._w = (s - c) / m,
                this._x = (i + o) / m,
                this._y = .25 * m,
                this._z = (l + u) / m
            } else {
                let m = 2 * Math.sqrt(1 + h - n - a);
                this._w = (o - i) / m,
                this._x = (s + c) / m,
                this._y = (l + u) / m,
                this._z = .25 * m
            }
            return this._onChangeCallback(),
            this
        }
        setFromUnitVectors(e, t) {
            let n = e.dot(t) + 1;
            return n < Number.EPSILON ? (n = 0,
            Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y,
            this._y = e.x,
            this._z = 0,
            this._w = n) : (this._x = 0,
            this._y = -e.z,
            this._z = e.y,
            this._w = n)) : (this._x = e.y * t.z - e.z * t.y,
            this._y = e.z * t.x - e.x * t.z,
            this._z = e.x * t.y - e.y * t.x,
            this._w = n),
            this.normalize()
        }
        angleTo(e) {
            return 2 * Math.acos(Math.abs(Vn(this.dot(e), -1, 1)))
        }
        rotateTowards(e, t) {
            let n = this.angleTo(e);
            if (n === 0)
                return this;
            let i = Math.min(1, t / n);
            return this.slerp(e, i),
            this
        }
        identity() {
            return this.set(0, 0, 0, 1)
        }
        invert() {
            return this.conjugate()
        }
        conjugate() {
            return this._x *= -1,
            this._y *= -1,
            this._z *= -1,
            this._onChangeCallback(),
            this
        }
        dot(e) {
            return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
        }
        lengthSq() {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
        }
        length() {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
        }
        normalize() {
            let e = this.length();
            return e === 0 ? (this._x = 0,
            this._y = 0,
            this._z = 0,
            this._w = 1) : (e = 1 / e,
            this._x = this._x * e,
            this._y = this._y * e,
            this._z = this._z * e,
            this._w = this._w * e),
            this._onChangeCallback(),
            this
        }
        multiply(e) {
            return this.multiplyQuaternions(this, e)
        }
        premultiply(e) {
            return this.multiplyQuaternions(e, this)
        }
        multiplyQuaternions(e, t) {
            let n = e._x
              , i = e._y
              , s = e._z
              , o = e._w
              , a = t._x
              , l = t._y
              , c = t._z
              , u = t._w;
            return this._x = n * u + o * a + i * c - s * l,
            this._y = i * u + o * l + s * a - n * c,
            this._z = s * u + o * c + n * l - i * a,
            this._w = o * u - n * a - i * l - s * c,
            this._onChangeCallback(),
            this
        }
        slerp(e, t) {
            if (t === 0)
                return this;
            if (t === 1)
                return this.copy(e);
            let n = this._x
              , i = this._y
              , s = this._z
              , o = this._w
              , a = o * e._w + n * e._x + i * e._y + s * e._z;
            if (a < 0 ? (this._w = -e._w,
            this._x = -e._x,
            this._y = -e._y,
            this._z = -e._z,
            a = -a) : this.copy(e),
            a >= 1)
                return this._w = o,
                this._x = n,
                this._y = i,
                this._z = s,
                this;
            let l = 1 - a * a;
            if (l <= Number.EPSILON) {
                let m = 1 - t;
                return this._w = m * o + t * this._w,
                this._x = m * n + t * this._x,
                this._y = m * i + t * this._y,
                this._z = m * s + t * this._z,
                this.normalize(),
                this._onChangeCallback(),
                this
            }
            let c = Math.sqrt(l)
              , u = Math.atan2(c, a)
              , h = Math.sin((1 - t) * u) / c
              , f = Math.sin(t * u) / c;
            return this._w = o * h + this._w * f,
            this._x = n * h + this._x * f,
            this._y = i * h + this._y * f,
            this._z = s * h + this._z * f,
            this._onChangeCallback(),
            this
        }
        slerpQuaternions(e, t, n) {
            return this.copy(e).slerp(t, n)
        }
        random() {
            let e = Math.random()
              , t = Math.sqrt(1 - e)
              , n = Math.sqrt(e)
              , i = 2 * Math.PI * Math.random()
              , s = 2 * Math.PI * Math.random();
            return this.set(t * Math.cos(i), n * Math.sin(s), n * Math.cos(s), t * Math.sin(i))
        }
        equals(e) {
            return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
        }
        fromArray(e, t=0) {
            return this._x = e[t],
            this._y = e[t + 1],
            this._z = e[t + 2],
            this._w = e[t + 3],
            this._onChangeCallback(),
            this
        }
        toArray(e=[], t=0) {
            return e[t] = this._x,
            e[t + 1] = this._y,
            e[t + 2] = this._z,
            e[t + 3] = this._w,
            e
        }
        fromBufferAttribute(e, t) {
            return this._x = e.getX(t),
            this._y = e.getY(t),
            this._z = e.getZ(t),
            this._w = e.getW(t),
            this
        }
        toJSON() {
            return this.toArray()
        }
        _onChange(e) {
            return this._onChangeCallback = e,
            this
        }
        _onChangeCallback() {}
        *[Symbol.iterator]() {
            yield this._x,
            yield this._y,
            yield this._z,
            yield this._w
        }
    }
      , ue = class {
        constructor(e=0, t=0, n=0) {
            ue.prototype.isVector3 = !0,
            this.x = e,
            this.y = t,
            this.z = n
        }
        set(e, t, n) {
            return n === void 0 && (n = this.z),
            this.x = e,
            this.y = t,
            this.z = n,
            this
        }
        setScalar(e) {
            return this.x = e,
            this.y = e,
            this.z = e,
            this
        }
        setX(e) {
            return this.x = e,
            this
        }
        setY(e) {
            return this.y = e,
            this
        }
        setZ(e) {
            return this.z = e,
            this
        }
        setComponent(e, t) {
            switch (e) {
            case 0:
                this.x = t;
                break;
            case 1:
                this.y = t;
                break;
            case 2:
                this.z = t;
                break;
            default:
                throw new Error("index is out of range: " + e)
            }
            return this
        }
        getComponent(e) {
            switch (e) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            default:
                throw new Error("index is out of range: " + e)
            }
        }
        clone() {
            return new this.constructor(this.x,this.y,this.z)
        }
        copy(e) {
            return this.x = e.x,
            this.y = e.y,
            this.z = e.z,
            this
        }
        add(e) {
            return this.x += e.x,
            this.y += e.y,
            this.z += e.z,
            this
        }
        addScalar(e) {
            return this.x += e,
            this.y += e,
            this.z += e,
            this
        }
        addVectors(e, t) {
            return this.x = e.x + t.x,
            this.y = e.y + t.y,
            this.z = e.z + t.z,
            this
        }
        addScaledVector(e, t) {
            return this.x += e.x * t,
            this.y += e.y * t,
            this.z += e.z * t,
            this
        }
        sub(e) {
            return this.x -= e.x,
            this.y -= e.y,
            this.z -= e.z,
            this
        }
        subScalar(e) {
            return this.x -= e,
            this.y -= e,
            this.z -= e,
            this
        }
        subVectors(e, t) {
            return this.x = e.x - t.x,
            this.y = e.y - t.y,
            this.z = e.z - t.z,
            this
        }
        multiply(e) {
            return this.x *= e.x,
            this.y *= e.y,
            this.z *= e.z,
            this
        }
        multiplyScalar(e) {
            return this.x *= e,
            this.y *= e,
            this.z *= e,
            this
        }
        multiplyVectors(e, t) {
            return this.x = e.x * t.x,
            this.y = e.y * t.y,
            this.z = e.z * t.z,
            this
        }
        applyEuler(e) {
            return this.applyQuaternion(a0.setFromEuler(e))
        }
        applyAxisAngle(e, t) {
            return this.applyQuaternion(a0.setFromAxisAngle(e, t))
        }
        applyMatrix3(e) {
            let t = this.x
              , n = this.y
              , i = this.z
              , s = e.elements;
            return this.x = s[0] * t + s[3] * n + s[6] * i,
            this.y = s[1] * t + s[4] * n + s[7] * i,
            this.z = s[2] * t + s[5] * n + s[8] * i,
            this
        }
        applyNormalMatrix(e) {
            return this.applyMatrix3(e).normalize()
        }
        applyMatrix4(e) {
            let t = this.x
              , n = this.y
              , i = this.z
              , s = e.elements
              , o = 1 / (s[3] * t + s[7] * n + s[11] * i + s[15]);
            return this.x = (s[0] * t + s[4] * n + s[8] * i + s[12]) * o,
            this.y = (s[1] * t + s[5] * n + s[9] * i + s[13]) * o,
            this.z = (s[2] * t + s[6] * n + s[10] * i + s[14]) * o,
            this
        }
        applyQuaternion(e) {
            let t = this.x
              , n = this.y
              , i = this.z
              , s = e.x
              , o = e.y
              , a = e.z
              , l = e.w
              , c = l * t + o * i - a * n
              , u = l * n + a * t - s * i
              , h = l * i + s * n - o * t
              , f = -s * t - o * n - a * i;
            return this.x = c * l + f * -s + u * -a - h * -o,
            this.y = u * l + f * -o + h * -s - c * -a,
            this.z = h * l + f * -a + c * -o - u * -s,
            this
        }
        project(e) {
            return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
        }
        unproject(e) {
            return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
        }
        transformDirection(e) {
            let t = this.x
              , n = this.y
              , i = this.z
              , s = e.elements;
            return this.x = s[0] * t + s[4] * n + s[8] * i,
            this.y = s[1] * t + s[5] * n + s[9] * i,
            this.z = s[2] * t + s[6] * n + s[10] * i,
            this.normalize()
        }
        divide(e) {
            return this.x /= e.x,
            this.y /= e.y,
            this.z /= e.z,
            this
        }
        divideScalar(e) {
            return this.multiplyScalar(1 / e)
        }
        min(e) {
            return this.x = Math.min(this.x, e.x),
            this.y = Math.min(this.y, e.y),
            this.z = Math.min(this.z, e.z),
            this
        }
        max(e) {
            return this.x = Math.max(this.x, e.x),
            this.y = Math.max(this.y, e.y),
            this.z = Math.max(this.z, e.z),
            this
        }
        clamp(e, t) {
            return this.x = Math.max(e.x, Math.min(t.x, this.x)),
            this.y = Math.max(e.y, Math.min(t.y, this.y)),
            this.z = Math.max(e.z, Math.min(t.z, this.z)),
            this
        }
        clampScalar(e, t) {
            return this.x = Math.max(e, Math.min(t, this.x)),
            this.y = Math.max(e, Math.min(t, this.y)),
            this.z = Math.max(e, Math.min(t, this.z)),
            this
        }
        clampLength(e, t) {
            let n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
        }
        floor() {
            return this.x = Math.floor(this.x),
            this.y = Math.floor(this.y),
            this.z = Math.floor(this.z),
            this
        }
        ceil() {
            return this.x = Math.ceil(this.x),
            this.y = Math.ceil(this.y),
            this.z = Math.ceil(this.z),
            this
        }
        round() {
            return this.x = Math.round(this.x),
            this.y = Math.round(this.y),
            this.z = Math.round(this.z),
            this
        }
        roundToZero() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
            this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
            this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
            this
        }
        negate() {
            return this.x = -this.x,
            this.y = -this.y,
            this.z = -this.z,
            this
        }
        dot(e) {
            return this.x * e.x + this.y * e.y + this.z * e.z
        }
        lengthSq() {
            return this.x * this.x + this.y * this.y + this.z * this.z
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
        }
        manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
        }
        normalize() {
            return this.divideScalar(this.length() || 1)
        }
        setLength(e) {
            return this.normalize().multiplyScalar(e)
        }
        lerp(e, t) {
            return this.x += (e.x - this.x) * t,
            this.y += (e.y - this.y) * t,
            this.z += (e.z - this.z) * t,
            this
        }
        lerpVectors(e, t, n) {
            return this.x = e.x + (t.x - e.x) * n,
            this.y = e.y + (t.y - e.y) * n,
            this.z = e.z + (t.z - e.z) * n,
            this
        }
        cross(e) {
            return this.crossVectors(this, e)
        }
        crossVectors(e, t) {
            let n = e.x
              , i = e.y
              , s = e.z
              , o = t.x
              , a = t.y
              , l = t.z;
            return this.x = i * l - s * a,
            this.y = s * o - n * l,
            this.z = n * a - i * o,
            this
        }
        projectOnVector(e) {
            let t = e.lengthSq();
            if (t === 0)
                return this.set(0, 0, 0);
            let n = e.dot(this) / t;
            return this.copy(e).multiplyScalar(n)
        }
        projectOnPlane(e) {
            return wd.copy(this).projectOnVector(e),
            this.sub(wd)
        }
        reflect(e) {
            return this.sub(wd.copy(e).multiplyScalar(2 * this.dot(e)))
        }
        angleTo(e) {
            let t = Math.sqrt(this.lengthSq() * e.lengthSq());
            if (t === 0)
                return Math.PI / 2;
            let n = this.dot(e) / t;
            return Math.acos(Vn(n, -1, 1))
        }
        distanceTo(e) {
            return Math.sqrt(this.distanceToSquared(e))
        }
        distanceToSquared(e) {
            let t = this.x - e.x
              , n = this.y - e.y
              , i = this.z - e.z;
            return t * t + n * n + i * i
        }
        manhattanDistanceTo(e) {
            return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
        }
        setFromSpherical(e) {
            return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
        }
        setFromSphericalCoords(e, t, n) {
            let i = Math.sin(t) * e;
            return this.x = i * Math.sin(n),
            this.y = Math.cos(t) * e,
            this.z = i * Math.cos(n),
            this
        }
        setFromCylindrical(e) {
            return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
        }
        setFromCylindricalCoords(e, t, n) {
            return this.x = e * Math.sin(t),
            this.y = n,
            this.z = e * Math.cos(t),
            this
        }
        setFromMatrixPosition(e) {
            let t = e.elements;
            return this.x = t[12],
            this.y = t[13],
            this.z = t[14],
            this
        }
        setFromMatrixScale(e) {
            let t = this.setFromMatrixColumn(e, 0).length()
              , n = this.setFromMatrixColumn(e, 1).length()
              , i = this.setFromMatrixColumn(e, 2).length();
            return this.x = t,
            this.y = n,
            this.z = i,
            this
        }
        setFromMatrixColumn(e, t) {
            return this.fromArray(e.elements, t * 4)
        }
        setFromMatrix3Column(e, t) {
            return this.fromArray(e.elements, t * 3)
        }
        setFromEuler(e) {
            return this.x = e._x,
            this.y = e._y,
            this.z = e._z,
            this
        }
        setFromColor(e) {
            return this.x = e.r,
            this.y = e.g,
            this.z = e.b,
            this
        }
        equals(e) {
            return e.x === this.x && e.y === this.y && e.z === this.z
        }
        fromArray(e, t=0) {
            return this.x = e[t],
            this.y = e[t + 1],
            this.z = e[t + 2],
            this
        }
        toArray(e=[], t=0) {
            return e[t] = this.x,
            e[t + 1] = this.y,
            e[t + 2] = this.z,
            e
        }
        fromBufferAttribute(e, t) {
            return this.x = e.getX(t),
            this.y = e.getY(t),
            this.z = e.getZ(t),
            this
        }
        random() {
            return this.x = Math.random(),
            this.y = Math.random(),
            this.z = Math.random(),
            this
        }
        randomDirection() {
            let e = (Math.random() - .5) * 2
              , t = Math.random() * Math.PI * 2
              , n = Math.sqrt(1 - e ** 2);
            return this.x = n * Math.cos(t),
            this.y = n * Math.sin(t),
            this.z = e,
            this
        }
        *[Symbol.iterator]() {
            yield this.x,
            yield this.y,
            yield this.z
        }
    }
      , wd = new ue
      , a0 = new Sn
      , cr = class {
        constructor(e=new ue(1 / 0,1 / 0,1 / 0), t=new ue(-1 / 0,-1 / 0,-1 / 0)) {
            this.isBox3 = !0,
            this.min = e,
            this.max = t
        }
        set(e, t) {
            return this.min.copy(e),
            this.max.copy(t),
            this
        }
        setFromArray(e) {
            this.makeEmpty();
            for (let t = 0, n = e.length; t < n; t += 3)
                this.expandByPoint(ss.fromArray(e, t));
            return this
        }
        setFromBufferAttribute(e) {
            this.makeEmpty();
            for (let t = 0, n = e.count; t < n; t++)
                this.expandByPoint(ss.fromBufferAttribute(e, t));
            return this
        }
        setFromPoints(e) {
            this.makeEmpty();
            for (let t = 0, n = e.length; t < n; t++)
                this.expandByPoint(e[t]);
            return this
        }
        setFromCenterAndSize(e, t) {
            let n = ss.copy(t).multiplyScalar(.5);
            return this.min.copy(e).sub(n),
            this.max.copy(e).add(n),
            this
        }
        setFromObject(e, t=!1) {
            return this.makeEmpty(),
            this.expandByObject(e, t)
        }
        clone() {
            return new this.constructor().copy(this)
        }
        copy(e) {
            return this.min.copy(e.min),
            this.max.copy(e.max),
            this
        }
        makeEmpty() {
            return this.min.x = this.min.y = this.min.z = 1 / 0,
            this.max.x = this.max.y = this.max.z = -1 / 0,
            this
        }
        isEmpty() {
            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
        }
        getCenter(e) {
            return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
        }
        getSize(e) {
            return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
        }
        expandByPoint(e) {
            return this.min.min(e),
            this.max.max(e),
            this
        }
        expandByVector(e) {
            return this.min.sub(e),
            this.max.add(e),
            this
        }
        expandByScalar(e) {
            return this.min.addScalar(-e),
            this.max.addScalar(e),
            this
        }
        expandByObject(e, t=!1) {
            if (e.updateWorldMatrix(!1, !1),
            e.boundingBox !== void 0)
                e.boundingBox === null && e.computeBoundingBox(),
                fa.copy(e.boundingBox),
                fa.applyMatrix4(e.matrixWorld),
                this.union(fa);
            else {
                let i = e.geometry;
                if (i !== void 0)
                    if (t && i.attributes !== void 0 && i.attributes.position !== void 0) {
                        let s = i.attributes.position;
                        for (let o = 0, a = s.count; o < a; o++)
                            ss.fromBufferAttribute(s, o).applyMatrix4(e.matrixWorld),
                            this.expandByPoint(ss)
                    } else
                        i.boundingBox === null && i.computeBoundingBox(),
                        fa.copy(i.boundingBox),
                        fa.applyMatrix4(e.matrixWorld),
                        this.union(fa)
            }
            let n = e.children;
            for (let i = 0, s = n.length; i < s; i++)
                this.expandByObject(n[i], t);
            return this
        }
        containsPoint(e) {
            return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
        }
        containsBox(e) {
            return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
        }
        getParameter(e, t) {
            return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
        }
        intersectsBox(e) {
            return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
        }
        intersectsSphere(e) {
            return this.clampPoint(e.center, ss),
            ss.distanceToSquared(e.center) <= e.radius * e.radius
        }
        intersectsPlane(e) {
            let t, n;
            return e.normal.x > 0 ? (t = e.normal.x * this.min.x,
            n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x,
            n = e.normal.x * this.min.x),
            e.normal.y > 0 ? (t += e.normal.y * this.min.y,
            n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y,
            n += e.normal.y * this.min.y),
            e.normal.z > 0 ? (t += e.normal.z * this.min.z,
            n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z,
            n += e.normal.z * this.min.z),
            t <= -e.constant && n >= -e.constant
        }
        intersectsTriangle(e) {
            if (this.isEmpty())
                return !1;
            this.getCenter(xc),
            Hu.subVectors(this.max, xc),
            da.subVectors(e.a, xc),
            pa.subVectors(e.b, xc),
            ma.subVectors(e.c, xc),
            Fs.subVectors(pa, da),
            ks.subVectors(ma, pa),
            Mo.subVectors(da, ma);
            let t = [0, -Fs.z, Fs.y, 0, -ks.z, ks.y, 0, -Mo.z, Mo.y, Fs.z, 0, -Fs.x, ks.z, 0, -ks.x, Mo.z, 0, -Mo.x, -Fs.y, Fs.x, 0, -ks.y, ks.x, 0, -Mo.y, Mo.x, 0];
            return !Ad(t, da, pa, ma, Hu) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1],
            !Ad(t, da, pa, ma, Hu)) ? !1 : (Wu.crossVectors(Fs, ks),
            t = [Wu.x, Wu.y, Wu.z],
            Ad(t, da, pa, ma, Hu))
        }
        clampPoint(e, t) {
            return t.copy(e).clamp(this.min, this.max)
        }
        distanceToPoint(e) {
            return this.clampPoint(e, ss).distanceTo(e)
        }
        getBoundingSphere(e) {
            return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center),
            e.radius = this.getSize(ss).length() * .5),
            e
        }
        intersect(e) {
            return this.min.max(e.min),
            this.max.min(e.max),
            this.isEmpty() && this.makeEmpty(),
            this
        }
        union(e) {
            return this.min.min(e.min),
            this.max.max(e.max),
            this
        }
        applyMatrix4(e) {
            return this.isEmpty() ? this : (rs[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
            rs[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
            rs[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
            rs[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
            rs[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
            rs[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
            rs[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
            rs[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
            this.setFromPoints(rs),
            this)
        }
        translate(e) {
            return this.min.add(e),
            this.max.add(e),
            this
        }
        equals(e) {
            return e.min.equals(this.min) && e.max.equals(this.max)
        }
    }
      , rs = [new ue, new ue, new ue, new ue, new ue, new ue, new ue, new ue]
      , ss = new ue
      , fa = new cr
      , da = new ue
      , pa = new ue
      , ma = new ue
      , Fs = new ue
      , ks = new ue
      , Mo = new ue
      , xc = new ue
      , Hu = new ue
      , Wu = new ue
      , Eo = new ue;
    function Ad(r, e, t, n, i) {
        for (let s = 0, o = r.length - 3; s <= o; s += 3) {
            Eo.fromArray(r, s);
            let a = i.x * Math.abs(Eo.x) + i.y * Math.abs(Eo.y) + i.z * Math.abs(Eo.z)
              , l = e.dot(Eo)
              , c = t.dot(Eo)
              , u = n.dot(Eo);
            if (Math.max(-Math.max(l, c, u), Math.min(l, c, u)) > a)
                return !1
        }
        return !0
    }
    var F_ = new cr
      , _c = new ue
      , Cd = new ue
      , Nr = class {
        constructor(e=new ue, t=-1) {
            this.center = e,
            this.radius = t
        }
        set(e, t) {
            return this.center.copy(e),
            this.radius = t,
            this
        }
        setFromPoints(e, t) {
            let n = this.center;
            t !== void 0 ? n.copy(t) : F_.setFromPoints(e).getCenter(n);
            let i = 0;
            for (let s = 0, o = e.length; s < o; s++)
                i = Math.max(i, n.distanceToSquared(e[s]));
            return this.radius = Math.sqrt(i),
            this
        }
        copy(e) {
            return this.center.copy(e.center),
            this.radius = e.radius,
            this
        }
        isEmpty() {
            return this.radius < 0
        }
        makeEmpty() {
            return this.center.set(0, 0, 0),
            this.radius = -1,
            this
        }
        containsPoint(e) {
            return e.distanceToSquared(this.center) <= this.radius * this.radius
        }
        distanceToPoint(e) {
            return e.distanceTo(this.center) - this.radius
        }
        intersectsSphere(e) {
            let t = this.radius + e.radius;
            return e.center.distanceToSquared(this.center) <= t * t
        }
        intersectsBox(e) {
            return e.intersectsSphere(this)
        }
        intersectsPlane(e) {
            return Math.abs(e.distanceToPoint(this.center)) <= this.radius
        }
        clampPoint(e, t) {
            let n = this.center.distanceToSquared(e);
            return t.copy(e),
            n > this.radius * this.radius && (t.sub(this.center).normalize(),
            t.multiplyScalar(this.radius).add(this.center)),
            t
        }
        getBoundingBox(e) {
            return this.isEmpty() ? (e.makeEmpty(),
            e) : (e.set(this.center, this.center),
            e.expandByScalar(this.radius),
            e)
        }
        applyMatrix4(e) {
            return this.center.applyMatrix4(e),
            this.radius = this.radius * e.getMaxScaleOnAxis(),
            this
        }
        translate(e) {
            return this.center.add(e),
            this
        }
        expandByPoint(e) {
            if (this.isEmpty())
                return this.center.copy(e),
                this.radius = 0,
                this;
            _c.subVectors(e, this.center);
            let t = _c.lengthSq();
            if (t > this.radius * this.radius) {
                let n = Math.sqrt(t)
                  , i = (n - this.radius) * .5;
                this.center.addScaledVector(_c, i / n),
                this.radius += i
            }
            return this
        }
        union(e) {
            return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e),
            this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (Cd.subVectors(e.center, this.center).setLength(e.radius),
            this.expandByPoint(_c.copy(e.center).add(Cd)),
            this.expandByPoint(_c.copy(e.center).sub(Cd))),
            this)
        }
        equals(e) {
            return e.center.equals(this.center) && e.radius === this.radius
        }
        clone() {
            return new this.constructor().copy(this)
        }
    }
      , os = new ue
      , Id = new ue
      , Xu = new ue
      , Us = new ue
      , Rd = new ue
      , ju = new ue
      , Pd = new ue
      , Va = class {
        constructor(e=new ue, t=new ue(0,0,-1)) {
            this.origin = e,
            this.direction = t
        }
        set(e, t) {
            return this.origin.copy(e),
            this.direction.copy(t),
            this
        }
        copy(e) {
            return this.origin.copy(e.origin),
            this.direction.copy(e.direction),
            this
        }
        at(e, t) {
            return t.copy(this.origin).addScaledVector(this.direction, e)
        }
        lookAt(e) {
            return this.direction.copy(e).sub(this.origin).normalize(),
            this
        }
        recast(e) {
            return this.origin.copy(this.at(e, os)),
            this
        }
        closestPointToPoint(e, t) {
            t.subVectors(e, this.origin);
            let n = t.dot(this.direction);
            return n < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, n)
        }
        distanceToPoint(e) {
            return Math.sqrt(this.distanceSqToPoint(e))
        }
        distanceSqToPoint(e) {
            let t = os.subVectors(e, this.origin).dot(this.direction);
            return t < 0 ? this.origin.distanceToSquared(e) : (os.copy(this.origin).addScaledVector(this.direction, t),
            os.distanceToSquared(e))
        }
        distanceSqToSegment(e, t, n, i) {
            Id.copy(e).add(t).multiplyScalar(.5),
            Xu.copy(t).sub(e).normalize(),
            Us.copy(this.origin).sub(Id);
            let s = e.distanceTo(t) * .5, o = -this.direction.dot(Xu), a = Us.dot(this.direction), l = -Us.dot(Xu), c = Us.lengthSq(), u = Math.abs(1 - o * o), h, f, m, g;
            if (u > 0)
                if (h = o * l - a,
                f = o * a - l,
                g = s * u,
                h >= 0)
                    if (f >= -g)
                        if (f <= g) {
                            let v = 1 / u;
                            h *= v,
                            f *= v,
                            m = h * (h + o * f + 2 * a) + f * (o * h + f + 2 * l) + c
                        } else
                            f = s,
                            h = Math.max(0, -(o * f + a)),
                            m = -h * h + f * (f + 2 * l) + c;
                    else
                        f = -s,
                        h = Math.max(0, -(o * f + a)),
                        m = -h * h + f * (f + 2 * l) + c;
                else
                    f <= -g ? (h = Math.max(0, -(-o * s + a)),
                    f = h > 0 ? -s : Math.min(Math.max(-s, -l), s),
                    m = -h * h + f * (f + 2 * l) + c) : f <= g ? (h = 0,
                    f = Math.min(Math.max(-s, -l), s),
                    m = f * (f + 2 * l) + c) : (h = Math.max(0, -(o * s + a)),
                    f = h > 0 ? s : Math.min(Math.max(-s, -l), s),
                    m = -h * h + f * (f + 2 * l) + c);
            else
                f = o > 0 ? -s : s,
                h = Math.max(0, -(o * f + a)),
                m = -h * h + f * (f + 2 * l) + c;
            return n && n.copy(this.origin).addScaledVector(this.direction, h),
            i && i.copy(Id).addScaledVector(Xu, f),
            m
        }
        intersectSphere(e, t) {
            os.subVectors(e.center, this.origin);
            let n = os.dot(this.direction)
              , i = os.dot(os) - n * n
              , s = e.radius * e.radius;
            if (i > s)
                return null;
            let o = Math.sqrt(s - i)
              , a = n - o
              , l = n + o;
            return l < 0 ? null : a < 0 ? this.at(l, t) : this.at(a, t)
        }
        intersectsSphere(e) {
            return this.distanceSqToPoint(e.center) <= e.radius * e.radius
        }
        distanceToPlane(e) {
            let t = e.normal.dot(this.direction);
            if (t === 0)
                return e.distanceToPoint(this.origin) === 0 ? 0 : null;
            let n = -(this.origin.dot(e.normal) + e.constant) / t;
            return n >= 0 ? n : null
        }
        intersectPlane(e, t) {
            let n = this.distanceToPlane(e);
            return n === null ? null : this.at(n, t)
        }
        intersectsPlane(e) {
            let t = e.distanceToPoint(this.origin);
            return t === 0 || e.normal.dot(this.direction) * t < 0
        }
        intersectBox(e, t) {
            let n, i, s, o, a, l, c = 1 / this.direction.x, u = 1 / this.direction.y, h = 1 / this.direction.z, f = this.origin;
            return c >= 0 ? (n = (e.min.x - f.x) * c,
            i = (e.max.x - f.x) * c) : (n = (e.max.x - f.x) * c,
            i = (e.min.x - f.x) * c),
            u >= 0 ? (s = (e.min.y - f.y) * u,
            o = (e.max.y - f.y) * u) : (s = (e.max.y - f.y) * u,
            o = (e.min.y - f.y) * u),
            n > o || s > i || ((s > n || isNaN(n)) && (n = s),
            (o < i || isNaN(i)) && (i = o),
            h >= 0 ? (a = (e.min.z - f.z) * h,
            l = (e.max.z - f.z) * h) : (a = (e.max.z - f.z) * h,
            l = (e.min.z - f.z) * h),
            n > l || a > i) || ((a > n || n !== n) && (n = a),
            (l < i || i !== i) && (i = l),
            i < 0) ? null : this.at(n >= 0 ? n : i, t)
        }
        intersectsBox(e) {
            return this.intersectBox(e, os) !== null
        }
        intersectTriangle(e, t, n, i, s) {
            Rd.subVectors(t, e),
            ju.subVectors(n, e),
            Pd.crossVectors(Rd, ju);
            let o = this.direction.dot(Pd), a;
            if (o > 0) {
                if (i)
                    return null;
                a = 1
            } else if (o < 0)
                a = -1,
                o = -o;
            else
                return null;
            Us.subVectors(this.origin, e);
            let l = a * this.direction.dot(ju.crossVectors(Us, ju));
            if (l < 0)
                return null;
            let c = a * this.direction.dot(Rd.cross(Us));
            if (c < 0 || l + c > o)
                return null;
            let u = -a * Us.dot(Pd);
            return u < 0 ? null : this.at(u / o, s)
        }
        applyMatrix4(e) {
            return this.origin.applyMatrix4(e),
            this.direction.transformDirection(e),
            this
        }
        equals(e) {
            return e.origin.equals(this.origin) && e.direction.equals(this.direction)
        }
        clone() {
            return new this.constructor().copy(this)
        }
    }
      , je = class {
        constructor() {
            je.prototype.isMatrix4 = !0,
            this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
        }
        set(e, t, n, i, s, o, a, l, c, u, h, f, m, g, v, p) {
            let d = this.elements;
            return d[0] = e,
            d[4] = t,
            d[8] = n,
            d[12] = i,
            d[1] = s,
            d[5] = o,
            d[9] = a,
            d[13] = l,
            d[2] = c,
            d[6] = u,
            d[10] = h,
            d[14] = f,
            d[3] = m,
            d[7] = g,
            d[11] = v,
            d[15] = p,
            this
        }
        identity() {
            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
            this
        }
        clone() {
            return new je().fromArray(this.elements)
        }
        copy(e) {
            let t = this.elements
              , n = e.elements;
            return t[0] = n[0],
            t[1] = n[1],
            t[2] = n[2],
            t[3] = n[3],
            t[4] = n[4],
            t[5] = n[5],
            t[6] = n[6],
            t[7] = n[7],
            t[8] = n[8],
            t[9] = n[9],
            t[10] = n[10],
            t[11] = n[11],
            t[12] = n[12],
            t[13] = n[13],
            t[14] = n[14],
            t[15] = n[15],
            this
        }
        copyPosition(e) {
            let t = this.elements
              , n = e.elements;
            return t[12] = n[12],
            t[13] = n[13],
            t[14] = n[14],
            this
        }
        setFromMatrix3(e) {
            let t = e.elements;
            return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1),
            this
        }
        extractBasis(e, t, n) {
            return e.setFromMatrixColumn(this, 0),
            t.setFromMatrixColumn(this, 1),
            n.setFromMatrixColumn(this, 2),
            this
        }
        makeBasis(e, t, n) {
            return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1),
            this
        }
        extractRotation(e) {
            let t = this.elements
              , n = e.elements
              , i = 1 / ga.setFromMatrixColumn(e, 0).length()
              , s = 1 / ga.setFromMatrixColumn(e, 1).length()
              , o = 1 / ga.setFromMatrixColumn(e, 2).length();
            return t[0] = n[0] * i,
            t[1] = n[1] * i,
            t[2] = n[2] * i,
            t[3] = 0,
            t[4] = n[4] * s,
            t[5] = n[5] * s,
            t[6] = n[6] * s,
            t[7] = 0,
            t[8] = n[8] * o,
            t[9] = n[9] * o,
            t[10] = n[10] * o,
            t[11] = 0,
            t[12] = 0,
            t[13] = 0,
            t[14] = 0,
            t[15] = 1,
            this
        }
        makeRotationFromEuler(e) {
            let t = this.elements
              , n = e.x
              , i = e.y
              , s = e.z
              , o = Math.cos(n)
              , a = Math.sin(n)
              , l = Math.cos(i)
              , c = Math.sin(i)
              , u = Math.cos(s)
              , h = Math.sin(s);
            if (e.order === "XYZ") {
                let f = o * u
                  , m = o * h
                  , g = a * u
                  , v = a * h;
                t[0] = l * u,
                t[4] = -l * h,
                t[8] = c,
                t[1] = m + g * c,
                t[5] = f - v * c,
                t[9] = -a * l,
                t[2] = v - f * c,
                t[6] = g + m * c,
                t[10] = o * l
            } else if (e.order === "YXZ") {
                let f = l * u
                  , m = l * h
                  , g = c * u
                  , v = c * h;
                t[0] = f + v * a,
                t[4] = g * a - m,
                t[8] = o * c,
                t[1] = o * h,
                t[5] = o * u,
                t[9] = -a,
                t[2] = m * a - g,
                t[6] = v + f * a,
                t[10] = o * l
            } else if (e.order === "ZXY") {
                let f = l * u
                  , m = l * h
                  , g = c * u
                  , v = c * h;
                t[0] = f - v * a,
                t[4] = -o * h,
                t[8] = g + m * a,
                t[1] = m + g * a,
                t[5] = o * u,
                t[9] = v - f * a,
                t[2] = -o * c,
                t[6] = a,
                t[10] = o * l
            } else if (e.order === "ZYX") {
                let f = o * u
                  , m = o * h
                  , g = a * u
                  , v = a * h;
                t[0] = l * u,
                t[4] = g * c - m,
                t[8] = f * c + v,
                t[1] = l * h,
                t[5] = v * c + f,
                t[9] = m * c - g,
                t[2] = -c,
                t[6] = a * l,
                t[10] = o * l
            } else if (e.order === "YZX") {
                let f = o * l
                  , m = o * c
                  , g = a * l
                  , v = a * c;
                t[0] = l * u,
                t[4] = v - f * h,
                t[8] = g * h + m,
                t[1] = h,
                t[5] = o * u,
                t[9] = -a * u,
                t[2] = -c * u,
                t[6] = m * h + g,
                t[10] = f - v * h
            } else if (e.order === "XZY") {
                let f = o * l
                  , m = o * c
                  , g = a * l
                  , v = a * c;
                t[0] = l * u,
                t[4] = -h,
                t[8] = c * u,
                t[1] = f * h + v,
                t[5] = o * u,
                t[9] = m * h - g,
                t[2] = g * h - m,
                t[6] = a * u,
                t[10] = v * h + f
            }
            return t[3] = 0,
            t[7] = 0,
            t[11] = 0,
            t[12] = 0,
            t[13] = 0,
            t[14] = 0,
            t[15] = 1,
            this
        }
        makeRotationFromQuaternion(e) {
            return this.compose(k_, e, U_)
        }
        lookAt(e, t, n) {
            let i = this.elements;
            return Ri.subVectors(e, t),
            Ri.lengthSq() === 0 && (Ri.z = 1),
            Ri.normalize(),
            Bs.crossVectors(n, Ri),
            Bs.lengthSq() === 0 && (Math.abs(n.z) === 1 ? Ri.x += 1e-4 : Ri.z += 1e-4,
            Ri.normalize(),
            Bs.crossVectors(n, Ri)),
            Bs.normalize(),
            qu.crossVectors(Ri, Bs),
            i[0] = Bs.x,
            i[4] = qu.x,
            i[8] = Ri.x,
            i[1] = Bs.y,
            i[5] = qu.y,
            i[9] = Ri.y,
            i[2] = Bs.z,
            i[6] = qu.z,
            i[10] = Ri.z,
            this
        }
        multiply(e) {
            return this.multiplyMatrices(this, e)
        }
        premultiply(e) {
            return this.multiplyMatrices(e, this)
        }
        multiplyMatrices(e, t) {
            let n = e.elements
              , i = t.elements
              , s = this.elements
              , o = n[0]
              , a = n[4]
              , l = n[8]
              , c = n[12]
              , u = n[1]
              , h = n[5]
              , f = n[9]
              , m = n[13]
              , g = n[2]
              , v = n[6]
              , p = n[10]
              , d = n[14]
              , x = n[3]
              , y = n[7]
              , _ = n[11]
              , S = n[15]
              , N = i[0]
              , I = i[4]
              , O = i[8]
              , M = i[12]
              , R = i[1]
              , q = i[5]
              , k = i[9]
              , B = i[13]
              , P = i[2]
              , C = i[6]
              , L = i[10]
              , F = i[14]
              , U = i[3]
              , W = i[7]
              , K = i[11]
              , re = i[15];
            return s[0] = o * N + a * R + l * P + c * U,
            s[4] = o * I + a * q + l * C + c * W,
            s[8] = o * O + a * k + l * L + c * K,
            s[12] = o * M + a * B + l * F + c * re,
            s[1] = u * N + h * R + f * P + m * U,
            s[5] = u * I + h * q + f * C + m * W,
            s[9] = u * O + h * k + f * L + m * K,
            s[13] = u * M + h * B + f * F + m * re,
            s[2] = g * N + v * R + p * P + d * U,
            s[6] = g * I + v * q + p * C + d * W,
            s[10] = g * O + v * k + p * L + d * K,
            s[14] = g * M + v * B + p * F + d * re,
            s[3] = x * N + y * R + _ * P + S * U,
            s[7] = x * I + y * q + _ * C + S * W,
            s[11] = x * O + y * k + _ * L + S * K,
            s[15] = x * M + y * B + _ * F + S * re,
            this
        }
        multiplyScalar(e) {
            let t = this.elements;
            return t[0] *= e,
            t[4] *= e,
            t[8] *= e,
            t[12] *= e,
            t[1] *= e,
            t[5] *= e,
            t[9] *= e,
            t[13] *= e,
            t[2] *= e,
            t[6] *= e,
            t[10] *= e,
            t[14] *= e,
            t[3] *= e,
            t[7] *= e,
            t[11] *= e,
            t[15] *= e,
            this
        }
        determinant() {
            let e = this.elements
              , t = e[0]
              , n = e[4]
              , i = e[8]
              , s = e[12]
              , o = e[1]
              , a = e[5]
              , l = e[9]
              , c = e[13]
              , u = e[2]
              , h = e[6]
              , f = e[10]
              , m = e[14]
              , g = e[3]
              , v = e[7]
              , p = e[11]
              , d = e[15];
            return g * (+s * l * h - i * c * h - s * a * f + n * c * f + i * a * m - n * l * m) + v * (+t * l * m - t * c * f + s * o * f - i * o * m + i * c * u - s * l * u) + p * (+t * c * h - t * a * m - s * o * h + n * o * m + s * a * u - n * c * u) + d * (-i * a * u - t * l * h + t * a * f + i * o * h - n * o * f + n * l * u)
        }
        transpose() {
            let e = this.elements, t;
            return t = e[1],
            e[1] = e[4],
            e[4] = t,
            t = e[2],
            e[2] = e[8],
            e[8] = t,
            t = e[6],
            e[6] = e[9],
            e[9] = t,
            t = e[3],
            e[3] = e[12],
            e[12] = t,
            t = e[7],
            e[7] = e[13],
            e[13] = t,
            t = e[11],
            e[11] = e[14],
            e[14] = t,
            this
        }
        setPosition(e, t, n) {
            let i = this.elements;
            return e.isVector3 ? (i[12] = e.x,
            i[13] = e.y,
            i[14] = e.z) : (i[12] = e,
            i[13] = t,
            i[14] = n),
            this
        }
        invert() {
            let e = this.elements
              , t = e[0]
              , n = e[1]
              , i = e[2]
              , s = e[3]
              , o = e[4]
              , a = e[5]
              , l = e[6]
              , c = e[7]
              , u = e[8]
              , h = e[9]
              , f = e[10]
              , m = e[11]
              , g = e[12]
              , v = e[13]
              , p = e[14]
              , d = e[15]
              , x = h * p * c - v * f * c + v * l * m - a * p * m - h * l * d + a * f * d
              , y = g * f * c - u * p * c - g * l * m + o * p * m + u * l * d - o * f * d
              , _ = u * v * c - g * h * c + g * a * m - o * v * m - u * a * d + o * h * d
              , S = g * h * l - u * v * l - g * a * f + o * v * f + u * a * p - o * h * p
              , N = t * x + n * y + i * _ + s * S;
            if (N === 0)
                return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
            let I = 1 / N;
            return e[0] = x * I,
            e[1] = (v * f * s - h * p * s - v * i * m + n * p * m + h * i * d - n * f * d) * I,
            e[2] = (a * p * s - v * l * s + v * i * c - n * p * c - a * i * d + n * l * d) * I,
            e[3] = (h * l * s - a * f * s - h * i * c + n * f * c + a * i * m - n * l * m) * I,
            e[4] = y * I,
            e[5] = (u * p * s - g * f * s + g * i * m - t * p * m - u * i * d + t * f * d) * I,
            e[6] = (g * l * s - o * p * s - g * i * c + t * p * c + o * i * d - t * l * d) * I,
            e[7] = (o * f * s - u * l * s + u * i * c - t * f * c - o * i * m + t * l * m) * I,
            e[8] = _ * I,
            e[9] = (g * h * s - u * v * s - g * n * m + t * v * m + u * n * d - t * h * d) * I,
            e[10] = (o * v * s - g * a * s + g * n * c - t * v * c - o * n * d + t * a * d) * I,
            e[11] = (u * a * s - o * h * s - u * n * c + t * h * c + o * n * m - t * a * m) * I,
            e[12] = S * I,
            e[13] = (u * v * i - g * h * i + g * n * f - t * v * f - u * n * p + t * h * p) * I,
            e[14] = (g * a * i - o * v * i - g * n * l + t * v * l + o * n * p - t * a * p) * I,
            e[15] = (o * h * i - u * a * i + u * n * l - t * h * l - o * n * f + t * a * f) * I,
            this
        }
        scale(e) {
            let t = this.elements
              , n = e.x
              , i = e.y
              , s = e.z;
            return t[0] *= n,
            t[4] *= i,
            t[8] *= s,
            t[1] *= n,
            t[5] *= i,
            t[9] *= s,
            t[2] *= n,
            t[6] *= i,
            t[10] *= s,
            t[3] *= n,
            t[7] *= i,
            t[11] *= s,
            this
        }
        getMaxScaleOnAxis() {
            let e = this.elements
              , t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2]
              , n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6]
              , i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
            return Math.sqrt(Math.max(t, n, i))
        }
        makeTranslation(e, t, n) {
            return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1),
            this
        }
        makeRotationX(e) {
            let t = Math.cos(e)
              , n = Math.sin(e);
            return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1),
            this
        }
        makeRotationY(e) {
            let t = Math.cos(e)
              , n = Math.sin(e);
            return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1),
            this
        }
        makeRotationZ(e) {
            let t = Math.cos(e)
              , n = Math.sin(e);
            return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
            this
        }
        makeRotationAxis(e, t) {
            let n = Math.cos(t)
              , i = Math.sin(t)
              , s = 1 - n
              , o = e.x
              , a = e.y
              , l = e.z
              , c = s * o
              , u = s * a;
            return this.set(c * o + n, c * a - i * l, c * l + i * a, 0, c * a + i * l, u * a + n, u * l - i * o, 0, c * l - i * a, u * l + i * o, s * l * l + n, 0, 0, 0, 0, 1),
            this
        }
        makeScale(e, t, n) {
            return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1),
            this
        }
        makeShear(e, t, n, i, s, o) {
            return this.set(1, n, s, 0, e, 1, o, 0, t, i, 1, 0, 0, 0, 0, 1),
            this
        }
        compose(e, t, n) {
            let i = this.elements
              , s = t._x
              , o = t._y
              , a = t._z
              , l = t._w
              , c = s + s
              , u = o + o
              , h = a + a
              , f = s * c
              , m = s * u
              , g = s * h
              , v = o * u
              , p = o * h
              , d = a * h
              , x = l * c
              , y = l * u
              , _ = l * h
              , S = n.x
              , N = n.y
              , I = n.z;
            return i[0] = (1 - (v + d)) * S,
            i[1] = (m + _) * S,
            i[2] = (g - y) * S,
            i[3] = 0,
            i[4] = (m - _) * N,
            i[5] = (1 - (f + d)) * N,
            i[6] = (p + x) * N,
            i[7] = 0,
            i[8] = (g + y) * I,
            i[9] = (p - x) * I,
            i[10] = (1 - (f + v)) * I,
            i[11] = 0,
            i[12] = e.x,
            i[13] = e.y,
            i[14] = e.z,
            i[15] = 1,
            this
        }
        decompose(e, t, n) {
            let i = this.elements
              , s = ga.set(i[0], i[1], i[2]).length()
              , o = ga.set(i[4], i[5], i[6]).length()
              , a = ga.set(i[8], i[9], i[10]).length();
            this.determinant() < 0 && (s = -s),
            e.x = i[12],
            e.y = i[13],
            e.z = i[14],
            rr.copy(this);
            let c = 1 / s
              , u = 1 / o
              , h = 1 / a;
            return rr.elements[0] *= c,
            rr.elements[1] *= c,
            rr.elements[2] *= c,
            rr.elements[4] *= u,
            rr.elements[5] *= u,
            rr.elements[6] *= u,
            rr.elements[8] *= h,
            rr.elements[9] *= h,
            rr.elements[10] *= h,
            t.setFromRotationMatrix(rr),
            n.x = s,
            n.y = o,
            n.z = a,
            this
        }
        makePerspective(e, t, n, i, s, o) {
            let a = this.elements
              , l = 2 * s / (t - e)
              , c = 2 * s / (n - i)
              , u = (t + e) / (t - e)
              , h = (n + i) / (n - i)
              , f = -(o + s) / (o - s)
              , m = -2 * o * s / (o - s);
            return a[0] = l,
            a[4] = 0,
            a[8] = u,
            a[12] = 0,
            a[1] = 0,
            a[5] = c,
            a[9] = h,
            a[13] = 0,
            a[2] = 0,
            a[6] = 0,
            a[10] = f,
            a[14] = m,
            a[3] = 0,
            a[7] = 0,
            a[11] = -1,
            a[15] = 0,
            this
        }
        makeOrthographic(e, t, n, i, s, o) {
            let a = this.elements
              , l = 1 / (t - e)
              , c = 1 / (n - i)
              , u = 1 / (o - s)
              , h = (t + e) * l
              , f = (n + i) * c
              , m = (o + s) * u;
            return a[0] = 2 * l,
            a[4] = 0,
            a[8] = 0,
            a[12] = -h,
            a[1] = 0,
            a[5] = 2 * c,
            a[9] = 0,
            a[13] = -f,
            a[2] = 0,
            a[6] = 0,
            a[10] = -2 * u,
            a[14] = -m,
            a[3] = 0,
            a[7] = 0,
            a[11] = 0,
            a[15] = 1,
            this
        }
        equals(e) {
            let t = this.elements
              , n = e.elements;
            for (let i = 0; i < 16; i++)
                if (t[i] !== n[i])
                    return !1;
            return !0
        }
        fromArray(e, t=0) {
            for (let n = 0; n < 16; n++)
                this.elements[n] = e[n + t];
            return this
        }
        toArray(e=[], t=0) {
            let n = this.elements;
            return e[t] = n[0],
            e[t + 1] = n[1],
            e[t + 2] = n[2],
            e[t + 3] = n[3],
            e[t + 4] = n[4],
            e[t + 5] = n[5],
            e[t + 6] = n[6],
            e[t + 7] = n[7],
            e[t + 8] = n[8],
            e[t + 9] = n[9],
            e[t + 10] = n[10],
            e[t + 11] = n[11],
            e[t + 12] = n[12],
            e[t + 13] = n[13],
            e[t + 14] = n[14],
            e[t + 15] = n[15],
            e
        }
    }
      , ga = new ue
      , rr = new je
      , k_ = new ue(0,0,0)
      , U_ = new ue(1,1,1)
      , Bs = new ue
      , qu = new ue
      , Ri = new ue
      , l0 = new je
      , c0 = new Sn
      , ii = class {
        constructor(e=0, t=0, n=0, i=ii.DEFAULT_ORDER) {
            this.isEuler = !0,
            this._x = e,
            this._y = t,
            this._z = n,
            this._order = i
        }
        get x() {
            return this._x
        }
        set x(e) {
            this._x = e,
            this._onChangeCallback()
        }
        get y() {
            return this._y
        }
        set y(e) {
            this._y = e,
            this._onChangeCallback()
        }
        get z() {
            return this._z
        }
        set z(e) {
            this._z = e,
            this._onChangeCallback()
        }
        get order() {
            return this._order
        }
        set order(e) {
            this._order = e,
            this._onChangeCallback()
        }
        set(e, t, n, i=this._order) {
            return this._x = e,
            this._y = t,
            this._z = n,
            this._order = i,
            this._onChangeCallback(),
            this
        }
        clone() {
            return new this.constructor(this._x,this._y,this._z,this._order)
        }
        copy(e) {
            return this._x = e._x,
            this._y = e._y,
            this._z = e._z,
            this._order = e._order,
            this._onChangeCallback(),
            this
        }
        setFromRotationMatrix(e, t=this._order, n=!0) {
            let i = e.elements
              , s = i[0]
              , o = i[4]
              , a = i[8]
              , l = i[1]
              , c = i[5]
              , u = i[9]
              , h = i[2]
              , f = i[6]
              , m = i[10];
            switch (t) {
            case "XYZ":
                this._y = Math.asin(Vn(a, -1, 1)),
                Math.abs(a) < .9999999 ? (this._x = Math.atan2(-u, m),
                this._z = Math.atan2(-o, s)) : (this._x = Math.atan2(f, c),
                this._z = 0);
                break;
            case "YXZ":
                this._x = Math.asin(-Vn(u, -1, 1)),
                Math.abs(u) < .9999999 ? (this._y = Math.atan2(a, m),
                this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-h, s),
                this._z = 0);
                break;
            case "ZXY":
                this._x = Math.asin(Vn(f, -1, 1)),
                Math.abs(f) < .9999999 ? (this._y = Math.atan2(-h, m),
                this._z = Math.atan2(-o, c)) : (this._y = 0,
                this._z = Math.atan2(l, s));
                break;
            case "ZYX":
                this._y = Math.asin(-Vn(h, -1, 1)),
                Math.abs(h) < .9999999 ? (this._x = Math.atan2(f, m),
                this._z = Math.atan2(l, s)) : (this._x = 0,
                this._z = Math.atan2(-o, c));
                break;
            case "YZX":
                this._z = Math.asin(Vn(l, -1, 1)),
                Math.abs(l) < .9999999 ? (this._x = Math.atan2(-u, c),
                this._y = Math.atan2(-h, s)) : (this._x = 0,
                this._y = Math.atan2(a, m));
                break;
            case "XZY":
                this._z = Math.asin(-Vn(o, -1, 1)),
                Math.abs(o) < .9999999 ? (this._x = Math.atan2(f, c),
                this._y = Math.atan2(a, s)) : (this._x = Math.atan2(-u, m),
                this._y = 0);
                break;
            default:
                console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
            }
            return this._order = t,
            n === !0 && this._onChangeCallback(),
            this
        }
        setFromQuaternion(e, t, n) {
            return l0.makeRotationFromQuaternion(e),
            this.setFromRotationMatrix(l0, t, n)
        }
        setFromVector3(e, t=this._order) {
            return this.set(e.x, e.y, e.z, t)
        }
        reorder(e) {
            return c0.setFromEuler(this),
            this.setFromQuaternion(c0, e)
        }
        equals(e) {
            return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
        }
        fromArray(e) {
            return this._x = e[0],
            this._y = e[1],
            this._z = e[2],
            e[3] !== void 0 && (this._order = e[3]),
            this._onChangeCallback(),
            this
        }
        toArray(e=[], t=0) {
            return e[t] = this._x,
            e[t + 1] = this._y,
            e[t + 2] = this._z,
            e[t + 3] = this._order,
            e
        }
        _onChange(e) {
            return this._onChangeCallback = e,
            this
        }
        _onChangeCallback() {}
        *[Symbol.iterator]() {
            yield this._x,
            yield this._y,
            yield this._z,
            yield this._order
        }
    }
    ;
    ii.DEFAULT_ORDER = "XYZ";
    var Dc = class {
        constructor() {
            this.mask = 1
        }
        set(e) {
            this.mask = (1 << e | 0) >>> 0
        }
        enable(e) {
            this.mask |= 1 << e | 0
        }
        enableAll() {
            this.mask = -1
        }
        toggle(e) {
            this.mask ^= 1 << e | 0
        }
        disable(e) {
            this.mask &= ~(1 << e | 0)
        }
        disableAll() {
            this.mask = 0
        }
        test(e) {
            return (this.mask & e.mask) !== 0
        }
        isEnabled(e) {
            return (this.mask & (1 << e | 0)) !== 0
        }
    }
      , B_ = 0
      , u0 = new ue
      , va = new Sn
      , as = new je
      , Yu = new ue
      , Tc = new ue
      , G_ = new ue
      , V_ = new Sn
      , h0 = new ue(1,0,0)
      , f0 = new ue(0,1,0)
      , d0 = new ue(0,0,1)
      , z_ = {
        type: "added"
    }
      , p0 = {
        type: "removed"
    }
      , bt = class extends Ws {
        constructor() {
            super(),
            this.isObject3D = !0,
            Object.defineProperty(this, "id", {
                value: B_++
            }),
            this.uuid = ys(),
            this.name = "",
            this.type = "Object3D",
            this.parent = null,
            this.children = [],
            this.up = bt.DEFAULT_UP.clone();
            let e = new ue
              , t = new ii
              , n = new Sn
              , i = new ue(1,1,1);
            function s() {
                n.setFromEuler(t, !1)
            }
            function o() {
                t.setFromQuaternion(n, void 0, !1)
            }
            t._onChange(s),
            n._onChange(o),
            Object.defineProperties(this, {
                position: {
                    configurable: !0,
                    enumerable: !0,
                    value: e
                },
                rotation: {
                    configurable: !0,
                    enumerable: !0,
                    value: t
                },
                quaternion: {
                    configurable: !0,
                    enumerable: !0,
                    value: n
                },
                scale: {
                    configurable: !0,
                    enumerable: !0,
                    value: i
                },
                modelViewMatrix: {
                    value: new je
                },
                normalMatrix: {
                    value: new vt
                }
            }),
            this.matrix = new je,
            this.matrixWorld = new je,
            this.matrixAutoUpdate = bt.DEFAULT_MATRIX_AUTO_UPDATE,
            this.matrixWorldNeedsUpdate = !1,
            this.matrixWorldAutoUpdate = bt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,
            this.layers = new Dc,
            this.visible = !0,
            this.castShadow = !1,
            this.receiveShadow = !1,
            this.frustumCulled = !0,
            this.renderOrder = 0,
            this.animations = [],
            this.userData = {}
        }
        onBeforeRender() {}
        onAfterRender() {}
        applyMatrix4(e) {
            this.matrixAutoUpdate && this.updateMatrix(),
            this.matrix.premultiply(e),
            this.matrix.decompose(this.position, this.quaternion, this.scale)
        }
        applyQuaternion(e) {
            return this.quaternion.premultiply(e),
            this
        }
        setRotationFromAxisAngle(e, t) {
            this.quaternion.setFromAxisAngle(e, t)
        }
        setRotationFromEuler(e) {
            this.quaternion.setFromEuler(e, !0)
        }
        setRotationFromMatrix(e) {
            this.quaternion.setFromRotationMatrix(e)
        }
        setRotationFromQuaternion(e) {
            this.quaternion.copy(e)
        }
        rotateOnAxis(e, t) {
            return va.setFromAxisAngle(e, t),
            this.quaternion.multiply(va),
            this
        }
        rotateOnWorldAxis(e, t) {
            return va.setFromAxisAngle(e, t),
            this.quaternion.premultiply(va),
            this
        }
        rotateX(e) {
            return this.rotateOnAxis(h0, e)
        }
        rotateY(e) {
            return this.rotateOnAxis(f0, e)
        }
        rotateZ(e) {
            return this.rotateOnAxis(d0, e)
        }
        translateOnAxis(e, t) {
            return u0.copy(e).applyQuaternion(this.quaternion),
            this.position.add(u0.multiplyScalar(t)),
            this
        }
        translateX(e) {
            return this.translateOnAxis(h0, e)
        }
        translateY(e) {
            return this.translateOnAxis(f0, e)
        }
        translateZ(e) {
            return this.translateOnAxis(d0, e)
        }
        localToWorld(e) {
            return this.updateWorldMatrix(!0, !1),
            e.applyMatrix4(this.matrixWorld)
        }
        worldToLocal(e) {
            return this.updateWorldMatrix(!0, !1),
            e.applyMatrix4(as.copy(this.matrixWorld).invert())
        }
        lookAt(e, t, n) {
            e.isVector3 ? Yu.copy(e) : Yu.set(e, t, n);
            let i = this.parent;
            this.updateWorldMatrix(!0, !1),
            Tc.setFromMatrixPosition(this.matrixWorld),
            this.isCamera || this.isLight ? as.lookAt(Tc, Yu, this.up) : as.lookAt(Yu, Tc, this.up),
            this.quaternion.setFromRotationMatrix(as),
            i && (as.extractRotation(i.matrixWorld),
            va.setFromRotationMatrix(as),
            this.quaternion.premultiply(va.invert()))
        }
        add(e) {
            if (arguments.length > 1) {
                for (let t = 0; t < arguments.length; t++)
                    this.add(arguments[t]);
                return this
            }
            return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e),
            this) : (e && e.isObject3D ? (e.parent !== null && e.parent.remove(e),
            e.parent = this,
            this.children.push(e),
            e.dispatchEvent(z_)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e),
            this)
        }
        remove(e) {
            if (arguments.length > 1) {
                for (let n = 0; n < arguments.length; n++)
                    this.remove(arguments[n]);
                return this
            }
            let t = this.children.indexOf(e);
            return t !== -1 && (e.parent = null,
            this.children.splice(t, 1),
            e.dispatchEvent(p0)),
            this
        }
        removeFromParent() {
            let e = this.parent;
            return e !== null && e.remove(this),
            this
        }
        clear() {
            for (let e = 0; e < this.children.length; e++) {
                let t = this.children[e];
                t.parent = null,
                t.dispatchEvent(p0)
            }
            return this.children.length = 0,
            this
        }
        attach(e) {
            return this.updateWorldMatrix(!0, !1),
            as.copy(this.matrixWorld).invert(),
            e.parent !== null && (e.parent.updateWorldMatrix(!0, !1),
            as.multiply(e.parent.matrixWorld)),
            e.applyMatrix4(as),
            this.add(e),
            e.updateWorldMatrix(!1, !0),
            this
        }
        getObjectById(e) {
            return this.getObjectByProperty("id", e)
        }
        getObjectByName(e) {
            return this.getObjectByProperty("name", e)
        }
        getObjectByProperty(e, t) {
            if (this[e] === t)
                return this;
            for (let n = 0, i = this.children.length; n < i; n++) {
                let o = this.children[n].getObjectByProperty(e, t);
                if (o !== void 0)
                    return o
            }
        }
        getObjectsByProperty(e, t) {
            let n = [];
            this[e] === t && n.push(this);
            for (let i = 0, s = this.children.length; i < s; i++) {
                let o = this.children[i].getObjectsByProperty(e, t);
                o.length > 0 && (n = n.concat(o))
            }
            return n
        }
        getWorldPosition(e) {
            return this.updateWorldMatrix(!0, !1),
            e.setFromMatrixPosition(this.matrixWorld)
        }
        getWorldQuaternion(e) {
            return this.updateWorldMatrix(!0, !1),
            this.matrixWorld.decompose(Tc, e, G_),
            e
        }
        getWorldScale(e) {
            return this.updateWorldMatrix(!0, !1),
            this.matrixWorld.decompose(Tc, V_, e),
            e
        }
        getWorldDirection(e) {
            this.updateWorldMatrix(!0, !1);
            let t = this.matrixWorld.elements;
            return e.set(t[8], t[9], t[10]).normalize()
        }
        raycast() {}
        traverse(e) {
            e(this);
            let t = this.children;
            for (let n = 0, i = t.length; n < i; n++)
                t[n].traverse(e)
        }
        traverseVisible(e) {
            if (this.visible === !1)
                return;
            e(this);
            let t = this.children;
            for (let n = 0, i = t.length; n < i; n++)
                t[n].traverseVisible(e)
        }
        traverseAncestors(e) {
            let t = this.parent;
            t !== null && (e(t),
            t.traverseAncestors(e))
        }
        updateMatrix() {
            this.matrix.compose(this.position, this.quaternion, this.scale),
            this.matrixWorldNeedsUpdate = !0
        }
        updateMatrixWorld(e) {
            this.matrixAutoUpdate && this.updateMatrix(),
            (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
            this.matrixWorldNeedsUpdate = !1,
            e = !0);
            let t = this.children;
            for (let n = 0, i = t.length; n < i; n++) {
                let s = t[n];
                (s.matrixWorldAutoUpdate === !0 || e === !0) && s.updateMatrixWorld(e)
            }
        }
        updateWorldMatrix(e, t) {
            let n = this.parent;
            if (e === !0 && n !== null && n.matrixWorldAutoUpdate === !0 && n.updateWorldMatrix(!0, !1),
            this.matrixAutoUpdate && this.updateMatrix(),
            this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
            t === !0) {
                let i = this.children;
                for (let s = 0, o = i.length; s < o; s++) {
                    let a = i[s];
                    a.matrixWorldAutoUpdate === !0 && a.updateWorldMatrix(!1, !0)
                }
            }
        }
        toJSON(e) {
            let t = e === void 0 || typeof e == "string"
              , n = {};
            t && (e = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                shapes: {},
                skeletons: {},
                animations: {},
                nodes: {}
            },
            n.metadata = {
                version: 4.5,
                type: "Object",
                generator: "Object3D.toJSON"
            });
            let i = {};
            i.uuid = this.uuid,
            i.type = this.type,
            this.name !== "" && (i.name = this.name),
            this.castShadow === !0 && (i.castShadow = !0),
            this.receiveShadow === !0 && (i.receiveShadow = !0),
            this.visible === !1 && (i.visible = !1),
            this.frustumCulled === !1 && (i.frustumCulled = !1),
            this.renderOrder !== 0 && (i.renderOrder = this.renderOrder),
            Object.keys(this.userData).length > 0 && (i.userData = this.userData),
            i.layers = this.layers.mask,
            i.matrix = this.matrix.toArray(),
            i.up = this.up.toArray(),
            this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1),
            this.isInstancedMesh && (i.type = "InstancedMesh",
            i.count = this.count,
            i.instanceMatrix = this.instanceMatrix.toJSON(),
            this.instanceColor !== null && (i.instanceColor = this.instanceColor.toJSON()));
            function s(a, l) {
                return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)),
                l.uuid
            }
            if (this.isScene)
                this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(e).uuid)),
                this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (i.environment = this.environment.toJSON(e).uuid);
            else if (this.isMesh || this.isLine || this.isPoints) {
                i.geometry = s(e.geometries, this.geometry);
                let a = this.geometry.parameters;
                if (a !== void 0 && a.shapes !== void 0) {
                    let l = a.shapes;
                    if (Array.isArray(l))
                        for (let c = 0, u = l.length; c < u; c++) {
                            let h = l[c];
                            s(e.shapes, h)
                        }
                    else
                        s(e.shapes, l)
                }
            }
            if (this.isSkinnedMesh && (i.bindMode = this.bindMode,
            i.bindMatrix = this.bindMatrix.toArray(),
            this.skeleton !== void 0 && (s(e.skeletons, this.skeleton),
            i.skeleton = this.skeleton.uuid)),
            this.material !== void 0)
                if (Array.isArray(this.material)) {
                    let a = [];
                    for (let l = 0, c = this.material.length; l < c; l++)
                        a.push(s(e.materials, this.material[l]));
                    i.material = a
                } else
                    i.material = s(e.materials, this.material);
            if (this.children.length > 0) {
                i.children = [];
                for (let a = 0; a < this.children.length; a++)
                    i.children.push(this.children[a].toJSON(e).object)
            }
            if (this.animations.length > 0) {
                i.animations = [];
                for (let a = 0; a < this.animations.length; a++) {
                    let l = this.animations[a];
                    i.animations.push(s(e.animations, l))
                }
            }
            if (t) {
                let a = o(e.geometries)
                  , l = o(e.materials)
                  , c = o(e.textures)
                  , u = o(e.images)
                  , h = o(e.shapes)
                  , f = o(e.skeletons)
                  , m = o(e.animations)
                  , g = o(e.nodes);
                a.length > 0 && (n.geometries = a),
                l.length > 0 && (n.materials = l),
                c.length > 0 && (n.textures = c),
                u.length > 0 && (n.images = u),
                h.length > 0 && (n.shapes = h),
                f.length > 0 && (n.skeletons = f),
                m.length > 0 && (n.animations = m),
                g.length > 0 && (n.nodes = g)
            }
            return n.object = i,
            n;
            function o(a) {
                let l = [];
                for (let c in a) {
                    let u = a[c];
                    delete u.metadata,
                    l.push(u)
                }
                return l
            }
        }
        clone(e) {
            return new this.constructor().copy(this, e)
        }
        copy(e, t=!0) {
            if (this.name = e.name,
            this.up.copy(e.up),
            this.position.copy(e.position),
            this.rotation.order = e.rotation.order,
            this.quaternion.copy(e.quaternion),
            this.scale.copy(e.scale),
            this.matrix.copy(e.matrix),
            this.matrixWorld.copy(e.matrixWorld),
            this.matrixAutoUpdate = e.matrixAutoUpdate,
            this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate,
            this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate,
            this.layers.mask = e.layers.mask,
            this.visible = e.visible,
            this.castShadow = e.castShadow,
            this.receiveShadow = e.receiveShadow,
            this.frustumCulled = e.frustumCulled,
            this.renderOrder = e.renderOrder,
            this.animations = e.animations,
            this.userData = JSON.parse(JSON.stringify(e.userData)),
            t === !0)
                for (let n = 0; n < e.children.length; n++) {
                    let i = e.children[n];
                    this.add(i.clone())
                }
            return this
        }
    }
    ;
    bt.DEFAULT_UP = new ue(0,1,0);
    bt.DEFAULT_MATRIX_AUTO_UPDATE = !0;
    bt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
    var sr = new ue
      , ls = new ue
      , Ld = new ue
      , cs = new ue
      , ya = new ue
      , xa = new ue
      , m0 = new ue
      , Nd = new ue
      , Dd = new ue
      , Od = new ue
      , Ku = !1
      , fi = class {
        constructor(e=new ue, t=new ue, n=new ue) {
            this.a = e,
            this.b = t,
            this.c = n
        }
        static getNormal(e, t, n, i) {
            i.subVectors(n, t),
            sr.subVectors(e, t),
            i.cross(sr);
            let s = i.lengthSq();
            return s > 0 ? i.multiplyScalar(1 / Math.sqrt(s)) : i.set(0, 0, 0)
        }
        static getBarycoord(e, t, n, i, s) {
            sr.subVectors(i, t),
            ls.subVectors(n, t),
            Ld.subVectors(e, t);
            let o = sr.dot(sr)
              , a = sr.dot(ls)
              , l = sr.dot(Ld)
              , c = ls.dot(ls)
              , u = ls.dot(Ld)
              , h = o * c - a * a;
            if (h === 0)
                return s.set(-2, -1, -1);
            let f = 1 / h
              , m = (c * l - a * u) * f
              , g = (o * u - a * l) * f;
            return s.set(1 - m - g, g, m)
        }
        static containsPoint(e, t, n, i) {
            return this.getBarycoord(e, t, n, i, cs),
            cs.x >= 0 && cs.y >= 0 && cs.x + cs.y <= 1
        }
        static getUV(e, t, n, i, s, o, a, l) {
            return Ku === !1 && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."),
            Ku = !0),
            this.getInterpolation(e, t, n, i, s, o, a, l)
        }
        static getInterpolation(e, t, n, i, s, o, a, l) {
            return this.getBarycoord(e, t, n, i, cs),
            l.setScalar(0),
            l.addScaledVector(s, cs.x),
            l.addScaledVector(o, cs.y),
            l.addScaledVector(a, cs.z),
            l
        }
        static isFrontFacing(e, t, n, i) {
            return sr.subVectors(n, t),
            ls.subVectors(e, t),
            sr.cross(ls).dot(i) < 0
        }
        set(e, t, n) {
            return this.a.copy(e),
            this.b.copy(t),
            this.c.copy(n),
            this
        }
        setFromPointsAndIndices(e, t, n, i) {
            return this.a.copy(e[t]),
            this.b.copy(e[n]),
            this.c.copy(e[i]),
            this
        }
        setFromAttributeAndIndices(e, t, n, i) {
            return this.a.fromBufferAttribute(e, t),
            this.b.fromBufferAttribute(e, n),
            this.c.fromBufferAttribute(e, i),
            this
        }
        clone() {
            return new this.constructor().copy(this)
        }
        copy(e) {
            return this.a.copy(e.a),
            this.b.copy(e.b),
            this.c.copy(e.c),
            this
        }
        getArea() {
            return sr.subVectors(this.c, this.b),
            ls.subVectors(this.a, this.b),
            sr.cross(ls).length() * .5
        }
        getMidpoint(e) {
            return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
        }
        getNormal(e) {
            return fi.getNormal(this.a, this.b, this.c, e)
        }
        getPlane(e) {
            return e.setFromCoplanarPoints(this.a, this.b, this.c)
        }
        getBarycoord(e, t) {
            return fi.getBarycoord(e, this.a, this.b, this.c, t)
        }
        getUV(e, t, n, i, s) {
            return Ku === !1 && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."),
            Ku = !0),
            fi.getInterpolation(e, this.a, this.b, this.c, t, n, i, s)
        }
        getInterpolation(e, t, n, i, s) {
            return fi.getInterpolation(e, this.a, this.b, this.c, t, n, i, s)
        }
        containsPoint(e) {
            return fi.containsPoint(e, this.a, this.b, this.c)
        }
        isFrontFacing(e) {
            return fi.isFrontFacing(this.a, this.b, this.c, e)
        }
        intersectsBox(e) {
            return e.intersectsTriangle(this)
        }
        closestPointToPoint(e, t) {
            let n = this.a, i = this.b, s = this.c, o, a;
            ya.subVectors(i, n),
            xa.subVectors(s, n),
            Nd.subVectors(e, n);
            let l = ya.dot(Nd)
              , c = xa.dot(Nd);
            if (l <= 0 && c <= 0)
                return t.copy(n);
            Dd.subVectors(e, i);
            let u = ya.dot(Dd)
              , h = xa.dot(Dd);
            if (u >= 0 && h <= u)
                return t.copy(i);
            let f = l * h - u * c;
            if (f <= 0 && l >= 0 && u <= 0)
                return o = l / (l - u),
                t.copy(n).addScaledVector(ya, o);
            Od.subVectors(e, s);
            let m = ya.dot(Od)
              , g = xa.dot(Od);
            if (g >= 0 && m <= g)
                return t.copy(s);
            let v = m * c - l * g;
            if (v <= 0 && c >= 0 && g <= 0)
                return a = c / (c - g),
                t.copy(n).addScaledVector(xa, a);
            let p = u * g - m * h;
            if (p <= 0 && h - u >= 0 && m - g >= 0)
                return m0.subVectors(s, i),
                a = (h - u) / (h - u + (m - g)),
                t.copy(i).addScaledVector(m0, a);
            let d = 1 / (p + v + f);
            return o = v * d,
            a = f * d,
            t.copy(n).addScaledVector(ya, o).addScaledVector(xa, a)
        }
        equals(e) {
            return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
        }
    }
      , H_ = 0
      , ur = class extends Ws {
        constructor() {
            super(),
            this.isMaterial = !0,
            Object.defineProperty(this, "id", {
                value: H_++
            }),
            this.uuid = ys(),
            this.name = "",
            this.type = "Material",
            this.blending = Pa,
            this.side = qi,
            this.vertexColors = !1,
            this.opacity = 1,
            this.transparent = !1,
            this.blendSrc = hv,
            this.blendDst = fv,
            this.blendEquation = Ca,
            this.blendSrcAlpha = null,
            this.blendDstAlpha = null,
            this.blendEquationAlpha = null,
            this.depthFunc = Zd,
            this.depthTest = !0,
            this.depthWrite = !0,
            this.stencilWriteMask = 255,
            this.stencilFunc = m_,
            this.stencilRef = 0,
            this.stencilFuncMask = 255,
            this.stencilFail = bd,
            this.stencilZFail = bd,
            this.stencilZPass = bd,
            this.stencilWrite = !1,
            this.clippingPlanes = null,
            this.clipIntersection = !1,
            this.clipShadows = !1,
            this.shadowSide = null,
            this.colorWrite = !0,
            this.precision = null,
            this.polygonOffset = !1,
            this.polygonOffsetFactor = 0,
            this.polygonOffsetUnits = 0,
            this.dithering = !1,
            this.alphaToCoverage = !1,
            this.premultipliedAlpha = !1,
            this.forceSinglePass = !1,
            this.visible = !0,
            this.toneMapped = !0,
            this.userData = {},
            this.version = 0,
            this._alphaTest = 0
        }
        get alphaTest() {
            return this._alphaTest
        }
        set alphaTest(e) {
            this._alphaTest > 0 != e > 0 && this.version++,
            this._alphaTest = e
        }
        onBuild() {}
        onBeforeRender() {}
        onBeforeCompile() {}
        customProgramCacheKey() {
            return this.onBeforeCompile.toString()
        }
        setValues(e) {
            if (e !== void 0)
                for (let t in e) {
                    let n = e[t];
                    if (n === void 0) {
                        console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
                        continue
                    }
                    let i = this[t];
                    if (i === void 0) {
                        console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);
                        continue
                    }
                    i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[t] = n
                }
        }
        toJSON(e) {
            let t = e === void 0 || typeof e == "string";
            t && (e = {
                textures: {},
                images: {}
            });
            let n = {
                metadata: {
                    version: 4.5,
                    type: "Material",
                    generator: "Material.toJSON"
                }
            };
            n.uuid = this.uuid,
            n.type = this.type,
            this.name !== "" && (n.name = this.name),
            this.color && this.color.isColor && (n.color = this.color.getHex()),
            this.roughness !== void 0 && (n.roughness = this.roughness),
            this.metalness !== void 0 && (n.metalness = this.metalness),
            this.sheen !== void 0 && (n.sheen = this.sheen),
            this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()),
            this.sheenRoughness !== void 0 && (n.sheenRoughness = this.sheenRoughness),
            this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()),
            this.emissiveIntensity && this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity),
            this.specular && this.specular.isColor && (n.specular = this.specular.getHex()),
            this.specularIntensity !== void 0 && (n.specularIntensity = this.specularIntensity),
            this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()),
            this.shininess !== void 0 && (n.shininess = this.shininess),
            this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat),
            this.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = this.clearcoatRoughness),
            this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
            this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
            this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid,
            n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
            this.iridescence !== void 0 && (n.iridescence = this.iridescence),
            this.iridescenceIOR !== void 0 && (n.iridescenceIOR = this.iridescenceIOR),
            this.iridescenceThicknessRange !== void 0 && (n.iridescenceThicknessRange = this.iridescenceThicknessRange),
            this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
            this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid),
            this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid),
            this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid),
            this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid),
            this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid,
            n.lightMapIntensity = this.lightMapIntensity),
            this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid,
            n.aoMapIntensity = this.aoMapIntensity),
            this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid,
            n.bumpScale = this.bumpScale),
            this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid,
            n.normalMapType = this.normalMapType,
            n.normalScale = this.normalScale.toArray()),
            this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid,
            n.displacementScale = this.displacementScale,
            n.displacementBias = this.displacementBias),
            this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid),
            this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid),
            this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid),
            this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid),
            this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
            this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid),
            this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid,
            this.combine !== void 0 && (n.combine = this.combine)),
            this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity),
            this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity),
            this.refractionRatio !== void 0 && (n.refractionRatio = this.refractionRatio),
            this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid),
            this.transmission !== void 0 && (n.transmission = this.transmission),
            this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid),
            this.thickness !== void 0 && (n.thickness = this.thickness),
            this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid),
            this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance),
            this.attenuationColor !== void 0 && (n.attenuationColor = this.attenuationColor.getHex()),
            this.size !== void 0 && (n.size = this.size),
            this.shadowSide !== null && (n.shadowSide = this.shadowSide),
            this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation),
            this.blending !== Pa && (n.blending = this.blending),
            this.side !== qi && (n.side = this.side),
            this.vertexColors && (n.vertexColors = !0),
            this.opacity < 1 && (n.opacity = this.opacity),
            this.transparent === !0 && (n.transparent = this.transparent),
            n.depthFunc = this.depthFunc,
            n.depthTest = this.depthTest,
            n.depthWrite = this.depthWrite,
            n.colorWrite = this.colorWrite,
            n.stencilWrite = this.stencilWrite,
            n.stencilWriteMask = this.stencilWriteMask,
            n.stencilFunc = this.stencilFunc,
            n.stencilRef = this.stencilRef,
            n.stencilFuncMask = this.stencilFuncMask,
            n.stencilFail = this.stencilFail,
            n.stencilZFail = this.stencilZFail,
            n.stencilZPass = this.stencilZPass,
            this.rotation !== void 0 && this.rotation !== 0 && (n.rotation = this.rotation),
            this.polygonOffset === !0 && (n.polygonOffset = !0),
            this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor),
            this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits),
            this.linewidth !== void 0 && this.linewidth !== 1 && (n.linewidth = this.linewidth),
            this.dashSize !== void 0 && (n.dashSize = this.dashSize),
            this.gapSize !== void 0 && (n.gapSize = this.gapSize),
            this.scale !== void 0 && (n.scale = this.scale),
            this.dithering === !0 && (n.dithering = !0),
            this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
            this.alphaToCoverage === !0 && (n.alphaToCoverage = this.alphaToCoverage),
            this.premultipliedAlpha === !0 && (n.premultipliedAlpha = this.premultipliedAlpha),
            this.forceSinglePass === !0 && (n.forceSinglePass = this.forceSinglePass),
            this.wireframe === !0 && (n.wireframe = this.wireframe),
            this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth),
            this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap),
            this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin),
            this.flatShading === !0 && (n.flatShading = this.flatShading),
            this.visible === !1 && (n.visible = !1),
            this.toneMapped === !1 && (n.toneMapped = !1),
            this.fog === !1 && (n.fog = !1),
            Object.keys(this.userData).length > 0 && (n.userData = this.userData);
            function i(s) {
                let o = [];
                for (let a in s) {
                    let l = s[a];
                    delete l.metadata,
                    o.push(l)
                }
                return o
            }
            if (t) {
                let s = i(e.textures)
                  , o = i(e.images);
                s.length > 0 && (n.textures = s),
                o.length > 0 && (n.images = o)
            }
            return n
        }
        clone() {
            return new this.constructor().copy(this)
        }
        copy(e) {
            this.name = e.name,
            this.blending = e.blending,
            this.side = e.side,
            this.vertexColors = e.vertexColors,
            this.opacity = e.opacity,
            this.transparent = e.transparent,
            this.blendSrc = e.blendSrc,
            this.blendDst = e.blendDst,
            this.blendEquation = e.blendEquation,
            this.blendSrcAlpha = e.blendSrcAlpha,
            this.blendDstAlpha = e.blendDstAlpha,
            this.blendEquationAlpha = e.blendEquationAlpha,
            this.depthFunc = e.depthFunc,
            this.depthTest = e.depthTest,
            this.depthWrite = e.depthWrite,
            this.stencilWriteMask = e.stencilWriteMask,
            this.stencilFunc = e.stencilFunc,
            this.stencilRef = e.stencilRef,
            this.stencilFuncMask = e.stencilFuncMask,
            this.stencilFail = e.stencilFail,
            this.stencilZFail = e.stencilZFail,
            this.stencilZPass = e.stencilZPass,
            this.stencilWrite = e.stencilWrite;
            let t = e.clippingPlanes
              , n = null;
            if (t !== null) {
                let i = t.length;
                n = new Array(i);
                for (let s = 0; s !== i; ++s)
                    n[s] = t[s].clone()
            }
            return this.clippingPlanes = n,
            this.clipIntersection = e.clipIntersection,
            this.clipShadows = e.clipShadows,
            this.shadowSide = e.shadowSide,
            this.colorWrite = e.colorWrite,
            this.precision = e.precision,
            this.polygonOffset = e.polygonOffset,
            this.polygonOffsetFactor = e.polygonOffsetFactor,
            this.polygonOffsetUnits = e.polygonOffsetUnits,
            this.dithering = e.dithering,
            this.alphaTest = e.alphaTest,
            this.alphaToCoverage = e.alphaToCoverage,
            this.premultipliedAlpha = e.premultipliedAlpha,
            this.forceSinglePass = e.forceSinglePass,
            this.visible = e.visible,
            this.toneMapped = e.toneMapped,
            this.userData = JSON.parse(JSON.stringify(e.userData)),
            this
        }
        dispose() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
        set needsUpdate(e) {
            e === !0 && this.version++
        }
    }
      , _v = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    }
      , or = {
        h: 0,
        s: 0,
        l: 0
    }
      , Zu = {
        h: 0,
        s: 0,
        l: 0
    };
    function Fd(r, e, t) {
        return t < 0 && (t += 1),
        t > 1 && (t -= 1),
        t < 1 / 6 ? r + (e - r) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? r + (e - r) * 6 * (2 / 3 - t) : r
    }
    var $e = class {
        constructor(e, t, n) {
            return this.isColor = !0,
            this.r = 1,
            this.g = 1,
            this.b = 1,
            t === void 0 && n === void 0 ? this.set(e) : this.setRGB(e, t, n)
        }
        set(e) {
            return e && e.isColor ? this.copy(e) : typeof e == "number" ? this.setHex(e) : typeof e == "string" && this.setStyle(e),
            this
        }
        setScalar(e) {
            return this.r = e,
            this.g = e,
            this.b = e,
            this
        }
        setHex(e, t=ct) {
            return e = Math.floor(e),
            this.r = (e >> 16 & 255) / 255,
            this.g = (e >> 8 & 255) / 255,
            this.b = (e & 255) / 255,
            Li.toWorkingColorSpace(this, t),
            this
        }
        setRGB(e, t, n, i=Li.workingColorSpace) {
            return this.r = e,
            this.g = t,
            this.b = n,
            Li.toWorkingColorSpace(this, i),
            this
        }
        setHSL(e, t, n, i=Li.workingColorSpace) {
            if (e = Op(e, 1),
            t = Vn(t, 0, 1),
            n = Vn(n, 0, 1),
            t === 0)
                this.r = this.g = this.b = n;
            else {
                let s = n <= .5 ? n * (1 + t) : n + t - n * t
                  , o = 2 * n - s;
                this.r = Fd(o, s, e + 1 / 3),
                this.g = Fd(o, s, e),
                this.b = Fd(o, s, e - 1 / 3)
            }
            return Li.toWorkingColorSpace(this, i),
            this
        }
        setStyle(e, t=ct) {
            function n(s) {
                s !== void 0 && parseFloat(s) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
            }
            let i;
            if (i = /^(\w+)\(([^\)]*)\)/.exec(e)) {
                let s, o = i[1], a = i[2];
                switch (o) {
                case "rgb":
                case "rgba":
                    if (s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                        return n(s[4]),
                        this.setRGB(Math.min(255, parseInt(s[1], 10)) / 255, Math.min(255, parseInt(s[2], 10)) / 255, Math.min(255, parseInt(s[3], 10)) / 255, t);
                    if (s = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                        return n(s[4]),
                        this.setRGB(Math.min(100, parseInt(s[1], 10)) / 100, Math.min(100, parseInt(s[2], 10)) / 100, Math.min(100, parseInt(s[3], 10)) / 100, t);
                    break;
                case "hsl":
                case "hsla":
                    if (s = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                        return n(s[4]),
                        this.setHSL(parseFloat(s[1]) / 360, parseFloat(s[2]) / 100, parseFloat(s[3]) / 100, t);
                    break;
                default:
                    console.warn("THREE.Color: Unknown color model " + e)
                }
            } else if (i = /^\#([A-Fa-f\d]+)$/.exec(e)) {
                let s = i[1]
                  , o = s.length;
                if (o === 3)
                    return this.setRGB(parseInt(s.charAt(0), 16) / 15, parseInt(s.charAt(1), 16) / 15, parseInt(s.charAt(2), 16) / 15, t);
                if (o === 6)
                    return this.setHex(parseInt(s, 16), t);
                console.warn("THREE.Color: Invalid hex color " + e)
            } else if (e && e.length > 0)
                return this.setColorName(e, t);
            return this
        }
        setColorName(e, t=ct) {
            let n = _v[e.toLowerCase()];
            return n !== void 0 ? this.setHex(n, t) : console.warn("THREE.Color: Unknown color " + e),
            this
        }
        clone() {
            return new this.constructor(this.r,this.g,this.b)
        }
        copy(e) {
            return this.r = e.r,
            this.g = e.g,
            this.b = e.b,
            this
        }
        copySRGBToLinear(e) {
            return this.r = Da(e.r),
            this.g = Da(e.g),
            this.b = Da(e.b),
            this
        }
        copyLinearToSRGB(e) {
            return this.r = Ed(e.r),
            this.g = Ed(e.g),
            this.b = Ed(e.b),
            this
        }
        convertSRGBToLinear() {
            return this.copySRGBToLinear(this),
            this
        }
        convertLinearToSRGB() {
            return this.copyLinearToSRGB(this),
            this
        }
        getHex(e=ct) {
            return Li.fromWorkingColorSpace(Kn.copy(this), e),
            Math.round(Vn(Kn.r * 255, 0, 255)) * 65536 + Math.round(Vn(Kn.g * 255, 0, 255)) * 256 + Math.round(Vn(Kn.b * 255, 0, 255))
        }
        getHexString(e=ct) {
            return ("000000" + this.getHex(e).toString(16)).slice(-6)
        }
        getHSL(e, t=Li.workingColorSpace) {
            Li.fromWorkingColorSpace(Kn.copy(this), t);
            let n = Kn.r, i = Kn.g, s = Kn.b, o = Math.max(n, i, s), a = Math.min(n, i, s), l, c, u = (a + o) / 2;
            if (a === o)
                l = 0,
                c = 0;
            else {
                let h = o - a;
                switch (c = u <= .5 ? h / (o + a) : h / (2 - o - a),
                o) {
                case n:
                    l = (i - s) / h + (i < s ? 6 : 0);
                    break;
                case i:
                    l = (s - n) / h + 2;
                    break;
                case s:
                    l = (n - i) / h + 4;
                    break
                }
                l /= 6
            }
            return e.h = l,
            e.s = c,
            e.l = u,
            e
        }
        getRGB(e, t=Li.workingColorSpace) {
            return Li.fromWorkingColorSpace(Kn.copy(this), t),
            e.r = Kn.r,
            e.g = Kn.g,
            e.b = Kn.b,
            e
        }
        getStyle(e=ct) {
            Li.fromWorkingColorSpace(Kn.copy(this), e);
            let t = Kn.r
              , n = Kn.g
              , i = Kn.b;
            return e !== ct ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(n * 255)},${Math.round(i * 255)})`
        }
        offsetHSL(e, t, n) {
            return this.getHSL(or),
            or.h += e,
            or.s += t,
            or.l += n,
            this.setHSL(or.h, or.s, or.l),
            this
        }
        add(e) {
            return this.r += e.r,
            this.g += e.g,
            this.b += e.b,
            this
        }
        addColors(e, t) {
            return this.r = e.r + t.r,
            this.g = e.g + t.g,
            this.b = e.b + t.b,
            this
        }
        addScalar(e) {
            return this.r += e,
            this.g += e,
            this.b += e,
            this
        }
        sub(e) {
            return this.r = Math.max(0, this.r - e.r),
            this.g = Math.max(0, this.g - e.g),
            this.b = Math.max(0, this.b - e.b),
            this
        }
        multiply(e) {
            return this.r *= e.r,
            this.g *= e.g,
            this.b *= e.b,
            this
        }
        multiplyScalar(e) {
            return this.r *= e,
            this.g *= e,
            this.b *= e,
            this
        }
        lerp(e, t) {
            return this.r += (e.r - this.r) * t,
            this.g += (e.g - this.g) * t,
            this.b += (e.b - this.b) * t,
            this
        }
        lerpColors(e, t, n) {
            return this.r = e.r + (t.r - e.r) * n,
            this.g = e.g + (t.g - e.g) * n,
            this.b = e.b + (t.b - e.b) * n,
            this
        }
        lerpHSL(e, t) {
            this.getHSL(or),
            e.getHSL(Zu);
            let n = wc(or.h, Zu.h, t)
              , i = wc(or.s, Zu.s, t)
              , s = wc(or.l, Zu.l, t);
            return this.setHSL(n, i, s),
            this
        }
        setFromVector3(e) {
            return this.r = e.x,
            this.g = e.y,
            this.b = e.z,
            this
        }
        applyMatrix3(e) {
            let t = this.r
              , n = this.g
              , i = this.b
              , s = e.elements;
            return this.r = s[0] * t + s[3] * n + s[6] * i,
            this.g = s[1] * t + s[4] * n + s[7] * i,
            this.b = s[2] * t + s[5] * n + s[8] * i,
            this
        }
        equals(e) {
            return e.r === this.r && e.g === this.g && e.b === this.b
        }
        fromArray(e, t=0) {
            return this.r = e[t],
            this.g = e[t + 1],
            this.b = e[t + 2],
            this
        }
        toArray(e=[], t=0) {
            return e[t] = this.r,
            e[t + 1] = this.g,
            e[t + 2] = this.b,
            e
        }
        fromBufferAttribute(e, t) {
            return this.r = e.getX(t),
            this.g = e.getY(t),
            this.b = e.getZ(t),
            this
        }
        toJSON() {
            return this.getHex()
        }
        *[Symbol.iterator]() {
            yield this.r,
            yield this.g,
            yield this.b
        }
    }
      , Kn = new $e;
    $e.NAMES = _v;
    var Yi = class extends ur {
        constructor(e) {
            super(),
            this.isMeshBasicMaterial = !0,
            this.type = "MeshBasicMaterial",
            this.color = new $e(16777215),
            this.map = null,
            this.lightMap = null,
            this.lightMapIntensity = 1,
            this.aoMap = null,
            this.aoMapIntensity = 1,
            this.specularMap = null,
            this.alphaMap = null,
            this.envMap = null,
            this.combine = Uh,
            this.reflectivity = 1,
            this.refractionRatio = .98,
            this.wireframe = !1,
            this.wireframeLinewidth = 1,
            this.wireframeLinecap = "round",
            this.wireframeLinejoin = "round",
            this.fog = !0,
            this.setValues(e)
        }
        copy(e) {
            return super.copy(e),
            this.color.copy(e.color),
            this.map = e.map,
            this.lightMap = e.lightMap,
            this.lightMapIntensity = e.lightMapIntensity,
            this.aoMap = e.aoMap,
            this.aoMapIntensity = e.aoMapIntensity,
            this.specularMap = e.specularMap,
            this.alphaMap = e.alphaMap,
            this.envMap = e.envMap,
            this.combine = e.combine,
            this.reflectivity = e.reflectivity,
            this.refractionRatio = e.refractionRatio,
            this.wireframe = e.wireframe,
            this.wireframeLinewidth = e.wireframeLinewidth,
            this.wireframeLinecap = e.wireframeLinecap,
            this.wireframeLinejoin = e.wireframeLinejoin,
            this.fog = e.fog,
            this
        }
    }
    ;
    var _n = new ue
      , Ju = new Ie
      , zn = class {
        constructor(e, t, n=!1) {
            if (Array.isArray(e))
                throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            this.isBufferAttribute = !0,
            this.name = "",
            this.array = e,
            this.itemSize = t,
            this.count = e !== void 0 ? e.length / t : 0,
            this.normalized = n,
            this.usage = i0,
            this.updateRange = {
                offset: 0,
                count: -1
            },
            this.version = 0
        }
        onUploadCallback() {}
        set needsUpdate(e) {
            e === !0 && this.version++
        }
        setUsage(e) {
            return this.usage = e,
            this
        }
        copy(e) {
            return this.name = e.name,
            this.array = new e.array.constructor(e.array),
            this.itemSize = e.itemSize,
            this.count = e.count,
            this.normalized = e.normalized,
            this.usage = e.usage,
            this
        }
        copyAt(e, t, n) {
            e *= this.itemSize,
            n *= t.itemSize;
            for (let i = 0, s = this.itemSize; i < s; i++)
                this.array[e + i] = t.array[n + i];
            return this
        }
        copyArray(e) {
            return this.array.set(e),
            this
        }
        applyMatrix3(e) {
            if (this.itemSize === 2)
                for (let t = 0, n = this.count; t < n; t++)
                    Ju.fromBufferAttribute(this, t),
                    Ju.applyMatrix3(e),
                    this.setXY(t, Ju.x, Ju.y);
            else if (this.itemSize === 3)
                for (let t = 0, n = this.count; t < n; t++)
                    _n.fromBufferAttribute(this, t),
                    _n.applyMatrix3(e),
                    this.setXYZ(t, _n.x, _n.y, _n.z);
            return this
        }
        applyMatrix4(e) {
            for (let t = 0, n = this.count; t < n; t++)
                _n.fromBufferAttribute(this, t),
                _n.applyMatrix4(e),
                this.setXYZ(t, _n.x, _n.y, _n.z);
            return this
        }
        applyNormalMatrix(e) {
            for (let t = 0, n = this.count; t < n; t++)
                _n.fromBufferAttribute(this, t),
                _n.applyNormalMatrix(e),
                this.setXYZ(t, _n.x, _n.y, _n.z);
            return this
        }
        transformDirection(e) {
            for (let t = 0, n = this.count; t < n; t++)
                _n.fromBufferAttribute(this, t),
                _n.transformDirection(e),
                this.setXYZ(t, _n.x, _n.y, _n.z);
            return this
        }
        set(e, t=0) {
            return this.array.set(e, t),
            this
        }
        getX(e) {
            let t = this.array[e * this.itemSize];
            return this.normalized && (t = Ec(t, this.array)),
            t
        }
        setX(e, t) {
            return this.normalized && (t = hi(t, this.array)),
            this.array[e * this.itemSize] = t,
            this
        }
        getY(e) {
            let t = this.array[e * this.itemSize + 1];
            return this.normalized && (t = Ec(t, this.array)),
            t
        }
        setY(e, t) {
            return this.normalized && (t = hi(t, this.array)),
            this.array[e * this.itemSize + 1] = t,
            this
        }
        getZ(e) {
            let t = this.array[e * this.itemSize + 2];
            return this.normalized && (t = Ec(t, this.array)),
            t
        }
        setZ(e, t) {
            return this.normalized && (t = hi(t, this.array)),
            this.array[e * this.itemSize + 2] = t,
            this
        }
        getW(e) {
            let t = this.array[e * this.itemSize + 3];
            return this.normalized && (t = Ec(t, this.array)),
            t
        }
        setW(e, t) {
            return this.normalized && (t = hi(t, this.array)),
            this.array[e * this.itemSize + 3] = t,
            this
        }
        setXY(e, t, n) {
            return e *= this.itemSize,
            this.normalized && (t = hi(t, this.array),
            n = hi(n, this.array)),
            this.array[e + 0] = t,
            this.array[e + 1] = n,
            this
        }
        setXYZ(e, t, n, i) {
            return e *= this.itemSize,
            this.normalized && (t = hi(t, this.array),
            n = hi(n, this.array),
            i = hi(i, this.array)),
            this.array[e + 0] = t,
            this.array[e + 1] = n,
            this.array[e + 2] = i,
            this
        }
        setXYZW(e, t, n, i, s) {
            return e *= this.itemSize,
            this.normalized && (t = hi(t, this.array),
            n = hi(n, this.array),
            i = hi(i, this.array),
            s = hi(s, this.array)),
            this.array[e + 0] = t,
            this.array[e + 1] = n,
            this.array[e + 2] = i,
            this.array[e + 3] = s,
            this
        }
        onUpload(e) {
            return this.onUploadCallback = e,
            this
        }
        clone() {
            return new this.constructor(this.array,this.itemSize).copy(this)
        }
        toJSON() {
            let e = {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: Array.from(this.array),
                normalized: this.normalized
            };
            return this.name !== "" && (e.name = this.name),
            this.usage !== i0 && (e.usage = this.usage),
            (this.updateRange.offset !== 0 || this.updateRange.count !== -1) && (e.updateRange = this.updateRange),
            e
        }
        copyColorsArray() {
            console.error("THREE.BufferAttribute: copyColorsArray() was removed in r144.")
        }
        copyVector2sArray() {
            console.error("THREE.BufferAttribute: copyVector2sArray() was removed in r144.")
        }
        copyVector3sArray() {
            console.error("THREE.BufferAttribute: copyVector3sArray() was removed in r144.")
        }
        copyVector4sArray() {
            console.error("THREE.BufferAttribute: copyVector4sArray() was removed in r144.")
        }
    }
    ;
    var za = class extends zn {
        constructor(e, t, n) {
            super(new Uint16Array(e), t, n)
        }
    }
    ;
    var Mh = class extends zn {
        constructor(e, t, n) {
            super(new Uint32Array(e), t, n)
        }
    }
    ;
    var qe = class extends zn {
        constructor(e, t, n) {
            super(new Float32Array(e), t, n)
        }
    }
    ;
    var W_ = 0
      , Wi = new je
      , kd = new bt
      , _a = new ue
      , Pi = new cr
      , bc = new cr
      , Dn = new ue
      , wt = class extends Ws {
        constructor() {
            super(),
            this.isBufferGeometry = !0,
            Object.defineProperty(this, "id", {
                value: W_++
            }),
            this.uuid = ys(),
            this.name = "",
            this.type = "BufferGeometry",
            this.index = null,
            this.attributes = {},
            this.morphAttributes = {},
            this.morphTargetsRelative = !1,
            this.groups = [],
            this.boundingBox = null,
            this.boundingSphere = null,
            this.drawRange = {
                start: 0,
                count: 1 / 0
            },
            this.userData = {}
        }
        getIndex() {
            return this.index
        }
        setIndex(e) {
            return Array.isArray(e) ? this.index = new (xv(e) ? Mh : za)(e,1) : this.index = e,
            this
        }
        getAttribute(e) {
            return this.attributes[e]
        }
        setAttribute(e, t) {
            return this.attributes[e] = t,
            this
        }
        deleteAttribute(e) {
            return delete this.attributes[e],
            this
        }
        hasAttribute(e) {
            return this.attributes[e] !== void 0
        }
        addGroup(e, t, n=0) {
            this.groups.push({
                start: e,
                count: t,
                materialIndex: n
            })
        }
        clearGroups() {
            this.groups = []
        }
        setDrawRange(e, t) {
            this.drawRange.start = e,
            this.drawRange.count = t
        }
        applyMatrix4(e) {
            let t = this.attributes.position;
            t !== void 0 && (t.applyMatrix4(e),
            t.needsUpdate = !0);
            let n = this.attributes.normal;
            if (n !== void 0) {
                let s = new vt().getNormalMatrix(e);
                n.applyNormalMatrix(s),
                n.needsUpdate = !0
            }
            let i = this.attributes.tangent;
            return i !== void 0 && (i.transformDirection(e),
            i.needsUpdate = !0),
            this.boundingBox !== null && this.computeBoundingBox(),
            this.boundingSphere !== null && this.computeBoundingSphere(),
            this
        }
        applyQuaternion(e) {
            return Wi.makeRotationFromQuaternion(e),
            this.applyMatrix4(Wi),
            this
        }
        rotateX(e) {
            return Wi.makeRotationX(e),
            this.applyMatrix4(Wi),
            this
        }
        rotateY(e) {
            return Wi.makeRotationY(e),
            this.applyMatrix4(Wi),
            this
        }
        rotateZ(e) {
            return Wi.makeRotationZ(e),
            this.applyMatrix4(Wi),
            this
        }
        translate(e, t, n) {
            return Wi.makeTranslation(e, t, n),
            this.applyMatrix4(Wi),
            this
        }
        scale(e, t, n) {
            return Wi.makeScale(e, t, n),
            this.applyMatrix4(Wi),
            this
        }
        lookAt(e) {
            return kd.lookAt(e),
            kd.updateMatrix(),
            this.applyMatrix4(kd.matrix),
            this
        }
        center() {
            return this.computeBoundingBox(),
            this.boundingBox.getCenter(_a).negate(),
            this.translate(_a.x, _a.y, _a.z),
            this
        }
        setFromPoints(e) {
            let t = [];
            for (let n = 0, i = e.length; n < i; n++) {
                let s = e[n];
                t.push(s.x, s.y, s.z || 0)
            }
            return this.setAttribute("position", new qe(t,3)),
            this
        }
        computeBoundingBox() {
            this.boundingBox === null && (this.boundingBox = new cr);
            let e = this.attributes.position
              , t = this.morphAttributes.position;
            if (e && e.isGLBufferAttribute) {
                console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this),
                this.boundingBox.set(new ue(-1 / 0,-1 / 0,-1 / 0), new ue(1 / 0,1 / 0,1 / 0));
                return
            }
            if (e !== void 0) {
                if (this.boundingBox.setFromBufferAttribute(e),
                t)
                    for (let n = 0, i = t.length; n < i; n++) {
                        let s = t[n];
                        Pi.setFromBufferAttribute(s),
                        this.morphTargetsRelative ? (Dn.addVectors(this.boundingBox.min, Pi.min),
                        this.boundingBox.expandByPoint(Dn),
                        Dn.addVectors(this.boundingBox.max, Pi.max),
                        this.boundingBox.expandByPoint(Dn)) : (this.boundingBox.expandByPoint(Pi.min),
                        this.boundingBox.expandByPoint(Pi.max))
                    }
            } else
                this.boundingBox.makeEmpty();
            (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
        }
        computeBoundingSphere() {
            this.boundingSphere === null && (this.boundingSphere = new Nr);
            let e = this.attributes.position
              , t = this.morphAttributes.position;
            if (e && e.isGLBufferAttribute) {
                console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this),
                this.boundingSphere.set(new ue, 1 / 0);
                return
            }
            if (e) {
                let n = this.boundingSphere.center;
                if (Pi.setFromBufferAttribute(e),
                t)
                    for (let s = 0, o = t.length; s < o; s++) {
                        let a = t[s];
                        bc.setFromBufferAttribute(a),
                        this.morphTargetsRelative ? (Dn.addVectors(Pi.min, bc.min),
                        Pi.expandByPoint(Dn),
                        Dn.addVectors(Pi.max, bc.max),
                        Pi.expandByPoint(Dn)) : (Pi.expandByPoint(bc.min),
                        Pi.expandByPoint(bc.max))
                    }
                Pi.getCenter(n);
                let i = 0;
                for (let s = 0, o = e.count; s < o; s++)
                    Dn.fromBufferAttribute(e, s),
                    i = Math.max(i, n.distanceToSquared(Dn));
                if (t)
                    for (let s = 0, o = t.length; s < o; s++) {
                        let a = t[s]
                          , l = this.morphTargetsRelative;
                        for (let c = 0, u = a.count; c < u; c++)
                            Dn.fromBufferAttribute(a, c),
                            l && (_a.fromBufferAttribute(e, c),
                            Dn.add(_a)),
                            i = Math.max(i, n.distanceToSquared(Dn))
                    }
                this.boundingSphere.radius = Math.sqrt(i),
                isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
            }
        }
        computeTangents() {
            let e = this.index
              , t = this.attributes;
            if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
                console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                return
            }
            let n = e.array
              , i = t.position.array
              , s = t.normal.array
              , o = t.uv.array
              , a = i.length / 3;
            this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new zn(new Float32Array(4 * a),4));
            let l = this.getAttribute("tangent").array
              , c = []
              , u = [];
            for (let R = 0; R < a; R++)
                c[R] = new ue,
                u[R] = new ue;
            let h = new ue
              , f = new ue
              , m = new ue
              , g = new Ie
              , v = new Ie
              , p = new Ie
              , d = new ue
              , x = new ue;
            function y(R, q, k) {
                h.fromArray(i, R * 3),
                f.fromArray(i, q * 3),
                m.fromArray(i, k * 3),
                g.fromArray(o, R * 2),
                v.fromArray(o, q * 2),
                p.fromArray(o, k * 2),
                f.sub(h),
                m.sub(h),
                v.sub(g),
                p.sub(g);
                let B = 1 / (v.x * p.y - p.x * v.y);
                isFinite(B) && (d.copy(f).multiplyScalar(p.y).addScaledVector(m, -v.y).multiplyScalar(B),
                x.copy(m).multiplyScalar(v.x).addScaledVector(f, -p.x).multiplyScalar(B),
                c[R].add(d),
                c[q].add(d),
                c[k].add(d),
                u[R].add(x),
                u[q].add(x),
                u[k].add(x))
            }
            let _ = this.groups;
            _.length === 0 && (_ = [{
                start: 0,
                count: n.length
            }]);
            for (let R = 0, q = _.length; R < q; ++R) {
                let k = _[R]
                  , B = k.start
                  , P = k.count;
                for (let C = B, L = B + P; C < L; C += 3)
                    y(n[C + 0], n[C + 1], n[C + 2])
            }
            let S = new ue
              , N = new ue
              , I = new ue
              , O = new ue;
            function M(R) {
                I.fromArray(s, R * 3),
                O.copy(I);
                let q = c[R];
                S.copy(q),
                S.sub(I.multiplyScalar(I.dot(q))).normalize(),
                N.crossVectors(O, q);
                let B = N.dot(u[R]) < 0 ? -1 : 1;
                l[R * 4] = S.x,
                l[R * 4 + 1] = S.y,
                l[R * 4 + 2] = S.z,
                l[R * 4 + 3] = B
            }
            for (let R = 0, q = _.length; R < q; ++R) {
                let k = _[R]
                  , B = k.start
                  , P = k.count;
                for (let C = B, L = B + P; C < L; C += 3)
                    M(n[C + 0]),
                    M(n[C + 1]),
                    M(n[C + 2])
            }
        }
        computeVertexNormals() {
            let e = this.index
              , t = this.getAttribute("position");
            if (t !== void 0) {
                let n = this.getAttribute("normal");
                if (n === void 0)
                    n = new zn(new Float32Array(t.count * 3),3),
                    this.setAttribute("normal", n);
                else
                    for (let f = 0, m = n.count; f < m; f++)
                        n.setXYZ(f, 0, 0, 0);
                let i = new ue
                  , s = new ue
                  , o = new ue
                  , a = new ue
                  , l = new ue
                  , c = new ue
                  , u = new ue
                  , h = new ue;
                if (e)
                    for (let f = 0, m = e.count; f < m; f += 3) {
                        let g = e.getX(f + 0)
                          , v = e.getX(f + 1)
                          , p = e.getX(f + 2);
                        i.fromBufferAttribute(t, g),
                        s.fromBufferAttribute(t, v),
                        o.fromBufferAttribute(t, p),
                        u.subVectors(o, s),
                        h.subVectors(i, s),
                        u.cross(h),
                        a.fromBufferAttribute(n, g),
                        l.fromBufferAttribute(n, v),
                        c.fromBufferAttribute(n, p),
                        a.add(u),
                        l.add(u),
                        c.add(u),
                        n.setXYZ(g, a.x, a.y, a.z),
                        n.setXYZ(v, l.x, l.y, l.z),
                        n.setXYZ(p, c.x, c.y, c.z)
                    }
                else
                    for (let f = 0, m = t.count; f < m; f += 3)
                        i.fromBufferAttribute(t, f + 0),
                        s.fromBufferAttribute(t, f + 1),
                        o.fromBufferAttribute(t, f + 2),
                        u.subVectors(o, s),
                        h.subVectors(i, s),
                        u.cross(h),
                        n.setXYZ(f + 0, u.x, u.y, u.z),
                        n.setXYZ(f + 1, u.x, u.y, u.z),
                        n.setXYZ(f + 2, u.x, u.y, u.z);
                this.normalizeNormals(),
                n.needsUpdate = !0
            }
        }
        merge() {
            return console.error("THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeGeometries() instead."),
            this
        }
        normalizeNormals() {
            let e = this.attributes.normal;
            for (let t = 0, n = e.count; t < n; t++)
                Dn.fromBufferAttribute(e, t),
                Dn.normalize(),
                e.setXYZ(t, Dn.x, Dn.y, Dn.z)
        }
        toNonIndexed() {
            function e(a, l) {
                let c = a.array
                  , u = a.itemSize
                  , h = a.normalized
                  , f = new c.constructor(l.length * u)
                  , m = 0
                  , g = 0;
                for (let v = 0, p = l.length; v < p; v++) {
                    a.isInterleavedBufferAttribute ? m = l[v] * a.data.stride + a.offset : m = l[v] * u;
                    for (let d = 0; d < u; d++)
                        f[g++] = c[m++]
                }
                return new zn(f,u,h)
            }
            if (this.index === null)
                return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),
                this;
            let t = new wt
              , n = this.index.array
              , i = this.attributes;
            for (let a in i) {
                let l = i[a]
                  , c = e(l, n);
                t.setAttribute(a, c)
            }
            let s = this.morphAttributes;
            for (let a in s) {
                let l = []
                  , c = s[a];
                for (let u = 0, h = c.length; u < h; u++) {
                    let f = c[u]
                      , m = e(f, n);
                    l.push(m)
                }
                t.morphAttributes[a] = l
            }
            t.morphTargetsRelative = this.morphTargetsRelative;
            let o = this.groups;
            for (let a = 0, l = o.length; a < l; a++) {
                let c = o[a];
                t.addGroup(c.start, c.count, c.materialIndex)
            }
            return t
        }
        toJSON() {
            let e = {
                metadata: {
                    version: 4.5,
                    type: "BufferGeometry",
                    generator: "BufferGeometry.toJSON"
                }
            };
            if (e.uuid = this.uuid,
            e.type = this.type,
            this.name !== "" && (e.name = this.name),
            Object.keys(this.userData).length > 0 && (e.userData = this.userData),
            this.parameters !== void 0) {
                let l = this.parameters;
                for (let c in l)
                    l[c] !== void 0 && (e[c] = l[c]);
                return e
            }
            e.data = {
                attributes: {}
            };
            let t = this.index;
            t !== null && (e.data.index = {
                type: t.array.constructor.name,
                array: Array.prototype.slice.call(t.array)
            });
            let n = this.attributes;
            for (let l in n) {
                let c = n[l];
                e.data.attributes[l] = c.toJSON(e.data)
            }
            let i = {}
              , s = !1;
            for (let l in this.morphAttributes) {
                let c = this.morphAttributes[l]
                  , u = [];
                for (let h = 0, f = c.length; h < f; h++) {
                    let m = c[h];
                    u.push(m.toJSON(e.data))
                }
                u.length > 0 && (i[l] = u,
                s = !0)
            }
            s && (e.data.morphAttributes = i,
            e.data.morphTargetsRelative = this.morphTargetsRelative);
            let o = this.groups;
            o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
            let a = this.boundingSphere;
            return a !== null && (e.data.boundingSphere = {
                center: a.center.toArray(),
                radius: a.radius
            }),
            e
        }
        clone() {
            return new this.constructor().copy(this)
        }
        copy(e) {
            this.index = null,
            this.attributes = {},
            this.morphAttributes = {},
            this.groups = [],
            this.boundingBox = null,
            this.boundingSphere = null;
            let t = {};
            this.name = e.name;
            let n = e.index;
            n !== null && this.setIndex(n.clone(t));
            let i = e.attributes;
            for (let c in i) {
                let u = i[c];
                this.setAttribute(c, u.clone(t))
            }
            let s = e.morphAttributes;
            for (let c in s) {
                let u = []
                  , h = s[c];
                for (let f = 0, m = h.length; f < m; f++)
                    u.push(h[f].clone(t));
                this.morphAttributes[c] = u
            }
            this.morphTargetsRelative = e.morphTargetsRelative;
            let o = e.groups;
            for (let c = 0, u = o.length; c < u; c++) {
                let h = o[c];
                this.addGroup(h.start, h.count, h.materialIndex)
            }
            let a = e.boundingBox;
            a !== null && (this.boundingBox = a.clone());
            let l = e.boundingSphere;
            return l !== null && (this.boundingSphere = l.clone()),
            this.drawRange.start = e.drawRange.start,
            this.drawRange.count = e.drawRange.count,
            this.userData = e.userData,
            this
        }
        dispose() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }
      , g0 = new je
      , Pr = new Va
      , $u = new Nr
      , v0 = new ue
      , Ta = new ue
      , ba = new ue
      , Ma = new ue
      , Ud = new ue
      , Qu = new ue
      , eh = new Ie
      , th = new Ie
      , nh = new Ie
      , y0 = new ue
      , x0 = new ue
      , _0 = new ue
      , ih = new ue
      , rh = new ue
      , Ht = class extends bt {
        constructor(e=new wt, t=new Yi) {
            super(),
            this.isMesh = !0,
            this.type = "Mesh",
            this.geometry = e,
            this.material = t,
            this.updateMorphTargets()
        }
        copy(e, t) {
            return super.copy(e, t),
            e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
            e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)),
            this.material = e.material,
            this.geometry = e.geometry,
            this
        }
        updateMorphTargets() {
            let t = this.geometry.morphAttributes
              , n = Object.keys(t);
            if (n.length > 0) {
                let i = t[n[0]];
                if (i !== void 0) {
                    this.morphTargetInfluences = [],
                    this.morphTargetDictionary = {};
                    for (let s = 0, o = i.length; s < o; s++) {
                        let a = i[s].name || String(s);
                        this.morphTargetInfluences.push(0),
                        this.morphTargetDictionary[a] = s
                    }
                }
            }
        }
        getVertexPosition(e, t) {
            let n = this.geometry
              , i = n.attributes.position
              , s = n.morphAttributes.position
              , o = n.morphTargetsRelative;
            t.fromBufferAttribute(i, e);
            let a = this.morphTargetInfluences;
            if (s && a) {
                Qu.set(0, 0, 0);
                for (let l = 0, c = s.length; l < c; l++) {
                    let u = a[l]
                      , h = s[l];
                    u !== 0 && (Ud.fromBufferAttribute(h, e),
                    o ? Qu.addScaledVector(Ud, u) : Qu.addScaledVector(Ud.sub(t), u))
                }
                t.add(Qu)
            }
            return t
        }
        raycast(e, t) {
            let n = this.geometry
              , i = this.material
              , s = this.matrixWorld;
            i !== void 0 && (n.boundingSphere === null && n.computeBoundingSphere(),
            $u.copy(n.boundingSphere),
            $u.applyMatrix4(s),
            Pr.copy(e.ray).recast(e.near),
            !($u.containsPoint(Pr.origin) === !1 && (Pr.intersectSphere($u, v0) === null || Pr.origin.distanceToSquared(v0) > (e.far - e.near) ** 2)) && (g0.copy(s).invert(),
            Pr.copy(e.ray).applyMatrix4(g0),
            !(n.boundingBox !== null && Pr.intersectsBox(n.boundingBox) === !1) && this._computeIntersections(e, t)))
        }
        _computeIntersections(e, t) {
            let n, i = this.geometry, s = this.material, o = i.index, a = i.attributes.position, l = i.attributes.uv, c = i.attributes.uv1, u = i.attributes.normal, h = i.groups, f = i.drawRange;
            if (o !== null)
                if (Array.isArray(s))
                    for (let m = 0, g = h.length; m < g; m++) {
                        let v = h[m]
                          , p = s[v.materialIndex]
                          , d = Math.max(v.start, f.start)
                          , x = Math.min(o.count, Math.min(v.start + v.count, f.start + f.count));
                        for (let y = d, _ = x; y < _; y += 3) {
                            let S = o.getX(y)
                              , N = o.getX(y + 1)
                              , I = o.getX(y + 2);
                            n = sh(this, p, e, Pr, l, c, u, S, N, I),
                            n && (n.faceIndex = Math.floor(y / 3),
                            n.face.materialIndex = v.materialIndex,
                            t.push(n))
                        }
                    }
                else {
                    let m = Math.max(0, f.start)
                      , g = Math.min(o.count, f.start + f.count);
                    for (let v = m, p = g; v < p; v += 3) {
                        let d = o.getX(v)
                          , x = o.getX(v + 1)
                          , y = o.getX(v + 2);
                        n = sh(this, s, e, Pr, l, c, u, d, x, y),
                        n && (n.faceIndex = Math.floor(v / 3),
                        t.push(n))
                    }
                }
            else if (a !== void 0)
                if (Array.isArray(s))
                    for (let m = 0, g = h.length; m < g; m++) {
                        let v = h[m]
                          , p = s[v.materialIndex]
                          , d = Math.max(v.start, f.start)
                          , x = Math.min(a.count, Math.min(v.start + v.count, f.start + f.count));
                        for (let y = d, _ = x; y < _; y += 3) {
                            let S = y
                              , N = y + 1
                              , I = y + 2;
                            n = sh(this, p, e, Pr, l, c, u, S, N, I),
                            n && (n.faceIndex = Math.floor(y / 3),
                            n.face.materialIndex = v.materialIndex,
                            t.push(n))
                        }
                    }
                else {
                    let m = Math.max(0, f.start)
                      , g = Math.min(a.count, f.start + f.count);
                    for (let v = m, p = g; v < p; v += 3) {
                        let d = v
                          , x = v + 1
                          , y = v + 2;
                        n = sh(this, s, e, Pr, l, c, u, d, x, y),
                        n && (n.faceIndex = Math.floor(v / 3),
                        t.push(n))
                    }
                }
        }
    }
    ;
    function X_(r, e, t, n, i, s, o, a) {
        let l;
        if (e.side === Mn ? l = n.intersectTriangle(o, s, i, !0, a) : l = n.intersectTriangle(i, s, o, e.side === qi, a),
        l === null)
            return null;
        rh.copy(a),
        rh.applyMatrix4(r.matrixWorld);
        let c = t.ray.origin.distanceTo(rh);
        return c < t.near || c > t.far ? null : {
            distance: c,
            point: rh.clone(),
            object: r
        }
    }
    function sh(r, e, t, n, i, s, o, a, l, c) {
        r.getVertexPosition(a, Ta),
        r.getVertexPosition(l, ba),
        r.getVertexPosition(c, Ma);
        let u = X_(r, e, t, n, Ta, ba, Ma, ih);
        if (u) {
            i && (eh.fromBufferAttribute(i, a),
            th.fromBufferAttribute(i, l),
            nh.fromBufferAttribute(i, c),
            u.uv = fi.getInterpolation(ih, Ta, ba, Ma, eh, th, nh, new Ie)),
            s && (eh.fromBufferAttribute(s, a),
            th.fromBufferAttribute(s, l),
            nh.fromBufferAttribute(s, c),
            u.uv1 = fi.getInterpolation(ih, Ta, ba, Ma, eh, th, nh, new Ie),
            u.uv2 = u.uv1),
            o && (y0.fromBufferAttribute(o, a),
            x0.fromBufferAttribute(o, l),
            _0.fromBufferAttribute(o, c),
            u.normal = fi.getInterpolation(ih, Ta, ba, Ma, y0, x0, _0, new ue),
            u.normal.dot(n.direction) > 0 && u.normal.multiplyScalar(-1));
            let h = {
                a,
                b: l,
                c,
                normal: new ue,
                materialIndex: 0
            };
            fi.getNormal(Ta, ba, Ma, h.normal),
            u.face = h
        }
        return u
    }
    var ps = class extends wt {
        constructor(e=1, t=1, n=1, i=1, s=1, o=1) {
            super(),
            this.type = "BoxGeometry",
            this.parameters = {
                width: e,
                height: t,
                depth: n,
                widthSegments: i,
                heightSegments: s,
                depthSegments: o
            };
            let a = this;
            i = Math.floor(i),
            s = Math.floor(s),
            o = Math.floor(o);
            let l = []
              , c = []
              , u = []
              , h = []
              , f = 0
              , m = 0;
            g("z", "y", "x", -1, -1, n, t, e, o, s, 0),
            g("z", "y", "x", 1, -1, n, t, -e, o, s, 1),
            g("x", "z", "y", 1, 1, e, n, t, i, o, 2),
            g("x", "z", "y", 1, -1, e, n, -t, i, o, 3),
            g("x", "y", "z", 1, -1, e, t, n, i, s, 4),
            g("x", "y", "z", -1, -1, e, t, -n, i, s, 5),
            this.setIndex(l),
            this.setAttribute("position", new qe(c,3)),
            this.setAttribute("normal", new qe(u,3)),
            this.setAttribute("uv", new qe(h,2));
            function g(v, p, d, x, y, _, S, N, I, O, M) {
                let R = _ / I
                  , q = S / O
                  , k = _ / 2
                  , B = S / 2
                  , P = N / 2
                  , C = I + 1
                  , L = O + 1
                  , F = 0
                  , U = 0
                  , W = new ue;
                for (let K = 0; K < L; K++) {
                    let re = K * q - B;
                    for (let oe = 0; oe < C; oe++) {
                        let j = oe * R - k;
                        W[v] = j * x,
                        W[p] = re * y,
                        W[d] = P,
                        c.push(W.x, W.y, W.z),
                        W[v] = 0,
                        W[p] = 0,
                        W[d] = N > 0 ? 1 : -1,
                        u.push(W.x, W.y, W.z),
                        h.push(oe / I),
                        h.push(1 - K / O),
                        F += 1
                    }
                }
                for (let K = 0; K < O; K++)
                    for (let re = 0; re < I; re++) {
                        let oe = f + re + C * K
                          , j = f + re + C * (K + 1)
                          , w = f + (re + 1) + C * (K + 1)
                          , b = f + (re + 1) + C * K;
                        l.push(oe, j, b),
                        l.push(j, w, b),
                        U += 6
                    }
                a.addGroup(m, U, M),
                m += U,
                f += F
            }
        }
        copy(e) {
            return super.copy(e),
            this.parameters = Object.assign({}, e.parameters),
            this
        }
        static fromJSON(e) {
            return new ps(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)
        }
    }
    ;
    function Ha(r) {
        let e = {};
        for (let t in r) {
            e[t] = {};
            for (let n in r[t]) {
                let i = r[t][n];
                i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? i.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),
                e[t][n] = null) : e[t][n] = i.clone() : Array.isArray(i) ? e[t][n] = i.slice() : e[t][n] = i
            }
        }
        return e
    }
    function ni(r) {
        let e = {};
        for (let t = 0; t < r.length; t++) {
            let n = Ha(r[t]);
            for (let i in n)
                e[i] = n[i]
        }
        return e
    }
    function j_(r) {
        let e = [];
        for (let t = 0; t < r.length; t++)
            e.push(r[t].clone());
        return e
    }
    function Tv(r) {
        return r.getRenderTarget() === null ? r.outputColorSpace : di
    }
    var q_ = {
        clone: Ha,
        merge: ni
    }
      , Y_ = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`
      , K_ = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`
      , ms = class extends ur {
        constructor(e) {
            super(),
            this.isShaderMaterial = !0,
            this.type = "ShaderMaterial",
            this.defines = {},
            this.uniforms = {},
            this.uniformsGroups = [],
            this.vertexShader = Y_,
            this.fragmentShader = K_,
            this.linewidth = 1,
            this.wireframe = !1,
            this.wireframeLinewidth = 1,
            this.fog = !1,
            this.lights = !1,
            this.clipping = !1,
            this.forceSinglePass = !0,
            this.extensions = {
                derivatives: !1,
                fragDepth: !1,
                drawBuffers: !1,
                shaderTextureLOD: !1
            },
            this.defaultAttributeValues = {
                color: [1, 1, 1],
                uv: [0, 0],
                uv1: [0, 0]
            },
            this.index0AttributeName = void 0,
            this.uniformsNeedUpdate = !1,
            this.glslVersion = null,
            e !== void 0 && this.setValues(e)
        }
        copy(e) {
            return super.copy(e),
            this.fragmentShader = e.fragmentShader,
            this.vertexShader = e.vertexShader,
            this.uniforms = Ha(e.uniforms),
            this.uniformsGroups = j_(e.uniformsGroups),
            this.defines = Object.assign({}, e.defines),
            this.wireframe = e.wireframe,
            this.wireframeLinewidth = e.wireframeLinewidth,
            this.fog = e.fog,
            this.lights = e.lights,
            this.clipping = e.clipping,
            this.extensions = Object.assign({}, e.extensions),
            this.glslVersion = e.glslVersion,
            this
        }
        toJSON(e) {
            let t = super.toJSON(e);
            t.glslVersion = this.glslVersion,
            t.uniforms = {};
            for (let i in this.uniforms) {
                let o = this.uniforms[i].value;
                o && o.isTexture ? t.uniforms[i] = {
                    type: "t",
                    value: o.toJSON(e).uuid
                } : o && o.isColor ? t.uniforms[i] = {
                    type: "c",
                    value: o.getHex()
                } : o && o.isVector2 ? t.uniforms[i] = {
                    type: "v2",
                    value: o.toArray()
                } : o && o.isVector3 ? t.uniforms[i] = {
                    type: "v3",
                    value: o.toArray()
                } : o && o.isVector4 ? t.uniforms[i] = {
                    type: "v4",
                    value: o.toArray()
                } : o && o.isMatrix3 ? t.uniforms[i] = {
                    type: "m3",
                    value: o.toArray()
                } : o && o.isMatrix4 ? t.uniforms[i] = {
                    type: "m4",
                    value: o.toArray()
                } : t.uniforms[i] = {
                    value: o
                }
            }
            Object.keys(this.defines).length > 0 && (t.defines = this.defines),
            t.vertexShader = this.vertexShader,
            t.fragmentShader = this.fragmentShader,
            t.lights = this.lights,
            t.clipping = this.clipping;
            let n = {};
            for (let i in this.extensions)
                this.extensions[i] === !0 && (n[i] = !0);
            return Object.keys(n).length > 0 && (t.extensions = n),
            t
        }
    }
      , Eh = class extends bt {
        constructor() {
            super(),
            this.isCamera = !0,
            this.type = "Camera",
            this.matrixWorldInverse = new je,
            this.projectionMatrix = new je,
            this.projectionMatrixInverse = new je
        }
        copy(e, t) {
            return super.copy(e, t),
            this.matrixWorldInverse.copy(e.matrixWorldInverse),
            this.projectionMatrix.copy(e.projectionMatrix),
            this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
            this
        }
        getWorldDirection(e) {
            this.updateWorldMatrix(!0, !1);
            let t = this.matrixWorld.elements;
            return e.set(-t[8], -t[9], -t[10]).normalize()
        }
        updateMatrixWorld(e) {
            super.updateMatrixWorld(e),
            this.matrixWorldInverse.copy(this.matrixWorld).invert()
        }
        updateWorldMatrix(e, t) {
            super.updateWorldMatrix(e, t),
            this.matrixWorldInverse.copy(this.matrixWorld).invert()
        }
        clone() {
            return new this.constructor().copy(this)
        }
    }
      , Qt = class extends Eh {
        constructor(e=50, t=1, n=.1, i=2e3) {
            super(),
            this.isPerspectiveCamera = !0,
            this.type = "PerspectiveCamera",
            this.fov = e,
            this.zoom = 1,
            this.near = n,
            this.far = i,
            this.focus = 10,
            this.aspect = t,
            this.view = null,
            this.filmGauge = 35,
            this.filmOffset = 0,
            this.updateProjectionMatrix()
        }
        copy(e, t) {
            return super.copy(e, t),
            this.fov = e.fov,
            this.zoom = e.zoom,
            this.near = e.near,
            this.far = e.far,
            this.focus = e.focus,
            this.aspect = e.aspect,
            this.view = e.view === null ? null : Object.assign({}, e.view),
            this.filmGauge = e.filmGauge,
            this.filmOffset = e.filmOffset,
            this
        }
        setFocalLength(e) {
            let t = .5 * this.getFilmHeight() / e;
            this.fov = Ga * 2 * Math.atan(t),
            this.updateProjectionMatrix()
        }
        getFocalLength() {
            let e = Math.tan(Na * .5 * this.fov);
            return .5 * this.getFilmHeight() / e
        }
        getEffectiveFOV() {
            return Ga * 2 * Math.atan(Math.tan(Na * .5 * this.fov) / this.zoom)
        }
        getFilmWidth() {
            return this.filmGauge * Math.min(this.aspect, 1)
        }
        getFilmHeight() {
            return this.filmGauge / Math.max(this.aspect, 1)
        }
        setViewOffset(e, t, n, i, s, o) {
            this.aspect = e / t,
            this.view === null && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }),
            this.view.enabled = !0,
            this.view.fullWidth = e,
            this.view.fullHeight = t,
            this.view.offsetX = n,
            this.view.offsetY = i,
            this.view.width = s,
            this.view.height = o,
            this.updateProjectionMatrix()
        }
        clearViewOffset() {
            this.view !== null && (this.view.enabled = !1),
            this.updateProjectionMatrix()
        }
        updateProjectionMatrix() {
            let e = this.near
              , t = e * Math.tan(Na * .5 * this.fov) / this.zoom
              , n = 2 * t
              , i = this.aspect * n
              , s = -.5 * i
              , o = this.view;
            if (this.view !== null && this.view.enabled) {
                let l = o.fullWidth
                  , c = o.fullHeight;
                s += o.offsetX * i / l,
                t -= o.offsetY * n / c,
                i *= o.width / l,
                n *= o.height / c
            }
            let a = this.filmOffset;
            a !== 0 && (s += e * a / this.getFilmWidth()),
            this.projectionMatrix.makePerspective(s, s + i, t, t - n, e, this.far),
            this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
        }
        toJSON(e) {
            let t = super.toJSON(e);
            return t.object.fov = this.fov,
            t.object.zoom = this.zoom,
            t.object.near = this.near,
            t.object.far = this.far,
            t.object.focus = this.focus,
            t.object.aspect = this.aspect,
            this.view !== null && (t.object.view = Object.assign({}, this.view)),
            t.object.filmGauge = this.filmGauge,
            t.object.filmOffset = this.filmOffset,
            t
        }
    }
      , Ea = -90
      , Sa = 1
      , tp = class extends bt {
        constructor(e, t, n) {
            super(),
            this.type = "CubeCamera",
            this.renderTarget = n;
            let i = new Qt(Ea,Sa,e,t);
            i.layers = this.layers,
            i.up.set(0, 1, 0),
            i.lookAt(1, 0, 0),
            this.add(i);
            let s = new Qt(Ea,Sa,e,t);
            s.layers = this.layers,
            s.up.set(0, 1, 0),
            s.lookAt(-1, 0, 0),
            this.add(s);
            let o = new Qt(Ea,Sa,e,t);
            o.layers = this.layers,
            o.up.set(0, 0, -1),
            o.lookAt(0, 1, 0),
            this.add(o);
            let a = new Qt(Ea,Sa,e,t);
            a.layers = this.layers,
            a.up.set(0, 0, 1),
            a.lookAt(0, -1, 0),
            this.add(a);
            let l = new Qt(Ea,Sa,e,t);
            l.layers = this.layers,
            l.up.set(0, 1, 0),
            l.lookAt(0, 0, 1),
            this.add(l);
            let c = new Qt(Ea,Sa,e,t);
            c.layers = this.layers,
            c.up.set(0, 1, 0),
            c.lookAt(0, 0, -1),
            this.add(c)
        }
        update(e, t) {
            this.parent === null && this.updateMatrixWorld();
            let n = this.renderTarget
              , [i,s,o,a,l,c] = this.children
              , u = e.getRenderTarget()
              , h = e.toneMapping
              , f = e.xr.enabled;
            e.toneMapping = fs,
            e.xr.enabled = !1;
            let m = n.texture.generateMipmaps;
            n.texture.generateMipmaps = !1,
            e.setRenderTarget(n, 0),
            e.render(t, i),
            e.setRenderTarget(n, 1),
            e.render(t, s),
            e.setRenderTarget(n, 2),
            e.render(t, o),
            e.setRenderTarget(n, 3),
            e.render(t, a),
            e.setRenderTarget(n, 4),
            e.render(t, l),
            n.texture.generateMipmaps = m,
            e.setRenderTarget(n, 5),
            e.render(t, c),
            e.setRenderTarget(u),
            e.toneMapping = h,
            e.xr.enabled = f,
            n.texture.needsPMREMUpdate = !0
        }
    }
      , Oc = class extends En {
        constructor(e, t, n, i, s, o, a, l, c, u) {
            e = e !== void 0 ? e : [],
            t = t !== void 0 ? t : Fa,
            super(e, t, n, i, s, o, a, l, c, u),
            this.isCubeTexture = !0,
            this.flipY = !1
        }
        get images() {
            return this.image
        }
        set images(e) {
            this.image = e
        }
    }
      , np = class extends ds {
        constructor(e=1, t={}) {
            super(e, e, t),
            this.isWebGLCubeRenderTarget = !0;
            let n = {
                width: e,
                height: e,
                depth: 1
            }
              , i = [n, n, n, n, n, n];
            t.encoding !== void 0 && (Ac("THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."),
            t.colorSpace = t.encoding === Ro ? ct : Po),
            this.texture = new Oc(i,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.colorSpace),
            this.texture.isRenderTargetTexture = !0,
            this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1,
            this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : bn
        }
        fromEquirectangularTexture(e, t) {
            this.texture.type = t.type,
            this.texture.colorSpace = t.colorSpace,
            this.texture.generateMipmaps = t.generateMipmaps,
            this.texture.minFilter = t.minFilter,
            this.texture.magFilter = t.magFilter;
            let n = {
                uniforms: {
                    tEquirect: {
                        value: null
                    }
                },
                vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
                fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
            }
              , i = new ps(5,5,5)
              , s = new ms({
                name: "CubemapFromEquirect",
                uniforms: Ha(n.uniforms),
                vertexShader: n.vertexShader,
                fragmentShader: n.fragmentShader,
                side: Mn,
                blending: zs
            });
            s.uniforms.tEquirect.value = t;
            let o = new Ht(i,s)
              , a = t.minFilter;
            return t.minFilter === lr && (t.minFilter = bn),
            new tp(1,10,this).update(e, o),
            t.minFilter = a,
            o.geometry.dispose(),
            o.material.dispose(),
            this
        }
        clear(e, t, n, i) {
            let s = e.getRenderTarget();
            for (let o = 0; o < 6; o++)
                e.setRenderTarget(this, o),
                e.clear(t, n, i);
            e.setRenderTarget(s)
        }
    }
      , Bd = new ue
      , Z_ = new ue
      , J_ = new vt
      , ar = class {
        constructor(e=new ue(1,0,0), t=0) {
            this.isPlane = !0,
            this.normal = e,
            this.constant = t
        }
        set(e, t) {
            return this.normal.copy(e),
            this.constant = t,
            this
        }
        setComponents(e, t, n, i) {
            return this.normal.set(e, t, n),
            this.constant = i,
            this
        }
        setFromNormalAndCoplanarPoint(e, t) {
            return this.normal.copy(e),
            this.constant = -t.dot(this.normal),
            this
        }
        setFromCoplanarPoints(e, t, n) {
            let i = Bd.subVectors(n, t).cross(Z_.subVectors(e, t)).normalize();
            return this.setFromNormalAndCoplanarPoint(i, e),
            this
        }
        copy(e) {
            return this.normal.copy(e.normal),
            this.constant = e.constant,
            this
        }
        normalize() {
            let e = 1 / this.normal.length();
            return this.normal.multiplyScalar(e),
            this.constant *= e,
            this
        }
        negate() {
            return this.constant *= -1,
            this.normal.negate(),
            this
        }
        distanceToPoint(e) {
            return this.normal.dot(e) + this.constant
        }
        distanceToSphere(e) {
            return this.distanceToPoint(e.center) - e.radius
        }
        projectPoint(e, t) {
            return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e))
        }
        intersectLine(e, t) {
            let n = e.delta(Bd)
              , i = this.normal.dot(n);
            if (i === 0)
                return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
            let s = -(e.start.dot(this.normal) + this.constant) / i;
            return s < 0 || s > 1 ? null : t.copy(e.start).addScaledVector(n, s)
        }
        intersectsLine(e) {
            let t = this.distanceToPoint(e.start)
              , n = this.distanceToPoint(e.end);
            return t < 0 && n > 0 || n < 0 && t > 0
        }
        intersectsBox(e) {
            return e.intersectsPlane(this)
        }
        intersectsSphere(e) {
            return e.intersectsPlane(this)
        }
        coplanarPoint(e) {
            return e.copy(this.normal).multiplyScalar(-this.constant)
        }
        applyMatrix4(e, t) {
            let n = t || J_.getNormalMatrix(e)
              , i = this.coplanarPoint(Bd).applyMatrix4(e)
              , s = this.normal.applyMatrix3(n).normalize();
            return this.constant = -i.dot(s),
            this
        }
        translate(e) {
            return this.constant -= e.dot(this.normal),
            this
        }
        equals(e) {
            return e.normal.equals(this.normal) && e.constant === this.constant
        }
        clone() {
            return new this.constructor().copy(this)
        }
    }
      , So = new Nr
      , oh = new ue
      , Fc = class {
        constructor(e=new ar, t=new ar, n=new ar, i=new ar, s=new ar, o=new ar) {
            this.planes = [e, t, n, i, s, o]
        }
        set(e, t, n, i, s, o) {
            let a = this.planes;
            return a[0].copy(e),
            a[1].copy(t),
            a[2].copy(n),
            a[3].copy(i),
            a[4].copy(s),
            a[5].copy(o),
            this
        }
        copy(e) {
            let t = this.planes;
            for (let n = 0; n < 6; n++)
                t[n].copy(e.planes[n]);
            return this
        }
        setFromProjectionMatrix(e) {
            let t = this.planes
              , n = e.elements
              , i = n[0]
              , s = n[1]
              , o = n[2]
              , a = n[3]
              , l = n[4]
              , c = n[5]
              , u = n[6]
              , h = n[7]
              , f = n[8]
              , m = n[9]
              , g = n[10]
              , v = n[11]
              , p = n[12]
              , d = n[13]
              , x = n[14]
              , y = n[15];
            return t[0].setComponents(a - i, h - l, v - f, y - p).normalize(),
            t[1].setComponents(a + i, h + l, v + f, y + p).normalize(),
            t[2].setComponents(a + s, h + c, v + m, y + d).normalize(),
            t[3].setComponents(a - s, h - c, v - m, y - d).normalize(),
            t[4].setComponents(a - o, h - u, v - g, y - x).normalize(),
            t[5].setComponents(a + o, h + u, v + g, y + x).normalize(),
            this
        }
        intersectsObject(e) {
            if (e.boundingSphere !== void 0)
                e.boundingSphere === null && e.computeBoundingSphere(),
                So.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
            else {
                let t = e.geometry;
                t.boundingSphere === null && t.computeBoundingSphere(),
                So.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)
            }
            return this.intersectsSphere(So)
        }
        intersectsSprite(e) {
            return So.center.set(0, 0, 0),
            So.radius = .7071067811865476,
            So.applyMatrix4(e.matrixWorld),
            this.intersectsSphere(So)
        }
        intersectsSphere(e) {
            let t = this.planes
              , n = e.center
              , i = -e.radius;
            for (let s = 0; s < 6; s++)
                if (t[s].distanceToPoint(n) < i)
                    return !1;
            return !0
        }
        intersectsBox(e) {
            let t = this.planes;
            for (let n = 0; n < 6; n++) {
                let i = t[n];
                if (oh.x = i.normal.x > 0 ? e.max.x : e.min.x,
                oh.y = i.normal.y > 0 ? e.max.y : e.min.y,
                oh.z = i.normal.z > 0 ? e.max.z : e.min.z,
                i.distanceToPoint(oh) < 0)
                    return !1
            }
            return !0
        }
        containsPoint(e) {
            let t = this.planes;
            for (let n = 0; n < 6; n++)
                if (t[n].distanceToPoint(e) < 0)
                    return !1;
            return !0
        }
        clone() {
            return new this.constructor().copy(this)
        }
    }
    ;
    function bv() {
        let r = null
          , e = !1
          , t = null
          , n = null;
        function i(s, o) {
            t(s, o),
            n = r.requestAnimationFrame(i)
        }
        return {
            start: function() {
                e !== !0 && t !== null && (n = r.requestAnimationFrame(i),
                e = !0)
            },
            stop: function() {
                r.cancelAnimationFrame(n),
                e = !1
            },
            setAnimationLoop: function(s) {
                t = s
            },
            setContext: function(s) {
                r = s
            }
        }
    }
    function $_(r, e) {
        let t = e.isWebGL2
          , n = new WeakMap;
        function i(c, u) {
            let h = c.array
              , f = c.usage
              , m = r.createBuffer();
            r.bindBuffer(u, m),
            r.bufferData(u, h, f),
            c.onUploadCallback();
            let g;
            if (h instanceof Float32Array)
                g = r.FLOAT;
            else if (h instanceof Uint16Array)
                if (c.isFloat16BufferAttribute)
                    if (t)
                        g = r.HALF_FLOAT;
                    else
                        throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
                else
                    g = r.UNSIGNED_SHORT;
            else if (h instanceof Int16Array)
                g = r.SHORT;
            else if (h instanceof Uint32Array)
                g = r.UNSIGNED_INT;
            else if (h instanceof Int32Array)
                g = r.INT;
            else if (h instanceof Int8Array)
                g = r.BYTE;
            else if (h instanceof Uint8Array)
                g = r.UNSIGNED_BYTE;
            else if (h instanceof Uint8ClampedArray)
                g = r.UNSIGNED_BYTE;
            else
                throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + h);
            return {
                buffer: m,
                type: g,
                bytesPerElement: h.BYTES_PER_ELEMENT,
                version: c.version
            }
        }
        function s(c, u, h) {
            let f = u.array
              , m = u.updateRange;
            r.bindBuffer(h, c),
            m.count === -1 ? r.bufferSubData(h, 0, f) : (t ? r.bufferSubData(h, m.offset * f.BYTES_PER_ELEMENT, f, m.offset, m.count) : r.bufferSubData(h, m.offset * f.BYTES_PER_ELEMENT, f.subarray(m.offset, m.offset + m.count)),
            m.count = -1),
            u.onUploadCallback()
        }
        function o(c) {
            return c.isInterleavedBufferAttribute && (c = c.data),
            n.get(c)
        }
        function a(c) {
            c.isInterleavedBufferAttribute && (c = c.data);
            let u = n.get(c);
            u && (r.deleteBuffer(u.buffer),
            n.delete(c))
        }
        function l(c, u) {
            if (c.isGLBufferAttribute) {
                let f = n.get(c);
                (!f || f.version < c.version) && n.set(c, {
                    buffer: c.buffer,
                    type: c.type,
                    bytesPerElement: c.elementSize,
                    version: c.version
                });
                return
            }
            c.isInterleavedBufferAttribute && (c = c.data);
            let h = n.get(c);
            h === void 0 ? n.set(c, i(c, u)) : h.version < c.version && (s(h.buffer, c, u),
            h.version = c.version)
        }
        return {
            get: o,
            remove: a,
            update: l
        }
    }
    var Do = class extends wt {
        constructor(e=1, t=1, n=1, i=1) {
            super(),
            this.type = "PlaneGeometry",
            this.parameters = {
                width: e,
                height: t,
                widthSegments: n,
                heightSegments: i
            };
            let s = e / 2
              , o = t / 2
              , a = Math.floor(n)
              , l = Math.floor(i)
              , c = a + 1
              , u = l + 1
              , h = e / a
              , f = t / l
              , m = []
              , g = []
              , v = []
              , p = [];
            for (let d = 0; d < u; d++) {
                let x = d * f - o;
                for (let y = 0; y < c; y++) {
                    let _ = y * h - s;
                    g.push(_, -x, 0),
                    v.push(0, 0, 1),
                    p.push(y / a),
                    p.push(1 - d / l)
                }
            }
            for (let d = 0; d < l; d++)
                for (let x = 0; x < a; x++) {
                    let y = x + c * d
                      , _ = x + c * (d + 1)
                      , S = x + 1 + c * (d + 1)
                      , N = x + 1 + c * d;
                    m.push(y, _, N),
                    m.push(_, S, N)
                }
            this.setIndex(m),
            this.setAttribute("position", new qe(g,3)),
            this.setAttribute("normal", new qe(v,3)),
            this.setAttribute("uv", new qe(p,2))
        }
        copy(e) {
            return super.copy(e),
            this.parameters = Object.assign({}, e.parameters),
            this
        }
        static fromJSON(e) {
            return new Do(e.width,e.height,e.widthSegments,e.heightSegments)
        }
    }
      , Q_ = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`
      , eT = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`
      , tT = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`
      , nT = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`
      , iT = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`
      , rT = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`
      , sT = "vec3 transformed = vec3( position );"
      , oT = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`
      , aT = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`
      , lT = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			 return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float R21 = R12;
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`
      , cT = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`
      , uT = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`
      , hT = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`
      , fT = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`
      , dT = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`
      , pT = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`
      , mT = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`
      , gT = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`
      , vT = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`
      , yT = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`
      , xT = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`
      , _T = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`
      , TT = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`
      , bT = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`
      , MT = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`
      , ET = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`
      , ST = "gl_FragColor = linearToOutputTexel( gl_FragColor );"
      , wT = `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`
      , AT = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`
      , CT = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`
      , IT = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`
      , RT = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`
      , PT = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`
      , LT = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`
      , NT = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`
      , DT = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`
      , OT = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`
      , FT = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`
      , kT = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`
      , UT = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`
      , BT = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`
      , GT = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`
      , VT = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`
      , zT = `#if defined( USE_ENVMAP )
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`
      , HT = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`
      , WT = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`
      , XT = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`
      , jT = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`
      , qT = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif`
      , YT = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`
      , KT = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometry.viewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`
      , ZT = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`
      , JT = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`
      , $T = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`
      , QT = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`
      , eb = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`
      , tb = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`
      , nb = `#ifdef USE_MAP
	diffuseColor *= texture2D( map, vMapUv );
#endif`
      , ib = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`
      , rb = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`
      , sb = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`
      , ob = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`
      , ab = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`
      , lb = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`
      , cb = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`
      , ub = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`
      , hb = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`
      , fb = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#ifdef USE_NORMALMAP_TANGENTSPACE
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal, vNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 geometryNormal = normal;`
      , db = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`
      , pb = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`
      , mb = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`
      , gb = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`
      , vb = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`
      , yb = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`
      , xb = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`
      , _b = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`
      , Tb = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`
      , bb = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`
      , Mb = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`
      , Eb = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`
      , Sb = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`
      , wb = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`
      , Ab = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`
      , Cb = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`
      , Ib = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`
      , Rb = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`
      , Pb = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`
      , Lb = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`
      , Nb = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`
      , Db = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`
      , Ob = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`
      , Fb = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`
      , kb = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`
      , Ub = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`
      , Bb = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`
      , Gb = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`
      , Vb = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`
      , zb = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );
#endif`
      , Hb = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`
      , Wb = `#ifdef USE_UV
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`
      , Xb = `#ifdef USE_UV
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`
      , jb = `#ifdef USE_UV
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`
      , qb = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`
      , Yb = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`
      , Kb = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`
      , Zb = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`
      , Jb = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`
      , $b = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`
      , Qb = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`
      , eM = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`
      , tM = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`
      , nM = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`
      , iM = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`
      , rM = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`
      , sM = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`
      , oM = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`
      , aM = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`
      , lM = `#include <common>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`
      , cM = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
      , uM = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
      , hM = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
      , fM = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`
      , dM = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
      , pM = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`
      , mM = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`
      , gM = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
      , vM = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
      , yM = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`
      , xM = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
      , _M = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
      , TM = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
      , bM = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`
      , MM = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`
      , EM = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
      , SM = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`
      , wM = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`
      , AM = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`
      , St = {
        alphamap_fragment: Q_,
        alphamap_pars_fragment: eT,
        alphatest_fragment: tT,
        alphatest_pars_fragment: nT,
        aomap_fragment: iT,
        aomap_pars_fragment: rT,
        begin_vertex: sT,
        beginnormal_vertex: oT,
        bsdfs: aT,
        iridescence_fragment: lT,
        bumpmap_pars_fragment: cT,
        clipping_planes_fragment: uT,
        clipping_planes_pars_fragment: hT,
        clipping_planes_pars_vertex: fT,
        clipping_planes_vertex: dT,
        color_fragment: pT,
        color_pars_fragment: mT,
        color_pars_vertex: gT,
        color_vertex: vT,
        common: yT,
        cube_uv_reflection_fragment: xT,
        defaultnormal_vertex: _T,
        displacementmap_pars_vertex: TT,
        displacementmap_vertex: bT,
        emissivemap_fragment: MT,
        emissivemap_pars_fragment: ET,
        encodings_fragment: ST,
        encodings_pars_fragment: wT,
        envmap_fragment: AT,
        envmap_common_pars_fragment: CT,
        envmap_pars_fragment: IT,
        envmap_pars_vertex: RT,
        envmap_physical_pars_fragment: zT,
        envmap_vertex: PT,
        fog_vertex: LT,
        fog_pars_vertex: NT,
        fog_fragment: DT,
        fog_pars_fragment: OT,
        gradientmap_pars_fragment: FT,
        lightmap_fragment: kT,
        lightmap_pars_fragment: UT,
        lights_lambert_fragment: BT,
        lights_lambert_pars_fragment: GT,
        lights_pars_begin: VT,
        lights_toon_fragment: HT,
        lights_toon_pars_fragment: WT,
        lights_phong_fragment: XT,
        lights_phong_pars_fragment: jT,
        lights_physical_fragment: qT,
        lights_physical_pars_fragment: YT,
        lights_fragment_begin: KT,
        lights_fragment_maps: ZT,
        lights_fragment_end: JT,
        logdepthbuf_fragment: $T,
        logdepthbuf_pars_fragment: QT,
        logdepthbuf_pars_vertex: eb,
        logdepthbuf_vertex: tb,
        map_fragment: nb,
        map_pars_fragment: ib,
        map_particle_fragment: rb,
        map_particle_pars_fragment: sb,
        metalnessmap_fragment: ob,
        metalnessmap_pars_fragment: ab,
        morphcolor_vertex: lb,
        morphnormal_vertex: cb,
        morphtarget_pars_vertex: ub,
        morphtarget_vertex: hb,
        normal_fragment_begin: fb,
        normal_fragment_maps: db,
        normal_pars_fragment: pb,
        normal_pars_vertex: mb,
        normal_vertex: gb,
        normalmap_pars_fragment: vb,
        clearcoat_normal_fragment_begin: yb,
        clearcoat_normal_fragment_maps: xb,
        clearcoat_pars_fragment: _b,
        iridescence_pars_fragment: Tb,
        output_fragment: bb,
        packing: Mb,
        premultiplied_alpha_fragment: Eb,
        project_vertex: Sb,
        dithering_fragment: wb,
        dithering_pars_fragment: Ab,
        roughnessmap_fragment: Cb,
        roughnessmap_pars_fragment: Ib,
        shadowmap_pars_fragment: Rb,
        shadowmap_pars_vertex: Pb,
        shadowmap_vertex: Lb,
        shadowmask_pars_fragment: Nb,
        skinbase_vertex: Db,
        skinning_pars_vertex: Ob,
        skinning_vertex: Fb,
        skinnormal_vertex: kb,
        specularmap_fragment: Ub,
        specularmap_pars_fragment: Bb,
        tonemapping_fragment: Gb,
        tonemapping_pars_fragment: Vb,
        transmission_fragment: zb,
        transmission_pars_fragment: Hb,
        uv_pars_fragment: Wb,
        uv_pars_vertex: Xb,
        uv_vertex: jb,
        worldpos_vertex: qb,
        background_vert: Yb,
        background_frag: Kb,
        backgroundCube_vert: Zb,
        backgroundCube_frag: Jb,
        cube_vert: $b,
        cube_frag: Qb,
        depth_vert: eM,
        depth_frag: tM,
        distanceRGBA_vert: nM,
        distanceRGBA_frag: iM,
        equirect_vert: rM,
        equirect_frag: sM,
        linedashed_vert: oM,
        linedashed_frag: aM,
        meshbasic_vert: lM,
        meshbasic_frag: cM,
        meshlambert_vert: uM,
        meshlambert_frag: hM,
        meshmatcap_vert: fM,
        meshmatcap_frag: dM,
        meshnormal_vert: pM,
        meshnormal_frag: mM,
        meshphong_vert: gM,
        meshphong_frag: vM,
        meshphysical_vert: yM,
        meshphysical_frag: xM,
        meshtoon_vert: _M,
        meshtoon_frag: TM,
        points_vert: bM,
        points_frag: MM,
        shadow_vert: EM,
        shadow_frag: SM,
        sprite_vert: wM,
        sprite_frag: AM
    }
      , He = {
        common: {
            diffuse: {
                value: new $e(16777215)
            },
            opacity: {
                value: 1
            },
            map: {
                value: null
            },
            mapTransform: {
                value: new vt
            },
            alphaMap: {
                value: null
            },
            alphaMapTransform: {
                value: new vt
            },
            alphaTest: {
                value: 0
            }
        },
        specularmap: {
            specularMap: {
                value: null
            },
            specularMapTransform: {
                value: new vt
            }
        },
        envmap: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            },
            reflectivity: {
                value: 1
            },
            ior: {
                value: 1.5
            },
            refractionRatio: {
                value: .98
            }
        },
        aomap: {
            aoMap: {
                value: null
            },
            aoMapIntensity: {
                value: 1
            },
            aoMapTransform: {
                value: new vt
            }
        },
        lightmap: {
            lightMap: {
                value: null
            },
            lightMapIntensity: {
                value: 1
            },
            lightMapTransform: {
                value: new vt
            }
        },
        bumpmap: {
            bumpMap: {
                value: null
            },
            bumpMapTransform: {
                value: new vt
            },
            bumpScale: {
                value: 1
            }
        },
        normalmap: {
            normalMap: {
                value: null
            },
            normalMapTransform: {
                value: new vt
            },
            normalScale: {
                value: new Ie(1,1)
            }
        },
        displacementmap: {
            displacementMap: {
                value: null
            },
            displacementMapTransform: {
                value: new vt
            },
            displacementScale: {
                value: 1
            },
            displacementBias: {
                value: 0
            }
        },
        emissivemap: {
            emissiveMap: {
                value: null
            },
            emissiveMapTransform: {
                value: new vt
            }
        },
        metalnessmap: {
            metalnessMap: {
                value: null
            },
            metalnessMapTransform: {
                value: new vt
            }
        },
        roughnessmap: {
            roughnessMap: {
                value: null
            },
            roughnessMapTransform: {
                value: new vt
            }
        },
        gradientmap: {
            gradientMap: {
                value: null
            }
        },
        fog: {
            fogDensity: {
                value: 25e-5
            },
            fogNear: {
                value: 1
            },
            fogFar: {
                value: 2e3
            },
            fogColor: {
                value: new $e(16777215)
            }
        },
        lights: {
            ambientLightColor: {
                value: []
            },
            lightProbe: {
                value: []
            },
            directionalLights: {
                value: [],
                properties: {
                    direction: {},
                    color: {}
                }
            },
            directionalLightShadows: {
                value: [],
                properties: {
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            directionalShadowMap: {
                value: []
            },
            directionalShadowMatrix: {
                value: []
            },
            spotLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    direction: {},
                    distance: {},
                    coneCos: {},
                    penumbraCos: {},
                    decay: {}
                }
            },
            spotLightShadows: {
                value: [],
                properties: {
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            spotLightMap: {
                value: []
            },
            spotShadowMap: {
                value: []
            },
            spotLightMatrix: {
                value: []
            },
            pointLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    decay: {},
                    distance: {}
                }
            },
            pointLightShadows: {
                value: [],
                properties: {
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {},
                    shadowCameraNear: {},
                    shadowCameraFar: {}
                }
            },
            pointShadowMap: {
                value: []
            },
            pointShadowMatrix: {
                value: []
            },
            hemisphereLights: {
                value: [],
                properties: {
                    direction: {},
                    skyColor: {},
                    groundColor: {}
                }
            },
            rectAreaLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    width: {},
                    height: {}
                }
            },
            ltc_1: {
                value: null
            },
            ltc_2: {
                value: null
            }
        },
        points: {
            diffuse: {
                value: new $e(16777215)
            },
            opacity: {
                value: 1
            },
            size: {
                value: 1
            },
            scale: {
                value: 1
            },
            map: {
                value: null
            },
            alphaMap: {
                value: null
            },
            alphaTest: {
                value: 0
            },
            uvTransform: {
                value: new vt
            }
        },
        sprite: {
            diffuse: {
                value: new $e(16777215)
            },
            opacity: {
                value: 1
            },
            center: {
                value: new Ie(.5,.5)
            },
            rotation: {
                value: 0
            },
            map: {
                value: null
            },
            mapTransform: {
                value: new vt
            },
            alphaMap: {
                value: null
            },
            alphaTest: {
                value: 0
            }
        }
    }
      , Lr = {
        basic: {
            uniforms: ni([He.common, He.specularmap, He.envmap, He.aomap, He.lightmap, He.fog]),
            vertexShader: St.meshbasic_vert,
            fragmentShader: St.meshbasic_frag
        },
        lambert: {
            uniforms: ni([He.common, He.specularmap, He.envmap, He.aomap, He.lightmap, He.emissivemap, He.bumpmap, He.normalmap, He.displacementmap, He.fog, He.lights, {
                emissive: {
                    value: new $e(0)
                }
            }]),
            vertexShader: St.meshlambert_vert,
            fragmentShader: St.meshlambert_frag
        },
        phong: {
            uniforms: ni([He.common, He.specularmap, He.envmap, He.aomap, He.lightmap, He.emissivemap, He.bumpmap, He.normalmap, He.displacementmap, He.fog, He.lights, {
                emissive: {
                    value: new $e(0)
                },
                specular: {
                    value: new $e(1118481)
                },
                shininess: {
                    value: 30
                }
            }]),
            vertexShader: St.meshphong_vert,
            fragmentShader: St.meshphong_frag
        },
        standard: {
            uniforms: ni([He.common, He.envmap, He.aomap, He.lightmap, He.emissivemap, He.bumpmap, He.normalmap, He.displacementmap, He.roughnessmap, He.metalnessmap, He.fog, He.lights, {
                emissive: {
                    value: new $e(0)
                },
                roughness: {
                    value: 1
                },
                metalness: {
                    value: 0
                },
                envMapIntensity: {
                    value: 1
                }
            }]),
            vertexShader: St.meshphysical_vert,
            fragmentShader: St.meshphysical_frag
        },
        toon: {
            uniforms: ni([He.common, He.aomap, He.lightmap, He.emissivemap, He.bumpmap, He.normalmap, He.displacementmap, He.gradientmap, He.fog, He.lights, {
                emissive: {
                    value: new $e(0)
                }
            }]),
            vertexShader: St.meshtoon_vert,
            fragmentShader: St.meshtoon_frag
        },
        matcap: {
            uniforms: ni([He.common, He.bumpmap, He.normalmap, He.displacementmap, He.fog, {
                matcap: {
                    value: null
                }
            }]),
            vertexShader: St.meshmatcap_vert,
            fragmentShader: St.meshmatcap_frag
        },
        points: {
            uniforms: ni([He.points, He.fog]),
            vertexShader: St.points_vert,
            fragmentShader: St.points_frag
        },
        dashed: {
            uniforms: ni([He.common, He.fog, {
                scale: {
                    value: 1
                },
                dashSize: {
                    value: 1
                },
                totalSize: {
                    value: 2
                }
            }]),
            vertexShader: St.linedashed_vert,
            fragmentShader: St.linedashed_frag
        },
        depth: {
            uniforms: ni([He.common, He.displacementmap]),
            vertexShader: St.depth_vert,
            fragmentShader: St.depth_frag
        },
        normal: {
            uniforms: ni([He.common, He.bumpmap, He.normalmap, He.displacementmap, {
                opacity: {
                    value: 1
                }
            }]),
            vertexShader: St.meshnormal_vert,
            fragmentShader: St.meshnormal_frag
        },
        sprite: {
            uniforms: ni([He.sprite, He.fog]),
            vertexShader: St.sprite_vert,
            fragmentShader: St.sprite_frag
        },
        background: {
            uniforms: {
                uvTransform: {
                    value: new vt
                },
                t2D: {
                    value: null
                },
                backgroundIntensity: {
                    value: 1
                }
            },
            vertexShader: St.background_vert,
            fragmentShader: St.background_frag
        },
        backgroundCube: {
            uniforms: {
                envMap: {
                    value: null
                },
                flipEnvMap: {
                    value: -1
                },
                backgroundBlurriness: {
                    value: 0
                },
                backgroundIntensity: {
                    value: 1
                }
            },
            vertexShader: St.backgroundCube_vert,
            fragmentShader: St.backgroundCube_frag
        },
        cube: {
            uniforms: {
                tCube: {
                    value: null
                },
                tFlip: {
                    value: -1
                },
                opacity: {
                    value: 1
                }
            },
            vertexShader: St.cube_vert,
            fragmentShader: St.cube_frag
        },
        equirect: {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: St.equirect_vert,
            fragmentShader: St.equirect_frag
        },
        distanceRGBA: {
            uniforms: ni([He.common, He.displacementmap, {
                referencePosition: {
                    value: new ue
                },
                nearDistance: {
                    value: 1
                },
                farDistance: {
                    value: 1e3
                }
            }]),
            vertexShader: St.distanceRGBA_vert,
            fragmentShader: St.distanceRGBA_frag
        },
        shadow: {
            uniforms: ni([He.lights, He.fog, {
                color: {
                    value: new $e(0)
                },
                opacity: {
                    value: 1
                }
            }]),
            vertexShader: St.shadow_vert,
            fragmentShader: St.shadow_frag
        }
    };
    Lr.physical = {
        uniforms: ni([Lr.standard.uniforms, {
            clearcoat: {
                value: 0
            },
            clearcoatMap: {
                value: null
            },
            clearcoatMapTransform: {
                value: new vt
            },
            clearcoatNormalMap: {
                value: null
            },
            clearcoatNormalMapTransform: {
                value: new vt
            },
            clearcoatNormalScale: {
                value: new Ie(1,1)
            },
            clearcoatRoughness: {
                value: 0
            },
            clearcoatRoughnessMap: {
                value: null
            },
            clearcoatRoughnessMapTransform: {
                value: new vt
            },
            iridescence: {
                value: 0
            },
            iridescenceMap: {
                value: null
            },
            iridescenceMapTransform: {
                value: new vt
            },
            iridescenceIOR: {
                value: 1.3
            },
            iridescenceThicknessMinimum: {
                value: 100
            },
            iridescenceThicknessMaximum: {
                value: 400
            },
            iridescenceThicknessMap: {
                value: null
            },
            iridescenceThicknessMapTransform: {
                value: new vt
            },
            sheen: {
                value: 0
            },
            sheenColor: {
                value: new $e(0)
            },
            sheenColorMap: {
                value: null
            },
            sheenColorMapTransform: {
                value: new vt
            },
            sheenRoughness: {
                value: 1
            },
            sheenRoughnessMap: {
                value: null
            },
            sheenRoughnessMapTransform: {
                value: new vt
            },
            transmission: {
                value: 0
            },
            transmissionMap: {
                value: null
            },
            transmissionMapTransform: {
                value: new vt
            },
            transmissionSamplerSize: {
                value: new Ie
            },
            transmissionSamplerMap: {
                value: null
            },
            thickness: {
                value: 0
            },
            thicknessMap: {
                value: null
            },
            thicknessMapTransform: {
                value: new vt
            },
            attenuationDistance: {
                value: 0
            },
            attenuationColor: {
                value: new $e(0)
            },
            specularColor: {
                value: new $e(1,1,1)
            },
            specularColorMap: {
                value: null
            },
            specularColorMapTransform: {
                value: new vt
            },
            specularIntensity: {
                value: 1
            },
            specularIntensityMap: {
                value: null
            },
            specularIntensityMapTransform: {
                value: new vt
            }
        }]),
        vertexShader: St.meshphysical_vert,
        fragmentShader: St.meshphysical_frag
    };
    var ah = {
        r: 0,
        b: 0,
        g: 0
    };
    function CM(r, e, t, n, i, s, o) {
        let a = new $e(0), l = s === !0 ? 0 : 1, c, u, h = null, f = 0, m = null;
        function g(p, d) {
            let x = !1
              , y = d.isScene === !0 ? d.background : null;
            switch (y && y.isTexture && (y = (d.backgroundBlurriness > 0 ? t : e).get(y)),
            y === null ? v(a, l) : y && y.isColor && (v(y, 1),
            x = !0),
            r.xr.getEnvironmentBlendMode()) {
            case "opaque":
                x = !0;
                break;
            case "additive":
                n.buffers.color.setClear(0, 0, 0, 1, o),
                x = !0;
                break;
            case "alpha-blend":
                n.buffers.color.setClear(0, 0, 0, 0, o),
                x = !0;
                break
            }
            (r.autoClear || x) && r.clear(r.autoClearColor, r.autoClearDepth, r.autoClearStencil),
            y && (y.isCubeTexture || y.mapping === Bh) ? (u === void 0 && (u = new Ht(new ps(1,1,1),new ms({
                name: "BackgroundCubeMaterial",
                uniforms: Ha(Lr.backgroundCube.uniforms),
                vertexShader: Lr.backgroundCube.vertexShader,
                fragmentShader: Lr.backgroundCube.fragmentShader,
                side: Mn,
                depthTest: !1,
                depthWrite: !1,
                fog: !1
            })),
            u.geometry.deleteAttribute("normal"),
            u.geometry.deleteAttribute("uv"),
            u.onBeforeRender = function(N, I, O) {
                this.matrixWorld.copyPosition(O.matrixWorld)
            }
            ,
            Object.defineProperty(u.material, "envMap", {
                get: function() {
                    return this.uniforms.envMap.value
                }
            }),
            i.update(u)),
            u.material.uniforms.envMap.value = y,
            u.material.uniforms.flipEnvMap.value = y.isCubeTexture && y.isRenderTargetTexture === !1 ? -1 : 1,
            u.material.uniforms.backgroundBlurriness.value = d.backgroundBlurriness,
            u.material.uniforms.backgroundIntensity.value = d.backgroundIntensity,
            u.material.toneMapped = y.colorSpace !== ct,
            (h !== y || f !== y.version || m !== r.toneMapping) && (u.material.needsUpdate = !0,
            h = y,
            f = y.version,
            m = r.toneMapping),
            u.layers.enableAll(),
            p.unshift(u, u.geometry, u.material, 0, 0, null)) : y && y.isTexture && (c === void 0 && (c = new Ht(new Do(2,2),new ms({
                name: "BackgroundMaterial",
                uniforms: Ha(Lr.background.uniforms),
                vertexShader: Lr.background.vertexShader,
                fragmentShader: Lr.background.fragmentShader,
                side: qi,
                depthTest: !1,
                depthWrite: !1,
                fog: !1
            })),
            c.geometry.deleteAttribute("normal"),
            Object.defineProperty(c.material, "map", {
                get: function() {
                    return this.uniforms.t2D.value
                }
            }),
            i.update(c)),
            c.material.uniforms.t2D.value = y,
            c.material.uniforms.backgroundIntensity.value = d.backgroundIntensity,
            c.material.toneMapped = y.colorSpace !== ct,
            y.matrixAutoUpdate === !0 && y.updateMatrix(),
            c.material.uniforms.uvTransform.value.copy(y.matrix),
            (h !== y || f !== y.version || m !== r.toneMapping) && (c.material.needsUpdate = !0,
            h = y,
            f = y.version,
            m = r.toneMapping),
            c.layers.enableAll(),
            p.unshift(c, c.geometry, c.material, 0, 0, null))
        }
        function v(p, d) {
            p.getRGB(ah, Tv(r)),
            n.buffers.color.setClear(ah.r, ah.g, ah.b, d, o)
        }
        return {
            getClearColor: function() {
                return a
            },
            setClearColor: function(p, d=1) {
                a.set(p),
                l = d,
                v(a, l)
            },
            getClearAlpha: function() {
                return l
            },
            setClearAlpha: function(p) {
                l = p,
                v(a, l)
            },
            render: g
        }
    }
    function IM(r, e, t, n) {
        let i = r.getParameter(r.MAX_VERTEX_ATTRIBS)
          , s = n.isWebGL2 ? null : e.get("OES_vertex_array_object")
          , o = n.isWebGL2 || s !== null
          , a = {}
          , l = p(null)
          , c = l
          , u = !1;
        function h(P, C, L, F, U) {
            let W = !1;
            if (o) {
                let K = v(F, L, C);
                c !== K && (c = K,
                m(c.object)),
                W = d(P, F, L, U),
                W && x(P, F, L, U)
            } else {
                let K = C.wireframe === !0;
                (c.geometry !== F.id || c.program !== L.id || c.wireframe !== K) && (c.geometry = F.id,
                c.program = L.id,
                c.wireframe = K,
                W = !0)
            }
            U !== null && t.update(U, r.ELEMENT_ARRAY_BUFFER),
            (W || u) && (u = !1,
            O(P, C, L, F),
            U !== null && r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, t.get(U).buffer))
        }
        function f() {
            return n.isWebGL2 ? r.createVertexArray() : s.createVertexArrayOES()
        }
        function m(P) {
            return n.isWebGL2 ? r.bindVertexArray(P) : s.bindVertexArrayOES(P)
        }
        function g(P) {
            return n.isWebGL2 ? r.deleteVertexArray(P) : s.deleteVertexArrayOES(P)
        }
        function v(P, C, L) {
            let F = L.wireframe === !0
              , U = a[P.id];
            U === void 0 && (U = {},
            a[P.id] = U);
            let W = U[C.id];
            W === void 0 && (W = {},
            U[C.id] = W);
            let K = W[F];
            return K === void 0 && (K = p(f()),
            W[F] = K),
            K
        }
        function p(P) {
            let C = []
              , L = []
              , F = [];
            for (let U = 0; U < i; U++)
                C[U] = 0,
                L[U] = 0,
                F[U] = 0;
            return {
                geometry: null,
                program: null,
                wireframe: !1,
                newAttributes: C,
                enabledAttributes: L,
                attributeDivisors: F,
                object: P,
                attributes: {},
                index: null
            }
        }
        function d(P, C, L, F) {
            let U = c.attributes
              , W = C.attributes
              , K = 0
              , re = L.getAttributes();
            for (let oe in re)
                if (re[oe].location >= 0) {
                    let w = U[oe]
                      , b = W[oe];
                    if (b === void 0 && (oe === "instanceMatrix" && P.instanceMatrix && (b = P.instanceMatrix),
                    oe === "instanceColor" && P.instanceColor && (b = P.instanceColor)),
                    w === void 0 || w.attribute !== b || b && w.data !== b.data)
                        return !0;
                    K++
                }
            return c.attributesNum !== K || c.index !== F
        }
        function x(P, C, L, F) {
            let U = {}
              , W = C.attributes
              , K = 0
              , re = L.getAttributes();
            for (let oe in re)
                if (re[oe].location >= 0) {
                    let w = W[oe];
                    w === void 0 && (oe === "instanceMatrix" && P.instanceMatrix && (w = P.instanceMatrix),
                    oe === "instanceColor" && P.instanceColor && (w = P.instanceColor));
                    let b = {};
                    b.attribute = w,
                    w && w.data && (b.data = w.data),
                    U[oe] = b,
                    K++
                }
            c.attributes = U,
            c.attributesNum = K,
            c.index = F
        }
        function y() {
            let P = c.newAttributes;
            for (let C = 0, L = P.length; C < L; C++)
                P[C] = 0
        }
        function _(P) {
            S(P, 0)
        }
        function S(P, C) {
            let L = c.newAttributes
              , F = c.enabledAttributes
              , U = c.attributeDivisors;
            L[P] = 1,
            F[P] === 0 && (r.enableVertexAttribArray(P),
            F[P] = 1),
            U[P] !== C && ((n.isWebGL2 ? r : e.get("ANGLE_instanced_arrays"))[n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](P, C),
            U[P] = C)
        }
        function N() {
            let P = c.newAttributes
              , C = c.enabledAttributes;
            for (let L = 0, F = C.length; L < F; L++)
                C[L] !== P[L] && (r.disableVertexAttribArray(L),
                C[L] = 0)
        }
        function I(P, C, L, F, U, W) {
            n.isWebGL2 === !0 && (L === r.INT || L === r.UNSIGNED_INT) ? r.vertexAttribIPointer(P, C, L, U, W) : r.vertexAttribPointer(P, C, L, F, U, W)
        }
        function O(P, C, L, F) {
            if (n.isWebGL2 === !1 && (P.isInstancedMesh || F.isInstancedBufferGeometry) && e.get("ANGLE_instanced_arrays") === null)
                return;
            y();
            let U = F.attributes
              , W = L.getAttributes()
              , K = C.defaultAttributeValues;
            for (let re in W) {
                let oe = W[re];
                if (oe.location >= 0) {
                    let j = U[re];
                    if (j === void 0 && (re === "instanceMatrix" && P.instanceMatrix && (j = P.instanceMatrix),
                    re === "instanceColor" && P.instanceColor && (j = P.instanceColor)),
                    j !== void 0) {
                        let w = j.normalized
                          , b = j.itemSize
                          , E = t.get(j);
                        if (E === void 0)
                            continue;
                        let T = E.buffer
                          , H = E.type
                          , Y = E.bytesPerElement;
                        if (j.isInterleavedBufferAttribute) {
                            let X = j.data
                              , ce = X.stride
                              , J = j.offset;
                            if (X.isInstancedInterleavedBuffer) {
                                for (let ae = 0; ae < oe.locationSize; ae++)
                                    S(oe.location + ae, X.meshPerAttribute);
                                P.isInstancedMesh !== !0 && F._maxInstanceCount === void 0 && (F._maxInstanceCount = X.meshPerAttribute * X.count)
                            } else
                                for (let ae = 0; ae < oe.locationSize; ae++)
                                    _(oe.location + ae);
                            r.bindBuffer(r.ARRAY_BUFFER, T);
                            for (let ae = 0; ae < oe.locationSize; ae++)
                                I(oe.location + ae, b / oe.locationSize, H, w, ce * Y, (J + b / oe.locationSize * ae) * Y)
                        } else {
                            if (j.isInstancedBufferAttribute) {
                                for (let X = 0; X < oe.locationSize; X++)
                                    S(oe.location + X, j.meshPerAttribute);
                                P.isInstancedMesh !== !0 && F._maxInstanceCount === void 0 && (F._maxInstanceCount = j.meshPerAttribute * j.count)
                            } else
                                for (let X = 0; X < oe.locationSize; X++)
                                    _(oe.location + X);
                            r.bindBuffer(r.ARRAY_BUFFER, T);
                            for (let X = 0; X < oe.locationSize; X++)
                                I(oe.location + X, b / oe.locationSize, H, w, b * Y, b / oe.locationSize * X * Y)
                        }
                    } else if (K !== void 0) {
                        let w = K[re];
                        if (w !== void 0)
                            switch (w.length) {
                            case 2:
                                r.vertexAttrib2fv(oe.location, w);
                                break;
                            case 3:
                                r.vertexAttrib3fv(oe.location, w);
                                break;
                            case 4:
                                r.vertexAttrib4fv(oe.location, w);
                                break;
                            default:
                                r.vertexAttrib1fv(oe.location, w)
                            }
                    }
                }
            }
            N()
        }
        function M() {
            k();
            for (let P in a) {
                let C = a[P];
                for (let L in C) {
                    let F = C[L];
                    for (let U in F)
                        g(F[U].object),
                        delete F[U];
                    delete C[L]
                }
                delete a[P]
            }
        }
        function R(P) {
            if (a[P.id] === void 0)
                return;
            let C = a[P.id];
            for (let L in C) {
                let F = C[L];
                for (let U in F)
                    g(F[U].object),
                    delete F[U];
                delete C[L]
            }
            delete a[P.id]
        }
        function q(P) {
            for (let C in a) {
                let L = a[C];
                if (L[P.id] === void 0)
                    continue;
                let F = L[P.id];
                for (let U in F)
                    g(F[U].object),
                    delete F[U];
                delete L[P.id]
            }
        }
        function k() {
            B(),
            u = !0,
            c !== l && (c = l,
            m(c.object))
        }
        function B() {
            l.geometry = null,
            l.program = null,
            l.wireframe = !1
        }
        return {
            setup: h,
            reset: k,
            resetDefaultState: B,
            dispose: M,
            releaseStatesOfGeometry: R,
            releaseStatesOfProgram: q,
            initAttributes: y,
            enableAttribute: _,
            disableUnusedAttributes: N
        }
    }
    function RM(r, e, t, n) {
        let i = n.isWebGL2, s;
        function o(c) {
            s = c
        }
        function a(c, u) {
            r.drawArrays(s, c, u),
            t.update(u, s, 1)
        }
        function l(c, u, h) {
            if (h === 0)
                return;
            let f, m;
            if (i)
                f = r,
                m = "drawArraysInstanced";
            else if (f = e.get("ANGLE_instanced_arrays"),
            m = "drawArraysInstancedANGLE",
            f === null) {
                console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                return
            }
            f[m](s, c, u, h),
            t.update(u, s, h)
        }
        this.setMode = o,
        this.render = a,
        this.renderInstances = l
    }
    function PM(r, e, t) {
        let n;
        function i() {
            if (n !== void 0)
                return n;
            if (e.has("EXT_texture_filter_anisotropic") === !0) {
                let I = e.get("EXT_texture_filter_anisotropic");
                n = r.getParameter(I.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
            } else
                n = 0;
            return n
        }
        function s(I) {
            if (I === "highp") {
                if (r.getShaderPrecisionFormat(r.VERTEX_SHADER, r.HIGH_FLOAT).precision > 0 && r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.HIGH_FLOAT).precision > 0)
                    return "highp";
                I = "mediump"
            }
            return I === "mediump" && r.getShaderPrecisionFormat(r.VERTEX_SHADER, r.MEDIUM_FLOAT).precision > 0 && r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
        }
        let o = typeof WebGL2RenderingContext < "u" && r.constructor.name === "WebGL2RenderingContext"
          , a = t.precision !== void 0 ? t.precision : "highp"
          , l = s(a);
        l !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", l, "instead."),
        a = l);
        let c = o || e.has("WEBGL_draw_buffers")
          , u = t.logarithmicDepthBuffer === !0
          , h = r.getParameter(r.MAX_TEXTURE_IMAGE_UNITS)
          , f = r.getParameter(r.MAX_VERTEX_TEXTURE_IMAGE_UNITS)
          , m = r.getParameter(r.MAX_TEXTURE_SIZE)
          , g = r.getParameter(r.MAX_CUBE_MAP_TEXTURE_SIZE)
          , v = r.getParameter(r.MAX_VERTEX_ATTRIBS)
          , p = r.getParameter(r.MAX_VERTEX_UNIFORM_VECTORS)
          , d = r.getParameter(r.MAX_VARYING_VECTORS)
          , x = r.getParameter(r.MAX_FRAGMENT_UNIFORM_VECTORS)
          , y = f > 0
          , _ = o || e.has("OES_texture_float")
          , S = y && _
          , N = o ? r.getParameter(r.MAX_SAMPLES) : 0;
        return {
            isWebGL2: o,
            drawBuffers: c,
            getMaxAnisotropy: i,
            getMaxPrecision: s,
            precision: a,
            logarithmicDepthBuffer: u,
            maxTextures: h,
            maxVertexTextures: f,
            maxTextureSize: m,
            maxCubemapSize: g,
            maxAttributes: v,
            maxVertexUniforms: p,
            maxVaryings: d,
            maxFragmentUniforms: x,
            vertexTextures: y,
            floatFragmentTextures: _,
            floatVertexTextures: S,
            maxSamples: N
        }
    }
    function LM(r) {
        let e = this
          , t = null
          , n = 0
          , i = !1
          , s = !1
          , o = new ar
          , a = new vt
          , l = {
            value: null,
            needsUpdate: !1
        };
        this.uniform = l,
        this.numPlanes = 0,
        this.numIntersection = 0,
        this.init = function(h, f) {
            let m = h.length !== 0 || f || n !== 0 || i;
            return i = f,
            n = h.length,
            m
        }
        ,
        this.beginShadows = function() {
            s = !0,
            u(null)
        }
        ,
        this.endShadows = function() {
            s = !1
        }
        ,
        this.setGlobalState = function(h, f) {
            t = u(h, f, 0)
        }
        ,
        this.setState = function(h, f, m) {
            let g = h.clippingPlanes
              , v = h.clipIntersection
              , p = h.clipShadows
              , d = r.get(h);
            if (!i || g === null || g.length === 0 || s && !p)
                s ? u(null) : c();
            else {
                let x = s ? 0 : n
                  , y = x * 4
                  , _ = d.clippingState || null;
                l.value = _,
                _ = u(g, f, y, m);
                for (let S = 0; S !== y; ++S)
                    _[S] = t[S];
                d.clippingState = _,
                this.numIntersection = v ? this.numPlanes : 0,
                this.numPlanes += x
            }
        }
        ;
        function c() {
            l.value !== t && (l.value = t,
            l.needsUpdate = n > 0),
            e.numPlanes = n,
            e.numIntersection = 0
        }
        function u(h, f, m, g) {
            let v = h !== null ? h.length : 0
              , p = null;
            if (v !== 0) {
                if (p = l.value,
                g !== !0 || p === null) {
                    let d = m + v * 4
                      , x = f.matrixWorldInverse;
                    a.getNormalMatrix(x),
                    (p === null || p.length < d) && (p = new Float32Array(d));
                    for (let y = 0, _ = m; y !== v; ++y,
                    _ += 4)
                        o.copy(h[y]).applyMatrix4(x, a),
                        o.normal.toArray(p, _),
                        p[_ + 3] = o.constant
                }
                l.value = p,
                l.needsUpdate = !0
            }
            return e.numPlanes = v,
            e.numIntersection = 0,
            p
        }
    }
    function NM(r) {
        let e = new WeakMap;
        function t(o, a) {
            return a === Pc ? o.mapping = Fa : a === Jd && (o.mapping = ka),
            o
        }
        function n(o) {
            if (o && o.isTexture && o.isRenderTargetTexture === !1) {
                let a = o.mapping;
                if (a === Pc || a === Jd)
                    if (e.has(o)) {
                        let l = e.get(o).texture;
                        return t(l, o.mapping)
                    } else {
                        let l = o.image;
                        if (l && l.height > 0) {
                            let c = new np(l.height / 2);
                            return c.fromEquirectangularTexture(r, o),
                            e.set(o, c),
                            o.addEventListener("dispose", i),
                            t(c.texture, o.mapping)
                        } else
                            return null
                    }
            }
            return o
        }
        function i(o) {
            let a = o.target;
            a.removeEventListener("dispose", i);
            let l = e.get(a);
            l !== void 0 && (e.delete(a),
            l.dispose())
        }
        function s() {
            e = new WeakMap
        }
        return {
            get: n,
            dispose: s
        }
    }
    var Dr = class extends Eh {
        constructor(e=-1, t=1, n=1, i=-1, s=.1, o=2e3) {
            super(),
            this.isOrthographicCamera = !0,
            this.type = "OrthographicCamera",
            this.zoom = 1,
            this.view = null,
            this.left = e,
            this.right = t,
            this.top = n,
            this.bottom = i,
            this.near = s,
            this.far = o,
            this.updateProjectionMatrix()
        }
        copy(e, t) {
            return super.copy(e, t),
            this.left = e.left,
            this.right = e.right,
            this.top = e.top,
            this.bottom = e.bottom,
            this.near = e.near,
            this.far = e.far,
            this.zoom = e.zoom,
            this.view = e.view === null ? null : Object.assign({}, e.view),
            this
        }
        setViewOffset(e, t, n, i, s, o) {
            this.view === null && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }),
            this.view.enabled = !0,
            this.view.fullWidth = e,
            this.view.fullHeight = t,
            this.view.offsetX = n,
            this.view.offsetY = i,
            this.view.width = s,
            this.view.height = o,
            this.updateProjectionMatrix()
        }
        clearViewOffset() {
            this.view !== null && (this.view.enabled = !1),
            this.updateProjectionMatrix()
        }
        updateProjectionMatrix() {
            let e = (this.right - this.left) / (2 * this.zoom)
              , t = (this.top - this.bottom) / (2 * this.zoom)
              , n = (this.right + this.left) / 2
              , i = (this.top + this.bottom) / 2
              , s = n - e
              , o = n + e
              , a = i + t
              , l = i - t;
            if (this.view !== null && this.view.enabled) {
                let c = (this.right - this.left) / this.view.fullWidth / this.zoom
                  , u = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                s += c * this.view.offsetX,
                o = s + c * this.view.width,
                a -= u * this.view.offsetY,
                l = a - u * this.view.height
            }
            this.projectionMatrix.makeOrthographic(s, o, a, l, this.near, this.far),
            this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
        }
        toJSON(e) {
            let t = super.toJSON(e);
            return t.object.zoom = this.zoom,
            t.object.left = this.left,
            t.object.right = this.right,
            t.object.top = this.top,
            t.object.bottom = this.bottom,
            t.object.near = this.near,
            t.object.far = this.far,
            this.view !== null && (t.object.view = Object.assign({}, this.view)),
            t
        }
    }
      , Ia = 4
      , T0 = [.125, .215, .35, .446, .526, .582]
      , Ao = 20
      , Gd = new Dr
      , b0 = new $e
      , Vd = null
      , wo = (1 + Math.sqrt(5)) / 2
      , wa = 1 / wo
      , M0 = [new ue(1,1,1), new ue(-1,1,1), new ue(1,1,-1), new ue(-1,1,-1), new ue(0,wo,wa), new ue(0,wo,-wa), new ue(wa,0,wo), new ue(-wa,0,wo), new ue(wo,wa,0), new ue(-wo,wa,0)]
      , Sh = class {
        constructor(e) {
            this._renderer = e,
            this._pingPongRenderTarget = null,
            this._lodMax = 0,
            this._cubeSize = 0,
            this._lodPlanes = [],
            this._sizeLods = [],
            this._sigmas = [],
            this._blurMaterial = null,
            this._cubemapMaterial = null,
            this._equirectMaterial = null,
            this._compileMaterial(this._blurMaterial)
        }
        fromScene(e, t=0, n=.1, i=100) {
            Vd = this._renderer.getRenderTarget(),
            this._setSize(256);
            let s = this._allocateTargets();
            return s.depthBuffer = !0,
            this._sceneToCubeUV(e, n, i, s),
            t > 0 && this._blur(s, 0, 0, t),
            this._applyPMREM(s),
            this._cleanup(s),
            s
        }
        fromEquirectangular(e, t=null) {
            return this._fromTexture(e, t)
        }
        fromCubemap(e, t=null) {
            return this._fromTexture(e, t)
        }
        compileCubemapShader() {
            this._cubemapMaterial === null && (this._cubemapMaterial = w0(),
            this._compileMaterial(this._cubemapMaterial))
        }
        compileEquirectangularShader() {
            this._equirectMaterial === null && (this._equirectMaterial = S0(),
            this._compileMaterial(this._equirectMaterial))
        }
        dispose() {
            this._dispose(),
            this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
            this._equirectMaterial !== null && this._equirectMaterial.dispose()
        }
        _setSize(e) {
            this._lodMax = Math.floor(Math.log2(e)),
            this._cubeSize = Math.pow(2, this._lodMax)
        }
        _dispose() {
            this._blurMaterial !== null && this._blurMaterial.dispose(),
            this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
            for (let e = 0; e < this._lodPlanes.length; e++)
                this._lodPlanes[e].dispose()
        }
        _cleanup(e) {
            this._renderer.setRenderTarget(Vd),
            e.scissorTest = !1,
            lh(e, 0, 0, e.width, e.height)
        }
        _fromTexture(e, t) {
            e.mapping === Fa || e.mapping === ka ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4),
            Vd = this._renderer.getRenderTarget();
            let n = t || this._allocateTargets();
            return this._textureToCubeUV(e, n),
            this._applyPMREM(n),
            this._cleanup(n),
            n
        }
        _allocateTargets() {
            let e = 3 * Math.max(this._cubeSize, 112)
              , t = 4 * this._cubeSize
              , n = {
                magFilter: bn,
                minFilter: bn,
                generateMipmaps: !1,
                type: Lc,
                format: Xi,
                colorSpace: di,
                depthBuffer: !1
            }
              , i = E0(e, t, n);
            if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
                this._pingPongRenderTarget !== null && this._dispose(),
                this._pingPongRenderTarget = E0(e, t, n);
                let {_lodMax: s} = this;
                ({sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas} = DM(s)),
                this._blurMaterial = OM(s, e, t)
            }
            return i
        }
        _compileMaterial(e) {
            let t = new Ht(this._lodPlanes[0],e);
            this._renderer.compile(t, Gd)
        }
        _sceneToCubeUV(e, t, n, i) {
            let a = new Qt(90,1,t,n)
              , l = [1, -1, 1, 1, 1, 1]
              , c = [1, 1, 1, -1, -1, -1]
              , u = this._renderer
              , h = u.autoClear
              , f = u.toneMapping;
            u.getClearColor(b0),
            u.toneMapping = fs,
            u.autoClear = !1;
            let m = new Yi({
                name: "PMREM.Background",
                side: Mn,
                depthWrite: !1,
                depthTest: !1
            })
              , g = new Ht(new ps,m)
              , v = !1
              , p = e.background;
            p ? p.isColor && (m.color.copy(p),
            e.background = null,
            v = !0) : (m.color.copy(b0),
            v = !0);
            for (let d = 0; d < 6; d++) {
                let x = d % 3;
                x === 0 ? (a.up.set(0, l[d], 0),
                a.lookAt(c[d], 0, 0)) : x === 1 ? (a.up.set(0, 0, l[d]),
                a.lookAt(0, c[d], 0)) : (a.up.set(0, l[d], 0),
                a.lookAt(0, 0, c[d]));
                let y = this._cubeSize;
                lh(i, x * y, d > 2 ? y : 0, y, y),
                u.setRenderTarget(i),
                v && u.render(g, a),
                u.render(e, a)
            }
            g.geometry.dispose(),
            g.material.dispose(),
            u.toneMapping = f,
            u.autoClear = h,
            e.background = p
        }
        _textureToCubeUV(e, t) {
            let n = this._renderer
              , i = e.mapping === Fa || e.mapping === ka;
            i ? (this._cubemapMaterial === null && (this._cubemapMaterial = w0()),
            this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = S0());
            let s = i ? this._cubemapMaterial : this._equirectMaterial
              , o = new Ht(this._lodPlanes[0],s)
              , a = s.uniforms;
            a.envMap.value = e;
            let l = this._cubeSize;
            lh(t, 0, 0, 3 * l, 2 * l),
            n.setRenderTarget(t),
            n.render(o, Gd)
        }
        _applyPMREM(e) {
            let t = this._renderer
              , n = t.autoClear;
            t.autoClear = !1;
            for (let i = 1; i < this._lodPlanes.length; i++) {
                let s = Math.sqrt(this._sigmas[i] * this._sigmas[i] - this._sigmas[i - 1] * this._sigmas[i - 1])
                  , o = M0[(i - 1) % M0.length];
                this._blur(e, i - 1, i, s, o)
            }
            t.autoClear = n
        }
        _blur(e, t, n, i, s) {
            let o = this._pingPongRenderTarget;
            this._halfBlur(e, o, t, n, i, "latitudinal", s),
            this._halfBlur(o, e, n, n, i, "longitudinal", s)
        }
        _halfBlur(e, t, n, i, s, o, a) {
            let l = this._renderer
              , c = this._blurMaterial;
            o !== "latitudinal" && o !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
            let u = 3
              , h = new Ht(this._lodPlanes[i],c)
              , f = c.uniforms
              , m = this._sizeLods[n] - 1
              , g = isFinite(s) ? Math.PI / (2 * m) : 2 * Math.PI / (2 * Ao - 1)
              , v = s / g
              , p = isFinite(s) ? 1 + Math.floor(u * v) : Ao;
            p > Ao && console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${p} samples when the maximum is set to ${Ao}`);
            let d = []
              , x = 0;
            for (let I = 0; I < Ao; ++I) {
                let O = I / v
                  , M = Math.exp(-O * O / 2);
                d.push(M),
                I === 0 ? x += M : I < p && (x += 2 * M)
            }
            for (let I = 0; I < d.length; I++)
                d[I] = d[I] / x;
            f.envMap.value = e.texture,
            f.samples.value = p,
            f.weights.value = d,
            f.latitudinal.value = o === "latitudinal",
            a && (f.poleAxis.value = a);
            let {_lodMax: y} = this;
            f.dTheta.value = g,
            f.mipInt.value = y - n;
            let _ = this._sizeLods[i]
              , S = 3 * _ * (i > y - Ia ? i - y + Ia : 0)
              , N = 4 * (this._cubeSize - _);
            lh(t, S, N, 3 * _, 2 * _),
            l.setRenderTarget(t),
            l.render(h, Gd)
        }
    }
    ;
    function DM(r) {
        let e = []
          , t = []
          , n = []
          , i = r
          , s = r - Ia + 1 + T0.length;
        for (let o = 0; o < s; o++) {
            let a = Math.pow(2, i);
            t.push(a);
            let l = 1 / a;
            o > r - Ia ? l = T0[o - r + Ia - 1] : o === 0 && (l = 0),
            n.push(l);
            let c = 1 / (a - 2)
              , u = -c
              , h = 1 + c
              , f = [u, u, h, u, h, h, u, u, h, h, u, h]
              , m = 6
              , g = 6
              , v = 3
              , p = 2
              , d = 1
              , x = new Float32Array(v * g * m)
              , y = new Float32Array(p * g * m)
              , _ = new Float32Array(d * g * m);
            for (let N = 0; N < m; N++) {
                let I = N % 3 * 2 / 3 - 1
                  , O = N > 2 ? 0 : -1
                  , M = [I, O, 0, I + 2 / 3, O, 0, I + 2 / 3, O + 1, 0, I, O, 0, I + 2 / 3, O + 1, 0, I, O + 1, 0];
                x.set(M, v * g * N),
                y.set(f, p * g * N);
                let R = [N, N, N, N, N, N];
                _.set(R, d * g * N)
            }
            let S = new wt;
            S.setAttribute("position", new zn(x,v)),
            S.setAttribute("uv", new zn(y,p)),
            S.setAttribute("faceIndex", new zn(_,d)),
            e.push(S),
            i > Ia && i--
        }
        return {
            lodPlanes: e,
            sizeLods: t,
            sigmas: n
        }
    }
    function E0(r, e, t) {
        let n = new ds(r,e,t);
        return n.texture.mapping = Bh,
        n.texture.name = "PMREM.cubeUv",
        n.scissorTest = !0,
        n
    }
    function lh(r, e, t, n, i) {
        r.viewport.set(e, t, n, i),
        r.scissor.set(e, t, n, i)
    }
    function OM(r, e, t) {
        let n = new Float32Array(Ao)
          , i = new ue(0,1,0);
        return new ms({
            name: "SphericalGaussianBlur",
            defines: {
                n: Ao,
                CUBEUV_TEXEL_WIDTH: 1 / e,
                CUBEUV_TEXEL_HEIGHT: 1 / t,
                CUBEUV_MAX_MIP: `${r}.0`
            },
            uniforms: {
                envMap: {
                    value: null
                },
                samples: {
                    value: 1
                },
                weights: {
                    value: n
                },
                latitudinal: {
                    value: !1
                },
                dTheta: {
                    value: 0
                },
                mipInt: {
                    value: 0
                },
                poleAxis: {
                    value: i
                }
            },
            vertexShader: Fp(),
            fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
            blending: zs,
            depthTest: !1,
            depthWrite: !1
        })
    }
    function S0() {
        return new ms({
            name: "EquirectangularToCubeUV",
            uniforms: {
                envMap: {
                    value: null
                }
            },
            vertexShader: Fp(),
            fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
            blending: zs,
            depthTest: !1,
            depthWrite: !1
        })
    }
    function w0() {
        return new ms({
            name: "CubemapToCubeUV",
            uniforms: {
                envMap: {
                    value: null
                },
                flipEnvMap: {
                    value: -1
                }
            },
            vertexShader: Fp(),
            fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
            blending: zs,
            depthTest: !1,
            depthWrite: !1
        })
    }
    function Fp() {
        return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
    }
    function FM(r) {
        let e = new WeakMap
          , t = null;
        function n(a) {
            if (a && a.isTexture) {
                let l = a.mapping
                  , c = l === Pc || l === Jd
                  , u = l === Fa || l === ka;
                if (c || u)
                    if (a.isRenderTargetTexture && a.needsPMREMUpdate === !0) {
                        a.needsPMREMUpdate = !1;
                        let h = e.get(a);
                        return t === null && (t = new Sh(r)),
                        h = c ? t.fromEquirectangular(a, h) : t.fromCubemap(a, h),
                        e.set(a, h),
                        h.texture
                    } else {
                        if (e.has(a))
                            return e.get(a).texture;
                        {
                            let h = a.image;
                            if (c && h && h.height > 0 || u && h && i(h)) {
                                t === null && (t = new Sh(r));
                                let f = c ? t.fromEquirectangular(a) : t.fromCubemap(a);
                                return e.set(a, f),
                                a.addEventListener("dispose", s),
                                f.texture
                            } else
                                return null
                        }
                    }
            }
            return a
        }
        function i(a) {
            let l = 0
              , c = 6;
            for (let u = 0; u < c; u++)
                a[u] !== void 0 && l++;
            return l === c
        }
        function s(a) {
            let l = a.target;
            l.removeEventListener("dispose", s);
            let c = e.get(l);
            c !== void 0 && (e.delete(l),
            c.dispose())
        }
        function o() {
            e = new WeakMap,
            t !== null && (t.dispose(),
            t = null)
        }
        return {
            get: n,
            dispose: o
        }
    }
    function kM(r) {
        let e = {};
        function t(n) {
            if (e[n] !== void 0)
                return e[n];
            let i;
            switch (n) {
            case "WEBGL_depth_texture":
                i = r.getExtension("WEBGL_depth_texture") || r.getExtension("MOZ_WEBGL_depth_texture") || r.getExtension("WEBKIT_WEBGL_depth_texture");
                break;
            case "EXT_texture_filter_anisotropic":
                i = r.getExtension("EXT_texture_filter_anisotropic") || r.getExtension("MOZ_EXT_texture_filter_anisotropic") || r.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                break;
            case "WEBGL_compressed_texture_s3tc":
                i = r.getExtension("WEBGL_compressed_texture_s3tc") || r.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || r.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                break;
            case "WEBGL_compressed_texture_pvrtc":
                i = r.getExtension("WEBGL_compressed_texture_pvrtc") || r.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                break;
            default:
                i = r.getExtension(n)
            }
            return e[n] = i,
            i
        }
        return {
            has: function(n) {
                return t(n) !== null
            },
            init: function(n) {
                n.isWebGL2 ? t("EXT_color_buffer_float") : (t("WEBGL_depth_texture"),
                t("OES_texture_float"),
                t("OES_texture_half_float"),
                t("OES_texture_half_float_linear"),
                t("OES_standard_derivatives"),
                t("OES_element_index_uint"),
                t("OES_vertex_array_object"),
                t("ANGLE_instanced_arrays")),
                t("OES_texture_float_linear"),
                t("EXT_color_buffer_half_float"),
                t("WEBGL_multisampled_render_to_texture")
            },
            get: function(n) {
                let i = t(n);
                return i === null && console.warn("THREE.WebGLRenderer: " + n + " extension not supported."),
                i
            }
        }
    }
    function UM(r, e, t, n) {
        let i = {}
          , s = new WeakMap;
        function o(h) {
            let f = h.target;
            f.index !== null && e.remove(f.index);
            for (let g in f.attributes)
                e.remove(f.attributes[g]);
            f.removeEventListener("dispose", o),
            delete i[f.id];
            let m = s.get(f);
            m && (e.remove(m),
            s.delete(f)),
            n.releaseStatesOfGeometry(f),
            f.isInstancedBufferGeometry === !0 && delete f._maxInstanceCount,
            t.memory.geometries--
        }
        function a(h, f) {
            return i[f.id] === !0 || (f.addEventListener("dispose", o),
            i[f.id] = !0,
            t.memory.geometries++),
            f
        }
        function l(h) {
            let f = h.attributes;
            for (let g in f)
                e.update(f[g], r.ARRAY_BUFFER);
            let m = h.morphAttributes;
            for (let g in m) {
                let v = m[g];
                for (let p = 0, d = v.length; p < d; p++)
                    e.update(v[p], r.ARRAY_BUFFER)
            }
        }
        function c(h) {
            let f = []
              , m = h.index
              , g = h.attributes.position
              , v = 0;
            if (m !== null) {
                let x = m.array;
                v = m.version;
                for (let y = 0, _ = x.length; y < _; y += 3) {
                    let S = x[y + 0]
                      , N = x[y + 1]
                      , I = x[y + 2];
                    f.push(S, N, N, I, I, S)
                }
            } else {
                let x = g.array;
                v = g.version;
                for (let y = 0, _ = x.length / 3 - 1; y < _; y += 3) {
                    let S = y + 0
                      , N = y + 1
                      , I = y + 2;
                    f.push(S, N, N, I, I, S)
                }
            }
            let p = new (xv(f) ? Mh : za)(f,1);
            p.version = v;
            let d = s.get(h);
            d && e.remove(d),
            s.set(h, p)
        }
        function u(h) {
            let f = s.get(h);
            if (f) {
                let m = h.index;
                m !== null && f.version < m.version && c(h)
            } else
                c(h);
            return s.get(h)
        }
        return {
            get: a,
            update: l,
            getWireframeAttribute: u
        }
    }
    function BM(r, e, t, n) {
        let i = n.isWebGL2, s;
        function o(f) {
            s = f
        }
        let a, l;
        function c(f) {
            a = f.type,
            l = f.bytesPerElement
        }
        function u(f, m) {
            r.drawElements(s, m, a, f * l),
            t.update(m, s, 1)
        }
        function h(f, m, g) {
            if (g === 0)
                return;
            let v, p;
            if (i)
                v = r,
                p = "drawElementsInstanced";
            else if (v = e.get("ANGLE_instanced_arrays"),
            p = "drawElementsInstancedANGLE",
            v === null) {
                console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                return
            }
            v[p](s, m, a, f * l, g),
            t.update(m, s, g)
        }
        this.setMode = o,
        this.setIndex = c,
        this.render = u,
        this.renderInstances = h
    }
    function GM(r) {
        let e = {
            geometries: 0,
            textures: 0
        }
          , t = {
            frame: 0,
            calls: 0,
            triangles: 0,
            points: 0,
            lines: 0
        };
        function n(s, o, a) {
            switch (t.calls++,
            o) {
            case r.TRIANGLES:
                t.triangles += a * (s / 3);
                break;
            case r.LINES:
                t.lines += a * (s / 2);
                break;
            case r.LINE_STRIP:
                t.lines += a * (s - 1);
                break;
            case r.LINE_LOOP:
                t.lines += a * s;
                break;
            case r.POINTS:
                t.points += a * s;
                break;
            default:
                console.error("THREE.WebGLInfo: Unknown draw mode:", o);
                break
            }
        }
        function i() {
            t.frame++,
            t.calls = 0,
            t.triangles = 0,
            t.points = 0,
            t.lines = 0
        }
        return {
            memory: e,
            render: t,
            programs: null,
            autoReset: !0,
            reset: i,
            update: n
        }
    }
    function VM(r, e) {
        return r[0] - e[0]
    }
    function zM(r, e) {
        return Math.abs(e[1]) - Math.abs(r[1])
    }
    function HM(r, e, t) {
        let n = {}
          , i = new Float32Array(8)
          , s = new WeakMap
          , o = new Lt
          , a = [];
        for (let c = 0; c < 8; c++)
            a[c] = [c, 0];
        function l(c, u, h) {
            let f = c.morphTargetInfluences;
            if (e.isWebGL2 === !0) {
                let m = u.morphAttributes.position || u.morphAttributes.normal || u.morphAttributes.color
                  , g = m !== void 0 ? m.length : 0
                  , v = s.get(u);
                if (v === void 0 || v.count !== g) {
                    let P = function() {
                        k.dispose(),
                        s.delete(u),
                        u.removeEventListener("dispose", P)
                    };
                    v !== void 0 && v.texture.dispose();
                    let x = u.morphAttributes.position !== void 0
                      , y = u.morphAttributes.normal !== void 0
                      , _ = u.morphAttributes.color !== void 0
                      , S = u.morphAttributes.position || []
                      , N = u.morphAttributes.normal || []
                      , I = u.morphAttributes.color || []
                      , O = 0;
                    x === !0 && (O = 1),
                    y === !0 && (O = 2),
                    _ === !0 && (O = 3);
                    let M = u.attributes.position.count * O
                      , R = 1;
                    M > e.maxTextureSize && (R = Math.ceil(M / e.maxTextureSize),
                    M = e.maxTextureSize);
                    let q = new Float32Array(M * R * 4 * g)
                      , k = new bh(q,M,R,g);
                    k.type = Vs,
                    k.needsUpdate = !0;
                    let B = O * 4;
                    for (let C = 0; C < g; C++) {
                        let L = S[C]
                          , F = N[C]
                          , U = I[C]
                          , W = M * R * 4 * C;
                        for (let K = 0; K < L.count; K++) {
                            let re = K * B;
                            x === !0 && (o.fromBufferAttribute(L, K),
                            q[W + re + 0] = o.x,
                            q[W + re + 1] = o.y,
                            q[W + re + 2] = o.z,
                            q[W + re + 3] = 0),
                            y === !0 && (o.fromBufferAttribute(F, K),
                            q[W + re + 4] = o.x,
                            q[W + re + 5] = o.y,
                            q[W + re + 6] = o.z,
                            q[W + re + 7] = 0),
                            _ === !0 && (o.fromBufferAttribute(U, K),
                            q[W + re + 8] = o.x,
                            q[W + re + 9] = o.y,
                            q[W + re + 10] = o.z,
                            q[W + re + 11] = U.itemSize === 4 ? o.w : 1)
                        }
                    }
                    v = {
                        count: g,
                        texture: k,
                        size: new Ie(M,R)
                    },
                    s.set(u, v),
                    u.addEventListener("dispose", P)
                }
                let p = 0;
                for (let x = 0; x < f.length; x++)
                    p += f[x];
                let d = u.morphTargetsRelative ? 1 : 1 - p;
                h.getUniforms().setValue(r, "morphTargetBaseInfluence", d),
                h.getUniforms().setValue(r, "morphTargetInfluences", f),
                h.getUniforms().setValue(r, "morphTargetsTexture", v.texture, t),
                h.getUniforms().setValue(r, "morphTargetsTextureSize", v.size)
            } else {
                let m = f === void 0 ? 0 : f.length
                  , g = n[u.id];
                if (g === void 0 || g.length !== m) {
                    g = [];
                    for (let y = 0; y < m; y++)
                        g[y] = [y, 0];
                    n[u.id] = g
                }
                for (let y = 0; y < m; y++) {
                    let _ = g[y];
                    _[0] = y,
                    _[1] = f[y]
                }
                g.sort(zM);
                for (let y = 0; y < 8; y++)
                    y < m && g[y][1] ? (a[y][0] = g[y][0],
                    a[y][1] = g[y][1]) : (a[y][0] = Number.MAX_SAFE_INTEGER,
                    a[y][1] = 0);
                a.sort(VM);
                let v = u.morphAttributes.position
                  , p = u.morphAttributes.normal
                  , d = 0;
                for (let y = 0; y < 8; y++) {
                    let _ = a[y]
                      , S = _[0]
                      , N = _[1];
                    S !== Number.MAX_SAFE_INTEGER && N ? (v && u.getAttribute("morphTarget" + y) !== v[S] && u.setAttribute("morphTarget" + y, v[S]),
                    p && u.getAttribute("morphNormal" + y) !== p[S] && u.setAttribute("morphNormal" + y, p[S]),
                    i[y] = N,
                    d += N) : (v && u.hasAttribute("morphTarget" + y) === !0 && u.deleteAttribute("morphTarget" + y),
                    p && u.hasAttribute("morphNormal" + y) === !0 && u.deleteAttribute("morphNormal" + y),
                    i[y] = 0)
                }
                let x = u.morphTargetsRelative ? 1 : 1 - d;
                h.getUniforms().setValue(r, "morphTargetBaseInfluence", x),
                h.getUniforms().setValue(r, "morphTargetInfluences", i)
            }
        }
        return {
            update: l
        }
    }
    function WM(r, e, t, n) {
        let i = new WeakMap;
        function s(l) {
            let c = n.render.frame
              , u = l.geometry
              , h = e.get(l, u);
            return i.get(h) !== c && (e.update(h),
            i.set(h, c)),
            l.isInstancedMesh && (l.hasEventListener("dispose", a) === !1 && l.addEventListener("dispose", a),
            t.update(l.instanceMatrix, r.ARRAY_BUFFER),
            l.instanceColor !== null && t.update(l.instanceColor, r.ARRAY_BUFFER)),
            h
        }
        function o() {
            i = new WeakMap
        }
        function a(l) {
            let c = l.target;
            c.removeEventListener("dispose", a),
            t.remove(c.instanceMatrix),
            c.instanceColor !== null && t.remove(c.instanceColor)
        }
        return {
            update: s,
            dispose: o
        }
    }
    var Mv = new En
      , Ev = new bh
      , Sv = new ep
      , wv = new Oc
      , A0 = []
      , C0 = []
      , I0 = new Float32Array(16)
      , R0 = new Float32Array(9)
      , P0 = new Float32Array(4);
    function $a(r, e, t) {
        let n = r[0];
        if (n <= 0 || n > 0)
            return r;
        let i = e * t
          , s = A0[i];
        if (s === void 0 && (s = new Float32Array(i),
        A0[i] = s),
        e !== 0) {
            n.toArray(s, 0);
            for (let o = 1, a = 0; o !== e; ++o)
                a += t,
                r[o].toArray(s, a)
        }
        return s
    }
    function Rn(r, e) {
        if (r.length !== e.length)
            return !1;
        for (let t = 0, n = r.length; t < n; t++)
            if (r[t] !== e[t])
                return !1;
        return !0
    }
    function Pn(r, e) {
        for (let t = 0, n = e.length; t < n; t++)
            r[t] = e[t]
    }
    function Vh(r, e) {
        let t = C0[e];
        t === void 0 && (t = new Int32Array(e),
        C0[e] = t);
        for (let n = 0; n !== e; ++n)
            t[n] = r.allocateTextureUnit();
        return t
    }
    function XM(r, e) {
        let t = this.cache;
        t[0] !== e && (r.uniform1f(this.addr, e),
        t[0] = e)
    }
    function jM(r, e) {
        let t = this.cache;
        if (e.x !== void 0)
            (t[0] !== e.x || t[1] !== e.y) && (r.uniform2f(this.addr, e.x, e.y),
            t[0] = e.x,
            t[1] = e.y);
        else {
            if (Rn(t, e))
                return;
            r.uniform2fv(this.addr, e),
            Pn(t, e)
        }
    }
    function qM(r, e) {
        let t = this.cache;
        if (e.x !== void 0)
            (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (r.uniform3f(this.addr, e.x, e.y, e.z),
            t[0] = e.x,
            t[1] = e.y,
            t[2] = e.z);
        else if (e.r !== void 0)
            (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (r.uniform3f(this.addr, e.r, e.g, e.b),
            t[0] = e.r,
            t[1] = e.g,
            t[2] = e.b);
        else {
            if (Rn(t, e))
                return;
            r.uniform3fv(this.addr, e),
            Pn(t, e)
        }
    }
    function YM(r, e) {
        let t = this.cache;
        if (e.x !== void 0)
            (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (r.uniform4f(this.addr, e.x, e.y, e.z, e.w),
            t[0] = e.x,
            t[1] = e.y,
            t[2] = e.z,
            t[3] = e.w);
        else {
            if (Rn(t, e))
                return;
            r.uniform4fv(this.addr, e),
            Pn(t, e)
        }
    }
    function KM(r, e) {
        let t = this.cache
          , n = e.elements;
        if (n === void 0) {
            if (Rn(t, e))
                return;
            r.uniformMatrix2fv(this.addr, !1, e),
            Pn(t, e)
        } else {
            if (Rn(t, n))
                return;
            P0.set(n),
            r.uniformMatrix2fv(this.addr, !1, P0),
            Pn(t, n)
        }
    }
    function ZM(r, e) {
        let t = this.cache
          , n = e.elements;
        if (n === void 0) {
            if (Rn(t, e))
                return;
            r.uniformMatrix3fv(this.addr, !1, e),
            Pn(t, e)
        } else {
            if (Rn(t, n))
                return;
            R0.set(n),
            r.uniformMatrix3fv(this.addr, !1, R0),
            Pn(t, n)
        }
    }
    function JM(r, e) {
        let t = this.cache
          , n = e.elements;
        if (n === void 0) {
            if (Rn(t, e))
                return;
            r.uniformMatrix4fv(this.addr, !1, e),
            Pn(t, e)
        } else {
            if (Rn(t, n))
                return;
            I0.set(n),
            r.uniformMatrix4fv(this.addr, !1, I0),
            Pn(t, n)
        }
    }
    function $M(r, e) {
        let t = this.cache;
        t[0] !== e && (r.uniform1i(this.addr, e),
        t[0] = e)
    }
    function QM(r, e) {
        let t = this.cache;
        if (e.x !== void 0)
            (t[0] !== e.x || t[1] !== e.y) && (r.uniform2i(this.addr, e.x, e.y),
            t[0] = e.x,
            t[1] = e.y);
        else {
            if (Rn(t, e))
                return;
            r.uniform2iv(this.addr, e),
            Pn(t, e)
        }
    }
    function eE(r, e) {
        let t = this.cache;
        if (e.x !== void 0)
            (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (r.uniform3i(this.addr, e.x, e.y, e.z),
            t[0] = e.x,
            t[1] = e.y,
            t[2] = e.z);
        else {
            if (Rn(t, e))
                return;
            r.uniform3iv(this.addr, e),
            Pn(t, e)
        }
    }
    function tE(r, e) {
        let t = this.cache;
        if (e.x !== void 0)
            (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (r.uniform4i(this.addr, e.x, e.y, e.z, e.w),
            t[0] = e.x,
            t[1] = e.y,
            t[2] = e.z,
            t[3] = e.w);
        else {
            if (Rn(t, e))
                return;
            r.uniform4iv(this.addr, e),
            Pn(t, e)
        }
    }
    function nE(r, e) {
        let t = this.cache;
        t[0] !== e && (r.uniform1ui(this.addr, e),
        t[0] = e)
    }
    function iE(r, e) {
        let t = this.cache;
        if (e.x !== void 0)
            (t[0] !== e.x || t[1] !== e.y) && (r.uniform2ui(this.addr, e.x, e.y),
            t[0] = e.x,
            t[1] = e.y);
        else {
            if (Rn(t, e))
                return;
            r.uniform2uiv(this.addr, e),
            Pn(t, e)
        }
    }
    function rE(r, e) {
        let t = this.cache;
        if (e.x !== void 0)
            (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (r.uniform3ui(this.addr, e.x, e.y, e.z),
            t[0] = e.x,
            t[1] = e.y,
            t[2] = e.z);
        else {
            if (Rn(t, e))
                return;
            r.uniform3uiv(this.addr, e),
            Pn(t, e)
        }
    }
    function sE(r, e) {
        let t = this.cache;
        if (e.x !== void 0)
            (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (r.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
            t[0] = e.x,
            t[1] = e.y,
            t[2] = e.z,
            t[3] = e.w);
        else {
            if (Rn(t, e))
                return;
            r.uniform4uiv(this.addr, e),
            Pn(t, e)
        }
    }
    function oE(r, e, t) {
        let n = this.cache
          , i = t.allocateTextureUnit();
        n[0] !== i && (r.uniform1i(this.addr, i),
        n[0] = i),
        t.setTexture2D(e || Mv, i)
    }
    function aE(r, e, t) {
        let n = this.cache
          , i = t.allocateTextureUnit();
        n[0] !== i && (r.uniform1i(this.addr, i),
        n[0] = i),
        t.setTexture3D(e || Sv, i)
    }
    function lE(r, e, t) {
        let n = this.cache
          , i = t.allocateTextureUnit();
        n[0] !== i && (r.uniform1i(this.addr, i),
        n[0] = i),
        t.setTextureCube(e || wv, i)
    }
    function cE(r, e, t) {
        let n = this.cache
          , i = t.allocateTextureUnit();
        n[0] !== i && (r.uniform1i(this.addr, i),
        n[0] = i),
        t.setTexture2DArray(e || Ev, i)
    }
    function uE(r) {
        switch (r) {
        case 5126:
            return XM;
        case 35664:
            return jM;
        case 35665:
            return qM;
        case 35666:
            return YM;
        case 35674:
            return KM;
        case 35675:
            return ZM;
        case 35676:
            return JM;
        case 5124:
        case 35670:
            return $M;
        case 35667:
        case 35671:
            return QM;
        case 35668:
        case 35672:
            return eE;
        case 35669:
        case 35673:
            return tE;
        case 5125:
            return nE;
        case 36294:
            return iE;
        case 36295:
            return rE;
        case 36296:
            return sE;
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
            return oE;
        case 35679:
        case 36299:
        case 36307:
            return aE;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
            return lE;
        case 36289:
        case 36303:
        case 36311:
        case 36292:
            return cE
        }
    }
    function hE(r, e) {
        r.uniform1fv(this.addr, e)
    }
    function fE(r, e) {
        let t = $a(e, this.size, 2);
        r.uniform2fv(this.addr, t)
    }
    function dE(r, e) {
        let t = $a(e, this.size, 3);
        r.uniform3fv(this.addr, t)
    }
    function pE(r, e) {
        let t = $a(e, this.size, 4);
        r.uniform4fv(this.addr, t)
    }
    function mE(r, e) {
        let t = $a(e, this.size, 4);
        r.uniformMatrix2fv(this.addr, !1, t)
    }
    function gE(r, e) {
        let t = $a(e, this.size, 9);
        r.uniformMatrix3fv(this.addr, !1, t)
    }
    function vE(r, e) {
        let t = $a(e, this.size, 16);
        r.uniformMatrix4fv(this.addr, !1, t)
    }
    function yE(r, e) {
        r.uniform1iv(this.addr, e)
    }
    function xE(r, e) {
        r.uniform2iv(this.addr, e)
    }
    function _E(r, e) {
        r.uniform3iv(this.addr, e)
    }
    function TE(r, e) {
        r.uniform4iv(this.addr, e)
    }
    function bE(r, e) {
        r.uniform1uiv(this.addr, e)
    }
    function ME(r, e) {
        r.uniform2uiv(this.addr, e)
    }
    function EE(r, e) {
        r.uniform3uiv(this.addr, e)
    }
    function SE(r, e) {
        r.uniform4uiv(this.addr, e)
    }
    function wE(r, e, t) {
        let n = this.cache
          , i = e.length
          , s = Vh(t, i);
        Rn(n, s) || (r.uniform1iv(this.addr, s),
        Pn(n, s));
        for (let o = 0; o !== i; ++o)
            t.setTexture2D(e[o] || Mv, s[o])
    }
    function AE(r, e, t) {
        let n = this.cache
          , i = e.length
          , s = Vh(t, i);
        Rn(n, s) || (r.uniform1iv(this.addr, s),
        Pn(n, s));
        for (let o = 0; o !== i; ++o)
            t.setTexture3D(e[o] || Sv, s[o])
    }
    function CE(r, e, t) {
        let n = this.cache
          , i = e.length
          , s = Vh(t, i);
        Rn(n, s) || (r.uniform1iv(this.addr, s),
        Pn(n, s));
        for (let o = 0; o !== i; ++o)
            t.setTextureCube(e[o] || wv, s[o])
    }
    function IE(r, e, t) {
        let n = this.cache
          , i = e.length
          , s = Vh(t, i);
        Rn(n, s) || (r.uniform1iv(this.addr, s),
        Pn(n, s));
        for (let o = 0; o !== i; ++o)
            t.setTexture2DArray(e[o] || Ev, s[o])
    }
    function RE(r) {
        switch (r) {
        case 5126:
            return hE;
        case 35664:
            return fE;
        case 35665:
            return dE;
        case 35666:
            return pE;
        case 35674:
            return mE;
        case 35675:
            return gE;
        case 35676:
            return vE;
        case 5124:
        case 35670:
            return yE;
        case 35667:
        case 35671:
            return xE;
        case 35668:
        case 35672:
            return _E;
        case 35669:
        case 35673:
            return TE;
        case 5125:
            return bE;
        case 36294:
            return ME;
        case 36295:
            return EE;
        case 36296:
            return SE;
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
            return wE;
        case 35679:
        case 36299:
        case 36307:
            return AE;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
            return CE;
        case 36289:
        case 36303:
        case 36311:
        case 36292:
            return IE
        }
    }
    var ip = class {
        constructor(e, t, n) {
            this.id = e,
            this.addr = n,
            this.cache = [],
            this.setValue = uE(t.type)
        }
    }
      , rp = class {
        constructor(e, t, n) {
            this.id = e,
            this.addr = n,
            this.cache = [],
            this.size = t.size,
            this.setValue = RE(t.type)
        }
    }
      , sp = class {
        constructor(e) {
            this.id = e,
            this.seq = [],
            this.map = {}
        }
        setValue(e, t, n) {
            let i = this.seq;
            for (let s = 0, o = i.length; s !== o; ++s) {
                let a = i[s];
                a.setValue(e, t[a.id], n)
            }
        }
    }
      , zd = /(\w+)(\])?(\[|\.)?/g;
    function L0(r, e) {
        r.seq.push(e),
        r.map[e.id] = e
    }
    function PE(r, e, t) {
        let n = r.name
          , i = n.length;
        for (zd.lastIndex = 0; ; ) {
            let s = zd.exec(n)
              , o = zd.lastIndex
              , a = s[1]
              , l = s[2] === "]"
              , c = s[3];
            if (l && (a = a | 0),
            c === void 0 || c === "[" && o + 2 === i) {
                L0(t, c === void 0 ? new ip(a,r,e) : new rp(a,r,e));
                break
            } else {
                let h = t.map[a];
                h === void 0 && (h = new sp(a),
                L0(t, h)),
                t = h
            }
        }
    }
    var Oa = class {
        constructor(e, t) {
            this.seq = [],
            this.map = {};
            let n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
            for (let i = 0; i < n; ++i) {
                let s = e.getActiveUniform(t, i)
                  , o = e.getUniformLocation(t, s.name);
                PE(s, o, this)
            }
        }
        setValue(e, t, n, i) {
            let s = this.map[t];
            s !== void 0 && s.setValue(e, n, i)
        }
        setOptional(e, t, n) {
            let i = t[n];
            i !== void 0 && this.setValue(e, n, i)
        }
        static upload(e, t, n, i) {
            for (let s = 0, o = t.length; s !== o; ++s) {
                let a = t[s]
                  , l = n[a.id];
                l.needsUpdate !== !1 && a.setValue(e, l.value, i)
            }
        }
        static seqWithValue(e, t) {
            let n = [];
            for (let i = 0, s = e.length; i !== s; ++i) {
                let o = e[i];
                o.id in t && n.push(o)
            }
            return n
        }
    }
    ;
    function N0(r, e, t) {
        let n = r.createShader(e);
        return r.shaderSource(n, t),
        r.compileShader(n),
        n
    }
    var LE = 0;
    function NE(r, e) {
        let t = r.split(`
`)
          , n = []
          , i = Math.max(e - 6, 0)
          , s = Math.min(e + 6, t.length);
        for (let o = i; o < s; o++) {
            let a = o + 1;
            n.push(`${a === e ? ">" : " "} ${a}: ${t[o]}`)
        }
        return n.join(`
`)
    }
    function DE(r) {
        switch (r) {
        case di:
            return ["Linear", "( value )"];
        case ct:
            return ["sRGB", "( value )"];
        default:
            return console.warn("THREE.WebGLProgram: Unsupported color space:", r),
            ["Linear", "( value )"]
        }
    }
    function D0(r, e, t) {
        let n = r.getShaderParameter(e, r.COMPILE_STATUS)
          , i = r.getShaderInfoLog(e).trim();
        if (n && i === "")
            return "";
        let s = /ERROR: 0:(\d+)/.exec(i);
        if (s) {
            let o = parseInt(s[1]);
            return t.toUpperCase() + `

` + i + `

` + NE(r.getShaderSource(e), o)
        } else
            return i
    }
    function OE(r, e) {
        let t = DE(e);
        return "vec4 " + r + "( vec4 value ) { return LinearTo" + t[0] + t[1] + "; }"
    }
    function FE(r, e) {
        let t;
        switch (e) {
        case Wx:
            t = "Linear";
            break;
        case Xx:
            t = "Reinhard";
            break;
        case jx:
            t = "OptimizedCineon";
            break;
        case qx:
            t = "ACESFilmic";
            break;
        case Yx:
            t = "Custom";
            break;
        default:
            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
            t = "Linear"
        }
        return "vec3 " + r + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
    }
    function kE(r) {
        return [r.extensionDerivatives || r.envMapCubeUVHeight || r.bumpMap || r.normalMapTangentSpace || r.clearcoatNormalMap || r.flatShading || r.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "", (r.extensionFragDepth || r.logarithmicDepthBuffer) && r.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", r.extensionDrawBuffers && r.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (r.extensionShaderTextureLOD || r.envMap || r.transmission) && r.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Sc).join(`
`)
    }
    function UE(r) {
        let e = [];
        for (let t in r) {
            let n = r[t];
            n !== !1 && e.push("#define " + t + " " + n)
        }
        return e.join(`
`)
    }
    function BE(r, e) {
        let t = {}
          , n = r.getProgramParameter(e, r.ACTIVE_ATTRIBUTES);
        for (let i = 0; i < n; i++) {
            let s = r.getActiveAttrib(e, i)
              , o = s.name
              , a = 1;
            s.type === r.FLOAT_MAT2 && (a = 2),
            s.type === r.FLOAT_MAT3 && (a = 3),
            s.type === r.FLOAT_MAT4 && (a = 4),
            t[o] = {
                type: s.type,
                location: r.getAttribLocation(e, o),
                locationSize: a
            }
        }
        return t
    }
    function Sc(r) {
        return r !== ""
    }
    function O0(r, e) {
        let t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
        return r.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
    }
    function F0(r, e) {
        return r.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
    }
    var GE = /^[ \t]*#include +<([\w\d./]+)>/gm;
    function op(r) {
        return r.replace(GE, VE)
    }
    function VE(r, e) {
        let t = St[e];
        if (t === void 0)
            throw new Error("Can not resolve #include <" + e + ">");
        return op(t)
    }
    var zE = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
    function k0(r) {
        return r.replace(zE, HE)
    }
    function HE(r, e, t, n) {
        let i = "";
        for (let s = parseInt(e); s < parseInt(t); s++)
            i += n.replace(/\[\s*i\s*\]/g, "[ " + s + " ]").replace(/UNROLLED_LOOP_INDEX/g, s);
        return i
    }
    function U0(r) {
        let e = "precision " + r.precision + ` float;
precision ` + r.precision + " int;";
        return r.precision === "highp" ? e += `
#define HIGH_PRECISION` : r.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : r.precision === "lowp" && (e += `
#define LOW_PRECISION`),
        e
    }
    function WE(r) {
        let e = "SHADOWMAP_TYPE_BASIC";
        return r.shadowMapType === uv ? e = "SHADOWMAP_TYPE_PCF" : r.shadowMapType === bx ? e = "SHADOWMAP_TYPE_PCF_SOFT" : r.shadowMapType === hs && (e = "SHADOWMAP_TYPE_VSM"),
        e
    }
    function XE(r) {
        let e = "ENVMAP_TYPE_CUBE";
        if (r.envMap)
            switch (r.envMapMode) {
            case Fa:
            case ka:
                e = "ENVMAP_TYPE_CUBE";
                break;
            case Bh:
                e = "ENVMAP_TYPE_CUBE_UV";
                break
            }
        return e
    }
    function jE(r) {
        let e = "ENVMAP_MODE_REFLECTION";
        if (r.envMap)
            switch (r.envMapMode) {
            case ka:
                e = "ENVMAP_MODE_REFRACTION";
                break
            }
        return e
    }
    function qE(r) {
        let e = "ENVMAP_BLENDING_NONE";
        if (r.envMap)
            switch (r.combine) {
            case Uh:
                e = "ENVMAP_BLENDING_MULTIPLY";
                break;
            case zx:
                e = "ENVMAP_BLENDING_MIX";
                break;
            case Hx:
                e = "ENVMAP_BLENDING_ADD";
                break
            }
        return e
    }
    function YE(r) {
        let e = r.envMapCubeUVHeight;
        if (e === null)
            return null;
        let t = Math.log2(e) - 2
          , n = 1 / e;
        return {
            texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
            texelHeight: n,
            maxMip: t
        }
    }
    function KE(r, e, t, n) {
        let i = r.getContext(), s = t.defines, o = t.vertexShader, a = t.fragmentShader, l = WE(t), c = XE(t), u = jE(t), h = qE(t), f = YE(t), m = t.isWebGL2 ? "" : kE(t), g = UE(s), v = i.createProgram(), p, d, x = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
        t.isRawShaderMaterial ? (p = [g].filter(Sc).join(`
`),
        p.length > 0 && (p += `
`),
        d = [m, g].filter(Sc).join(`
`),
        d.length > 0 && (d += `
`)) : (p = [U0(t), "#define SHADER_NAME " + t.shaderName, g, t.instancing ? "#define USE_INSTANCING" : "", t.instancingColor ? "#define USE_INSTANCING_COLOR" : "", t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + u : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.mapUv ? "#define MAP_UV " + t.mapUv : "", t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "", t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "", t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "", t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "", t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "", t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "", t.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv : "", t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "", t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "", t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "", t.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv : "", t.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv : "", t.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv : "", t.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv : "", t.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv : "", t.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv : "", t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "", t.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv : "", t.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv : "", t.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv : "", t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "", t.vertexTangents ? "#define USE_TANGENT" : "", t.vertexColors ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.skinning ? "#define USE_SKINNING" : "", t.morphTargets ? "#define USE_MORPHTARGETS" : "", t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + l : "", t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "	attribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "	attribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "	attribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(Sc).join(`
`),
        d = [m, U0(t), "#define SHADER_NAME " + t.shaderName, g, t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.matcap ? "#define USE_MATCAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + c : "", t.envMap ? "#define " + u : "", t.envMap ? "#define " + h : "", f ? "#define CUBEUV_TEXEL_WIDTH " + f.texelWidth : "", f ? "#define CUBEUV_TEXEL_HEIGHT " + f.texelHeight : "", f ? "#define CUBEUV_MAX_MIP " + f.maxMip + ".0" : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.clearcoat ? "#define USE_CLEARCOAT" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescence ? "#define USE_IRIDESCENCE" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaTest ? "#define USE_ALPHATEST" : "", t.sheen ? "#define USE_SHEEN" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.vertexTangents ? "#define USE_TANGENT" : "", t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.gradientMap ? "#define USE_GRADIENTMAP" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + l : "", t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", t.useLegacyLights ? "#define LEGACY_LIGHTS" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", t.toneMapping !== fs ? "#define TONE_MAPPING" : "", t.toneMapping !== fs ? St.tonemapping_pars_fragment : "", t.toneMapping !== fs ? FE("toneMapping", t.toneMapping) : "", t.dithering ? "#define DITHERING" : "", t.opaque ? "#define OPAQUE" : "", St.encodings_pars_fragment, OE("linearToOutputTexel", t.outputColorSpace), t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "", `
`].filter(Sc).join(`
`)),
        o = op(o),
        o = O0(o, t),
        o = F0(o, t),
        a = op(a),
        a = O0(a, t),
        a = F0(a, t),
        o = k0(o),
        a = k0(a),
        t.isWebGL2 && t.isRawShaderMaterial !== !0 && (x = `#version 300 es
`,
        p = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
` + p,
        d = ["#define varying in", t.glslVersion === r0 ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", t.glslVersion === r0 ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
` + d);
        let y = x + p + o
          , _ = x + d + a
          , S = N0(i, i.VERTEX_SHADER, y)
          , N = N0(i, i.FRAGMENT_SHADER, _);
        if (i.attachShader(v, S),
        i.attachShader(v, N),
        t.index0AttributeName !== void 0 ? i.bindAttribLocation(v, 0, t.index0AttributeName) : t.morphTargets === !0 && i.bindAttribLocation(v, 0, "position"),
        i.linkProgram(v),
        r.debug.checkShaderErrors) {
            let M = i.getProgramInfoLog(v).trim()
              , R = i.getShaderInfoLog(S).trim()
              , q = i.getShaderInfoLog(N).trim()
              , k = !0
              , B = !0;
            if (i.getProgramParameter(v, i.LINK_STATUS) === !1)
                if (k = !1,
                typeof r.debug.onShaderError == "function")
                    r.debug.onShaderError(i, v, S, N);
                else {
                    let P = D0(i, S, "vertex")
                      , C = D0(i, N, "fragment");
                    console.error("THREE.WebGLProgram: Shader Error " + i.getError() + " - VALIDATE_STATUS " + i.getProgramParameter(v, i.VALIDATE_STATUS) + `

Program Info Log: ` + M + `
` + P + `
` + C)
                }
            else
                M !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", M) : (R === "" || q === "") && (B = !1);
            B && (this.diagnostics = {
                runnable: k,
                programLog: M,
                vertexShader: {
                    log: R,
                    prefix: p
                },
                fragmentShader: {
                    log: q,
                    prefix: d
                }
            })
        }
        i.deleteShader(S),
        i.deleteShader(N);
        let I;
        this.getUniforms = function() {
            return I === void 0 && (I = new Oa(i,v)),
            I
        }
        ;
        let O;
        return this.getAttributes = function() {
            return O === void 0 && (O = BE(i, v)),
            O
        }
        ,
        this.destroy = function() {
            n.releaseStatesOfProgram(this),
            i.deleteProgram(v),
            this.program = void 0
        }
        ,
        this.name = t.shaderName,
        this.id = LE++,
        this.cacheKey = e,
        this.usedTimes = 1,
        this.program = v,
        this.vertexShader = S,
        this.fragmentShader = N,
        this
    }
    var ZE = 0
      , ap = class {
        constructor() {
            this.shaderCache = new Map,
            this.materialCache = new Map
        }
        update(e) {
            let t = e.vertexShader
              , n = e.fragmentShader
              , i = this._getShaderStage(t)
              , s = this._getShaderStage(n)
              , o = this._getShaderCacheForMaterial(e);
            return o.has(i) === !1 && (o.add(i),
            i.usedTimes++),
            o.has(s) === !1 && (o.add(s),
            s.usedTimes++),
            this
        }
        remove(e) {
            let t = this.materialCache.get(e);
            for (let n of t)
                n.usedTimes--,
                n.usedTimes === 0 && this.shaderCache.delete(n.code);
            return this.materialCache.delete(e),
            this
        }
        getVertexShaderID(e) {
            return this._getShaderStage(e.vertexShader).id
        }
        getFragmentShaderID(e) {
            return this._getShaderStage(e.fragmentShader).id
        }
        dispose() {
            this.shaderCache.clear(),
            this.materialCache.clear()
        }
        _getShaderCacheForMaterial(e) {
            let t = this.materialCache
              , n = t.get(e);
            return n === void 0 && (n = new Set,
            t.set(e, n)),
            n
        }
        _getShaderStage(e) {
            let t = this.shaderCache
              , n = t.get(e);
            return n === void 0 && (n = new lp(e),
            t.set(e, n)),
            n
        }
    }
      , lp = class {
        constructor(e) {
            this.id = ZE++,
            this.code = e,
            this.usedTimes = 0
        }
    }
    ;
    function JE(r, e, t, n, i, s, o) {
        let a = new Dc
          , l = new ap
          , c = []
          , u = i.isWebGL2
          , h = i.logarithmicDepthBuffer
          , f = i.vertexTextures
          , m = i.precision
          , g = {
            MeshDepthMaterial: "depth",
            MeshDistanceMaterial: "distanceRGBA",
            MeshNormalMaterial: "normal",
            MeshBasicMaterial: "basic",
            MeshLambertMaterial: "lambert",
            MeshPhongMaterial: "phong",
            MeshToonMaterial: "toon",
            MeshStandardMaterial: "physical",
            MeshPhysicalMaterial: "physical",
            MeshMatcapMaterial: "matcap",
            LineBasicMaterial: "basic",
            LineDashedMaterial: "dashed",
            PointsMaterial: "points",
            ShadowMaterial: "shadow",
            SpriteMaterial: "sprite"
        };
        function v(M) {
            return M === 1 ? "uv1" : M === 2 ? "uv2" : M === 3 ? "uv3" : "uv"
        }
        function p(M, R, q, k, B) {
            let P = k.fog
              , C = B.geometry
              , L = M.isMeshStandardMaterial ? k.environment : null
              , F = (M.isMeshStandardMaterial ? t : e).get(M.envMap || L)
              , U = F && F.mapping === Bh ? F.image.height : null
              , W = g[M.type];
            M.precision !== null && (m = i.getMaxPrecision(M.precision),
            m !== M.precision && console.warn("THREE.WebGLProgram.getParameters:", M.precision, "not supported, using", m, "instead."));
            let K = C.morphAttributes.position || C.morphAttributes.normal || C.morphAttributes.color
              , re = K !== void 0 ? K.length : 0
              , oe = 0;
            C.morphAttributes.position !== void 0 && (oe = 1),
            C.morphAttributes.normal !== void 0 && (oe = 2),
            C.morphAttributes.color !== void 0 && (oe = 3);
            let j, w, b, E;
            if (W) {
                let pt = Lr[W];
                j = pt.vertexShader,
                w = pt.fragmentShader
            } else
                j = M.vertexShader,
                w = M.fragmentShader,
                l.update(M),
                b = l.getVertexShaderID(M),
                E = l.getFragmentShaderID(M);
            let T = r.getRenderTarget()
              , H = B.isInstancedMesh === !0
              , Y = !!M.map
              , X = !!M.matcap
              , ce = !!F
              , J = !!M.aoMap
              , ae = !!M.lightMap
              , ie = !!M.bumpMap
              , me = !!M.normalMap
              , ve = !!M.displacementMap
              , be = !!M.emissiveMap
              , fe = !!M.metalnessMap
              , te = !!M.roughnessMap
              , Ee = M.clearcoat > 0
              , Le = M.iridescence > 0
              , D = M.sheen > 0
              , A = M.transmission > 0
              , G = Ee && !!M.clearcoatMap
              , ne = Ee && !!M.clearcoatNormalMap
              , Q = Ee && !!M.clearcoatRoughnessMap
              , he = Le && !!M.iridescenceMap
              , de = Le && !!M.iridescenceThicknessMap
              , ge = D && !!M.sheenColorMap
              , le = D && !!M.sheenRoughnessMap
              , xe = !!M.specularMap
              , Me = !!M.specularColorMap
              , Ne = !!M.specularIntensityMap
              , De = A && !!M.transmissionMap
              , Ve = A && !!M.thicknessMap
              , Ze = !!M.gradientMap
              , We = !!M.alphaMap
              , Qe = M.alphaTest > 0
              , pe = !!M.extensions
              , _e = !!C.attributes.uv1
              , we = !!C.attributes.uv2
              , Fe = !!C.attributes.uv3;
            return {
                isWebGL2: u,
                shaderID: W,
                shaderName: M.type,
                vertexShader: j,
                fragmentShader: w,
                defines: M.defines,
                customVertexShaderID: b,
                customFragmentShaderID: E,
                isRawShaderMaterial: M.isRawShaderMaterial === !0,
                glslVersion: M.glslVersion,
                precision: m,
                instancing: H,
                instancingColor: H && B.instanceColor !== null,
                supportsVertexTextures: f,
                outputColorSpace: T === null ? r.outputColorSpace : T.isXRRenderTarget === !0 ? T.texture.colorSpace : di,
                map: Y,
                matcap: X,
                envMap: ce,
                envMapMode: ce && F.mapping,
                envMapCubeUVHeight: U,
                aoMap: J,
                lightMap: ae,
                bumpMap: ie,
                normalMap: me,
                displacementMap: f && ve,
                emissiveMap: be,
                normalMapObjectSpace: me && M.normalMapType === p_,
                normalMapTangentSpace: me && M.normalMapType === Gh,
                metalnessMap: fe,
                roughnessMap: te,
                clearcoat: Ee,
                clearcoatMap: G,
                clearcoatNormalMap: ne,
                clearcoatRoughnessMap: Q,
                iridescence: Le,
                iridescenceMap: he,
                iridescenceThicknessMap: de,
                sheen: D,
                sheenColorMap: ge,
                sheenRoughnessMap: le,
                specularMap: xe,
                specularColorMap: Me,
                specularIntensityMap: Ne,
                transmission: A,
                transmissionMap: De,
                thicknessMap: Ve,
                gradientMap: Ze,
                opaque: M.transparent === !1 && M.blending === Pa,
                alphaMap: We,
                alphaTest: Qe,
                combine: M.combine,
                mapUv: Y && v(M.map.channel),
                aoMapUv: J && v(M.aoMap.channel),
                lightMapUv: ae && v(M.lightMap.channel),
                bumpMapUv: ie && v(M.bumpMap.channel),
                normalMapUv: me && v(M.normalMap.channel),
                displacementMapUv: ve && v(M.displacementMap.channel),
                emissiveMapUv: be && v(M.emissiveMap.channel),
                metalnessMapUv: fe && v(M.metalnessMap.channel),
                roughnessMapUv: te && v(M.roughnessMap.channel),
                clearcoatMapUv: G && v(M.clearcoatMap.channel),
                clearcoatNormalMapUv: ne && v(M.clearcoatNormalMap.channel),
                clearcoatRoughnessMapUv: Q && v(M.clearcoatRoughnessMap.channel),
                iridescenceMapUv: he && v(M.iridescenceMap.channel),
                iridescenceThicknessMapUv: de && v(M.iridescenceThicknessMap.channel),
                sheenColorMapUv: ge && v(M.sheenColorMap.channel),
                sheenRoughnessMapUv: le && v(M.sheenRoughnessMap.channel),
                specularMapUv: xe && v(M.specularMap.channel),
                specularColorMapUv: Me && v(M.specularColorMap.channel),
                specularIntensityMapUv: Ne && v(M.specularIntensityMap.channel),
                transmissionMapUv: De && v(M.transmissionMap.channel),
                thicknessMapUv: Ve && v(M.thicknessMap.channel),
                alphaMapUv: We && v(M.alphaMap.channel),
                vertexTangents: me && !!C.attributes.tangent,
                vertexColors: M.vertexColors,
                vertexAlphas: M.vertexColors === !0 && !!C.attributes.color && C.attributes.color.itemSize === 4,
                vertexUv1s: _e,
                vertexUv2s: we,
                vertexUv3s: Fe,
                pointsUvs: B.isPoints === !0 && !!C.attributes.uv && (Y || We),
                fog: !!P,
                useFog: M.fog === !0,
                fogExp2: P && P.isFogExp2,
                flatShading: M.flatShading === !0,
                sizeAttenuation: M.sizeAttenuation === !0,
                logarithmicDepthBuffer: h,
                skinning: B.isSkinnedMesh === !0,
                morphTargets: C.morphAttributes.position !== void 0,
                morphNormals: C.morphAttributes.normal !== void 0,
                morphColors: C.morphAttributes.color !== void 0,
                morphTargetsCount: re,
                morphTextureStride: oe,
                numDirLights: R.directional.length,
                numPointLights: R.point.length,
                numSpotLights: R.spot.length,
                numSpotLightMaps: R.spotLightMap.length,
                numRectAreaLights: R.rectArea.length,
                numHemiLights: R.hemi.length,
                numDirLightShadows: R.directionalShadowMap.length,
                numPointLightShadows: R.pointShadowMap.length,
                numSpotLightShadows: R.spotShadowMap.length,
                numSpotLightShadowsWithMaps: R.numSpotLightShadowsWithMaps,
                numClippingPlanes: o.numPlanes,
                numClipIntersection: o.numIntersection,
                dithering: M.dithering,
                shadowMapEnabled: r.shadowMap.enabled && q.length > 0,
                shadowMapType: r.shadowMap.type,
                toneMapping: M.toneMapped ? r.toneMapping : fs,
                useLegacyLights: r.useLegacyLights,
                premultipliedAlpha: M.premultipliedAlpha,
                doubleSided: M.side === On,
                flipSided: M.side === Mn,
                useDepthPacking: M.depthPacking >= 0,
                depthPacking: M.depthPacking || 0,
                index0AttributeName: M.index0AttributeName,
                extensionDerivatives: pe && M.extensions.derivatives === !0,
                extensionFragDepth: pe && M.extensions.fragDepth === !0,
                extensionDrawBuffers: pe && M.extensions.drawBuffers === !0,
                extensionShaderTextureLOD: pe && M.extensions.shaderTextureLOD === !0,
                rendererExtensionFragDepth: u || n.has("EXT_frag_depth"),
                rendererExtensionDrawBuffers: u || n.has("WEBGL_draw_buffers"),
                rendererExtensionShaderTextureLod: u || n.has("EXT_shader_texture_lod"),
                customProgramCacheKey: M.customProgramCacheKey()
            }
        }
        function d(M) {
            let R = [];
            if (M.shaderID ? R.push(M.shaderID) : (R.push(M.customVertexShaderID),
            R.push(M.customFragmentShaderID)),
            M.defines !== void 0)
                for (let q in M.defines)
                    R.push(q),
                    R.push(M.defines[q]);
            return M.isRawShaderMaterial === !1 && (x(R, M),
            y(R, M),
            R.push(r.outputColorSpace)),
            R.push(M.customProgramCacheKey),
            R.join()
        }
        function x(M, R) {
            M.push(R.precision),
            M.push(R.outputColorSpace),
            M.push(R.envMapMode),
            M.push(R.envMapCubeUVHeight),
            M.push(R.mapUv),
            M.push(R.alphaMapUv),
            M.push(R.lightMapUv),
            M.push(R.aoMapUv),
            M.push(R.bumpMapUv),
            M.push(R.normalMapUv),
            M.push(R.displacementMapUv),
            M.push(R.emissiveMapUv),
            M.push(R.metalnessMapUv),
            M.push(R.roughnessMapUv),
            M.push(R.clearcoatMapUv),
            M.push(R.clearcoatNormalMapUv),
            M.push(R.clearcoatRoughnessMapUv),
            M.push(R.iridescenceMapUv),
            M.push(R.iridescenceThicknessMapUv),
            M.push(R.sheenColorMapUv),
            M.push(R.sheenRoughnessMapUv),
            M.push(R.specularMapUv),
            M.push(R.specularColorMapUv),
            M.push(R.specularIntensityMapUv),
            M.push(R.transmissionMapUv),
            M.push(R.thicknessMapUv),
            M.push(R.combine),
            M.push(R.fogExp2),
            M.push(R.sizeAttenuation),
            M.push(R.morphTargetsCount),
            M.push(R.morphAttributeCount),
            M.push(R.numDirLights),
            M.push(R.numPointLights),
            M.push(R.numSpotLights),
            M.push(R.numSpotLightMaps),
            M.push(R.numHemiLights),
            M.push(R.numRectAreaLights),
            M.push(R.numDirLightShadows),
            M.push(R.numPointLightShadows),
            M.push(R.numSpotLightShadows),
            M.push(R.numSpotLightShadowsWithMaps),
            M.push(R.shadowMapType),
            M.push(R.toneMapping),
            M.push(R.numClippingPlanes),
            M.push(R.numClipIntersection),
            M.push(R.depthPacking)
        }
        function y(M, R) {
            a.disableAll(),
            R.isWebGL2 && a.enable(0),
            R.supportsVertexTextures && a.enable(1),
            R.instancing && a.enable(2),
            R.instancingColor && a.enable(3),
            R.matcap && a.enable(4),
            R.envMap && a.enable(5),
            R.normalMapObjectSpace && a.enable(6),
            R.normalMapTangentSpace && a.enable(7),
            R.clearcoat && a.enable(8),
            R.iridescence && a.enable(9),
            R.alphaTest && a.enable(10),
            R.vertexColors && a.enable(11),
            R.vertexAlphas && a.enable(12),
            R.vertexUv1s && a.enable(13),
            R.vertexUv2s && a.enable(14),
            R.vertexUv3s && a.enable(15),
            R.vertexTangents && a.enable(16),
            M.push(a.mask),
            a.disableAll(),
            R.fog && a.enable(0),
            R.useFog && a.enable(1),
            R.flatShading && a.enable(2),
            R.logarithmicDepthBuffer && a.enable(3),
            R.skinning && a.enable(4),
            R.morphTargets && a.enable(5),
            R.morphNormals && a.enable(6),
            R.morphColors && a.enable(7),
            R.premultipliedAlpha && a.enable(8),
            R.shadowMapEnabled && a.enable(9),
            R.useLegacyLights && a.enable(10),
            R.doubleSided && a.enable(11),
            R.flipSided && a.enable(12),
            R.useDepthPacking && a.enable(13),
            R.dithering && a.enable(14),
            R.transmission && a.enable(15),
            R.sheen && a.enable(16),
            R.opaque && a.enable(17),
            R.pointsUvs && a.enable(18),
            M.push(a.mask)
        }
        function _(M) {
            let R = g[M.type], q;
            if (R) {
                let k = Lr[R];
                q = q_.clone(k.uniforms)
            } else
                q = M.uniforms;
            return q
        }
        function S(M, R) {
            let q;
            for (let k = 0, B = c.length; k < B; k++) {
                let P = c[k];
                if (P.cacheKey === R) {
                    q = P,
                    ++q.usedTimes;
                    break
                }
            }
            return q === void 0 && (q = new KE(r,R,M,s),
            c.push(q)),
            q
        }
        function N(M) {
            if (--M.usedTimes === 0) {
                let R = c.indexOf(M);
                c[R] = c[c.length - 1],
                c.pop(),
                M.destroy()
            }
        }
        function I(M) {
            l.remove(M)
        }
        function O() {
            l.dispose()
        }
        return {
            getParameters: p,
            getProgramCacheKey: d,
            getUniforms: _,
            acquireProgram: S,
            releaseProgram: N,
            releaseShaderCache: I,
            programs: c,
            dispose: O
        }
    }
    function $E() {
        let r = new WeakMap;
        function e(s) {
            let o = r.get(s);
            return o === void 0 && (o = {},
            r.set(s, o)),
            o
        }
        function t(s) {
            r.delete(s)
        }
        function n(s, o, a) {
            r.get(s)[o] = a
        }
        function i() {
            r = new WeakMap
        }
        return {
            get: e,
            remove: t,
            update: n,
            dispose: i
        }
    }
    function QE(r, e) {
        return r.groupOrder !== e.groupOrder ? r.groupOrder - e.groupOrder : r.renderOrder !== e.renderOrder ? r.renderOrder - e.renderOrder : r.material.id !== e.material.id ? r.material.id - e.material.id : r.z !== e.z ? r.z - e.z : r.id - e.id
    }
    function B0(r, e) {
        return r.groupOrder !== e.groupOrder ? r.groupOrder - e.groupOrder : r.renderOrder !== e.renderOrder ? r.renderOrder - e.renderOrder : r.z !== e.z ? e.z - r.z : r.id - e.id
    }
    function G0() {
        let r = []
          , e = 0
          , t = []
          , n = []
          , i = [];
        function s() {
            e = 0,
            t.length = 0,
            n.length = 0,
            i.length = 0
        }
        function o(h, f, m, g, v, p) {
            let d = r[e];
            return d === void 0 ? (d = {
                id: h.id,
                object: h,
                geometry: f,
                material: m,
                groupOrder: g,
                renderOrder: h.renderOrder,
                z: v,
                group: p
            },
            r[e] = d) : (d.id = h.id,
            d.object = h,
            d.geometry = f,
            d.material = m,
            d.groupOrder = g,
            d.renderOrder = h.renderOrder,
            d.z = v,
            d.group = p),
            e++,
            d
        }
        function a(h, f, m, g, v, p) {
            let d = o(h, f, m, g, v, p);
            m.transmission > 0 ? n.push(d) : m.transparent === !0 ? i.push(d) : t.push(d)
        }
        function l(h, f, m, g, v, p) {
            let d = o(h, f, m, g, v, p);
            m.transmission > 0 ? n.unshift(d) : m.transparent === !0 ? i.unshift(d) : t.unshift(d)
        }
        function c(h, f) {
            t.length > 1 && t.sort(h || QE),
            n.length > 1 && n.sort(f || B0),
            i.length > 1 && i.sort(f || B0)
        }
        function u() {
            for (let h = e, f = r.length; h < f; h++) {
                let m = r[h];
                if (m.id === null)
                    break;
                m.id = null,
                m.object = null,
                m.geometry = null,
                m.material = null,
                m.group = null
            }
        }
        return {
            opaque: t,
            transmissive: n,
            transparent: i,
            init: s,
            push: a,
            unshift: l,
            finish: u,
            sort: c
        }
    }
    function eS() {
        let r = new WeakMap;
        function e(n, i) {
            let s = r.get(n), o;
            return s === void 0 ? (o = new G0,
            r.set(n, [o])) : i >= s.length ? (o = new G0,
            s.push(o)) : o = s[i],
            o
        }
        function t() {
            r = new WeakMap
        }
        return {
            get: e,
            dispose: t
        }
    }
    function tS() {
        let r = {};
        return {
            get: function(e) {
                if (r[e.id] !== void 0)
                    return r[e.id];
                let t;
                switch (e.type) {
                case "DirectionalLight":
                    t = {
                        direction: new ue,
                        color: new $e
                    };
                    break;
                case "SpotLight":
                    t = {
                        position: new ue,
                        direction: new ue,
                        color: new $e,
                        distance: 0,
                        coneCos: 0,
                        penumbraCos: 0,
                        decay: 0
                    };
                    break;
                case "PointLight":
                    t = {
                        position: new ue,
                        color: new $e,
                        distance: 0,
                        decay: 0
                    };
                    break;
                case "HemisphereLight":
                    t = {
                        direction: new ue,
                        skyColor: new $e,
                        groundColor: new $e
                    };
                    break;
                case "RectAreaLight":
                    t = {
                        color: new $e,
                        position: new ue,
                        halfWidth: new ue,
                        halfHeight: new ue
                    };
                    break
                }
                return r[e.id] = t,
                t
            }
        }
    }
    function nS() {
        let r = {};
        return {
            get: function(e) {
                if (r[e.id] !== void 0)
                    return r[e.id];
                let t;
                switch (e.type) {
                case "DirectionalLight":
                    t = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Ie
                    };
                    break;
                case "SpotLight":
                    t = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Ie
                    };
                    break;
                case "PointLight":
                    t = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Ie,
                        shadowCameraNear: 1,
                        shadowCameraFar: 1e3
                    };
                    break
                }
                return r[e.id] = t,
                t
            }
        }
    }
    var iS = 0;
    function rS(r, e) {
        return (e.castShadow ? 2 : 0) - (r.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (r.map ? 1 : 0)
    }
    function sS(r, e) {
        let t = new tS
          , n = nS()
          , i = {
            version: 0,
            hash: {
                directionalLength: -1,
                pointLength: -1,
                spotLength: -1,
                rectAreaLength: -1,
                hemiLength: -1,
                numDirectionalShadows: -1,
                numPointShadows: -1,
                numSpotShadows: -1,
                numSpotMaps: -1
            },
            ambient: [0, 0, 0],
            probe: [],
            directional: [],
            directionalShadow: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotLightMap: [],
            spotShadow: [],
            spotShadowMap: [],
            spotLightMatrix: [],
            rectArea: [],
            rectAreaLTC1: null,
            rectAreaLTC2: null,
            point: [],
            pointShadow: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: [],
            numSpotLightShadowsWithMaps: 0
        };
        for (let u = 0; u < 9; u++)
            i.probe.push(new ue);
        let s = new ue
          , o = new je
          , a = new je;
        function l(u, h) {
            let f = 0
              , m = 0
              , g = 0;
            for (let q = 0; q < 9; q++)
                i.probe[q].set(0, 0, 0);
            let v = 0
              , p = 0
              , d = 0
              , x = 0
              , y = 0
              , _ = 0
              , S = 0
              , N = 0
              , I = 0
              , O = 0;
            u.sort(rS);
            let M = h === !0 ? Math.PI : 1;
            for (let q = 0, k = u.length; q < k; q++) {
                let B = u[q]
                  , P = B.color
                  , C = B.intensity
                  , L = B.distance
                  , F = B.shadow && B.shadow.map ? B.shadow.map.texture : null;
                if (B.isAmbientLight)
                    f += P.r * C * M,
                    m += P.g * C * M,
                    g += P.b * C * M;
                else if (B.isLightProbe)
                    for (let U = 0; U < 9; U++)
                        i.probe[U].addScaledVector(B.sh.coefficients[U], C);
                else if (B.isDirectionalLight) {
                    let U = t.get(B);
                    if (U.color.copy(B.color).multiplyScalar(B.intensity * M),
                    B.castShadow) {
                        let W = B.shadow
                          , K = n.get(B);
                        K.shadowBias = W.bias,
                        K.shadowNormalBias = W.normalBias,
                        K.shadowRadius = W.radius,
                        K.shadowMapSize = W.mapSize,
                        i.directionalShadow[v] = K,
                        i.directionalShadowMap[v] = F,
                        i.directionalShadowMatrix[v] = B.shadow.matrix,
                        _++
                    }
                    i.directional[v] = U,
                    v++
                } else if (B.isSpotLight) {
                    let U = t.get(B);
                    U.position.setFromMatrixPosition(B.matrixWorld),
                    U.color.copy(P).multiplyScalar(C * M),
                    U.distance = L,
                    U.coneCos = Math.cos(B.angle),
                    U.penumbraCos = Math.cos(B.angle * (1 - B.penumbra)),
                    U.decay = B.decay,
                    i.spot[d] = U;
                    let W = B.shadow;
                    if (B.map && (i.spotLightMap[I] = B.map,
                    I++,
                    W.updateMatrices(B),
                    B.castShadow && O++),
                    i.spotLightMatrix[d] = W.matrix,
                    B.castShadow) {
                        let K = n.get(B);
                        K.shadowBias = W.bias,
                        K.shadowNormalBias = W.normalBias,
                        K.shadowRadius = W.radius,
                        K.shadowMapSize = W.mapSize,
                        i.spotShadow[d] = K,
                        i.spotShadowMap[d] = F,
                        N++
                    }
                    d++
                } else if (B.isRectAreaLight) {
                    let U = t.get(B);
                    U.color.copy(P).multiplyScalar(C),
                    U.halfWidth.set(B.width * .5, 0, 0),
                    U.halfHeight.set(0, B.height * .5, 0),
                    i.rectArea[x] = U,
                    x++
                } else if (B.isPointLight) {
                    let U = t.get(B);
                    if (U.color.copy(B.color).multiplyScalar(B.intensity * M),
                    U.distance = B.distance,
                    U.decay = B.decay,
                    B.castShadow) {
                        let W = B.shadow
                          , K = n.get(B);
                        K.shadowBias = W.bias,
                        K.shadowNormalBias = W.normalBias,
                        K.shadowRadius = W.radius,
                        K.shadowMapSize = W.mapSize,
                        K.shadowCameraNear = W.camera.near,
                        K.shadowCameraFar = W.camera.far,
                        i.pointShadow[p] = K,
                        i.pointShadowMap[p] = F,
                        i.pointShadowMatrix[p] = B.shadow.matrix,
                        S++
                    }
                    i.point[p] = U,
                    p++
                } else if (B.isHemisphereLight) {
                    let U = t.get(B);
                    U.skyColor.copy(B.color).multiplyScalar(C * M),
                    U.groundColor.copy(B.groundColor).multiplyScalar(C * M),
                    i.hemi[y] = U,
                    y++
                }
            }
            x > 0 && (e.isWebGL2 || r.has("OES_texture_float_linear") === !0 ? (i.rectAreaLTC1 = He.LTC_FLOAT_1,
            i.rectAreaLTC2 = He.LTC_FLOAT_2) : r.has("OES_texture_half_float_linear") === !0 ? (i.rectAreaLTC1 = He.LTC_HALF_1,
            i.rectAreaLTC2 = He.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),
            i.ambient[0] = f,
            i.ambient[1] = m,
            i.ambient[2] = g;
            let R = i.hash;
            (R.directionalLength !== v || R.pointLength !== p || R.spotLength !== d || R.rectAreaLength !== x || R.hemiLength !== y || R.numDirectionalShadows !== _ || R.numPointShadows !== S || R.numSpotShadows !== N || R.numSpotMaps !== I) && (i.directional.length = v,
            i.spot.length = d,
            i.rectArea.length = x,
            i.point.length = p,
            i.hemi.length = y,
            i.directionalShadow.length = _,
            i.directionalShadowMap.length = _,
            i.pointShadow.length = S,
            i.pointShadowMap.length = S,
            i.spotShadow.length = N,
            i.spotShadowMap.length = N,
            i.directionalShadowMatrix.length = _,
            i.pointShadowMatrix.length = S,
            i.spotLightMatrix.length = N + I - O,
            i.spotLightMap.length = I,
            i.numSpotLightShadowsWithMaps = O,
            R.directionalLength = v,
            R.pointLength = p,
            R.spotLength = d,
            R.rectAreaLength = x,
            R.hemiLength = y,
            R.numDirectionalShadows = _,
            R.numPointShadows = S,
            R.numSpotShadows = N,
            R.numSpotMaps = I,
            i.version = iS++)
        }
        function c(u, h) {
            let f = 0
              , m = 0
              , g = 0
              , v = 0
              , p = 0
              , d = h.matrixWorldInverse;
            for (let x = 0, y = u.length; x < y; x++) {
                let _ = u[x];
                if (_.isDirectionalLight) {
                    let S = i.directional[f];
                    S.direction.setFromMatrixPosition(_.matrixWorld),
                    s.setFromMatrixPosition(_.target.matrixWorld),
                    S.direction.sub(s),
                    S.direction.transformDirection(d),
                    f++
                } else if (_.isSpotLight) {
                    let S = i.spot[g];
                    S.position.setFromMatrixPosition(_.matrixWorld),
                    S.position.applyMatrix4(d),
                    S.direction.setFromMatrixPosition(_.matrixWorld),
                    s.setFromMatrixPosition(_.target.matrixWorld),
                    S.direction.sub(s),
                    S.direction.transformDirection(d),
                    g++
                } else if (_.isRectAreaLight) {
                    let S = i.rectArea[v];
                    S.position.setFromMatrixPosition(_.matrixWorld),
                    S.position.applyMatrix4(d),
                    a.identity(),
                    o.copy(_.matrixWorld),
                    o.premultiply(d),
                    a.extractRotation(o),
                    S.halfWidth.set(_.width * .5, 0, 0),
                    S.halfHeight.set(0, _.height * .5, 0),
                    S.halfWidth.applyMatrix4(a),
                    S.halfHeight.applyMatrix4(a),
                    v++
                } else if (_.isPointLight) {
                    let S = i.point[m];
                    S.position.setFromMatrixPosition(_.matrixWorld),
                    S.position.applyMatrix4(d),
                    m++
                } else if (_.isHemisphereLight) {
                    let S = i.hemi[p];
                    S.direction.setFromMatrixPosition(_.matrixWorld),
                    S.direction.transformDirection(d),
                    p++
                }
            }
        }
        return {
            setup: l,
            setupView: c,
            state: i
        }
    }
    function V0(r, e) {
        let t = new sS(r,e)
          , n = []
          , i = [];
        function s() {
            n.length = 0,
            i.length = 0
        }
        function o(h) {
            n.push(h)
        }
        function a(h) {
            i.push(h)
        }
        function l(h) {
            t.setup(n, h)
        }
        function c(h) {
            t.setupView(n, h)
        }
        return {
            init: s,
            state: {
                lightsArray: n,
                shadowsArray: i,
                lights: t
            },
            setupLights: l,
            setupLightsView: c,
            pushLight: o,
            pushShadow: a
        }
    }
    function oS(r, e) {
        let t = new WeakMap;
        function n(s, o=0) {
            let a = t.get(s), l;
            return a === void 0 ? (l = new V0(r,e),
            t.set(s, [l])) : o >= a.length ? (l = new V0(r,e),
            a.push(l)) : l = a[o],
            l
        }
        function i() {
            t = new WeakMap
        }
        return {
            get: n,
            dispose: i
        }
    }
    var cp = class extends ur {
        constructor(e) {
            super(),
            this.isMeshDepthMaterial = !0,
            this.type = "MeshDepthMaterial",
            this.depthPacking = f_,
            this.map = null,
            this.alphaMap = null,
            this.displacementMap = null,
            this.displacementScale = 1,
            this.displacementBias = 0,
            this.wireframe = !1,
            this.wireframeLinewidth = 1,
            this.setValues(e)
        }
        copy(e) {
            return super.copy(e),
            this.depthPacking = e.depthPacking,
            this.map = e.map,
            this.alphaMap = e.alphaMap,
            this.displacementMap = e.displacementMap,
            this.displacementScale = e.displacementScale,
            this.displacementBias = e.displacementBias,
            this.wireframe = e.wireframe,
            this.wireframeLinewidth = e.wireframeLinewidth,
            this
        }
    }
      , up = class extends ur {
        constructor(e) {
            super(),
            this.isMeshDistanceMaterial = !0,
            this.type = "MeshDistanceMaterial",
            this.map = null,
            this.alphaMap = null,
            this.displacementMap = null,
            this.displacementScale = 1,
            this.displacementBias = 0,
            this.setValues(e)
        }
        copy(e) {
            return super.copy(e),
            this.map = e.map,
            this.alphaMap = e.alphaMap,
            this.displacementMap = e.displacementMap,
            this.displacementScale = e.displacementScale,
            this.displacementBias = e.displacementBias,
            this
        }
    }
      , aS = `void main() {
	gl_Position = vec4( position, 1.0 );
}`
      , lS = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
    function cS(r, e, t) {
        let n = new Fc
          , i = new Ie
          , s = new Ie
          , o = new Lt
          , a = new cp({
            depthPacking: d_
        })
          , l = new up
          , c = {}
          , u = t.maxTextureSize
          , h = {
            [qi]: Mn,
            [Mn]: qi,
            [On]: On
        }
          , f = new ms({
            defines: {
                VSM_SAMPLES: 8
            },
            uniforms: {
                shadow_pass: {
                    value: null
                },
                resolution: {
                    value: new Ie
                },
                radius: {
                    value: 4
                }
            },
            vertexShader: aS,
            fragmentShader: lS
        })
          , m = f.clone();
        m.defines.HORIZONTAL_PASS = 1;
        let g = new wt;
        g.setAttribute("position", new zn(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]),3));
        let v = new Ht(g,f)
          , p = this;
        this.enabled = !1,
        this.autoUpdate = !0,
        this.needsUpdate = !1,
        this.type = uv;
        let d = this.type;
        this.render = function(S, N, I) {
            if (p.enabled === !1 || p.autoUpdate === !1 && p.needsUpdate === !1 || S.length === 0)
                return;
            let O = r.getRenderTarget()
              , M = r.getActiveCubeFace()
              , R = r.getActiveMipmapLevel()
              , q = r.state;
            q.setBlending(zs),
            q.buffers.color.setClear(1, 1, 1, 1),
            q.buffers.depth.setTest(!0),
            q.setScissorTest(!1);
            let k = d !== hs && this.type === hs
              , B = d === hs && this.type !== hs;
            for (let P = 0, C = S.length; P < C; P++) {
                let L = S[P]
                  , F = L.shadow;
                if (F === void 0) {
                    console.warn("THREE.WebGLShadowMap:", L, "has no shadow.");
                    continue
                }
                if (F.autoUpdate === !1 && F.needsUpdate === !1)
                    continue;
                i.copy(F.mapSize);
                let U = F.getFrameExtents();
                if (i.multiply(U),
                s.copy(F.mapSize),
                (i.x > u || i.y > u) && (i.x > u && (s.x = Math.floor(u / U.x),
                i.x = s.x * U.x,
                F.mapSize.x = s.x),
                i.y > u && (s.y = Math.floor(u / U.y),
                i.y = s.y * U.y,
                F.mapSize.y = s.y)),
                F.map === null || k === !0 || B === !0) {
                    let K = this.type !== hs ? {
                        minFilter: Tn,
                        magFilter: Tn
                    } : {};
                    F.map !== null && F.map.dispose(),
                    F.map = new ds(i.x,i.y,K),
                    F.map.texture.name = L.name + ".shadowMap",
                    F.camera.updateProjectionMatrix()
                }
                r.setRenderTarget(F.map),
                r.clear();
                let W = F.getViewportCount();
                for (let K = 0; K < W; K++) {
                    let re = F.getViewport(K);
                    o.set(s.x * re.x, s.y * re.y, s.x * re.z, s.y * re.w),
                    q.viewport(o),
                    F.updateMatrices(L, K),
                    n = F.getFrustum(),
                    _(N, I, F.camera, L, this.type)
                }
                F.isPointLightShadow !== !0 && this.type === hs && x(F, I),
                F.needsUpdate = !1
            }
            d = this.type,
            p.needsUpdate = !1,
            r.setRenderTarget(O, M, R)
        }
        ;
        function x(S, N) {
            let I = e.update(v);
            f.defines.VSM_SAMPLES !== S.blurSamples && (f.defines.VSM_SAMPLES = S.blurSamples,
            m.defines.VSM_SAMPLES = S.blurSamples,
            f.needsUpdate = !0,
            m.needsUpdate = !0),
            S.mapPass === null && (S.mapPass = new ds(i.x,i.y)),
            f.uniforms.shadow_pass.value = S.map.texture,
            f.uniforms.resolution.value = S.mapSize,
            f.uniforms.radius.value = S.radius,
            r.setRenderTarget(S.mapPass),
            r.clear(),
            r.renderBufferDirect(N, null, I, f, v, null),
            m.uniforms.shadow_pass.value = S.mapPass.texture,
            m.uniforms.resolution.value = S.mapSize,
            m.uniforms.radius.value = S.radius,
            r.setRenderTarget(S.map),
            r.clear(),
            r.renderBufferDirect(N, null, I, m, v, null)
        }
        function y(S, N, I, O) {
            let M = null
              , R = I.isPointLight === !0 ? S.customDistanceMaterial : S.customDepthMaterial;
            if (R !== void 0)
                M = R;
            else if (M = I.isPointLight === !0 ? l : a,
            r.localClippingEnabled && N.clipShadows === !0 && Array.isArray(N.clippingPlanes) && N.clippingPlanes.length !== 0 || N.displacementMap && N.displacementScale !== 0 || N.alphaMap && N.alphaTest > 0 || N.map && N.alphaTest > 0) {
                let q = M.uuid
                  , k = N.uuid
                  , B = c[q];
                B === void 0 && (B = {},
                c[q] = B);
                let P = B[k];
                P === void 0 && (P = M.clone(),
                B[k] = P),
                M = P
            }
            if (M.visible = N.visible,
            M.wireframe = N.wireframe,
            O === hs ? M.side = N.shadowSide !== null ? N.shadowSide : N.side : M.side = N.shadowSide !== null ? N.shadowSide : h[N.side],
            M.alphaMap = N.alphaMap,
            M.alphaTest = N.alphaTest,
            M.map = N.map,
            M.clipShadows = N.clipShadows,
            M.clippingPlanes = N.clippingPlanes,
            M.clipIntersection = N.clipIntersection,
            M.displacementMap = N.displacementMap,
            M.displacementScale = N.displacementScale,
            M.displacementBias = N.displacementBias,
            M.wireframeLinewidth = N.wireframeLinewidth,
            M.linewidth = N.linewidth,
            I.isPointLight === !0 && M.isMeshDistanceMaterial === !0) {
                let q = r.properties.get(M);
                q.light = I
            }
            return M
        }
        function _(S, N, I, O, M) {
            if (S.visible === !1)
                return;
            if (S.layers.test(N.layers) && (S.isMesh || S.isLine || S.isPoints) && (S.castShadow || S.receiveShadow && M === hs) && (!S.frustumCulled || n.intersectsObject(S))) {
                S.modelViewMatrix.multiplyMatrices(I.matrixWorldInverse, S.matrixWorld);
                let k = e.update(S)
                  , B = S.material;
                if (Array.isArray(B)) {
                    let P = k.groups;
                    for (let C = 0, L = P.length; C < L; C++) {
                        let F = P[C]
                          , U = B[F.materialIndex];
                        if (U && U.visible) {
                            let W = y(S, U, O, M);
                            r.renderBufferDirect(I, null, k, W, S, F)
                        }
                    }
                } else if (B.visible) {
                    let P = y(S, B, O, M);
                    r.renderBufferDirect(I, null, k, P, S, null)
                }
            }
            let q = S.children;
            for (let k = 0, B = q.length; k < B; k++)
                _(q[k], N, I, O, M)
        }
    }
    function uS(r, e, t) {
        let n = t.isWebGL2;
        function i() {
            let pe = !1
              , _e = new Lt
              , we = null
              , Fe = new Lt(0,0,0,0);
            return {
                setMask: function(Ue) {
                    we !== Ue && !pe && (r.colorMask(Ue, Ue, Ue, Ue),
                    we = Ue)
                },
                setLocked: function(Ue) {
                    pe = Ue
                },
                setClear: function(Ue, pt, mt, ot, Ke) {
                    Ke === !0 && (Ue *= ot,
                    pt *= ot,
                    mt *= ot),
                    _e.set(Ue, pt, mt, ot),
                    Fe.equals(_e) === !1 && (r.clearColor(Ue, pt, mt, ot),
                    Fe.copy(_e))
                },
                reset: function() {
                    pe = !1,
                    we = null,
                    Fe.set(-1, 0, 0, 0)
                }
            }
        }
        function s() {
            let pe = !1
              , _e = null
              , we = null
              , Fe = null;
            return {
                setTest: function(Ue) {
                    Ue ? T(r.DEPTH_TEST) : H(r.DEPTH_TEST)
                },
                setMask: function(Ue) {
                    _e !== Ue && !pe && (r.depthMask(Ue),
                    _e = Ue)
                },
                setFunc: function(Ue) {
                    if (we !== Ue) {
                        switch (Ue) {
                        case Ox:
                            r.depthFunc(r.NEVER);
                            break;
                        case Fx:
                            r.depthFunc(r.ALWAYS);
                            break;
                        case kx:
                            r.depthFunc(r.LESS);
                            break;
                        case Zd:
                            r.depthFunc(r.LEQUAL);
                            break;
                        case Ux:
                            r.depthFunc(r.EQUAL);
                            break;
                        case Bx:
                            r.depthFunc(r.GEQUAL);
                            break;
                        case Gx:
                            r.depthFunc(r.GREATER);
                            break;
                        case Vx:
                            r.depthFunc(r.NOTEQUAL);
                            break;
                        default:
                            r.depthFunc(r.LEQUAL)
                        }
                        we = Ue
                    }
                },
                setLocked: function(Ue) {
                    pe = Ue
                },
                setClear: function(Ue) {
                    Fe !== Ue && (r.clearDepth(Ue),
                    Fe = Ue)
                },
                reset: function() {
                    pe = !1,
                    _e = null,
                    we = null,
                    Fe = null
                }
            }
        }
        function o() {
            let pe = !1
              , _e = null
              , we = null
              , Fe = null
              , Ue = null
              , pt = null
              , mt = null
              , ot = null
              , Ke = null;
            return {
                setTest: function(ke) {
                    pe || (ke ? T(r.STENCIL_TEST) : H(r.STENCIL_TEST))
                },
                setMask: function(ke) {
                    _e !== ke && !pe && (r.stencilMask(ke),
                    _e = ke)
                },
                setFunc: function(ke, Be, Ye) {
                    (we !== ke || Fe !== Be || Ue !== Ye) && (r.stencilFunc(ke, Be, Ye),
                    we = ke,
                    Fe = Be,
                    Ue = Ye)
                },
                setOp: function(ke, Be, Ye) {
                    (pt !== ke || mt !== Be || ot !== Ye) && (r.stencilOp(ke, Be, Ye),
                    pt = ke,
                    mt = Be,
                    ot = Ye)
                },
                setLocked: function(ke) {
                    pe = ke
                },
                setClear: function(ke) {
                    Ke !== ke && (r.clearStencil(ke),
                    Ke = ke)
                },
                reset: function() {
                    pe = !1,
                    _e = null,
                    we = null,
                    Fe = null,
                    Ue = null,
                    pt = null,
                    mt = null,
                    ot = null,
                    Ke = null
                }
            }
        }
        let a = new i
          , l = new s
          , c = new o
          , u = new WeakMap
          , h = new WeakMap
          , f = {}
          , m = {}
          , g = new WeakMap
          , v = []
          , p = null
          , d = !1
          , x = null
          , y = null
          , _ = null
          , S = null
          , N = null
          , I = null
          , O = null
          , M = !1
          , R = null
          , q = null
          , k = null
          , B = null
          , P = null
          , C = r.getParameter(r.MAX_COMBINED_TEXTURE_IMAGE_UNITS)
          , L = !1
          , F = 0
          , U = r.getParameter(r.VERSION);
        U.indexOf("WebGL") !== -1 ? (F = parseFloat(/^WebGL (\d)/.exec(U)[1]),
        L = F >= 1) : U.indexOf("OpenGL ES") !== -1 && (F = parseFloat(/^OpenGL ES (\d)/.exec(U)[1]),
        L = F >= 2);
        let W = null
          , K = {}
          , re = r.getParameter(r.SCISSOR_BOX)
          , oe = r.getParameter(r.VIEWPORT)
          , j = new Lt().fromArray(re)
          , w = new Lt().fromArray(oe);
        function b(pe, _e, we, Fe) {
            let Ue = new Uint8Array(4)
              , pt = r.createTexture();
            r.bindTexture(pe, pt),
            r.texParameteri(pe, r.TEXTURE_MIN_FILTER, r.NEAREST),
            r.texParameteri(pe, r.TEXTURE_MAG_FILTER, r.NEAREST);
            for (let mt = 0; mt < we; mt++)
                n && (pe === r.TEXTURE_3D || pe === r.TEXTURE_2D_ARRAY) ? r.texImage3D(_e, 0, r.RGBA, 1, 1, Fe, 0, r.RGBA, r.UNSIGNED_BYTE, Ue) : r.texImage2D(_e + mt, 0, r.RGBA, 1, 1, 0, r.RGBA, r.UNSIGNED_BYTE, Ue);
            return pt
        }
        let E = {};
        E[r.TEXTURE_2D] = b(r.TEXTURE_2D, r.TEXTURE_2D, 1),
        E[r.TEXTURE_CUBE_MAP] = b(r.TEXTURE_CUBE_MAP, r.TEXTURE_CUBE_MAP_POSITIVE_X, 6),
        n && (E[r.TEXTURE_2D_ARRAY] = b(r.TEXTURE_2D_ARRAY, r.TEXTURE_2D_ARRAY, 1, 1),
        E[r.TEXTURE_3D] = b(r.TEXTURE_3D, r.TEXTURE_3D, 1, 1)),
        a.setClear(0, 0, 0, 1),
        l.setClear(1),
        c.setClear(0),
        T(r.DEPTH_TEST),
        l.setFunc(Zd),
        ve(!1),
        be(Eg),
        T(r.CULL_FACE),
        ie(zs);
        function T(pe) {
            f[pe] !== !0 && (r.enable(pe),
            f[pe] = !0)
        }
        function H(pe) {
            f[pe] !== !1 && (r.disable(pe),
            f[pe] = !1)
        }
        function Y(pe, _e) {
            return m[pe] !== _e ? (r.bindFramebuffer(pe, _e),
            m[pe] = _e,
            n && (pe === r.DRAW_FRAMEBUFFER && (m[r.FRAMEBUFFER] = _e),
            pe === r.FRAMEBUFFER && (m[r.DRAW_FRAMEBUFFER] = _e)),
            !0) : !1
        }
        function X(pe, _e) {
            let we = v
              , Fe = !1;
            if (pe)
                if (we = g.get(_e),
                we === void 0 && (we = [],
                g.set(_e, we)),
                pe.isWebGLMultipleRenderTargets) {
                    let Ue = pe.texture;
                    if (we.length !== Ue.length || we[0] !== r.COLOR_ATTACHMENT0) {
                        for (let pt = 0, mt = Ue.length; pt < mt; pt++)
                            we[pt] = r.COLOR_ATTACHMENT0 + pt;
                        we.length = Ue.length,
                        Fe = !0
                    }
                } else
                    we[0] !== r.COLOR_ATTACHMENT0 && (we[0] = r.COLOR_ATTACHMENT0,
                    Fe = !0);
            else
                we[0] !== r.BACK && (we[0] = r.BACK,
                Fe = !0);
            Fe && (t.isWebGL2 ? r.drawBuffers(we) : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(we))
        }
        function ce(pe) {
            return p !== pe ? (r.useProgram(pe),
            p = pe,
            !0) : !1
        }
        let J = {
            [Ca]: r.FUNC_ADD,
            [Ex]: r.FUNC_SUBTRACT,
            [Sx]: r.FUNC_REVERSE_SUBTRACT
        };
        if (n)
            J[Cg] = r.MIN,
            J[Ig] = r.MAX;
        else {
            let pe = e.get("EXT_blend_minmax");
            pe !== null && (J[Cg] = pe.MIN_EXT,
            J[Ig] = pe.MAX_EXT)
        }
        let ae = {
            [wx]: r.ZERO,
            [Ax]: r.ONE,
            [Cx]: r.SRC_COLOR,
            [hv]: r.SRC_ALPHA,
            [Dx]: r.SRC_ALPHA_SATURATE,
            [Lx]: r.DST_COLOR,
            [Rx]: r.DST_ALPHA,
            [Ix]: r.ONE_MINUS_SRC_COLOR,
            [fv]: r.ONE_MINUS_SRC_ALPHA,
            [Nx]: r.ONE_MINUS_DST_COLOR,
            [Px]: r.ONE_MINUS_DST_ALPHA
        };
        function ie(pe, _e, we, Fe, Ue, pt, mt, ot) {
            if (pe === zs) {
                d === !0 && (H(r.BLEND),
                d = !1);
                return
            }
            if (d === !1 && (T(r.BLEND),
            d = !0),
            pe !== Mx) {
                if (pe !== x || ot !== M) {
                    if ((y !== Ca || N !== Ca) && (r.blendEquation(r.FUNC_ADD),
                    y = Ca,
                    N = Ca),
                    ot)
                        switch (pe) {
                        case Pa:
                            r.blendFuncSeparate(r.ONE, r.ONE_MINUS_SRC_ALPHA, r.ONE, r.ONE_MINUS_SRC_ALPHA);
                            break;
                        case Sg:
                            r.blendFunc(r.ONE, r.ONE);
                            break;
                        case wg:
                            r.blendFuncSeparate(r.ZERO, r.ONE_MINUS_SRC_COLOR, r.ZERO, r.ONE);
                            break;
                        case Ag:
                            r.blendFuncSeparate(r.ZERO, r.SRC_COLOR, r.ZERO, r.SRC_ALPHA);
                            break;
                        default:
                            console.error("THREE.WebGLState: Invalid blending: ", pe);
                            break
                        }
                    else
                        switch (pe) {
                        case Pa:
                            r.blendFuncSeparate(r.SRC_ALPHA, r.ONE_MINUS_SRC_ALPHA, r.ONE, r.ONE_MINUS_SRC_ALPHA);
                            break;
                        case Sg:
                            r.blendFunc(r.SRC_ALPHA, r.ONE);
                            break;
                        case wg:
                            r.blendFuncSeparate(r.ZERO, r.ONE_MINUS_SRC_COLOR, r.ZERO, r.ONE);
                            break;
                        case Ag:
                            r.blendFunc(r.ZERO, r.SRC_COLOR);
                            break;
                        default:
                            console.error("THREE.WebGLState: Invalid blending: ", pe);
                            break
                        }
                    _ = null,
                    S = null,
                    I = null,
                    O = null,
                    x = pe,
                    M = ot
                }
                return
            }
            Ue = Ue || _e,
            pt = pt || we,
            mt = mt || Fe,
            (_e !== y || Ue !== N) && (r.blendEquationSeparate(J[_e], J[Ue]),
            y = _e,
            N = Ue),
            (we !== _ || Fe !== S || pt !== I || mt !== O) && (r.blendFuncSeparate(ae[we], ae[Fe], ae[pt], ae[mt]),
            _ = we,
            S = Fe,
            I = pt,
            O = mt),
            x = pe,
            M = !1
        }
        function me(pe, _e) {
            pe.side === On ? H(r.CULL_FACE) : T(r.CULL_FACE);
            let we = pe.side === Mn;
            _e && (we = !we),
            ve(we),
            pe.blending === Pa && pe.transparent === !1 ? ie(zs) : ie(pe.blending, pe.blendEquation, pe.blendSrc, pe.blendDst, pe.blendEquationAlpha, pe.blendSrcAlpha, pe.blendDstAlpha, pe.premultipliedAlpha),
            l.setFunc(pe.depthFunc),
            l.setTest(pe.depthTest),
            l.setMask(pe.depthWrite),
            a.setMask(pe.colorWrite);
            let Fe = pe.stencilWrite;
            c.setTest(Fe),
            Fe && (c.setMask(pe.stencilWriteMask),
            c.setFunc(pe.stencilFunc, pe.stencilRef, pe.stencilFuncMask),
            c.setOp(pe.stencilFail, pe.stencilZFail, pe.stencilZPass)),
            te(pe.polygonOffset, pe.polygonOffsetFactor, pe.polygonOffsetUnits),
            pe.alphaToCoverage === !0 ? T(r.SAMPLE_ALPHA_TO_COVERAGE) : H(r.SAMPLE_ALPHA_TO_COVERAGE)
        }
        function ve(pe) {
            R !== pe && (pe ? r.frontFace(r.CW) : r.frontFace(r.CCW),
            R = pe)
        }
        function be(pe) {
            pe !== _x ? (T(r.CULL_FACE),
            pe !== q && (pe === Eg ? r.cullFace(r.BACK) : pe === Tx ? r.cullFace(r.FRONT) : r.cullFace(r.FRONT_AND_BACK))) : H(r.CULL_FACE),
            q = pe
        }
        function fe(pe) {
            pe !== k && (L && r.lineWidth(pe),
            k = pe)
        }
        function te(pe, _e, we) {
            pe ? (T(r.POLYGON_OFFSET_FILL),
            (B !== _e || P !== we) && (r.polygonOffset(_e, we),
            B = _e,
            P = we)) : H(r.POLYGON_OFFSET_FILL)
        }
        function Ee(pe) {
            pe ? T(r.SCISSOR_TEST) : H(r.SCISSOR_TEST)
        }
        function Le(pe) {
            pe === void 0 && (pe = r.TEXTURE0 + C - 1),
            W !== pe && (r.activeTexture(pe),
            W = pe)
        }
        function D(pe, _e, we) {
            we === void 0 && (W === null ? we = r.TEXTURE0 + C - 1 : we = W);
            let Fe = K[we];
            Fe === void 0 && (Fe = {
                type: void 0,
                texture: void 0
            },
            K[we] = Fe),
            (Fe.type !== pe || Fe.texture !== _e) && (W !== we && (r.activeTexture(we),
            W = we),
            r.bindTexture(pe, _e || E[pe]),
            Fe.type = pe,
            Fe.texture = _e)
        }
        function A() {
            let pe = K[W];
            pe !== void 0 && pe.type !== void 0 && (r.bindTexture(pe.type, null),
            pe.type = void 0,
            pe.texture = void 0)
        }
        function G() {
            try {
                r.compressedTexImage2D.apply(r, arguments)
            } catch (pe) {
                console.error("THREE.WebGLState:", pe)
            }
        }
        function ne() {
            try {
                r.compressedTexImage3D.apply(r, arguments)
            } catch (pe) {
                console.error("THREE.WebGLState:", pe)
            }
        }
        function Q() {
            try {
                r.texSubImage2D.apply(r, arguments)
            } catch (pe) {
                console.error("THREE.WebGLState:", pe)
            }
        }
        function he() {
            try {
                r.texSubImage3D.apply(r, arguments)
            } catch (pe) {
                console.error("THREE.WebGLState:", pe)
            }
        }
        function de() {
            try {
                r.compressedTexSubImage2D.apply(r, arguments)
            } catch (pe) {
                console.error("THREE.WebGLState:", pe)
            }
        }
        function ge() {
            try {
                r.compressedTexSubImage3D.apply(r, arguments)
            } catch (pe) {
                console.error("THREE.WebGLState:", pe)
            }
        }
        function le() {
            try {
                r.texStorage2D.apply(r, arguments)
            } catch (pe) {
                console.error("THREE.WebGLState:", pe)
            }
        }
        function xe() {
            try {
                r.texStorage3D.apply(r, arguments)
            } catch (pe) {
                console.error("THREE.WebGLState:", pe)
            }
        }
        function Me() {
            try {
                r.texImage2D.apply(r, arguments)
            } catch (pe) {
                console.error("THREE.WebGLState:", pe)
            }
        }
        function Ne() {
            try {
                r.texImage3D.apply(r, arguments)
            } catch (pe) {
                console.error("THREE.WebGLState:", pe)
            }
        }
        function De(pe) {
            j.equals(pe) === !1 && (r.scissor(pe.x, pe.y, pe.z, pe.w),
            j.copy(pe))
        }
        function Ve(pe) {
            w.equals(pe) === !1 && (r.viewport(pe.x, pe.y, pe.z, pe.w),
            w.copy(pe))
        }
        function Ze(pe, _e) {
            let we = h.get(_e);
            we === void 0 && (we = new WeakMap,
            h.set(_e, we));
            let Fe = we.get(pe);
            Fe === void 0 && (Fe = r.getUniformBlockIndex(_e, pe.name),
            we.set(pe, Fe))
        }
        function We(pe, _e) {
            let Fe = h.get(_e).get(pe);
            u.get(_e) !== Fe && (r.uniformBlockBinding(_e, Fe, pe.__bindingPointIndex),
            u.set(_e, Fe))
        }
        function Qe() {
            r.disable(r.BLEND),
            r.disable(r.CULL_FACE),
            r.disable(r.DEPTH_TEST),
            r.disable(r.POLYGON_OFFSET_FILL),
            r.disable(r.SCISSOR_TEST),
            r.disable(r.STENCIL_TEST),
            r.disable(r.SAMPLE_ALPHA_TO_COVERAGE),
            r.blendEquation(r.FUNC_ADD),
            r.blendFunc(r.ONE, r.ZERO),
            r.blendFuncSeparate(r.ONE, r.ZERO, r.ONE, r.ZERO),
            r.colorMask(!0, !0, !0, !0),
            r.clearColor(0, 0, 0, 0),
            r.depthMask(!0),
            r.depthFunc(r.LESS),
            r.clearDepth(1),
            r.stencilMask(4294967295),
            r.stencilFunc(r.ALWAYS, 0, 4294967295),
            r.stencilOp(r.KEEP, r.KEEP, r.KEEP),
            r.clearStencil(0),
            r.cullFace(r.BACK),
            r.frontFace(r.CCW),
            r.polygonOffset(0, 0),
            r.activeTexture(r.TEXTURE0),
            r.bindFramebuffer(r.FRAMEBUFFER, null),
            n === !0 && (r.bindFramebuffer(r.DRAW_FRAMEBUFFER, null),
            r.bindFramebuffer(r.READ_FRAMEBUFFER, null)),
            r.useProgram(null),
            r.lineWidth(1),
            r.scissor(0, 0, r.canvas.width, r.canvas.height),
            r.viewport(0, 0, r.canvas.width, r.canvas.height),
            f = {},
            W = null,
            K = {},
            m = {},
            g = new WeakMap,
            v = [],
            p = null,
            d = !1,
            x = null,
            y = null,
            _ = null,
            S = null,
            N = null,
            I = null,
            O = null,
            M = !1,
            R = null,
            q = null,
            k = null,
            B = null,
            P = null,
            j.set(0, 0, r.canvas.width, r.canvas.height),
            w.set(0, 0, r.canvas.width, r.canvas.height),
            a.reset(),
            l.reset(),
            c.reset()
        }
        return {
            buffers: {
                color: a,
                depth: l,
                stencil: c
            },
            enable: T,
            disable: H,
            bindFramebuffer: Y,
            drawBuffers: X,
            useProgram: ce,
            setBlending: ie,
            setMaterial: me,
            setFlipSided: ve,
            setCullFace: be,
            setLineWidth: fe,
            setPolygonOffset: te,
            setScissorTest: Ee,
            activeTexture: Le,
            bindTexture: D,
            unbindTexture: A,
            compressedTexImage2D: G,
            compressedTexImage3D: ne,
            texImage2D: Me,
            texImage3D: Ne,
            updateUBOMapping: Ze,
            uniformBlockBinding: We,
            texStorage2D: le,
            texStorage3D: xe,
            texSubImage2D: Q,
            texSubImage3D: he,
            compressedTexSubImage2D: de,
            compressedTexSubImage3D: ge,
            scissor: De,
            viewport: Ve,
            reset: Qe
        }
    }
    function hS(r, e, t, n, i, s, o) {
        let a = i.isWebGL2, l = i.maxTextures, c = i.maxCubemapSize, u = i.maxTextureSize, h = i.maxSamples, f = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null, m = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent), g = new WeakMap, v, p = new WeakMap, d = !1;
        try {
            d = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1,1).getContext("2d") !== null
        } catch {}
        function x(D, A) {
            return d ? new OffscreenCanvas(D,A) : Nc("canvas")
        }
        function y(D, A, G, ne) {
            let Q = 1;
            if ((D.width > ne || D.height > ne) && (Q = ne / Math.max(D.width, D.height)),
            Q < 1 || A === !0)
                if (typeof HTMLImageElement < "u" && D instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && D instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && D instanceof ImageBitmap) {
                    let he = A ? yv : Math.floor
                      , de = he(Q * D.width)
                      , ge = he(Q * D.height);
                    v === void 0 && (v = x(de, ge));
                    let le = G ? x(de, ge) : v;
                    return le.width = de,
                    le.height = ge,
                    le.getContext("2d").drawImage(D, 0, 0, de, ge),
                    console.warn("THREE.WebGLRenderer: Texture has been resized from (" + D.width + "x" + D.height + ") to (" + de + "x" + ge + ")."),
                    le
                } else
                    return "data"in D && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + D.width + "x" + D.height + ")."),
                    D;
            return D
        }
        function _(D) {
            return Qd(D.width) && Qd(D.height)
        }
        function S(D) {
            return a ? !1 : D.wrapS !== Zt || D.wrapT !== Zt || D.minFilter !== Tn && D.minFilter !== bn
        }
        function N(D, A) {
            return D.generateMipmaps && A && D.minFilter !== Tn && D.minFilter !== bn
        }
        function I(D) {
            r.generateMipmap(D)
        }
        function O(D, A, G, ne, Q=!1) {
            if (a === !1)
                return A;
            if (D !== null) {
                if (r[D] !== void 0)
                    return r[D];
                console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + D + "'")
            }
            let he = A;
            return A === r.RED && (G === r.FLOAT && (he = r.R32F),
            G === r.HALF_FLOAT && (he = r.R16F),
            G === r.UNSIGNED_BYTE && (he = r.R8)),
            A === r.RG && (G === r.FLOAT && (he = r.RG32F),
            G === r.HALF_FLOAT && (he = r.RG16F),
            G === r.UNSIGNED_BYTE && (he = r.RG8)),
            A === r.RGBA && (G === r.FLOAT && (he = r.RGBA32F),
            G === r.HALF_FLOAT && (he = r.RGBA16F),
            G === r.UNSIGNED_BYTE && (he = ne === ct && Q === !1 ? r.SRGB8_ALPHA8 : r.RGBA8),
            G === r.UNSIGNED_SHORT_4_4_4_4 && (he = r.RGBA4),
            G === r.UNSIGNED_SHORT_5_5_5_1 && (he = r.RGB5_A1)),
            (he === r.R16F || he === r.R32F || he === r.RG16F || he === r.RG32F || he === r.RGBA16F || he === r.RGBA32F) && e.get("EXT_color_buffer_float"),
            he
        }
        function M(D, A, G) {
            return N(D, G) === !0 || D.isFramebufferTexture && D.minFilter !== Tn && D.minFilter !== bn ? Math.log2(Math.max(A.width, A.height)) + 1 : D.mipmaps !== void 0 && D.mipmaps.length > 0 ? D.mipmaps.length : D.isCompressedTexture && Array.isArray(D.image) ? A.mipmaps.length : 1
        }
        function R(D) {
            return D === Tn || D === Rg || D === md ? r.NEAREST : r.LINEAR
        }
        function q(D) {
            let A = D.target;
            A.removeEventListener("dispose", q),
            B(A),
            A.isVideoTexture && g.delete(A)
        }
        function k(D) {
            let A = D.target;
            A.removeEventListener("dispose", k),
            C(A)
        }
        function B(D) {
            let A = n.get(D);
            if (A.__webglInit === void 0)
                return;
            let G = D.source
              , ne = p.get(G);
            if (ne) {
                let Q = ne[A.__cacheKey];
                Q.usedTimes--,
                Q.usedTimes === 0 && P(D),
                Object.keys(ne).length === 0 && p.delete(G)
            }
            n.remove(D)
        }
        function P(D) {
            let A = n.get(D);
            r.deleteTexture(A.__webglTexture);
            let G = D.source
              , ne = p.get(G);
            delete ne[A.__cacheKey],
            o.memory.textures--
        }
        function C(D) {
            let A = D.texture
              , G = n.get(D)
              , ne = n.get(A);
            if (ne.__webglTexture !== void 0 && (r.deleteTexture(ne.__webglTexture),
            o.memory.textures--),
            D.depthTexture && D.depthTexture.dispose(),
            D.isWebGLCubeRenderTarget)
                for (let Q = 0; Q < 6; Q++)
                    r.deleteFramebuffer(G.__webglFramebuffer[Q]),
                    G.__webglDepthbuffer && r.deleteRenderbuffer(G.__webglDepthbuffer[Q]);
            else {
                if (r.deleteFramebuffer(G.__webglFramebuffer),
                G.__webglDepthbuffer && r.deleteRenderbuffer(G.__webglDepthbuffer),
                G.__webglMultisampledFramebuffer && r.deleteFramebuffer(G.__webglMultisampledFramebuffer),
                G.__webglColorRenderbuffer)
                    for (let Q = 0; Q < G.__webglColorRenderbuffer.length; Q++)
                        G.__webglColorRenderbuffer[Q] && r.deleteRenderbuffer(G.__webglColorRenderbuffer[Q]);
                G.__webglDepthRenderbuffer && r.deleteRenderbuffer(G.__webglDepthRenderbuffer)
            }
            if (D.isWebGLMultipleRenderTargets)
                for (let Q = 0, he = A.length; Q < he; Q++) {
                    let de = n.get(A[Q]);
                    de.__webglTexture && (r.deleteTexture(de.__webglTexture),
                    o.memory.textures--),
                    n.remove(A[Q])
                }
            n.remove(A),
            n.remove(D)
        }
        let L = 0;
        function F() {
            L = 0
        }
        function U() {
            let D = L;
            return D >= l && console.warn("THREE.WebGLTextures: Trying to use " + D + " texture units while this GPU supports only " + l),
            L += 1,
            D
        }
        function W(D) {
            let A = [];
            return A.push(D.wrapS),
            A.push(D.wrapT),
            A.push(D.wrapR || 0),
            A.push(D.magFilter),
            A.push(D.minFilter),
            A.push(D.anisotropy),
            A.push(D.internalFormat),
            A.push(D.format),
            A.push(D.type),
            A.push(D.generateMipmaps),
            A.push(D.premultiplyAlpha),
            A.push(D.flipY),
            A.push(D.unpackAlignment),
            A.push(D.colorSpace),
            A.join()
        }
        function K(D, A) {
            let G = n.get(D);
            if (D.isVideoTexture && Ee(D),
            D.isRenderTargetTexture === !1 && D.version > 0 && G.__version !== D.version) {
                let ne = D.image;
                if (ne === null)
                    console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
                else if (ne.complete === !1)
                    console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
                else {
                    H(G, D, A);
                    return
                }
            }
            t.bindTexture(r.TEXTURE_2D, G.__webglTexture, r.TEXTURE0 + A)
        }
        function re(D, A) {
            let G = n.get(D);
            if (D.version > 0 && G.__version !== D.version) {
                H(G, D, A);
                return
            }
            t.bindTexture(r.TEXTURE_2D_ARRAY, G.__webglTexture, r.TEXTURE0 + A)
        }
        function oe(D, A) {
            let G = n.get(D);
            if (D.version > 0 && G.__version !== D.version) {
                H(G, D, A);
                return
            }
            t.bindTexture(r.TEXTURE_3D, G.__webglTexture, r.TEXTURE0 + A)
        }
        function j(D, A) {
            let G = n.get(D);
            if (D.version > 0 && G.__version !== D.version) {
                Y(G, D, A);
                return
            }
            t.bindTexture(r.TEXTURE_CUBE_MAP, G.__webglTexture, r.TEXTURE0 + A)
        }
        let w = {
            [rn]: r.REPEAT,
            [Zt]: r.CLAMP_TO_EDGE,
            [Ua]: r.MIRRORED_REPEAT
        }
          , b = {
            [Tn]: r.NEAREST,
            [Rg]: r.NEAREST_MIPMAP_NEAREST,
            [md]: r.NEAREST_MIPMAP_LINEAR,
            [bn]: r.LINEAR,
            [Kx]: r.LINEAR_MIPMAP_NEAREST,
            [lr]: r.LINEAR_MIPMAP_LINEAR
        };
        function E(D, A, G) {
            if (G ? (r.texParameteri(D, r.TEXTURE_WRAP_S, w[A.wrapS]),
            r.texParameteri(D, r.TEXTURE_WRAP_T, w[A.wrapT]),
            (D === r.TEXTURE_3D || D === r.TEXTURE_2D_ARRAY) && r.texParameteri(D, r.TEXTURE_WRAP_R, w[A.wrapR]),
            r.texParameteri(D, r.TEXTURE_MAG_FILTER, b[A.magFilter]),
            r.texParameteri(D, r.TEXTURE_MIN_FILTER, b[A.minFilter])) : (r.texParameteri(D, r.TEXTURE_WRAP_S, r.CLAMP_TO_EDGE),
            r.texParameteri(D, r.TEXTURE_WRAP_T, r.CLAMP_TO_EDGE),
            (D === r.TEXTURE_3D || D === r.TEXTURE_2D_ARRAY) && r.texParameteri(D, r.TEXTURE_WRAP_R, r.CLAMP_TO_EDGE),
            (A.wrapS !== Zt || A.wrapT !== Zt) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),
            r.texParameteri(D, r.TEXTURE_MAG_FILTER, R(A.magFilter)),
            r.texParameteri(D, r.TEXTURE_MIN_FILTER, R(A.minFilter)),
            A.minFilter !== Tn && A.minFilter !== bn && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),
            e.has("EXT_texture_filter_anisotropic") === !0) {
                let ne = e.get("EXT_texture_filter_anisotropic");
                if (A.magFilter === Tn || A.minFilter !== md && A.minFilter !== lr || A.type === Vs && e.has("OES_texture_float_linear") === !1 || a === !1 && A.type === Lc && e.has("OES_texture_half_float_linear") === !1)
                    return;
                (A.anisotropy > 1 || n.get(A).__currentAnisotropy) && (r.texParameterf(D, ne.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(A.anisotropy, i.getMaxAnisotropy())),
                n.get(A).__currentAnisotropy = A.anisotropy)
            }
        }
        function T(D, A) {
            let G = !1;
            D.__webglInit === void 0 && (D.__webglInit = !0,
            A.addEventListener("dispose", q));
            let ne = A.source
              , Q = p.get(ne);
            Q === void 0 && (Q = {},
            p.set(ne, Q));
            let he = W(A);
            if (he !== D.__cacheKey) {
                Q[he] === void 0 && (Q[he] = {
                    texture: r.createTexture(),
                    usedTimes: 0
                },
                o.memory.textures++,
                G = !0),
                Q[he].usedTimes++;
                let de = Q[D.__cacheKey];
                de !== void 0 && (Q[D.__cacheKey].usedTimes--,
                de.usedTimes === 0 && P(A)),
                D.__cacheKey = he,
                D.__webglTexture = Q[he].texture
            }
            return G
        }
        function H(D, A, G) {
            let ne = r.TEXTURE_2D;
            (A.isDataArrayTexture || A.isCompressedArrayTexture) && (ne = r.TEXTURE_2D_ARRAY),
            A.isData3DTexture && (ne = r.TEXTURE_3D);
            let Q = T(D, A)
              , he = A.source;
            t.bindTexture(ne, D.__webglTexture, r.TEXTURE0 + G);
            let de = n.get(he);
            if (he.version !== de.__version || Q === !0) {
                t.activeTexture(r.TEXTURE0 + G),
                r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, A.flipY),
                r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, A.premultiplyAlpha),
                r.pixelStorei(r.UNPACK_ALIGNMENT, A.unpackAlignment),
                r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL, r.NONE);
                let ge = S(A) && _(A.image) === !1
                  , le = y(A.image, ge, !1, u);
                le = Le(A, le);
                let xe = _(le) || a
                  , Me = s.convert(A.format, A.colorSpace)
                  , Ne = s.convert(A.type)
                  , De = O(A.internalFormat, Me, Ne, A.colorSpace);
                E(ne, A, xe);
                let Ve, Ze = A.mipmaps, We = a && A.isVideoTexture !== !0, Qe = de.__version === void 0 || Q === !0, pe = M(A, le, xe);
                if (A.isDepthTexture)
                    De = r.DEPTH_COMPONENT,
                    a ? A.type === Vs ? De = r.DEPTH_COMPONENT32F : A.type === Co ? De = r.DEPTH_COMPONENT24 : A.type === La ? De = r.DEPTH24_STENCIL8 : De = r.DEPTH_COMPONENT16 : A.type === Vs && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),
                    A.format === Io && De === r.DEPTH_COMPONENT && A.type !== pv && A.type !== Co && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),
                    A.type = Co,
                    Ne = s.convert(A.type)),
                    A.format === Ba && De === r.DEPTH_COMPONENT && (De = r.DEPTH_STENCIL,
                    A.type !== La && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),
                    A.type = La,
                    Ne = s.convert(A.type))),
                    Qe && (We ? t.texStorage2D(r.TEXTURE_2D, 1, De, le.width, le.height) : t.texImage2D(r.TEXTURE_2D, 0, De, le.width, le.height, 0, Me, Ne, null));
                else if (A.isDataTexture)
                    if (Ze.length > 0 && xe) {
                        We && Qe && t.texStorage2D(r.TEXTURE_2D, pe, De, Ze[0].width, Ze[0].height);
                        for (let _e = 0, we = Ze.length; _e < we; _e++)
                            Ve = Ze[_e],
                            We ? t.texSubImage2D(r.TEXTURE_2D, _e, 0, 0, Ve.width, Ve.height, Me, Ne, Ve.data) : t.texImage2D(r.TEXTURE_2D, _e, De, Ve.width, Ve.height, 0, Me, Ne, Ve.data);
                        A.generateMipmaps = !1
                    } else
                        We ? (Qe && t.texStorage2D(r.TEXTURE_2D, pe, De, le.width, le.height),
                        t.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, le.width, le.height, Me, Ne, le.data)) : t.texImage2D(r.TEXTURE_2D, 0, De, le.width, le.height, 0, Me, Ne, le.data);
                else if (A.isCompressedTexture)
                    if (A.isCompressedArrayTexture) {
                        We && Qe && t.texStorage3D(r.TEXTURE_2D_ARRAY, pe, De, Ze[0].width, Ze[0].height, le.depth);
                        for (let _e = 0, we = Ze.length; _e < we; _e++)
                            Ve = Ze[_e],
                            A.format !== Xi ? Me !== null ? We ? t.compressedTexSubImage3D(r.TEXTURE_2D_ARRAY, _e, 0, 0, 0, Ve.width, Ve.height, le.depth, Me, Ve.data, 0, 0) : t.compressedTexImage3D(r.TEXTURE_2D_ARRAY, _e, De, Ve.width, Ve.height, le.depth, 0, Ve.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : We ? t.texSubImage3D(r.TEXTURE_2D_ARRAY, _e, 0, 0, 0, Ve.width, Ve.height, le.depth, Me, Ne, Ve.data) : t.texImage3D(r.TEXTURE_2D_ARRAY, _e, De, Ve.width, Ve.height, le.depth, 0, Me, Ne, Ve.data)
                    } else {
                        We && Qe && t.texStorage2D(r.TEXTURE_2D, pe, De, Ze[0].width, Ze[0].height);
                        for (let _e = 0, we = Ze.length; _e < we; _e++)
                            Ve = Ze[_e],
                            A.format !== Xi ? Me !== null ? We ? t.compressedTexSubImage2D(r.TEXTURE_2D, _e, 0, 0, Ve.width, Ve.height, Me, Ve.data) : t.compressedTexImage2D(r.TEXTURE_2D, _e, De, Ve.width, Ve.height, 0, Ve.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : We ? t.texSubImage2D(r.TEXTURE_2D, _e, 0, 0, Ve.width, Ve.height, Me, Ne, Ve.data) : t.texImage2D(r.TEXTURE_2D, _e, De, Ve.width, Ve.height, 0, Me, Ne, Ve.data)
                    }
                else if (A.isDataArrayTexture)
                    We ? (Qe && t.texStorage3D(r.TEXTURE_2D_ARRAY, pe, De, le.width, le.height, le.depth),
                    t.texSubImage3D(r.TEXTURE_2D_ARRAY, 0, 0, 0, 0, le.width, le.height, le.depth, Me, Ne, le.data)) : t.texImage3D(r.TEXTURE_2D_ARRAY, 0, De, le.width, le.height, le.depth, 0, Me, Ne, le.data);
                else if (A.isData3DTexture)
                    We ? (Qe && t.texStorage3D(r.TEXTURE_3D, pe, De, le.width, le.height, le.depth),
                    t.texSubImage3D(r.TEXTURE_3D, 0, 0, 0, 0, le.width, le.height, le.depth, Me, Ne, le.data)) : t.texImage3D(r.TEXTURE_3D, 0, De, le.width, le.height, le.depth, 0, Me, Ne, le.data);
                else if (A.isFramebufferTexture) {
                    if (Qe)
                        if (We)
                            t.texStorage2D(r.TEXTURE_2D, pe, De, le.width, le.height);
                        else {
                            let _e = le.width
                              , we = le.height;
                            for (let Fe = 0; Fe < pe; Fe++)
                                t.texImage2D(r.TEXTURE_2D, Fe, De, _e, we, 0, Me, Ne, null),
                                _e >>= 1,
                                we >>= 1
                        }
                } else if (Ze.length > 0 && xe) {
                    We && Qe && t.texStorage2D(r.TEXTURE_2D, pe, De, Ze[0].width, Ze[0].height);
                    for (let _e = 0, we = Ze.length; _e < we; _e++)
                        Ve = Ze[_e],
                        We ? t.texSubImage2D(r.TEXTURE_2D, _e, 0, 0, Me, Ne, Ve) : t.texImage2D(r.TEXTURE_2D, _e, De, Me, Ne, Ve);
                    A.generateMipmaps = !1
                } else
                    We ? (Qe && t.texStorage2D(r.TEXTURE_2D, pe, De, le.width, le.height),
                    t.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, Me, Ne, le)) : t.texImage2D(r.TEXTURE_2D, 0, De, Me, Ne, le);
                N(A, xe) && I(ne),
                de.__version = he.version,
                A.onUpdate && A.onUpdate(A)
            }
            D.__version = A.version
        }
        function Y(D, A, G) {
            if (A.image.length !== 6)
                return;
            let ne = T(D, A)
              , Q = A.source;
            t.bindTexture(r.TEXTURE_CUBE_MAP, D.__webglTexture, r.TEXTURE0 + G);
            let he = n.get(Q);
            if (Q.version !== he.__version || ne === !0) {
                t.activeTexture(r.TEXTURE0 + G),
                r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, A.flipY),
                r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, A.premultiplyAlpha),
                r.pixelStorei(r.UNPACK_ALIGNMENT, A.unpackAlignment),
                r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL, r.NONE);
                let de = A.isCompressedTexture || A.image[0].isCompressedTexture
                  , ge = A.image[0] && A.image[0].isDataTexture
                  , le = [];
                for (let _e = 0; _e < 6; _e++)
                    !de && !ge ? le[_e] = y(A.image[_e], !1, !0, c) : le[_e] = ge ? A.image[_e].image : A.image[_e],
                    le[_e] = Le(A, le[_e]);
                let xe = le[0]
                  , Me = _(xe) || a
                  , Ne = s.convert(A.format, A.colorSpace)
                  , De = s.convert(A.type)
                  , Ve = O(A.internalFormat, Ne, De, A.colorSpace)
                  , Ze = a && A.isVideoTexture !== !0
                  , We = he.__version === void 0 || ne === !0
                  , Qe = M(A, xe, Me);
                E(r.TEXTURE_CUBE_MAP, A, Me);
                let pe;
                if (de) {
                    Ze && We && t.texStorage2D(r.TEXTURE_CUBE_MAP, Qe, Ve, xe.width, xe.height);
                    for (let _e = 0; _e < 6; _e++) {
                        pe = le[_e].mipmaps;
                        for (let we = 0; we < pe.length; we++) {
                            let Fe = pe[we];
                            A.format !== Xi ? Ne !== null ? Ze ? t.compressedTexSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + _e, we, 0, 0, Fe.width, Fe.height, Ne, Fe.data) : t.compressedTexImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + _e, we, Ve, Fe.width, Fe.height, 0, Fe.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : Ze ? t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + _e, we, 0, 0, Fe.width, Fe.height, Ne, De, Fe.data) : t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + _e, we, Ve, Fe.width, Fe.height, 0, Ne, De, Fe.data)
                        }
                    }
                } else {
                    pe = A.mipmaps,
                    Ze && We && (pe.length > 0 && Qe++,
                    t.texStorage2D(r.TEXTURE_CUBE_MAP, Qe, Ve, le[0].width, le[0].height));
                    for (let _e = 0; _e < 6; _e++)
                        if (ge) {
                            Ze ? t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + _e, 0, 0, 0, le[_e].width, le[_e].height, Ne, De, le[_e].data) : t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + _e, 0, Ve, le[_e].width, le[_e].height, 0, Ne, De, le[_e].data);
                            for (let we = 0; we < pe.length; we++) {
                                let Ue = pe[we].image[_e].image;
                                Ze ? t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + _e, we + 1, 0, 0, Ue.width, Ue.height, Ne, De, Ue.data) : t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + _e, we + 1, Ve, Ue.width, Ue.height, 0, Ne, De, Ue.data)
                            }
                        } else {
                            Ze ? t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + _e, 0, 0, 0, Ne, De, le[_e]) : t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + _e, 0, Ve, Ne, De, le[_e]);
                            for (let we = 0; we < pe.length; we++) {
                                let Fe = pe[we];
                                Ze ? t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + _e, we + 1, 0, 0, Ne, De, Fe.image[_e]) : t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + _e, we + 1, Ve, Ne, De, Fe.image[_e])
                            }
                        }
                }
                N(A, Me) && I(r.TEXTURE_CUBE_MAP),
                he.__version = Q.version,
                A.onUpdate && A.onUpdate(A)
            }
            D.__version = A.version
        }
        function X(D, A, G, ne, Q) {
            let he = s.convert(G.format, G.colorSpace)
              , de = s.convert(G.type)
              , ge = O(G.internalFormat, he, de, G.colorSpace);
            n.get(A).__hasExternalTextures || (Q === r.TEXTURE_3D || Q === r.TEXTURE_2D_ARRAY ? t.texImage3D(Q, 0, ge, A.width, A.height, A.depth, 0, he, de, null) : t.texImage2D(Q, 0, ge, A.width, A.height, 0, he, de, null)),
            t.bindFramebuffer(r.FRAMEBUFFER, D),
            te(A) ? f.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, ne, Q, n.get(G).__webglTexture, 0, fe(A)) : (Q === r.TEXTURE_2D || Q >= r.TEXTURE_CUBE_MAP_POSITIVE_X && Q <= r.TEXTURE_CUBE_MAP_NEGATIVE_Z) && r.framebufferTexture2D(r.FRAMEBUFFER, ne, Q, n.get(G).__webglTexture, 0),
            t.bindFramebuffer(r.FRAMEBUFFER, null)
        }
        function ce(D, A, G) {
            if (r.bindRenderbuffer(r.RENDERBUFFER, D),
            A.depthBuffer && !A.stencilBuffer) {
                let ne = r.DEPTH_COMPONENT16;
                if (G || te(A)) {
                    let Q = A.depthTexture;
                    Q && Q.isDepthTexture && (Q.type === Vs ? ne = r.DEPTH_COMPONENT32F : Q.type === Co && (ne = r.DEPTH_COMPONENT24));
                    let he = fe(A);
                    te(A) ? f.renderbufferStorageMultisampleEXT(r.RENDERBUFFER, he, ne, A.width, A.height) : r.renderbufferStorageMultisample(r.RENDERBUFFER, he, ne, A.width, A.height)
                } else
                    r.renderbufferStorage(r.RENDERBUFFER, ne, A.width, A.height);
                r.framebufferRenderbuffer(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.RENDERBUFFER, D)
            } else if (A.depthBuffer && A.stencilBuffer) {
                let ne = fe(A);
                G && te(A) === !1 ? r.renderbufferStorageMultisample(r.RENDERBUFFER, ne, r.DEPTH24_STENCIL8, A.width, A.height) : te(A) ? f.renderbufferStorageMultisampleEXT(r.RENDERBUFFER, ne, r.DEPTH24_STENCIL8, A.width, A.height) : r.renderbufferStorage(r.RENDERBUFFER, r.DEPTH_STENCIL, A.width, A.height),
                r.framebufferRenderbuffer(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.RENDERBUFFER, D)
            } else {
                let ne = A.isWebGLMultipleRenderTargets === !0 ? A.texture : [A.texture];
                for (let Q = 0; Q < ne.length; Q++) {
                    let he = ne[Q]
                      , de = s.convert(he.format, he.colorSpace)
                      , ge = s.convert(he.type)
                      , le = O(he.internalFormat, de, ge, he.colorSpace)
                      , xe = fe(A);
                    G && te(A) === !1 ? r.renderbufferStorageMultisample(r.RENDERBUFFER, xe, le, A.width, A.height) : te(A) ? f.renderbufferStorageMultisampleEXT(r.RENDERBUFFER, xe, le, A.width, A.height) : r.renderbufferStorage(r.RENDERBUFFER, le, A.width, A.height)
                }
            }
            r.bindRenderbuffer(r.RENDERBUFFER, null)
        }
        function J(D, A) {
            if (A && A.isWebGLCubeRenderTarget)
                throw new Error("Depth Texture with cube render targets is not supported");
            if (t.bindFramebuffer(r.FRAMEBUFFER, D),
            !(A.depthTexture && A.depthTexture.isDepthTexture))
                throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
            (!n.get(A.depthTexture).__webglTexture || A.depthTexture.image.width !== A.width || A.depthTexture.image.height !== A.height) && (A.depthTexture.image.width = A.width,
            A.depthTexture.image.height = A.height,
            A.depthTexture.needsUpdate = !0),
            K(A.depthTexture, 0);
            let ne = n.get(A.depthTexture).__webglTexture
              , Q = fe(A);
            if (A.depthTexture.format === Io)
                te(A) ? f.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.TEXTURE_2D, ne, 0, Q) : r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.TEXTURE_2D, ne, 0);
            else if (A.depthTexture.format === Ba)
                te(A) ? f.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.TEXTURE_2D, ne, 0, Q) : r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.TEXTURE_2D, ne, 0);
            else
                throw new Error("Unknown depthTexture format")
        }
        function ae(D) {
            let A = n.get(D)
              , G = D.isWebGLCubeRenderTarget === !0;
            if (D.depthTexture && !A.__autoAllocateDepthBuffer) {
                if (G)
                    throw new Error("target.depthTexture not supported in Cube render targets");
                J(A.__webglFramebuffer, D)
            } else if (G) {
                A.__webglDepthbuffer = [];
                for (let ne = 0; ne < 6; ne++)
                    t.bindFramebuffer(r.FRAMEBUFFER, A.__webglFramebuffer[ne]),
                    A.__webglDepthbuffer[ne] = r.createRenderbuffer(),
                    ce(A.__webglDepthbuffer[ne], D, !1)
            } else
                t.bindFramebuffer(r.FRAMEBUFFER, A.__webglFramebuffer),
                A.__webglDepthbuffer = r.createRenderbuffer(),
                ce(A.__webglDepthbuffer, D, !1);
            t.bindFramebuffer(r.FRAMEBUFFER, null)
        }
        function ie(D, A, G) {
            let ne = n.get(D);
            A !== void 0 && X(ne.__webglFramebuffer, D, D.texture, r.COLOR_ATTACHMENT0, r.TEXTURE_2D),
            G !== void 0 && ae(D)
        }
        function me(D) {
            let A = D.texture
              , G = n.get(D)
              , ne = n.get(A);
            D.addEventListener("dispose", k),
            D.isWebGLMultipleRenderTargets !== !0 && (ne.__webglTexture === void 0 && (ne.__webglTexture = r.createTexture()),
            ne.__version = A.version,
            o.memory.textures++);
            let Q = D.isWebGLCubeRenderTarget === !0
              , he = D.isWebGLMultipleRenderTargets === !0
              , de = _(D) || a;
            if (Q) {
                G.__webglFramebuffer = [];
                for (let ge = 0; ge < 6; ge++)
                    G.__webglFramebuffer[ge] = r.createFramebuffer()
            } else {
                if (G.__webglFramebuffer = r.createFramebuffer(),
                he)
                    if (i.drawBuffers) {
                        let ge = D.texture;
                        for (let le = 0, xe = ge.length; le < xe; le++) {
                            let Me = n.get(ge[le]);
                            Me.__webglTexture === void 0 && (Me.__webglTexture = r.createTexture(),
                            o.memory.textures++)
                        }
                    } else
                        console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
                if (a && D.samples > 0 && te(D) === !1) {
                    let ge = he ? A : [A];
                    G.__webglMultisampledFramebuffer = r.createFramebuffer(),
                    G.__webglColorRenderbuffer = [],
                    t.bindFramebuffer(r.FRAMEBUFFER, G.__webglMultisampledFramebuffer);
                    for (let le = 0; le < ge.length; le++) {
                        let xe = ge[le];
                        G.__webglColorRenderbuffer[le] = r.createRenderbuffer(),
                        r.bindRenderbuffer(r.RENDERBUFFER, G.__webglColorRenderbuffer[le]);
                        let Me = s.convert(xe.format, xe.colorSpace)
                          , Ne = s.convert(xe.type)
                          , De = O(xe.internalFormat, Me, Ne, xe.colorSpace, D.isXRRenderTarget === !0)
                          , Ve = fe(D);
                        r.renderbufferStorageMultisample(r.RENDERBUFFER, Ve, De, D.width, D.height),
                        r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + le, r.RENDERBUFFER, G.__webglColorRenderbuffer[le])
                    }
                    r.bindRenderbuffer(r.RENDERBUFFER, null),
                    D.depthBuffer && (G.__webglDepthRenderbuffer = r.createRenderbuffer(),
                    ce(G.__webglDepthRenderbuffer, D, !0)),
                    t.bindFramebuffer(r.FRAMEBUFFER, null)
                }
            }
            if (Q) {
                t.bindTexture(r.TEXTURE_CUBE_MAP, ne.__webglTexture),
                E(r.TEXTURE_CUBE_MAP, A, de);
                for (let ge = 0; ge < 6; ge++)
                    X(G.__webglFramebuffer[ge], D, A, r.COLOR_ATTACHMENT0, r.TEXTURE_CUBE_MAP_POSITIVE_X + ge);
                N(A, de) && I(r.TEXTURE_CUBE_MAP),
                t.unbindTexture()
            } else if (he) {
                let ge = D.texture;
                for (let le = 0, xe = ge.length; le < xe; le++) {
                    let Me = ge[le]
                      , Ne = n.get(Me);
                    t.bindTexture(r.TEXTURE_2D, Ne.__webglTexture),
                    E(r.TEXTURE_2D, Me, de),
                    X(G.__webglFramebuffer, D, Me, r.COLOR_ATTACHMENT0 + le, r.TEXTURE_2D),
                    N(Me, de) && I(r.TEXTURE_2D)
                }
                t.unbindTexture()
            } else {
                let ge = r.TEXTURE_2D;
                (D.isWebGL3DRenderTarget || D.isWebGLArrayRenderTarget) && (a ? ge = D.isWebGL3DRenderTarget ? r.TEXTURE_3D : r.TEXTURE_2D_ARRAY : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),
                t.bindTexture(ge, ne.__webglTexture),
                E(ge, A, de),
                X(G.__webglFramebuffer, D, A, r.COLOR_ATTACHMENT0, ge),
                N(A, de) && I(ge),
                t.unbindTexture()
            }
            D.depthBuffer && ae(D)
        }
        function ve(D) {
            let A = _(D) || a
              , G = D.isWebGLMultipleRenderTargets === !0 ? D.texture : [D.texture];
            for (let ne = 0, Q = G.length; ne < Q; ne++) {
                let he = G[ne];
                if (N(he, A)) {
                    let de = D.isWebGLCubeRenderTarget ? r.TEXTURE_CUBE_MAP : r.TEXTURE_2D
                      , ge = n.get(he).__webglTexture;
                    t.bindTexture(de, ge),
                    I(de),
                    t.unbindTexture()
                }
            }
        }
        function be(D) {
            if (a && D.samples > 0 && te(D) === !1) {
                let A = D.isWebGLMultipleRenderTargets ? D.texture : [D.texture]
                  , G = D.width
                  , ne = D.height
                  , Q = r.COLOR_BUFFER_BIT
                  , he = []
                  , de = D.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT
                  , ge = n.get(D)
                  , le = D.isWebGLMultipleRenderTargets === !0;
                if (le)
                    for (let xe = 0; xe < A.length; xe++)
                        t.bindFramebuffer(r.FRAMEBUFFER, ge.__webglMultisampledFramebuffer),
                        r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + xe, r.RENDERBUFFER, null),
                        t.bindFramebuffer(r.FRAMEBUFFER, ge.__webglFramebuffer),
                        r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0 + xe, r.TEXTURE_2D, null, 0);
                t.bindFramebuffer(r.READ_FRAMEBUFFER, ge.__webglMultisampledFramebuffer),
                t.bindFramebuffer(r.DRAW_FRAMEBUFFER, ge.__webglFramebuffer);
                for (let xe = 0; xe < A.length; xe++) {
                    he.push(r.COLOR_ATTACHMENT0 + xe),
                    D.depthBuffer && he.push(de);
                    let Me = ge.__ignoreDepthValues !== void 0 ? ge.__ignoreDepthValues : !1;
                    if (Me === !1 && (D.depthBuffer && (Q |= r.DEPTH_BUFFER_BIT),
                    D.stencilBuffer && (Q |= r.STENCIL_BUFFER_BIT)),
                    le && r.framebufferRenderbuffer(r.READ_FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.RENDERBUFFER, ge.__webglColorRenderbuffer[xe]),
                    Me === !0 && (r.invalidateFramebuffer(r.READ_FRAMEBUFFER, [de]),
                    r.invalidateFramebuffer(r.DRAW_FRAMEBUFFER, [de])),
                    le) {
                        let Ne = n.get(A[xe]).__webglTexture;
                        r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, Ne, 0)
                    }
                    r.blitFramebuffer(0, 0, G, ne, 0, 0, G, ne, Q, r.NEAREST),
                    m && r.invalidateFramebuffer(r.READ_FRAMEBUFFER, he)
                }
                if (t.bindFramebuffer(r.READ_FRAMEBUFFER, null),
                t.bindFramebuffer(r.DRAW_FRAMEBUFFER, null),
                le)
                    for (let xe = 0; xe < A.length; xe++) {
                        t.bindFramebuffer(r.FRAMEBUFFER, ge.__webglMultisampledFramebuffer),
                        r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + xe, r.RENDERBUFFER, ge.__webglColorRenderbuffer[xe]);
                        let Me = n.get(A[xe]).__webglTexture;
                        t.bindFramebuffer(r.FRAMEBUFFER, ge.__webglFramebuffer),
                        r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0 + xe, r.TEXTURE_2D, Me, 0)
                    }
                t.bindFramebuffer(r.DRAW_FRAMEBUFFER, ge.__webglMultisampledFramebuffer)
            }
        }
        function fe(D) {
            return Math.min(h, D.samples)
        }
        function te(D) {
            let A = n.get(D);
            return a && D.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && A.__useRenderToTexture !== !1
        }
        function Ee(D) {
            let A = o.render.frame;
            g.get(D) !== A && (g.set(D, A),
            D.update())
        }
        function Le(D, A) {
            let G = D.colorSpace
              , ne = D.format
              , Q = D.type;
            return D.isCompressedTexture === !0 || D.format === $d || G !== di && G !== Po && (G === ct ? a === !1 ? e.has("EXT_sRGB") === !0 && ne === Xi ? (D.format = $d,
            D.minFilter = bn,
            D.generateMipmaps = !1) : A = No.sRGBToLinear(A) : (ne !== Xi || Q !== Lo) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", G)),
            A
        }
        this.allocateTextureUnit = U,
        this.resetTextureUnits = F,
        this.setTexture2D = K,
        this.setTexture2DArray = re,
        this.setTexture3D = oe,
        this.setTextureCube = j,
        this.rebindTextures = ie,
        this.setupRenderTarget = me,
        this.updateRenderTargetMipmap = ve,
        this.updateMultisampleRenderTarget = be,
        this.setupDepthRenderbuffer = ae,
        this.setupFrameBufferTexture = X,
        this.useMultisampledRTT = te
    }
    function fS(r, e, t) {
        let n = t.isWebGL2;
        function i(s, o=Po) {
            let a;
            if (s === Lo)
                return r.UNSIGNED_BYTE;
            if (s === Qx)
                return r.UNSIGNED_SHORT_4_4_4_4;
            if (s === e_)
                return r.UNSIGNED_SHORT_5_5_5_1;
            if (s === Zx)
                return r.BYTE;
            if (s === Jx)
                return r.SHORT;
            if (s === pv)
                return r.UNSIGNED_SHORT;
            if (s === $x)
                return r.INT;
            if (s === Co)
                return r.UNSIGNED_INT;
            if (s === Vs)
                return r.FLOAT;
            if (s === Lc)
                return n ? r.HALF_FLOAT : (a = e.get("OES_texture_half_float"),
                a !== null ? a.HALF_FLOAT_OES : null);
            if (s === t_)
                return r.ALPHA;
            if (s === Xi)
                return r.RGBA;
            if (s === n_)
                return r.LUMINANCE;
            if (s === i_)
                return r.LUMINANCE_ALPHA;
            if (s === Io)
                return r.DEPTH_COMPONENT;
            if (s === Ba)
                return r.DEPTH_STENCIL;
            if (s === $d)
                return a = e.get("EXT_sRGB"),
                a !== null ? a.SRGB_ALPHA_EXT : null;
            if (s === r_)
                return r.RED;
            if (s === s_)
                return r.RED_INTEGER;
            if (s === o_)
                return r.RG;
            if (s === a_)
                return r.RG_INTEGER;
            if (s === l_)
                return r.RGBA_INTEGER;
            if (s === gd || s === vd || s === yd || s === xd)
                if (o === ct)
                    if (a = e.get("WEBGL_compressed_texture_s3tc_srgb"),
                    a !== null) {
                        if (s === gd)
                            return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                        if (s === vd)
                            return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                        if (s === yd)
                            return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                        if (s === xd)
                            return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                    } else
                        return null;
                else if (a = e.get("WEBGL_compressed_texture_s3tc"),
                a !== null) {
                    if (s === gd)
                        return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
                    if (s === vd)
                        return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    if (s === yd)
                        return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    if (s === xd)
                        return a.COMPRESSED_RGBA_S3TC_DXT5_EXT
                } else
                    return null;
            if (s === Pg || s === Lg || s === Ng || s === Dg)
                if (a = e.get("WEBGL_compressed_texture_pvrtc"),
                a !== null) {
                    if (s === Pg)
                        return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                    if (s === Lg)
                        return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                    if (s === Ng)
                        return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                    if (s === Dg)
                        return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                } else
                    return null;
            if (s === c_)
                return a = e.get("WEBGL_compressed_texture_etc1"),
                a !== null ? a.COMPRESSED_RGB_ETC1_WEBGL : null;
            if (s === Og || s === Fg)
                if (a = e.get("WEBGL_compressed_texture_etc"),
                a !== null) {
                    if (s === Og)
                        return o === ct ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
                    if (s === Fg)
                        return o === ct ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : a.COMPRESSED_RGBA8_ETC2_EAC
                } else
                    return null;
            if (s === kg || s === Ug || s === Bg || s === Gg || s === Vg || s === zg || s === Hg || s === Wg || s === Xg || s === jg || s === qg || s === Yg || s === Kg || s === Zg)
                if (a = e.get("WEBGL_compressed_texture_astc"),
                a !== null) {
                    if (s === kg)
                        return o === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
                    if (s === Ug)
                        return o === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
                    if (s === Bg)
                        return o === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
                    if (s === Gg)
                        return o === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
                    if (s === Vg)
                        return o === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
                    if (s === zg)
                        return o === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
                    if (s === Hg)
                        return o === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
                    if (s === Wg)
                        return o === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
                    if (s === Xg)
                        return o === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
                    if (s === jg)
                        return o === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
                    if (s === qg)
                        return o === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
                    if (s === Yg)
                        return o === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
                    if (s === Kg)
                        return o === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
                    if (s === Zg)
                        return o === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : a.COMPRESSED_RGBA_ASTC_12x12_KHR
                } else
                    return null;
            if (s === _d)
                if (a = e.get("EXT_texture_compression_bptc"),
                a !== null) {
                    if (s === _d)
                        return o === ct ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : a.COMPRESSED_RGBA_BPTC_UNORM_EXT
                } else
                    return null;
            if (s === u_ || s === Jg || s === $g || s === Qg)
                if (a = e.get("EXT_texture_compression_rgtc"),
                a !== null) {
                    if (s === _d)
                        return a.COMPRESSED_RED_RGTC1_EXT;
                    if (s === Jg)
                        return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                    if (s === $g)
                        return a.COMPRESSED_RED_GREEN_RGTC2_EXT;
                    if (s === Qg)
                        return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
                } else
                    return null;
            return s === La ? n ? r.UNSIGNED_INT_24_8 : (a = e.get("WEBGL_depth_texture"),
            a !== null ? a.UNSIGNED_INT_24_8_WEBGL : null) : r[s] !== void 0 ? r[s] : null
        }
        return {
            convert: i
        }
    }
    var hp = class extends Qt {
        constructor(e=[]) {
            super(),
            this.isArrayCamera = !0,
            this.cameras = e
        }
    }
      , In = class extends bt {
        constructor() {
            super(),
            this.isGroup = !0,
            this.type = "Group"
        }
    }
      , dS = {
        type: "move"
    }
      , Cc = class {
        constructor() {
            this._targetRay = null,
            this._grip = null,
            this._hand = null
        }
        getHandSpace() {
            return this._hand === null && (this._hand = new In,
            this._hand.matrixAutoUpdate = !1,
            this._hand.visible = !1,
            this._hand.joints = {},
            this._hand.inputState = {
                pinching: !1
            }),
            this._hand
        }
        getTargetRaySpace() {
            return this._targetRay === null && (this._targetRay = new In,
            this._targetRay.matrixAutoUpdate = !1,
            this._targetRay.visible = !1,
            this._targetRay.hasLinearVelocity = !1,
            this._targetRay.linearVelocity = new ue,
            this._targetRay.hasAngularVelocity = !1,
            this._targetRay.angularVelocity = new ue),
            this._targetRay
        }
        getGripSpace() {
            return this._grip === null && (this._grip = new In,
            this._grip.matrixAutoUpdate = !1,
            this._grip.visible = !1,
            this._grip.hasLinearVelocity = !1,
            this._grip.linearVelocity = new ue,
            this._grip.hasAngularVelocity = !1,
            this._grip.angularVelocity = new ue),
            this._grip
        }
        dispatchEvent(e) {
            return this._targetRay !== null && this._targetRay.dispatchEvent(e),
            this._grip !== null && this._grip.dispatchEvent(e),
            this._hand !== null && this._hand.dispatchEvent(e),
            this
        }
        connect(e) {
            if (e && e.hand) {
                let t = this._hand;
                if (t)
                    for (let n of e.hand.values())
                        this._getHandJoint(t, n)
            }
            return this.dispatchEvent({
                type: "connected",
                data: e
            }),
            this
        }
        disconnect(e) {
            return this.dispatchEvent({
                type: "disconnected",
                data: e
            }),
            this._targetRay !== null && (this._targetRay.visible = !1),
            this._grip !== null && (this._grip.visible = !1),
            this._hand !== null && (this._hand.visible = !1),
            this
        }
        update(e, t, n) {
            let i = null
              , s = null
              , o = null
              , a = this._targetRay
              , l = this._grip
              , c = this._hand;
            if (e && t.session.visibilityState !== "visible-blurred") {
                if (c && e.hand) {
                    o = !0;
                    for (let v of e.hand.values()) {
                        let p = t.getJointPose(v, n)
                          , d = this._getHandJoint(c, v);
                        p !== null && (d.matrix.fromArray(p.transform.matrix),
                        d.matrix.decompose(d.position, d.rotation, d.scale),
                        d.matrixWorldNeedsUpdate = !0,
                        d.jointRadius = p.radius),
                        d.visible = p !== null
                    }
                    let u = c.joints["index-finger-tip"]
                      , h = c.joints["thumb-tip"]
                      , f = u.position.distanceTo(h.position)
                      , m = .02
                      , g = .005;
                    c.inputState.pinching && f > m + g ? (c.inputState.pinching = !1,
                    this.dispatchEvent({
                        type: "pinchend",
                        handedness: e.handedness,
                        target: this
                    })) : !c.inputState.pinching && f <= m - g && (c.inputState.pinching = !0,
                    this.dispatchEvent({
                        type: "pinchstart",
                        handedness: e.handedness,
                        target: this
                    }))
                } else
                    l !== null && e.gripSpace && (s = t.getPose(e.gripSpace, n),
                    s !== null && (l.matrix.fromArray(s.transform.matrix),
                    l.matrix.decompose(l.position, l.rotation, l.scale),
                    l.matrixWorldNeedsUpdate = !0,
                    s.linearVelocity ? (l.hasLinearVelocity = !0,
                    l.linearVelocity.copy(s.linearVelocity)) : l.hasLinearVelocity = !1,
                    s.angularVelocity ? (l.hasAngularVelocity = !0,
                    l.angularVelocity.copy(s.angularVelocity)) : l.hasAngularVelocity = !1));
                a !== null && (i = t.getPose(e.targetRaySpace, n),
                i === null && s !== null && (i = s),
                i !== null && (a.matrix.fromArray(i.transform.matrix),
                a.matrix.decompose(a.position, a.rotation, a.scale),
                a.matrixWorldNeedsUpdate = !0,
                i.linearVelocity ? (a.hasLinearVelocity = !0,
                a.linearVelocity.copy(i.linearVelocity)) : a.hasLinearVelocity = !1,
                i.angularVelocity ? (a.hasAngularVelocity = !0,
                a.angularVelocity.copy(i.angularVelocity)) : a.hasAngularVelocity = !1,
                this.dispatchEvent(dS)))
            }
            return a !== null && (a.visible = i !== null),
            l !== null && (l.visible = s !== null),
            c !== null && (c.visible = o !== null),
            this
        }
        _getHandJoint(e, t) {
            if (e.joints[t.jointName] === void 0) {
                let n = new In;
                n.matrixAutoUpdate = !1,
                n.visible = !1,
                e.joints[t.jointName] = n,
                e.add(n)
            }
            return e.joints[t.jointName]
        }
    }
      , fp = class extends En {
        constructor(e, t, n, i, s, o, a, l, c, u) {
            if (u = u !== void 0 ? u : Io,
            u !== Io && u !== Ba)
                throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
            n === void 0 && u === Io && (n = Co),
            n === void 0 && u === Ba && (n = La),
            super(null, i, s, o, a, l, u, n, c),
            this.isDepthTexture = !0,
            this.image = {
                width: e,
                height: t
            },
            this.magFilter = a !== void 0 ? a : Tn,
            this.minFilter = l !== void 0 ? l : Tn,
            this.flipY = !1,
            this.generateMipmaps = !1
        }
    }
      , dp = class extends Ws {
        constructor(e, t) {
            super();
            let n = this
              , i = null
              , s = 1
              , o = null
              , a = "local-floor"
              , l = 1
              , c = null
              , u = null
              , h = null
              , f = null
              , m = null
              , g = null
              , v = t.getContextAttributes()
              , p = null
              , d = null
              , x = []
              , y = []
              , _ = new Set
              , S = new Map
              , N = new Qt;
            N.layers.enable(1),
            N.viewport = new Lt;
            let I = new Qt;
            I.layers.enable(2),
            I.viewport = new Lt;
            let O = [N, I]
              , M = new hp;
            M.layers.enable(1),
            M.layers.enable(2);
            let R = null
              , q = null;
            this.cameraAutoUpdate = !0,
            this.enabled = !1,
            this.isPresenting = !1,
            this.getController = function(j) {
                let w = x[j];
                return w === void 0 && (w = new Cc,
                x[j] = w),
                w.getTargetRaySpace()
            }
            ,
            this.getControllerGrip = function(j) {
                let w = x[j];
                return w === void 0 && (w = new Cc,
                x[j] = w),
                w.getGripSpace()
            }
            ,
            this.getHand = function(j) {
                let w = x[j];
                return w === void 0 && (w = new Cc,
                x[j] = w),
                w.getHandSpace()
            }
            ;
            function k(j) {
                let w = y.indexOf(j.inputSource);
                if (w === -1)
                    return;
                let b = x[w];
                b !== void 0 && (b.update(j.inputSource, j.frame, c || o),
                b.dispatchEvent({
                    type: j.type,
                    data: j.inputSource
                }))
            }
            function B() {
                i.removeEventListener("select", k),
                i.removeEventListener("selectstart", k),
                i.removeEventListener("selectend", k),
                i.removeEventListener("squeeze", k),
                i.removeEventListener("squeezestart", k),
                i.removeEventListener("squeezeend", k),
                i.removeEventListener("end", B),
                i.removeEventListener("inputsourceschange", P);
                for (let j = 0; j < x.length; j++) {
                    let w = y[j];
                    w !== null && (y[j] = null,
                    x[j].disconnect(w))
                }
                R = null,
                q = null,
                e.setRenderTarget(p),
                m = null,
                f = null,
                h = null,
                i = null,
                d = null,
                oe.stop(),
                n.isPresenting = !1,
                n.dispatchEvent({
                    type: "sessionend"
                })
            }
            this.setFramebufferScaleFactor = function(j) {
                s = j,
                n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
            }
            ,
            this.setReferenceSpaceType = function(j) {
                a = j,
                n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
            }
            ,
            this.getReferenceSpace = function() {
                return c || o
            }
            ,
            this.setReferenceSpace = function(j) {
                c = j
            }
            ,
            this.getBaseLayer = function() {
                return f !== null ? f : m
            }
            ,
            this.getBinding = function() {
                return h
            }
            ,
            this.getFrame = function() {
                return g
            }
            ,
            this.getSession = function() {
                return i
            }
            ,
            this.setSession = async function(j) {
                if (i = j,
                i !== null) {
                    if (p = e.getRenderTarget(),
                    i.addEventListener("select", k),
                    i.addEventListener("selectstart", k),
                    i.addEventListener("selectend", k),
                    i.addEventListener("squeeze", k),
                    i.addEventListener("squeezestart", k),
                    i.addEventListener("squeezeend", k),
                    i.addEventListener("end", B),
                    i.addEventListener("inputsourceschange", P),
                    v.xrCompatible !== !0 && await t.makeXRCompatible(),
                    i.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1) {
                        let w = {
                            antialias: i.renderState.layers === void 0 ? v.antialias : !0,
                            alpha: !0,
                            depth: v.depth,
                            stencil: v.stencil,
                            framebufferScaleFactor: s
                        };
                        m = new XRWebGLLayer(i,t,w),
                        i.updateRenderState({
                            baseLayer: m
                        }),
                        d = new ds(m.framebufferWidth,m.framebufferHeight,{
                            format: Xi,
                            type: Lo,
                            colorSpace: e.outputColorSpace,
                            stencilBuffer: v.stencil
                        })
                    } else {
                        let w = null
                          , b = null
                          , E = null;
                        v.depth && (E = v.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24,
                        w = v.stencil ? Ba : Io,
                        b = v.stencil ? La : Co);
                        let T = {
                            colorFormat: t.RGBA8,
                            depthFormat: E,
                            scaleFactor: s
                        };
                        h = new XRWebGLBinding(i,t),
                        f = h.createProjectionLayer(T),
                        i.updateRenderState({
                            layers: [f]
                        }),
                        d = new ds(f.textureWidth,f.textureHeight,{
                            format: Xi,
                            type: Lo,
                            depthTexture: new fp(f.textureWidth,f.textureHeight,b,void 0,void 0,void 0,void 0,void 0,void 0,w),
                            stencilBuffer: v.stencil,
                            colorSpace: e.outputColorSpace,
                            samples: v.antialias ? 4 : 0
                        });
                        let H = e.properties.get(d);
                        H.__ignoreDepthValues = f.ignoreDepthValues
                    }
                    d.isXRRenderTarget = !0,
                    this.setFoveation(l),
                    c = null,
                    o = await i.requestReferenceSpace(a),
                    oe.setContext(i),
                    oe.start(),
                    n.isPresenting = !0,
                    n.dispatchEvent({
                        type: "sessionstart"
                    })
                }
            }
            ,
            this.getEnvironmentBlendMode = function() {
                if (i !== null)
                    return i.environmentBlendMode
            }
            ;
            function P(j) {
                for (let w = 0; w < j.removed.length; w++) {
                    let b = j.removed[w]
                      , E = y.indexOf(b);
                    E >= 0 && (y[E] = null,
                    x[E].disconnect(b))
                }
                for (let w = 0; w < j.added.length; w++) {
                    let b = j.added[w]
                      , E = y.indexOf(b);
                    if (E === -1) {
                        for (let H = 0; H < x.length; H++)
                            if (H >= y.length) {
                                y.push(b),
                                E = H;
                                break
                            } else if (y[H] === null) {
                                y[H] = b,
                                E = H;
                                break
                            }
                        if (E === -1)
                            break
                    }
                    let T = x[E];
                    T && T.connect(b)
                }
            }
            let C = new ue
              , L = new ue;
            function F(j, w, b) {
                C.setFromMatrixPosition(w.matrixWorld),
                L.setFromMatrixPosition(b.matrixWorld);
                let E = C.distanceTo(L)
                  , T = w.projectionMatrix.elements
                  , H = b.projectionMatrix.elements
                  , Y = T[14] / (T[10] - 1)
                  , X = T[14] / (T[10] + 1)
                  , ce = (T[9] + 1) / T[5]
                  , J = (T[9] - 1) / T[5]
                  , ae = (T[8] - 1) / T[0]
                  , ie = (H[8] + 1) / H[0]
                  , me = Y * ae
                  , ve = Y * ie
                  , be = E / (-ae + ie)
                  , fe = be * -ae;
                w.matrixWorld.decompose(j.position, j.quaternion, j.scale),
                j.translateX(fe),
                j.translateZ(be),
                j.matrixWorld.compose(j.position, j.quaternion, j.scale),
                j.matrixWorldInverse.copy(j.matrixWorld).invert();
                let te = Y + be
                  , Ee = X + be
                  , Le = me - fe
                  , D = ve + (E - fe)
                  , A = ce * X / Ee * te
                  , G = J * X / Ee * te;
                j.projectionMatrix.makePerspective(Le, D, A, G, te, Ee),
                j.projectionMatrixInverse.copy(j.projectionMatrix).invert()
            }
            function U(j, w) {
                w === null ? j.matrixWorld.copy(j.matrix) : j.matrixWorld.multiplyMatrices(w.matrixWorld, j.matrix),
                j.matrixWorldInverse.copy(j.matrixWorld).invert()
            }
            this.updateCamera = function(j) {
                if (i === null)
                    return;
                M.near = I.near = N.near = j.near,
                M.far = I.far = N.far = j.far,
                (R !== M.near || q !== M.far) && (i.updateRenderState({
                    depthNear: M.near,
                    depthFar: M.far
                }),
                R = M.near,
                q = M.far);
                let w = j.parent
                  , b = M.cameras;
                U(M, w);
                for (let E = 0; E < b.length; E++)
                    U(b[E], w);
                b.length === 2 ? F(M, N, I) : M.projectionMatrix.copy(N.projectionMatrix),
                W(j, M, w)
            }
            ;
            function W(j, w, b) {
                b === null ? j.matrix.copy(w.matrixWorld) : (j.matrix.copy(b.matrixWorld),
                j.matrix.invert(),
                j.matrix.multiply(w.matrixWorld)),
                j.matrix.decompose(j.position, j.quaternion, j.scale),
                j.updateMatrixWorld(!0);
                let E = j.children;
                for (let T = 0, H = E.length; T < H; T++)
                    E[T].updateMatrixWorld(!0);
                j.projectionMatrix.copy(w.projectionMatrix),
                j.projectionMatrixInverse.copy(w.projectionMatrixInverse),
                j.isPerspectiveCamera && (j.fov = Ga * 2 * Math.atan(1 / j.projectionMatrix.elements[5]),
                j.zoom = 1)
            }
            this.getCamera = function() {
                return M
            }
            ,
            this.getFoveation = function() {
                if (!(f === null && m === null))
                    return l
            }
            ,
            this.setFoveation = function(j) {
                l = j,
                f !== null && (f.fixedFoveation = j),
                m !== null && m.fixedFoveation !== void 0 && (m.fixedFoveation = j)
            }
            ,
            this.getPlanes = function() {
                return _
            }
            ;
            let K = null;
            function re(j, w) {
                if (u = w.getViewerPose(c || o),
                g = w,
                u !== null) {
                    let b = u.views;
                    m !== null && (e.setRenderTargetFramebuffer(d, m.framebuffer),
                    e.setRenderTarget(d));
                    let E = !1;
                    b.length !== M.cameras.length && (M.cameras.length = 0,
                    E = !0);
                    for (let T = 0; T < b.length; T++) {
                        let H = b[T]
                          , Y = null;
                        if (m !== null)
                            Y = m.getViewport(H);
                        else {
                            let ce = h.getViewSubImage(f, H);
                            Y = ce.viewport,
                            T === 0 && (e.setRenderTargetTextures(d, ce.colorTexture, f.ignoreDepthValues ? void 0 : ce.depthStencilTexture),
                            e.setRenderTarget(d))
                        }
                        let X = O[T];
                        X === void 0 && (X = new Qt,
                        X.layers.enable(T),
                        X.viewport = new Lt,
                        O[T] = X),
                        X.matrix.fromArray(H.transform.matrix),
                        X.matrix.decompose(X.position, X.quaternion, X.scale),
                        X.projectionMatrix.fromArray(H.projectionMatrix),
                        X.projectionMatrixInverse.copy(X.projectionMatrix).invert(),
                        X.viewport.set(Y.x, Y.y, Y.width, Y.height),
                        T === 0 && (M.matrix.copy(X.matrix),
                        M.matrix.decompose(M.position, M.quaternion, M.scale)),
                        E === !0 && M.cameras.push(X)
                    }
                }
                for (let b = 0; b < x.length; b++) {
                    let E = y[b]
                      , T = x[b];
                    E !== null && T !== void 0 && T.update(E, w, c || o)
                }
                if (K && K(j, w),
                w.detectedPlanes) {
                    n.dispatchEvent({
                        type: "planesdetected",
                        data: w.detectedPlanes
                    });
                    let b = null;
                    for (let E of _)
                        w.detectedPlanes.has(E) || (b === null && (b = []),
                        b.push(E));
                    if (b !== null)
                        for (let E of b)
                            _.delete(E),
                            S.delete(E),
                            n.dispatchEvent({
                                type: "planeremoved",
                                data: E
                            });
                    for (let E of w.detectedPlanes)
                        if (!_.has(E))
                            _.add(E),
                            S.set(E, w.lastChangedTime),
                            n.dispatchEvent({
                                type: "planeadded",
                                data: E
                            });
                        else {
                            let T = S.get(E);
                            E.lastChangedTime > T && (S.set(E, E.lastChangedTime),
                            n.dispatchEvent({
                                type: "planechanged",
                                data: E
                            }))
                        }
                }
                g = null
            }
            let oe = new bv;
            oe.setAnimationLoop(re),
            this.setAnimationLoop = function(j) {
                K = j
            }
            ,
            this.dispose = function() {}
        }
    }
    ;
    function pS(r, e) {
        function t(p, d) {
            p.matrixAutoUpdate === !0 && p.updateMatrix(),
            d.value.copy(p.matrix)
        }
        function n(p, d) {
            d.color.getRGB(p.fogColor.value, Tv(r)),
            d.isFog ? (p.fogNear.value = d.near,
            p.fogFar.value = d.far) : d.isFogExp2 && (p.fogDensity.value = d.density)
        }
        function i(p, d, x, y, _) {
            d.isMeshBasicMaterial || d.isMeshLambertMaterial ? s(p, d) : d.isMeshToonMaterial ? (s(p, d),
            h(p, d)) : d.isMeshPhongMaterial ? (s(p, d),
            u(p, d)) : d.isMeshStandardMaterial ? (s(p, d),
            f(p, d),
            d.isMeshPhysicalMaterial && m(p, d, _)) : d.isMeshMatcapMaterial ? (s(p, d),
            g(p, d)) : d.isMeshDepthMaterial ? s(p, d) : d.isMeshDistanceMaterial ? (s(p, d),
            v(p, d)) : d.isMeshNormalMaterial ? s(p, d) : d.isLineBasicMaterial ? (o(p, d),
            d.isLineDashedMaterial && a(p, d)) : d.isPointsMaterial ? l(p, d, x, y) : d.isSpriteMaterial ? c(p, d) : d.isShadowMaterial ? (p.color.value.copy(d.color),
            p.opacity.value = d.opacity) : d.isShaderMaterial && (d.uniformsNeedUpdate = !1)
        }
        function s(p, d) {
            p.opacity.value = d.opacity,
            d.color && p.diffuse.value.copy(d.color),
            d.emissive && p.emissive.value.copy(d.emissive).multiplyScalar(d.emissiveIntensity),
            d.map && (p.map.value = d.map,
            t(d.map, p.mapTransform)),
            d.alphaMap && (p.alphaMap.value = d.alphaMap,
            t(d.alphaMap, p.alphaMapTransform)),
            d.bumpMap && (p.bumpMap.value = d.bumpMap,
            t(d.bumpMap, p.bumpMapTransform),
            p.bumpScale.value = d.bumpScale,
            d.side === Mn && (p.bumpScale.value *= -1)),
            d.normalMap && (p.normalMap.value = d.normalMap,
            t(d.normalMap, p.normalMapTransform),
            p.normalScale.value.copy(d.normalScale),
            d.side === Mn && p.normalScale.value.negate()),
            d.displacementMap && (p.displacementMap.value = d.displacementMap,
            t(d.displacementMap, p.displacementMapTransform),
            p.displacementScale.value = d.displacementScale,
            p.displacementBias.value = d.displacementBias),
            d.emissiveMap && (p.emissiveMap.value = d.emissiveMap,
            t(d.emissiveMap, p.emissiveMapTransform)),
            d.specularMap && (p.specularMap.value = d.specularMap,
            t(d.specularMap, p.specularMapTransform)),
            d.alphaTest > 0 && (p.alphaTest.value = d.alphaTest);
            let x = e.get(d).envMap;
            if (x && (p.envMap.value = x,
            p.flipEnvMap.value = x.isCubeTexture && x.isRenderTargetTexture === !1 ? -1 : 1,
            p.reflectivity.value = d.reflectivity,
            p.ior.value = d.ior,
            p.refractionRatio.value = d.refractionRatio),
            d.lightMap) {
                p.lightMap.value = d.lightMap;
                let y = r.useLegacyLights === !0 ? Math.PI : 1;
                p.lightMapIntensity.value = d.lightMapIntensity * y,
                t(d.lightMap, p.lightMapTransform)
            }
            d.aoMap && (p.aoMap.value = d.aoMap,
            p.aoMapIntensity.value = d.aoMapIntensity,
            t(d.aoMap, p.aoMapTransform))
        }
        function o(p, d) {
            p.diffuse.value.copy(d.color),
            p.opacity.value = d.opacity,
            d.map && (p.map.value = d.map,
            t(d.map, p.mapTransform))
        }
        function a(p, d) {
            p.dashSize.value = d.dashSize,
            p.totalSize.value = d.dashSize + d.gapSize,
            p.scale.value = d.scale
        }
        function l(p, d, x, y) {
            p.diffuse.value.copy(d.color),
            p.opacity.value = d.opacity,
            p.size.value = d.size * x,
            p.scale.value = y * .5,
            d.map && (p.map.value = d.map,
            t(d.map, p.uvTransform)),
            d.alphaMap && (p.alphaMap.value = d.alphaMap),
            d.alphaTest > 0 && (p.alphaTest.value = d.alphaTest)
        }
        function c(p, d) {
            p.diffuse.value.copy(d.color),
            p.opacity.value = d.opacity,
            p.rotation.value = d.rotation,
            d.map && (p.map.value = d.map,
            t(d.map, p.mapTransform)),
            d.alphaMap && (p.alphaMap.value = d.alphaMap),
            d.alphaTest > 0 && (p.alphaTest.value = d.alphaTest)
        }
        function u(p, d) {
            p.specular.value.copy(d.specular),
            p.shininess.value = Math.max(d.shininess, 1e-4)
        }
        function h(p, d) {
            d.gradientMap && (p.gradientMap.value = d.gradientMap)
        }
        function f(p, d) {
            p.metalness.value = d.metalness,
            d.metalnessMap && (p.metalnessMap.value = d.metalnessMap,
            t(d.metalnessMap, p.metalnessMapTransform)),
            p.roughness.value = d.roughness,
            d.roughnessMap && (p.roughnessMap.value = d.roughnessMap,
            t(d.roughnessMap, p.roughnessMapTransform)),
            e.get(d).envMap && (p.envMapIntensity.value = d.envMapIntensity)
        }
        function m(p, d, x) {
            p.ior.value = d.ior,
            d.sheen > 0 && (p.sheenColor.value.copy(d.sheenColor).multiplyScalar(d.sheen),
            p.sheenRoughness.value = d.sheenRoughness,
            d.sheenColorMap && (p.sheenColorMap.value = d.sheenColorMap,
            t(d.sheenColorMap, p.sheenColorMapTransform)),
            d.sheenRoughnessMap && (p.sheenRoughnessMap.value = d.sheenRoughnessMap,
            t(d.sheenRoughnessMap, p.sheenRoughnessMapTransform))),
            d.clearcoat > 0 && (p.clearcoat.value = d.clearcoat,
            p.clearcoatRoughness.value = d.clearcoatRoughness,
            d.clearcoatMap && (p.clearcoatMap.value = d.clearcoatMap,
            t(d.clearcoatMap, p.clearcoatMapTransform)),
            d.clearcoatRoughnessMap && (p.clearcoatRoughnessMap.value = d.clearcoatRoughnessMap,
            t(d.clearcoatRoughnessMap, p.clearcoatRoughnessMapTransform)),
            d.clearcoatNormalMap && (p.clearcoatNormalMap.value = d.clearcoatNormalMap,
            t(d.clearcoatNormalMap, p.clearcoatNormalMapTransform),
            p.clearcoatNormalScale.value.copy(d.clearcoatNormalScale),
            d.side === Mn && p.clearcoatNormalScale.value.negate())),
            d.iridescence > 0 && (p.iridescence.value = d.iridescence,
            p.iridescenceIOR.value = d.iridescenceIOR,
            p.iridescenceThicknessMinimum.value = d.iridescenceThicknessRange[0],
            p.iridescenceThicknessMaximum.value = d.iridescenceThicknessRange[1],
            d.iridescenceMap && (p.iridescenceMap.value = d.iridescenceMap,
            t(d.iridescenceMap, p.iridescenceMapTransform)),
            d.iridescenceThicknessMap && (p.iridescenceThicknessMap.value = d.iridescenceThicknessMap,
            t(d.iridescenceThicknessMap, p.iridescenceThicknessMapTransform))),
            d.transmission > 0 && (p.transmission.value = d.transmission,
            p.transmissionSamplerMap.value = x.texture,
            p.transmissionSamplerSize.value.set(x.width, x.height),
            d.transmissionMap && (p.transmissionMap.value = d.transmissionMap,
            t(d.transmissionMap, p.transmissionMapTransform)),
            p.thickness.value = d.thickness,
            d.thicknessMap && (p.thicknessMap.value = d.thicknessMap,
            t(d.thicknessMap, p.thicknessMapTransform)),
            p.attenuationDistance.value = d.attenuationDistance,
            p.attenuationColor.value.copy(d.attenuationColor)),
            p.specularIntensity.value = d.specularIntensity,
            p.specularColor.value.copy(d.specularColor),
            d.specularColorMap && (p.specularColorMap.value = d.specularColorMap,
            t(d.specularColorMap, p.specularColorMapTransform)),
            d.specularIntensityMap && (p.specularIntensityMap.value = d.specularIntensityMap,
            t(d.specularIntensityMap, p.specularIntensityMapTransform))
        }
        function g(p, d) {
            d.matcap && (p.matcap.value = d.matcap)
        }
        function v(p, d) {
            let x = e.get(d).light;
            p.referencePosition.value.setFromMatrixPosition(x.matrixWorld),
            p.nearDistance.value = x.shadow.camera.near,
            p.farDistance.value = x.shadow.camera.far
        }
        return {
            refreshFogUniforms: n,
            refreshMaterialUniforms: i
        }
    }
    function mS(r, e, t, n) {
        let i = {}
          , s = {}
          , o = []
          , a = t.isWebGL2 ? r.getParameter(r.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
        function l(x, y) {
            let _ = y.program;
            n.uniformBlockBinding(x, _)
        }
        function c(x, y) {
            let _ = i[x.id];
            _ === void 0 && (g(x),
            _ = u(x),
            i[x.id] = _,
            x.addEventListener("dispose", p));
            let S = y.program;
            n.updateUBOMapping(x, S);
            let N = e.render.frame;
            s[x.id] !== N && (f(x),
            s[x.id] = N)
        }
        function u(x) {
            let y = h();
            x.__bindingPointIndex = y;
            let _ = r.createBuffer()
              , S = x.__size
              , N = x.usage;
            return r.bindBuffer(r.UNIFORM_BUFFER, _),
            r.bufferData(r.UNIFORM_BUFFER, S, N),
            r.bindBuffer(r.UNIFORM_BUFFER, null),
            r.bindBufferBase(r.UNIFORM_BUFFER, y, _),
            _
        }
        function h() {
            for (let x = 0; x < a; x++)
                if (o.indexOf(x) === -1)
                    return o.push(x),
                    x;
            return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),
            0
        }
        function f(x) {
            let y = i[x.id]
              , _ = x.uniforms
              , S = x.__cache;
            r.bindBuffer(r.UNIFORM_BUFFER, y);
            for (let N = 0, I = _.length; N < I; N++) {
                let O = _[N];
                if (m(O, N, S) === !0) {
                    let M = O.__offset
                      , R = Array.isArray(O.value) ? O.value : [O.value]
                      , q = 0;
                    for (let k = 0; k < R.length; k++) {
                        let B = R[k]
                          , P = v(B);
                        typeof B == "number" ? (O.__data[0] = B,
                        r.bufferSubData(r.UNIFORM_BUFFER, M + q, O.__data)) : B.isMatrix3 ? (O.__data[0] = B.elements[0],
                        O.__data[1] = B.elements[1],
                        O.__data[2] = B.elements[2],
                        O.__data[3] = B.elements[0],
                        O.__data[4] = B.elements[3],
                        O.__data[5] = B.elements[4],
                        O.__data[6] = B.elements[5],
                        O.__data[7] = B.elements[0],
                        O.__data[8] = B.elements[6],
                        O.__data[9] = B.elements[7],
                        O.__data[10] = B.elements[8],
                        O.__data[11] = B.elements[0]) : (B.toArray(O.__data, q),
                        q += P.storage / Float32Array.BYTES_PER_ELEMENT)
                    }
                    r.bufferSubData(r.UNIFORM_BUFFER, M, O.__data)
                }
            }
            r.bindBuffer(r.UNIFORM_BUFFER, null)
        }
        function m(x, y, _) {
            let S = x.value;
            if (_[y] === void 0) {
                if (typeof S == "number")
                    _[y] = S;
                else {
                    let N = Array.isArray(S) ? S : [S]
                      , I = [];
                    for (let O = 0; O < N.length; O++)
                        I.push(N[O].clone());
                    _[y] = I
                }
                return !0
            } else if (typeof S == "number") {
                if (_[y] !== S)
                    return _[y] = S,
                    !0
            } else {
                let N = Array.isArray(_[y]) ? _[y] : [_[y]]
                  , I = Array.isArray(S) ? S : [S];
                for (let O = 0; O < N.length; O++) {
                    let M = N[O];
                    if (M.equals(I[O]) === !1)
                        return M.copy(I[O]),
                        !0
                }
            }
            return !1
        }
        function g(x) {
            let y = x.uniforms
              , _ = 0
              , S = 16
              , N = 0;
            for (let I = 0, O = y.length; I < O; I++) {
                let M = y[I]
                  , R = {
                    boundary: 0,
                    storage: 0
                }
                  , q = Array.isArray(M.value) ? M.value : [M.value];
                for (let k = 0, B = q.length; k < B; k++) {
                    let P = q[k]
                      , C = v(P);
                    R.boundary += C.boundary,
                    R.storage += C.storage
                }
                if (M.__data = new Float32Array(R.storage / Float32Array.BYTES_PER_ELEMENT),
                M.__offset = _,
                I > 0) {
                    N = _ % S;
                    let k = S - N;
                    N !== 0 && k - R.boundary < 0 && (_ += S - N,
                    M.__offset = _)
                }
                _ += R.storage
            }
            return N = _ % S,
            N > 0 && (_ += S - N),
            x.__size = _,
            x.__cache = {},
            this
        }
        function v(x) {
            let y = {
                boundary: 0,
                storage: 0
            };
            return typeof x == "number" ? (y.boundary = 4,
            y.storage = 4) : x.isVector2 ? (y.boundary = 8,
            y.storage = 8) : x.isVector3 || x.isColor ? (y.boundary = 16,
            y.storage = 12) : x.isVector4 ? (y.boundary = 16,
            y.storage = 16) : x.isMatrix3 ? (y.boundary = 48,
            y.storage = 48) : x.isMatrix4 ? (y.boundary = 64,
            y.storage = 64) : x.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", x),
            y
        }
        function p(x) {
            let y = x.target;
            y.removeEventListener("dispose", p);
            let _ = o.indexOf(y.__bindingPointIndex);
            o.splice(_, 1),
            r.deleteBuffer(i[y.id]),
            delete i[y.id],
            delete s[y.id]
        }
        function d() {
            for (let x in i)
                r.deleteBuffer(i[x]);
            o = [],
            i = {},
            s = {}
        }
        return {
            bind: l,
            update: c,
            dispose: d
        }
    }
    function gS() {
        let r = Nc("canvas");
        return r.style.display = "block",
        r
    }
    var Oo = class {
        constructor(e={}) {
            let {canvas: t=gS(), context: n=null, depth: i=!0, stencil: s=!0, alpha: o=!1, antialias: a=!1, premultipliedAlpha: l=!0, preserveDrawingBuffer: c=!1, powerPreference: u="default", failIfMajorPerformanceCaveat: h=!1} = e;
            this.isWebGLRenderer = !0;
            let f;
            n !== null ? f = n.getContextAttributes().alpha : f = o;
            let m = null
              , g = null
              , v = []
              , p = [];
            this.domElement = t,
            this.debug = {
                checkShaderErrors: !0,
                onShaderError: null
            },
            this.autoClear = !0,
            this.autoClearColor = !0,
            this.autoClearDepth = !0,
            this.autoClearStencil = !0,
            this.sortObjects = !0,
            this.clippingPlanes = [],
            this.localClippingEnabled = !1,
            this.outputColorSpace = ct,
            this.useLegacyLights = !0,
            this.toneMapping = fs,
            this.toneMappingExposure = 1;
            let d = this
              , x = !1
              , y = 0
              , _ = 0
              , S = null
              , N = -1
              , I = null
              , O = new Lt
              , M = new Lt
              , R = null
              , q = t.width
              , k = t.height
              , B = 1
              , P = null
              , C = null
              , L = new Lt(0,0,q,k)
              , F = new Lt(0,0,q,k)
              , U = !1
              , W = new Fc
              , K = !1
              , re = !1
              , oe = null
              , j = new je
              , w = new ue
              , b = {
                background: null,
                fog: null,
                environment: null,
                overrideMaterial: null,
                isScene: !0
            };
            function E() {
                return S === null ? B : 1
            }
            let T = n;
            function H(se, Te) {
                for (let Ae = 0; Ae < se.length; Ae++) {
                    let ye = se[Ae]
                      , Pe = t.getContext(ye, Te);
                    if (Pe !== null)
                        return Pe
                }
                return null
            }
            try {
                let se = {
                    alpha: !0,
                    depth: i,
                    stencil: s,
                    antialias: a,
                    premultipliedAlpha: l,
                    preserveDrawingBuffer: c,
                    powerPreference: u,
                    failIfMajorPerformanceCaveat: h
                };
                if ("setAttribute"in t && t.setAttribute("data-engine", `three.js r ${Dp}`),
                t.addEventListener("webglcontextlost", Ve, !1),
                t.addEventListener("webglcontextrestored", Ze, !1),
                t.addEventListener("webglcontextcreationerror", We, !1),
                T === null) {
                    let Te = ["webgl2", "webgl", "experimental-webgl"];
                    if (d.isWebGL1Renderer === !0 && Te.shift(),
                    T = H(Te, se),
                    T === null)
                        throw H(Te) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
                }
                T.getShaderPrecisionFormat === void 0 && (T.getShaderPrecisionFormat = function() {
                    return {
                        rangeMin: 1,
                        rangeMax: 1,
                        precision: 1
                    }
                }
                )
            } catch (se) {
                throw console.error("THREE.WebGLRenderer: " + se.message),
                se
            }
            let Y, X, ce, J, ae, ie, me, ve, be, fe, te, Ee, Le, D, A, G, ne, Q, he, de, ge, le, xe, Me;
            function Ne() {
                Y = new kM(T),
                X = new PM(T,Y,e),
                Y.init(X),
                le = new fS(T,Y,X),
                ce = new uS(T,Y,X),
                J = new GM(T),
                ae = new $E,
                ie = new hS(T,Y,ce,ae,X,le,J),
                me = new NM(d),
                ve = new FM(d),
                be = new $_(T,X),
                xe = new IM(T,Y,be,X),
                fe = new UM(T,be,J,xe),
                te = new WM(T,fe,be,J),
                he = new HM(T,X,ie),
                G = new LM(ae),
                Ee = new JE(d,me,ve,Y,X,xe,G),
                Le = new pS(d,ae),
                D = new eS,
                A = new oS(Y,X),
                Q = new CM(d,me,ve,ce,te,f,l),
                ne = new cS(d,te,X),
                Me = new mS(T,J,X,ce),
                de = new RM(T,Y,J,X),
                ge = new BM(T,Y,J,X),
                J.programs = Ee.programs,
                d.capabilities = X,
                d.extensions = Y,
                d.properties = ae,
                d.renderLists = D,
                d.shadowMap = ne,
                d.state = ce,
                d.info = J
            }
            Ne();
            let De = new dp(d,T);
            this.xr = De,
            this.getContext = function() {
                return T
            }
            ,
            this.getContextAttributes = function() {
                return T.getContextAttributes()
            }
            ,
            this.forceContextLoss = function() {
                let se = Y.get("WEBGL_lose_context");
                se && se.loseContext()
            }
            ,
            this.forceContextRestore = function() {
                let se = Y.get("WEBGL_lose_context");
                se && se.restoreContext()
            }
            ,
            this.getPixelRatio = function() {
                return B
            }
            ,
            this.setPixelRatio = function(se) {
                se !== void 0 && (B = se,
                this.setSize(q, k, !1))
            }
            ,
            this.getSize = function(se) {
                return se.set(q, k)
            }
            ,
            this.setSize = function(se, Te, Ae=!0) {
                if (De.isPresenting) {
                    console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
                    return
                }
                q = se,
                k = Te,
                t.width = Math.floor(se * B),
                t.height = Math.floor(Te * B),
                Ae === !0 && (t.style.width = se + "px",
                t.style.height = Te + "px"),
                this.setViewport(0, 0, se, Te)
            }
            ,
            this.getDrawingBufferSize = function(se) {
                return se.set(q * B, k * B).floor()
            }
            ,
            this.setDrawingBufferSize = function(se, Te, Ae) {
                q = se,
                k = Te,
                B = Ae,
                t.width = Math.floor(se * Ae),
                t.height = Math.floor(Te * Ae),
                this.setViewport(0, 0, se, Te)
            }
            ,
            this.getCurrentViewport = function(se) {
                return se.copy(O)
            }
            ,
            this.getViewport = function(se) {
                return se.copy(L)
            }
            ,
            this.setViewport = function(se, Te, Ae, ye) {
                se.isVector4 ? L.set(se.x, se.y, se.z, se.w) : L.set(se, Te, Ae, ye),
                ce.viewport(O.copy(L).multiplyScalar(B).floor())
            }
            ,
            this.getScissor = function(se) {
                return se.copy(F)
            }
            ,
            this.setScissor = function(se, Te, Ae, ye) {
                se.isVector4 ? F.set(se.x, se.y, se.z, se.w) : F.set(se, Te, Ae, ye),
                ce.scissor(M.copy(F).multiplyScalar(B).floor())
            }
            ,
            this.getScissorTest = function() {
                return U
            }
            ,
            this.setScissorTest = function(se) {
                ce.setScissorTest(U = se)
            }
            ,
            this.setOpaqueSort = function(se) {
                P = se
            }
            ,
            this.setTransparentSort = function(se) {
                C = se
            }
            ,
            this.getClearColor = function(se) {
                return se.copy(Q.getClearColor())
            }
            ,
            this.setClearColor = function() {
                Q.setClearColor.apply(Q, arguments)
            }
            ,
            this.getClearAlpha = function() {
                return Q.getClearAlpha()
            }
            ,
            this.setClearAlpha = function() {
                Q.setClearAlpha.apply(Q, arguments)
            }
            ,
            this.clear = function(se=!0, Te=!0, Ae=!0) {
                let ye = 0;
                se && (ye |= T.COLOR_BUFFER_BIT),
                Te && (ye |= T.DEPTH_BUFFER_BIT),
                Ae && (ye |= T.STENCIL_BUFFER_BIT),
                T.clear(ye)
            }
            ,
            this.clearColor = function() {
                this.clear(!0, !1, !1)
            }
            ,
            this.clearDepth = function() {
                this.clear(!1, !0, !1)
            }
            ,
            this.clearStencil = function() {
                this.clear(!1, !1, !0)
            }
            ,
            this.dispose = function() {
                t.removeEventListener("webglcontextlost", Ve, !1),
                t.removeEventListener("webglcontextrestored", Ze, !1),
                t.removeEventListener("webglcontextcreationerror", We, !1),
                D.dispose(),
                A.dispose(),
                ae.dispose(),
                me.dispose(),
                ve.dispose(),
                te.dispose(),
                xe.dispose(),
                Me.dispose(),
                Ee.dispose(),
                De.dispose(),
                De.removeEventListener("sessionstart", Ue),
                De.removeEventListener("sessionend", pt),
                oe && (oe.dispose(),
                oe = null),
                mt.stop()
            }
            ;
            function Ve(se) {
                se.preventDefault(),
                console.log("THREE.WebGLRenderer: Context Lost."),
                x = !0
            }
            function Ze() {
                console.log("THREE.WebGLRenderer: Context Restored."),
                x = !1;
                let se = J.autoReset
                  , Te = ne.enabled
                  , Ae = ne.autoUpdate
                  , ye = ne.needsUpdate
                  , Pe = ne.type;
                Ne(),
                J.autoReset = se,
                ne.enabled = Te,
                ne.autoUpdate = Ae,
                ne.needsUpdate = ye,
                ne.type = Pe
            }
            function We(se) {
                console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", se.statusMessage)
            }
            function Qe(se) {
                let Te = se.target;
                Te.removeEventListener("dispose", Qe),
                pe(Te)
            }
            function pe(se) {
                _e(se),
                ae.remove(se)
            }
            function _e(se) {
                let Te = ae.get(se).programs;
                Te !== void 0 && (Te.forEach(function(Ae) {
                    Ee.releaseProgram(Ae)
                }),
                se.isShaderMaterial && Ee.releaseShaderCache(se))
            }
            this.renderBufferDirect = function(se, Te, Ae, ye, Pe, at) {
                Te === null && (Te = b);
                let ht = Pe.isMesh && Pe.matrixWorld.determinant() < 0
                  , gt = Gi(se, Te, Ae, ye, Pe);
                ce.setMaterial(ye, ht);
                let Tt = Ae.index
                  , Mt = 1;
                ye.wireframe === !0 && (Tt = fe.getWireframeAttribute(Ae),
                Mt = 2);
                let Et = Ae.drawRange
                  , At = Ae.attributes.position
                  , zt = Et.start * Mt
                  , Wt = (Et.start + Et.count) * Mt;
                at !== null && (zt = Math.max(zt, at.start * Mt),
                Wt = Math.min(Wt, (at.start + at.count) * Mt)),
                Tt !== null ? (zt = Math.max(zt, 0),
                Wt = Math.min(Wt, Tt.count)) : At != null && (zt = Math.max(zt, 0),
                Wt = Math.min(Wt, At.count));
                let Ln = Wt - zt;
                if (Ln < 0 || Ln === 1 / 0)
                    return;
                xe.setup(Pe, ye, gt, Ae, Tt);
                let tr, on = de;
                if (Tt !== null && (tr = be.get(Tt),
                on = ge,
                on.setIndex(tr)),
                Pe.isMesh)
                    ye.wireframe === !0 ? (ce.setLineWidth(ye.wireframeLinewidth * E()),
                    on.setMode(T.LINES)) : on.setMode(T.TRIANGLES);
                else if (Pe.isLine) {
                    let Rt = ye.linewidth;
                    Rt === void 0 && (Rt = 1),
                    ce.setLineWidth(Rt * E()),
                    Pe.isLineSegments ? on.setMode(T.LINES) : Pe.isLineLoop ? on.setMode(T.LINE_LOOP) : on.setMode(T.LINE_STRIP)
                } else
                    Pe.isPoints ? on.setMode(T.POINTS) : Pe.isSprite && on.setMode(T.TRIANGLES);
                if (Pe.isInstancedMesh)
                    on.renderInstances(zt, Ln, Pe.count);
                else if (Ae.isInstancedBufferGeometry) {
                    let Rt = Ae._maxInstanceCount !== void 0 ? Ae._maxInstanceCount : 1 / 0
                      , ta = Math.min(Ae.instanceCount, Rt);
                    on.renderInstances(zt, Ln, ta)
                } else
                    on.render(zt, Ln)
            }
            ,
            this.compile = function(se, Te) {
                function Ae(ye, Pe, at) {
                    ye.transparent === !0 && ye.side === On && ye.forceSinglePass === !1 ? (ye.side = Mn,
                    ye.needsUpdate = !0,
                    tt(ye, Pe, at),
                    ye.side = qi,
                    ye.needsUpdate = !0,
                    tt(ye, Pe, at),
                    ye.side = On) : tt(ye, Pe, at)
                }
                g = A.get(se),
                g.init(),
                p.push(g),
                se.traverseVisible(function(ye) {
                    ye.isLight && ye.layers.test(Te.layers) && (g.pushLight(ye),
                    ye.castShadow && g.pushShadow(ye))
                }),
                g.setupLights(d.useLegacyLights),
                se.traverse(function(ye) {
                    let Pe = ye.material;
                    if (Pe)
                        if (Array.isArray(Pe))
                            for (let at = 0; at < Pe.length; at++) {
                                let ht = Pe[at];
                                Ae(ht, se, ye)
                            }
                        else
                            Ae(Pe, se, ye)
                }),
                p.pop(),
                g = null
            }
            ;
            let we = null;
            function Fe(se) {
                we && we(se)
            }
            function Ue() {
                mt.stop()
            }
            function pt() {
                mt.start()
            }
            let mt = new bv;
            mt.setAnimationLoop(Fe),
            typeof self < "u" && mt.setContext(self),
            this.setAnimationLoop = function(se) {
                we = se,
                De.setAnimationLoop(se),
                se === null ? mt.stop() : mt.start()
            }
            ,
            De.addEventListener("sessionstart", Ue),
            De.addEventListener("sessionend", pt),
            this.render = function(se, Te) {
                if (Te !== void 0 && Te.isCamera !== !0) {
                    console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                    return
                }
                if (x === !0)
                    return;
                se.matrixWorldAutoUpdate === !0 && se.updateMatrixWorld(),
                Te.parent === null && Te.matrixWorldAutoUpdate === !0 && Te.updateMatrixWorld(),
                De.enabled === !0 && De.isPresenting === !0 && (De.cameraAutoUpdate === !0 && De.updateCamera(Te),
                Te = De.getCamera()),
                se.isScene === !0 && se.onBeforeRender(d, se, Te, S),
                g = A.get(se, p.length),
                g.init(),
                p.push(g),
                j.multiplyMatrices(Te.projectionMatrix, Te.matrixWorldInverse),
                W.setFromProjectionMatrix(j),
                re = this.localClippingEnabled,
                K = G.init(this.clippingPlanes, re),
                m = D.get(se, v.length),
                m.init(),
                v.push(m),
                ot(se, Te, 0, d.sortObjects),
                m.finish(),
                d.sortObjects === !0 && m.sort(P, C),
                K === !0 && G.beginShadows();
                let Ae = g.state.shadowsArray;
                if (ne.render(Ae, se, Te),
                K === !0 && G.endShadows(),
                this.info.autoReset === !0 && this.info.reset(),
                Q.render(m, se),
                g.setupLights(d.useLegacyLights),
                Te.isArrayCamera) {
                    let ye = Te.cameras;
                    for (let Pe = 0, at = ye.length; Pe < at; Pe++) {
                        let ht = ye[Pe];
                        Ke(m, se, ht, ht.viewport)
                    }
                } else
                    Ke(m, se, Te);
                S !== null && (ie.updateMultisampleRenderTarget(S),
                ie.updateRenderTargetMipmap(S)),
                se.isScene === !0 && se.onAfterRender(d, se, Te),
                xe.resetDefaultState(),
                N = -1,
                I = null,
                p.pop(),
                p.length > 0 ? g = p[p.length - 1] : g = null,
                v.pop(),
                v.length > 0 ? m = v[v.length - 1] : m = null
            }
            ;
            function ot(se, Te, Ae, ye) {
                if (se.visible === !1)
                    return;
                if (se.layers.test(Te.layers)) {
                    if (se.isGroup)
                        Ae = se.renderOrder;
                    else if (se.isLOD)
                        se.autoUpdate === !0 && se.update(Te);
                    else if (se.isLight)
                        g.pushLight(se),
                        se.castShadow && g.pushShadow(se);
                    else if (se.isSprite) {
                        if (!se.frustumCulled || W.intersectsSprite(se)) {
                            ye && w.setFromMatrixPosition(se.matrixWorld).applyMatrix4(j);
                            let ht = te.update(se)
                              , gt = se.material;
                            gt.visible && m.push(se, ht, gt, Ae, w.z, null)
                        }
                    } else if ((se.isMesh || se.isLine || se.isPoints) && (!se.frustumCulled || W.intersectsObject(se))) {
                        se.isSkinnedMesh && se.skeleton.frame !== J.render.frame && (se.skeleton.update(),
                        se.skeleton.frame = J.render.frame);
                        let ht = te.update(se)
                          , gt = se.material;
                        if (ye && (ht.boundingSphere === null && ht.computeBoundingSphere(),
                        w.copy(ht.boundingSphere.center).applyMatrix4(se.matrixWorld).applyMatrix4(j)),
                        Array.isArray(gt)) {
                            let Tt = ht.groups;
                            for (let Mt = 0, Et = Tt.length; Mt < Et; Mt++) {
                                let At = Tt[Mt]
                                  , zt = gt[At.materialIndex];
                                zt && zt.visible && m.push(se, ht, zt, Ae, w.z, At)
                            }
                        } else
                            gt.visible && m.push(se, ht, gt, Ae, w.z, null)
                    }
                }
                let at = se.children;
                for (let ht = 0, gt = at.length; ht < gt; ht++)
                    ot(at[ht], Te, Ae, ye)
            }
            function Ke(se, Te, Ae, ye) {
                let Pe = se.opaque
                  , at = se.transmissive
                  , ht = se.transparent;
                g.setupLightsView(Ae),
                K === !0 && G.setGlobalState(d.clippingPlanes, Ae),
                at.length > 0 && ke(Pe, at, Te, Ae),
                ye && ce.viewport(O.copy(ye)),
                Pe.length > 0 && Be(Pe, Te, Ae),
                at.length > 0 && Be(at, Te, Ae),
                ht.length > 0 && Be(ht, Te, Ae),
                ce.buffers.depth.setTest(!0),
                ce.buffers.depth.setMask(!0),
                ce.buffers.color.setMask(!0),
                ce.setPolygonOffset(!1)
            }
            function ke(se, Te, Ae, ye) {
                if (oe === null) {
                    let gt = X.isWebGL2;
                    oe = new ds(1024,1024,{
                        generateMipmaps: !0,
                        type: Y.has("EXT_color_buffer_half_float") ? Lc : Lo,
                        minFilter: lr,
                        samples: gt && a === !0 ? 4 : 0
                    })
                }
                let Pe = d.getRenderTarget();
                d.setRenderTarget(oe),
                d.clear();
                let at = d.toneMapping;
                d.toneMapping = fs,
                Be(se, Ae, ye),
                ie.updateMultisampleRenderTarget(oe),
                ie.updateRenderTargetMipmap(oe);
                let ht = !1;
                for (let gt = 0, Tt = Te.length; gt < Tt; gt++) {
                    let Mt = Te[gt]
                      , Et = Mt.object
                      , At = Mt.geometry
                      , zt = Mt.material
                      , Wt = Mt.group;
                    if (zt.side === On && Et.layers.test(ye.layers)) {
                        let Ln = zt.side;
                        zt.side = Mn,
                        zt.needsUpdate = !0,
                        Ye(Et, Ae, ye, At, zt, Wt),
                        zt.side = Ln,
                        zt.needsUpdate = !0,
                        ht = !0
                    }
                }
                ht === !0 && (ie.updateMultisampleRenderTarget(oe),
                ie.updateRenderTargetMipmap(oe)),
                d.setRenderTarget(Pe),
                d.toneMapping = at
            }
            function Be(se, Te, Ae) {
                let ye = Te.isScene === !0 ? Te.overrideMaterial : null;
                for (let Pe = 0, at = se.length; Pe < at; Pe++) {
                    let ht = se[Pe]
                      , gt = ht.object
                      , Tt = ht.geometry
                      , Mt = ye === null ? ht.material : ye
                      , Et = ht.group;
                    gt.layers.test(Ae.layers) && Ye(gt, Te, Ae, Tt, Mt, Et)
                }
            }
            function Ye(se, Te, Ae, ye, Pe, at) {
                se.onBeforeRender(d, Te, Ae, ye, Pe, at),
                se.modelViewMatrix.multiplyMatrices(Ae.matrixWorldInverse, se.matrixWorld),
                se.normalMatrix.getNormalMatrix(se.modelViewMatrix),
                Pe.onBeforeRender(d, Te, Ae, ye, se, at),
                Pe.transparent === !0 && Pe.side === On && Pe.forceSinglePass === !1 ? (Pe.side = Mn,
                Pe.needsUpdate = !0,
                d.renderBufferDirect(Ae, Te, ye, Pe, se, at),
                Pe.side = qi,
                Pe.needsUpdate = !0,
                d.renderBufferDirect(Ae, Te, ye, Pe, se, at),
                Pe.side = On) : d.renderBufferDirect(Ae, Te, ye, Pe, se, at),
                se.onAfterRender(d, Te, Ae, ye, Pe, at)
            }
            function tt(se, Te, Ae) {
                Te.isScene !== !0 && (Te = b);
                let ye = ae.get(se)
                  , Pe = g.state.lights
                  , at = g.state.shadowsArray
                  , ht = Pe.state.version
                  , gt = Ee.getParameters(se, Pe.state, at, Te, Ae)
                  , Tt = Ee.getProgramCacheKey(gt)
                  , Mt = ye.programs;
                ye.environment = se.isMeshStandardMaterial ? Te.environment : null,
                ye.fog = Te.fog,
                ye.envMap = (se.isMeshStandardMaterial ? ve : me).get(se.envMap || ye.environment),
                Mt === void 0 && (se.addEventListener("dispose", Qe),
                Mt = new Map,
                ye.programs = Mt);
                let Et = Mt.get(Tt);
                if (Et !== void 0) {
                    if (ye.currentProgram === Et && ye.lightsStateVersion === ht)
                        return qt(se, gt),
                        Et
                } else
                    gt.uniforms = Ee.getUniforms(se),
                    se.onBuild(Ae, gt, d),
                    se.onBeforeCompile(gt, d),
                    Et = Ee.acquireProgram(gt, Tt),
                    Mt.set(Tt, Et),
                    ye.uniforms = gt.uniforms;
                let At = ye.uniforms;
                (!se.isShaderMaterial && !se.isRawShaderMaterial || se.clipping === !0) && (At.clippingPlanes = G.uniform),
                qt(se, gt),
                ye.needsLights = xo(se),
                ye.lightsStateVersion = ht,
                ye.needsLights && (At.ambientLightColor.value = Pe.state.ambient,
                At.lightProbe.value = Pe.state.probe,
                At.directionalLights.value = Pe.state.directional,
                At.directionalLightShadows.value = Pe.state.directionalShadow,
                At.spotLights.value = Pe.state.spot,
                At.spotLightShadows.value = Pe.state.spotShadow,
                At.rectAreaLights.value = Pe.state.rectArea,
                At.ltc_1.value = Pe.state.rectAreaLTC1,
                At.ltc_2.value = Pe.state.rectAreaLTC2,
                At.pointLights.value = Pe.state.point,
                At.pointLightShadows.value = Pe.state.pointShadow,
                At.hemisphereLights.value = Pe.state.hemi,
                At.directionalShadowMap.value = Pe.state.directionalShadowMap,
                At.directionalShadowMatrix.value = Pe.state.directionalShadowMatrix,
                At.spotShadowMap.value = Pe.state.spotShadowMap,
                At.spotLightMatrix.value = Pe.state.spotLightMatrix,
                At.spotLightMap.value = Pe.state.spotLightMap,
                At.pointShadowMap.value = Pe.state.pointShadowMap,
                At.pointShadowMatrix.value = Pe.state.pointShadowMatrix);
                let zt = Et.getUniforms()
                  , Wt = Oa.seqWithValue(zt.seq, At);
                return ye.currentProgram = Et,
                ye.uniformsList = Wt,
                Et
            }
            function qt(se, Te) {
                let Ae = ae.get(se);
                Ae.outputColorSpace = Te.outputColorSpace,
                Ae.instancing = Te.instancing,
                Ae.skinning = Te.skinning,
                Ae.morphTargets = Te.morphTargets,
                Ae.morphNormals = Te.morphNormals,
                Ae.morphColors = Te.morphColors,
                Ae.morphTargetsCount = Te.morphTargetsCount,
                Ae.numClippingPlanes = Te.numClippingPlanes,
                Ae.numIntersection = Te.numClipIntersection,
                Ae.vertexAlphas = Te.vertexAlphas,
                Ae.vertexTangents = Te.vertexTangents,
                Ae.toneMapping = Te.toneMapping
            }
            function Gi(se, Te, Ae, ye, Pe) {
                Te.isScene !== !0 && (Te = b),
                ie.resetTextureUnits();
                let at = Te.fog
                  , ht = ye.isMeshStandardMaterial ? Te.environment : null
                  , gt = S === null ? d.outputColorSpace : S.isXRRenderTarget === !0 ? S.texture.colorSpace : di
                  , Tt = (ye.isMeshStandardMaterial ? ve : me).get(ye.envMap || ht)
                  , Mt = ye.vertexColors === !0 && !!Ae.attributes.color && Ae.attributes.color.itemSize === 4
                  , Et = !!ye.normalMap && !!Ae.attributes.tangent
                  , At = !!Ae.morphAttributes.position
                  , zt = !!Ae.morphAttributes.normal
                  , Wt = !!Ae.morphAttributes.color
                  , Ln = ye.toneMapped ? d.toneMapping : fs
                  , tr = Ae.morphAttributes.position || Ae.morphAttributes.normal || Ae.morphAttributes.color
                  , on = tr !== void 0 ? tr.length : 0
                  , Rt = ae.get(ye)
                  , ta = g.state.lights;
                if (K === !0 && (re === !0 || se !== I)) {
                    let ei = se === I && ye.id === N;
                    G.setState(ye, se, ei)
                }
                let gn = !1;
                ye.version === Rt.__version ? (Rt.needsLights && Rt.lightsStateVersion !== ta.state.version || Rt.outputColorSpace !== gt || Pe.isInstancedMesh && Rt.instancing === !1 || !Pe.isInstancedMesh && Rt.instancing === !0 || Pe.isSkinnedMesh && Rt.skinning === !1 || !Pe.isSkinnedMesh && Rt.skinning === !0 || Rt.envMap !== Tt || ye.fog === !0 && Rt.fog !== at || Rt.numClippingPlanes !== void 0 && (Rt.numClippingPlanes !== G.numPlanes || Rt.numIntersection !== G.numIntersection) || Rt.vertexAlphas !== Mt || Rt.vertexTangents !== Et || Rt.morphTargets !== At || Rt.morphNormals !== zt || Rt.morphColors !== Wt || Rt.toneMapping !== Ln || X.isWebGL2 === !0 && Rt.morphTargetsCount !== on) && (gn = !0) : (gn = !0,
                Rt.__version = ye.version);
                let $r = Rt.currentProgram;
                gn === !0 && ($r = tt(ye, Te, Pe));
                let Pu = !1
                  , Ls = !1
                  , na = !1
                  , cn = $r.getUniforms()
                  , Qr = Rt.uniforms;
                if (ce.useProgram($r.program) && (Pu = !0,
                Ls = !0,
                na = !0),
                ye.id !== N && (N = ye.id,
                Ls = !0),
                Pu || I !== se) {
                    if (cn.setValue(T, "projectionMatrix", se.projectionMatrix),
                    X.logarithmicDepthBuffer && cn.setValue(T, "logDepthBufFC", 2 / (Math.log(se.far + 1) / Math.LN2)),
                    I !== se && (I = se,
                    Ls = !0,
                    na = !0),
                    ye.isShaderMaterial || ye.isMeshPhongMaterial || ye.isMeshToonMaterial || ye.isMeshStandardMaterial || ye.envMap) {
                        let ei = cn.map.cameraPosition;
                        ei !== void 0 && ei.setValue(T, w.setFromMatrixPosition(se.matrixWorld))
                    }
                    (ye.isMeshPhongMaterial || ye.isMeshToonMaterial || ye.isMeshLambertMaterial || ye.isMeshBasicMaterial || ye.isMeshStandardMaterial || ye.isShaderMaterial) && cn.setValue(T, "isOrthographic", se.isOrthographicCamera === !0),
                    (ye.isMeshPhongMaterial || ye.isMeshToonMaterial || ye.isMeshLambertMaterial || ye.isMeshBasicMaterial || ye.isMeshStandardMaterial || ye.isShaderMaterial || ye.isShadowMaterial || Pe.isSkinnedMesh) && cn.setValue(T, "viewMatrix", se.matrixWorldInverse)
                }
                if (Pe.isSkinnedMesh) {
                    cn.setOptional(T, Pe, "bindMatrix"),
                    cn.setOptional(T, Pe, "bindMatrixInverse");
                    let ei = Pe.skeleton;
                    ei && (X.floatVertexTextures ? (ei.boneTexture === null && ei.computeBoneTexture(),
                    cn.setValue(T, "boneTexture", ei.boneTexture, ie),
                    cn.setValue(T, "boneTextureSize", ei.boneTextureSize)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))
                }
                let ia = Ae.morphAttributes;
                if ((ia.position !== void 0 || ia.normal !== void 0 || ia.color !== void 0 && X.isWebGL2 === !0) && he.update(Pe, Ae, $r),
                (Ls || Rt.receiveShadow !== Pe.receiveShadow) && (Rt.receiveShadow = Pe.receiveShadow,
                cn.setValue(T, "receiveShadow", Pe.receiveShadow)),
                ye.isMeshGouraudMaterial && ye.envMap !== null && (Qr.envMap.value = Tt,
                Qr.flipEnvMap.value = Tt.isCubeTexture && Tt.isRenderTargetTexture === !1 ? -1 : 1),
                Ls && (cn.setValue(T, "toneMappingExposure", d.toneMappingExposure),
                Rt.needsLights && Vi(Qr, na),
                at && ye.fog === !0 && Le.refreshFogUniforms(Qr, at),
                Le.refreshMaterialUniforms(Qr, ye, B, k, oe),
                Oa.upload(T, Rt.uniformsList, Qr, ie)),
                ye.isShaderMaterial && ye.uniformsNeedUpdate === !0 && (Oa.upload(T, Rt.uniformsList, Qr, ie),
                ye.uniformsNeedUpdate = !1),
                ye.isSpriteMaterial && cn.setValue(T, "center", Pe.center),
                cn.setValue(T, "modelViewMatrix", Pe.modelViewMatrix),
                cn.setValue(T, "normalMatrix", Pe.normalMatrix),
                cn.setValue(T, "modelMatrix", Pe.matrixWorld),
                ye.isShaderMaterial || ye.isRawShaderMaterial) {
                    let ei = ye.uniformsGroups;
                    for (let ra = 0, fd = ei.length; ra < fd; ra++)
                        if (X.isWebGL2) {
                            let Lu = ei[ra];
                            Me.update(Lu, $r),
                            Me.bind(Lu, $r)
                        } else
                            console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")
                }
                return $r
            }
            function Vi(se, Te) {
                se.ambientLightColor.needsUpdate = Te,
                se.lightProbe.needsUpdate = Te,
                se.directionalLights.needsUpdate = Te,
                se.directionalLightShadows.needsUpdate = Te,
                se.pointLights.needsUpdate = Te,
                se.pointLightShadows.needsUpdate = Te,
                se.spotLights.needsUpdate = Te,
                se.spotLightShadows.needsUpdate = Te,
                se.rectAreaLights.needsUpdate = Te,
                se.hemisphereLights.needsUpdate = Te
            }
            function xo(se) {
                return se.isMeshLambertMaterial || se.isMeshToonMaterial || se.isMeshPhongMaterial || se.isMeshStandardMaterial || se.isShadowMaterial || se.isShaderMaterial && se.lights === !0
            }
            this.getActiveCubeFace = function() {
                return y
            }
            ,
            this.getActiveMipmapLevel = function() {
                return _
            }
            ,
            this.getRenderTarget = function() {
                return S
            }
            ,
            this.setRenderTargetTextures = function(se, Te, Ae) {
                ae.get(se.texture).__webglTexture = Te,
                ae.get(se.depthTexture).__webglTexture = Ae;
                let ye = ae.get(se);
                ye.__hasExternalTextures = !0,
                ye.__hasExternalTextures && (ye.__autoAllocateDepthBuffer = Ae === void 0,
                ye.__autoAllocateDepthBuffer || Y.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),
                ye.__useRenderToTexture = !1))
            }
            ,
            this.setRenderTargetFramebuffer = function(se, Te) {
                let Ae = ae.get(se);
                Ae.__webglFramebuffer = Te,
                Ae.__useDefaultFramebuffer = Te === void 0
            }
            ,
            this.setRenderTarget = function(se, Te=0, Ae=0) {
                S = se,
                y = Te,
                _ = Ae;
                let ye = !0
                  , Pe = null
                  , at = !1
                  , ht = !1;
                if (se) {
                    let Tt = ae.get(se);
                    Tt.__useDefaultFramebuffer !== void 0 ? (ce.bindFramebuffer(T.FRAMEBUFFER, null),
                    ye = !1) : Tt.__webglFramebuffer === void 0 ? ie.setupRenderTarget(se) : Tt.__hasExternalTextures && ie.rebindTextures(se, ae.get(se.texture).__webglTexture, ae.get(se.depthTexture).__webglTexture);
                    let Mt = se.texture;
                    (Mt.isData3DTexture || Mt.isDataArrayTexture || Mt.isCompressedArrayTexture) && (ht = !0);
                    let Et = ae.get(se).__webglFramebuffer;
                    se.isWebGLCubeRenderTarget ? (Pe = Et[Te],
                    at = !0) : X.isWebGL2 && se.samples > 0 && ie.useMultisampledRTT(se) === !1 ? Pe = ae.get(se).__webglMultisampledFramebuffer : Pe = Et,
                    O.copy(se.viewport),
                    M.copy(se.scissor),
                    R = se.scissorTest
                } else
                    O.copy(L).multiplyScalar(B).floor(),
                    M.copy(F).multiplyScalar(B).floor(),
                    R = U;
                if (ce.bindFramebuffer(T.FRAMEBUFFER, Pe) && X.drawBuffers && ye && ce.drawBuffers(se, Pe),
                ce.viewport(O),
                ce.scissor(M),
                ce.setScissorTest(R),
                at) {
                    let Tt = ae.get(se.texture);
                    T.framebufferTexture2D(T.FRAMEBUFFER, T.COLOR_ATTACHMENT0, T.TEXTURE_CUBE_MAP_POSITIVE_X + Te, Tt.__webglTexture, Ae)
                } else if (ht) {
                    let Tt = ae.get(se.texture)
                      , Mt = Te || 0;
                    T.framebufferTextureLayer(T.FRAMEBUFFER, T.COLOR_ATTACHMENT0, Tt.__webglTexture, Ae || 0, Mt)
                }
                N = -1
            }
            ,
            this.readRenderTargetPixels = function(se, Te, Ae, ye, Pe, at, ht) {
                if (!(se && se.isWebGLRenderTarget)) {
                    console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                    return
                }
                let gt = ae.get(se).__webglFramebuffer;
                if (se.isWebGLCubeRenderTarget && ht !== void 0 && (gt = gt[ht]),
                gt) {
                    ce.bindFramebuffer(T.FRAMEBUFFER, gt);
                    try {
                        let Tt = se.texture
                          , Mt = Tt.format
                          , Et = Tt.type;
                        if (Mt !== Xi && le.convert(Mt) !== T.getParameter(T.IMPLEMENTATION_COLOR_READ_FORMAT)) {
                            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                            return
                        }
                        let At = Et === Lc && (Y.has("EXT_color_buffer_half_float") || X.isWebGL2 && Y.has("EXT_color_buffer_float"));
                        if (Et !== Lo && le.convert(Et) !== T.getParameter(T.IMPLEMENTATION_COLOR_READ_TYPE) && !(Et === Vs && (X.isWebGL2 || Y.has("OES_texture_float") || Y.has("WEBGL_color_buffer_float"))) && !At) {
                            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                            return
                        }
                        Te >= 0 && Te <= se.width - ye && Ae >= 0 && Ae <= se.height - Pe && T.readPixels(Te, Ae, ye, Pe, le.convert(Mt), le.convert(Et), at)
                    } finally {
                        let Tt = S !== null ? ae.get(S).__webglFramebuffer : null;
                        ce.bindFramebuffer(T.FRAMEBUFFER, Tt)
                    }
                }
            }
            ,
            this.copyFramebufferToTexture = function(se, Te, Ae=0) {
                let ye = Math.pow(2, -Ae)
                  , Pe = Math.floor(Te.image.width * ye)
                  , at = Math.floor(Te.image.height * ye);
                ie.setTexture2D(Te, 0),
                T.copyTexSubImage2D(T.TEXTURE_2D, Ae, 0, 0, se.x, se.y, Pe, at),
                ce.unbindTexture()
            }
            ,
            this.copyTextureToTexture = function(se, Te, Ae, ye=0) {
                let Pe = Te.image.width
                  , at = Te.image.height
                  , ht = le.convert(Ae.format)
                  , gt = le.convert(Ae.type);
                ie.setTexture2D(Ae, 0),
                T.pixelStorei(T.UNPACK_FLIP_Y_WEBGL, Ae.flipY),
                T.pixelStorei(T.UNPACK_PREMULTIPLY_ALPHA_WEBGL, Ae.premultiplyAlpha),
                T.pixelStorei(T.UNPACK_ALIGNMENT, Ae.unpackAlignment),
                Te.isDataTexture ? T.texSubImage2D(T.TEXTURE_2D, ye, se.x, se.y, Pe, at, ht, gt, Te.image.data) : Te.isCompressedTexture ? T.compressedTexSubImage2D(T.TEXTURE_2D, ye, se.x, se.y, Te.mipmaps[0].width, Te.mipmaps[0].height, ht, Te.mipmaps[0].data) : T.texSubImage2D(T.TEXTURE_2D, ye, se.x, se.y, ht, gt, Te.image),
                ye === 0 && Ae.generateMipmaps && T.generateMipmap(T.TEXTURE_2D),
                ce.unbindTexture()
            }
            ,
            this.copyTextureToTexture3D = function(se, Te, Ae, ye, Pe=0) {
                if (d.isWebGL1Renderer) {
                    console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
                    return
                }
                let at = se.max.x - se.min.x + 1, ht = se.max.y - se.min.y + 1, gt = se.max.z - se.min.z + 1, Tt = le.convert(ye.format), Mt = le.convert(ye.type), Et;
                if (ye.isData3DTexture)
                    ie.setTexture3D(ye, 0),
                    Et = T.TEXTURE_3D;
                else if (ye.isDataArrayTexture)
                    ie.setTexture2DArray(ye, 0),
                    Et = T.TEXTURE_2D_ARRAY;
                else {
                    console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                    return
                }
                T.pixelStorei(T.UNPACK_FLIP_Y_WEBGL, ye.flipY),
                T.pixelStorei(T.UNPACK_PREMULTIPLY_ALPHA_WEBGL, ye.premultiplyAlpha),
                T.pixelStorei(T.UNPACK_ALIGNMENT, ye.unpackAlignment);
                let At = T.getParameter(T.UNPACK_ROW_LENGTH)
                  , zt = T.getParameter(T.UNPACK_IMAGE_HEIGHT)
                  , Wt = T.getParameter(T.UNPACK_SKIP_PIXELS)
                  , Ln = T.getParameter(T.UNPACK_SKIP_ROWS)
                  , tr = T.getParameter(T.UNPACK_SKIP_IMAGES)
                  , on = Ae.isCompressedTexture ? Ae.mipmaps[0] : Ae.image;
                T.pixelStorei(T.UNPACK_ROW_LENGTH, on.width),
                T.pixelStorei(T.UNPACK_IMAGE_HEIGHT, on.height),
                T.pixelStorei(T.UNPACK_SKIP_PIXELS, se.min.x),
                T.pixelStorei(T.UNPACK_SKIP_ROWS, se.min.y),
                T.pixelStorei(T.UNPACK_SKIP_IMAGES, se.min.z),
                Ae.isDataTexture || Ae.isData3DTexture ? T.texSubImage3D(Et, Pe, Te.x, Te.y, Te.z, at, ht, gt, Tt, Mt, on.data) : Ae.isCompressedArrayTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),
                T.compressedTexSubImage3D(Et, Pe, Te.x, Te.y, Te.z, at, ht, gt, Tt, on.data)) : T.texSubImage3D(Et, Pe, Te.x, Te.y, Te.z, at, ht, gt, Tt, Mt, on),
                T.pixelStorei(T.UNPACK_ROW_LENGTH, At),
                T.pixelStorei(T.UNPACK_IMAGE_HEIGHT, zt),
                T.pixelStorei(T.UNPACK_SKIP_PIXELS, Wt),
                T.pixelStorei(T.UNPACK_SKIP_ROWS, Ln),
                T.pixelStorei(T.UNPACK_SKIP_IMAGES, tr),
                Pe === 0 && ye.generateMipmaps && T.generateMipmap(Et),
                ce.unbindTexture()
            }
            ,
            this.initTexture = function(se) {
                se.isCubeTexture ? ie.setTextureCube(se, 0) : se.isData3DTexture ? ie.setTexture3D(se, 0) : se.isDataArrayTexture || se.isCompressedArrayTexture ? ie.setTexture2DArray(se, 0) : ie.setTexture2D(se, 0),
                ce.unbindTexture()
            }
            ,
            this.resetState = function() {
                y = 0,
                _ = 0,
                S = null,
                ce.reset(),
                xe.reset()
            }
            ,
            typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
                detail: this
            }))
        }
        get physicallyCorrectLights() {
            return console.warn("THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."),
            !this.useLegacyLights
        }
        set physicallyCorrectLights(e) {
            console.warn("THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."),
            this.useLegacyLights = !e
        }
        get outputEncoding() {
            return console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."),
            this.outputColorSpace === ct ? Ro : mv
        }
        set outputEncoding(e) {
            console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."),
            this.outputColorSpace = e === Ro ? ct : di
        }
    }
      , pp = class extends Oo {
    }
    ;
    pp.prototype.isWebGL1Renderer = !0;
    var Or = class extends bt {
        constructor() {
            super(),
            this.isScene = !0,
            this.type = "Scene",
            this.background = null,
            this.environment = null,
            this.fog = null,
            this.backgroundBlurriness = 0,
            this.backgroundIntensity = 1,
            this.overrideMaterial = null,
            typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
                detail: this
            }))
        }
        copy(e, t) {
            return super.copy(e, t),
            e.background !== null && (this.background = e.background.clone()),
            e.environment !== null && (this.environment = e.environment.clone()),
            e.fog !== null && (this.fog = e.fog.clone()),
            this.backgroundBlurriness = e.backgroundBlurriness,
            this.backgroundIntensity = e.backgroundIntensity,
            e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()),
            this.matrixAutoUpdate = e.matrixAutoUpdate,
            this
        }
        toJSON(e) {
            let t = super.toJSON(e);
            return this.fog !== null && (t.object.fog = this.fog.toJSON()),
            this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness),
            this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity),
            t
        }
        get autoUpdate() {
            return console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."),
            this.matrixWorldAutoUpdate
        }
        set autoUpdate(e) {
            console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."),
            this.matrixWorldAutoUpdate = e
        }
    }
    ;
    var z0 = new ue
      , H0 = new Lt
      , W0 = new Lt
      , vS = new ue
      , X0 = new je
      , Aa = new ue
      , Wa = class extends Ht {
        constructor(e, t) {
            super(e, t),
            this.isSkinnedMesh = !0,
            this.type = "SkinnedMesh",
            this.bindMode = "attached",
            this.bindMatrix = new je,
            this.bindMatrixInverse = new je,
            this.boundingBox = null,
            this.boundingSphere = null
        }
        computeBoundingBox() {
            let e = this.geometry;
            this.boundingBox === null && (this.boundingBox = new cr),
            this.boundingBox.makeEmpty();
            let t = e.getAttribute("position");
            for (let n = 0; n < t.count; n++)
                Aa.fromBufferAttribute(t, n),
                this.applyBoneTransform(n, Aa),
                this.boundingBox.expandByPoint(Aa)
        }
        computeBoundingSphere() {
            let e = this.geometry;
            this.boundingSphere === null && (this.boundingSphere = new Nr),
            this.boundingSphere.makeEmpty();
            let t = e.getAttribute("position");
            for (let n = 0; n < t.count; n++)
                Aa.fromBufferAttribute(t, n),
                this.applyBoneTransform(n, Aa),
                this.boundingSphere.expandByPoint(Aa)
        }
        copy(e, t) {
            return super.copy(e, t),
            this.bindMode = e.bindMode,
            this.bindMatrix.copy(e.bindMatrix),
            this.bindMatrixInverse.copy(e.bindMatrixInverse),
            this.skeleton = e.skeleton,
            this
        }
        getVertexPosition(e, t) {
            return super.getVertexPosition(e, t),
            this.applyBoneTransform(e, t),
            t
        }
        bind(e, t) {
            this.skeleton = e,
            t === void 0 && (this.updateMatrixWorld(!0),
            this.skeleton.calculateInverses(),
            t = this.matrixWorld),
            this.bindMatrix.copy(t),
            this.bindMatrixInverse.copy(t).invert()
        }
        pose() {
            this.skeleton.pose()
        }
        normalizeSkinWeights() {
            let e = new Lt
              , t = this.geometry.attributes.skinWeight;
            for (let n = 0, i = t.count; n < i; n++) {
                e.fromBufferAttribute(t, n);
                let s = 1 / e.manhattanLength();
                s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0),
                t.setXYZW(n, e.x, e.y, e.z, e.w)
            }
        }
        updateMatrixWorld(e) {
            super.updateMatrixWorld(e),
            this.bindMode === "attached" ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === "detached" ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
        }
        applyBoneTransform(e, t) {
            let n = this.skeleton
              , i = this.geometry;
            H0.fromBufferAttribute(i.attributes.skinIndex, e),
            W0.fromBufferAttribute(i.attributes.skinWeight, e),
            z0.copy(t).applyMatrix4(this.bindMatrix),
            t.set(0, 0, 0);
            for (let s = 0; s < 4; s++) {
                let o = W0.getComponent(s);
                if (o !== 0) {
                    let a = H0.getComponent(s);
                    X0.multiplyMatrices(n.bones[a].matrixWorld, n.boneInverses[a]),
                    t.addScaledVector(vS.copy(z0).applyMatrix4(X0), o)
                }
            }
            return t.applyMatrix4(this.bindMatrixInverse)
        }
        boneTransform(e, t) {
            return console.warn("THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151."),
            this.applyBoneTransform(e, t)
        }
    }
      , Xs = class extends bt {
        constructor() {
            super(),
            this.isBone = !0,
            this.type = "Bone"
        }
    }
      , Xa = class extends En {
        constructor(e=null, t=1, n=1, i, s, o, a, l, c=Tn, u=Tn, h, f) {
            super(null, o, a, l, c, u, i, s, h, f),
            this.isDataTexture = !0,
            this.image = {
                data: e,
                width: t,
                height: n
            },
            this.generateMipmaps = !1,
            this.flipY = !1,
            this.unpackAlignment = 1
        }
    }
      , j0 = new je
      , yS = new je
      , js = class {
        constructor(e=[], t=[]) {
            this.uuid = ys(),
            this.bones = e.slice(0),
            this.boneInverses = t,
            this.boneMatrices = null,
            this.boneTexture = null,
            this.boneTextureSize = 0,
            this.frame = -1,
            this.init()
        }
        init() {
            let e = this.bones
              , t = this.boneInverses;
            if (this.boneMatrices = new Float32Array(e.length * 16),
            t.length === 0)
                this.calculateInverses();
            else if (e.length !== t.length) {
                console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),
                this.boneInverses = [];
                for (let n = 0, i = this.bones.length; n < i; n++)
                    this.boneInverses.push(new je)
            }
        }
        calculateInverses() {
            this.boneInverses.length = 0;
            for (let e = 0, t = this.bones.length; e < t; e++) {
                let n = new je;
                this.bones[e] && n.copy(this.bones[e].matrixWorld).invert(),
                this.boneInverses.push(n)
            }
        }
        pose() {
            for (let e = 0, t = this.bones.length; e < t; e++) {
                let n = this.bones[e];
                n && n.matrixWorld.copy(this.boneInverses[e]).invert()
            }
            for (let e = 0, t = this.bones.length; e < t; e++) {
                let n = this.bones[e];
                n && (n.parent && n.parent.isBone ? (n.matrix.copy(n.parent.matrixWorld).invert(),
                n.matrix.multiply(n.matrixWorld)) : n.matrix.copy(n.matrixWorld),
                n.matrix.decompose(n.position, n.quaternion, n.scale))
            }
        }
        update() {
            let e = this.bones
              , t = this.boneInverses
              , n = this.boneMatrices
              , i = this.boneTexture;
            for (let s = 0, o = e.length; s < o; s++) {
                let a = e[s] ? e[s].matrixWorld : yS;
                j0.multiplyMatrices(a, t[s]),
                j0.toArray(n, s * 16)
            }
            i !== null && (i.needsUpdate = !0)
        }
        clone() {
            return new js(this.bones,this.boneInverses)
        }
        computeBoneTexture() {
            let e = Math.sqrt(this.bones.length * 4);
            e = vv(e),
            e = Math.max(e, 4);
            let t = new Float32Array(e * e * 4);
            t.set(this.boneMatrices);
            let n = new Xa(t,e,e,Xi,Vs);
            return n.needsUpdate = !0,
            this.boneMatrices = t,
            this.boneTexture = n,
            this.boneTextureSize = e,
            this
        }
        getBoneByName(e) {
            for (let t = 0, n = this.bones.length; t < n; t++) {
                let i = this.bones[t];
                if (i.name === e)
                    return i
            }
        }
        dispose() {
            this.boneTexture !== null && (this.boneTexture.dispose(),
            this.boneTexture = null)
        }
        fromJSON(e, t) {
            this.uuid = e.uuid;
            for (let n = 0, i = e.bones.length; n < i; n++) {
                let s = e.bones[n]
                  , o = t[s];
                o === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", s),
                o = new Xs),
                this.bones.push(o),
                this.boneInverses.push(new je().fromArray(e.boneInverses[n]))
            }
            return this.init(),
            this
        }
        toJSON() {
            let e = {
                metadata: {
                    version: 4.5,
                    type: "Skeleton",
                    generator: "Skeleton.toJSON"
                },
                bones: [],
                boneInverses: []
            };
            e.uuid = this.uuid;
            let t = this.bones
              , n = this.boneInverses;
            for (let i = 0, s = t.length; i < s; i++) {
                let o = t[i];
                e.bones.push(o.uuid);
                let a = n[i];
                e.boneInverses.push(a.toArray())
            }
            return e
        }
    }
    ;
    var pi = class extends ur {
        constructor(e) {
            super(),
            this.isLineBasicMaterial = !0,
            this.type = "LineBasicMaterial",
            this.color = new $e(16777215),
            this.map = null,
            this.linewidth = 1,
            this.linecap = "round",
            this.linejoin = "round",
            this.fog = !0,
            this.setValues(e)
        }
        copy(e) {
            return super.copy(e),
            this.color.copy(e.color),
            this.map = e.map,
            this.linewidth = e.linewidth,
            this.linecap = e.linecap,
            this.linejoin = e.linejoin,
            this.fog = e.fog,
            this
        }
    }
      , q0 = new ue
      , Y0 = new ue
      , K0 = new je
      , Hd = new Va
      , ch = new Nr
      , gs = class extends bt {
        constructor(e=new wt, t=new pi) {
            super(),
            this.isLine = !0,
            this.type = "Line",
            this.geometry = e,
            this.material = t,
            this.updateMorphTargets()
        }
        copy(e, t) {
            return super.copy(e, t),
            this.material = e.material,
            this.geometry = e.geometry,
            this
        }
        computeLineDistances() {
            let e = this.geometry;
            if (e.index === null) {
                let t = e.attributes.position
                  , n = [0];
                for (let i = 1, s = t.count; i < s; i++)
                    q0.fromBufferAttribute(t, i - 1),
                    Y0.fromBufferAttribute(t, i),
                    n[i] = n[i - 1],
                    n[i] += q0.distanceTo(Y0);
                e.setAttribute("lineDistance", new qe(n,1))
            } else
                console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            return this
        }
        raycast(e, t) {
            let n = this.geometry
              , i = this.matrixWorld
              , s = e.params.Line.threshold
              , o = n.drawRange;
            if (n.boundingSphere === null && n.computeBoundingSphere(),
            ch.copy(n.boundingSphere),
            ch.applyMatrix4(i),
            ch.radius += s,
            e.ray.intersectsSphere(ch) === !1)
                return;
            K0.copy(i).invert(),
            Hd.copy(e.ray).applyMatrix4(K0);
            let a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3)
              , l = a * a
              , c = new ue
              , u = new ue
              , h = new ue
              , f = new ue
              , m = this.isLineSegments ? 2 : 1
              , g = n.index
              , p = n.attributes.position;
            if (g !== null) {
                let d = Math.max(0, o.start)
                  , x = Math.min(g.count, o.start + o.count);
                for (let y = d, _ = x - 1; y < _; y += m) {
                    let S = g.getX(y)
                      , N = g.getX(y + 1);
                    if (c.fromBufferAttribute(p, S),
                    u.fromBufferAttribute(p, N),
                    Hd.distanceSqToSegment(c, u, f, h) > l)
                        continue;
                    f.applyMatrix4(this.matrixWorld);
                    let O = e.ray.origin.distanceTo(f);
                    O < e.near || O > e.far || t.push({
                        distance: O,
                        point: h.clone().applyMatrix4(this.matrixWorld),
                        index: y,
                        face: null,
                        faceIndex: null,
                        object: this
                    })
                }
            } else {
                let d = Math.max(0, o.start)
                  , x = Math.min(p.count, o.start + o.count);
                for (let y = d, _ = x - 1; y < _; y += m) {
                    if (c.fromBufferAttribute(p, y),
                    u.fromBufferAttribute(p, y + 1),
                    Hd.distanceSqToSegment(c, u, f, h) > l)
                        continue;
                    f.applyMatrix4(this.matrixWorld);
                    let N = e.ray.origin.distanceTo(f);
                    N < e.near || N > e.far || t.push({
                        distance: N,
                        point: h.clone().applyMatrix4(this.matrixWorld),
                        index: y,
                        face: null,
                        faceIndex: null,
                        object: this
                    })
                }
            }
        }
        updateMorphTargets() {
            let t = this.geometry.morphAttributes
              , n = Object.keys(t);
            if (n.length > 0) {
                let i = t[n[0]];
                if (i !== void 0) {
                    this.morphTargetInfluences = [],
                    this.morphTargetDictionary = {};
                    for (let s = 0, o = i.length; s < o; s++) {
                        let a = i[s].name || String(s);
                        this.morphTargetInfluences.push(0),
                        this.morphTargetDictionary[a] = s
                    }
                }
            }
        }
    }
      , Z0 = new ue
      , J0 = new ue
      , qs = class extends gs {
        constructor(e, t) {
            super(e, t),
            this.isLineSegments = !0,
            this.type = "LineSegments"
        }
        computeLineDistances() {
            let e = this.geometry;
            if (e.index === null) {
                let t = e.attributes.position
                  , n = [];
                for (let i = 0, s = t.count; i < s; i += 2)
                    Z0.fromBufferAttribute(t, i),
                    J0.fromBufferAttribute(t, i + 1),
                    n[i] = i === 0 ? 0 : n[i - 1],
                    n[i + 1] = n[i] + Z0.distanceTo(J0);
                e.setAttribute("lineDistance", new qe(n,1))
            } else
                console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            return this
        }
    }
    ;
    var kc = class extends ur {
        constructor(e) {
            super(),
            this.isPointsMaterial = !0,
            this.type = "PointsMaterial",
            this.color = new $e(16777215),
            this.map = null,
            this.alphaMap = null,
            this.size = 1,
            this.sizeAttenuation = !0,
            this.fog = !0,
            this.setValues(e)
        }
        copy(e) {
            return super.copy(e),
            this.color.copy(e.color),
            this.map = e.map,
            this.alphaMap = e.alphaMap,
            this.size = e.size,
            this.sizeAttenuation = e.sizeAttenuation,
            this.fog = e.fog,
            this
        }
    }
      , $0 = new je
      , mp = new Va
      , uh = new Nr
      , hh = new ue
      , wh = class extends bt {
        constructor(e=new wt, t=new kc) {
            super(),
            this.isPoints = !0,
            this.type = "Points",
            this.geometry = e,
            this.material = t,
            this.updateMorphTargets()
        }
        copy(e, t) {
            return super.copy(e, t),
            this.material = e.material,
            this.geometry = e.geometry,
            this
        }
        raycast(e, t) {
            let n = this.geometry
              , i = this.matrixWorld
              , s = e.params.Points.threshold
              , o = n.drawRange;
            if (n.boundingSphere === null && n.computeBoundingSphere(),
            uh.copy(n.boundingSphere),
            uh.applyMatrix4(i),
            uh.radius += s,
            e.ray.intersectsSphere(uh) === !1)
                return;
            $0.copy(i).invert(),
            mp.copy(e.ray).applyMatrix4($0);
            let a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3)
              , l = a * a
              , c = n.index
              , h = n.attributes.position;
            if (c !== null) {
                let f = Math.max(0, o.start)
                  , m = Math.min(c.count, o.start + o.count);
                for (let g = f, v = m; g < v; g++) {
                    let p = c.getX(g);
                    hh.fromBufferAttribute(h, p),
                    Q0(hh, p, l, i, e, t, this)
                }
            } else {
                let f = Math.max(0, o.start)
                  , m = Math.min(h.count, o.start + o.count);
                for (let g = f, v = m; g < v; g++)
                    hh.fromBufferAttribute(h, g),
                    Q0(hh, g, l, i, e, t, this)
            }
        }
        updateMorphTargets() {
            let t = this.geometry.morphAttributes
              , n = Object.keys(t);
            if (n.length > 0) {
                let i = t[n[0]];
                if (i !== void 0) {
                    this.morphTargetInfluences = [],
                    this.morphTargetDictionary = {};
                    for (let s = 0, o = i.length; s < o; s++) {
                        let a = i[s].name || String(s);
                        this.morphTargetInfluences.push(0),
                        this.morphTargetDictionary[a] = s
                    }
                }
            }
        }
    }
    ;
    function Q0(r, e, t, n, i, s, o) {
        let a = mp.distanceSqToPoint(r);
        if (a < t) {
            let l = new ue;
            mp.closestPointToPoint(r, l),
            l.applyMatrix4(n);
            let c = i.ray.origin.distanceTo(l);
            if (c < i.near || c > i.far)
                return;
            s.push({
                distance: c,
                distanceToRay: Math.sqrt(a),
                point: l,
                index: e,
                face: null,
                object: o
            })
        }
    }
    var mi = class {
        constructor() {
            this.type = "Curve",
            this.arcLengthDivisions = 200
        }
        getPoint() {
            return console.warn("THREE.Curve: .getPoint() not implemented."),
            null
        }
        getPointAt(e, t) {
            let n = this.getUtoTmapping(e);
            return this.getPoint(n, t)
        }
        getPoints(e=5) {
            let t = [];
            for (let n = 0; n <= e; n++)
                t.push(this.getPoint(n / e));
            return t
        }
        getSpacedPoints(e=5) {
            let t = [];
            for (let n = 0; n <= e; n++)
                t.push(this.getPointAt(n / e));
            return t
        }
        getLength() {
            let e = this.getLengths();
            return e[e.length - 1]
        }
        getLengths(e=this.arcLengthDivisions) {
            if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
                return this.cacheArcLengths;
            this.needsUpdate = !1;
            let t = [], n, i = this.getPoint(0), s = 0;
            t.push(0);
            for (let o = 1; o <= e; o++)
                n = this.getPoint(o / e),
                s += n.distanceTo(i),
                t.push(s),
                i = n;
            return this.cacheArcLengths = t,
            t
        }
        updateArcLengths() {
            this.needsUpdate = !0,
            this.getLengths()
        }
        getUtoTmapping(e, t) {
            let n = this.getLengths(), i = 0, s = n.length, o;
            t ? o = t : o = e * n[s - 1];
            let a = 0, l = s - 1, c;
            for (; a <= l; )
                if (i = Math.floor(a + (l - a) / 2),
                c = n[i] - o,
                c < 0)
                    a = i + 1;
                else if (c > 0)
                    l = i - 1;
                else {
                    l = i;
                    break
                }
            if (i = l,
            n[i] === o)
                return i / (s - 1);
            let u = n[i]
              , f = n[i + 1] - u
              , m = (o - u) / f;
            return (i + m) / (s - 1)
        }
        getTangent(e, t) {
            let i = e - 1e-4
              , s = e + 1e-4;
            i < 0 && (i = 0),
            s > 1 && (s = 1);
            let o = this.getPoint(i)
              , a = this.getPoint(s)
              , l = t || (o.isVector2 ? new Ie : new ue);
            return l.copy(a).sub(o).normalize(),
            l
        }
        getTangentAt(e, t) {
            let n = this.getUtoTmapping(e);
            return this.getTangent(n, t)
        }
        computeFrenetFrames(e, t) {
            let n = new ue
              , i = []
              , s = []
              , o = []
              , a = new ue
              , l = new je;
            for (let m = 0; m <= e; m++) {
                let g = m / e;
                i[m] = this.getTangentAt(g, new ue)
            }
            s[0] = new ue,
            o[0] = new ue;
            let c = Number.MAX_VALUE
              , u = Math.abs(i[0].x)
              , h = Math.abs(i[0].y)
              , f = Math.abs(i[0].z);
            u <= c && (c = u,
            n.set(1, 0, 0)),
            h <= c && (c = h,
            n.set(0, 1, 0)),
            f <= c && n.set(0, 0, 1),
            a.crossVectors(i[0], n).normalize(),
            s[0].crossVectors(i[0], a),
            o[0].crossVectors(i[0], s[0]);
            for (let m = 1; m <= e; m++) {
                if (s[m] = s[m - 1].clone(),
                o[m] = o[m - 1].clone(),
                a.crossVectors(i[m - 1], i[m]),
                a.length() > Number.EPSILON) {
                    a.normalize();
                    let g = Math.acos(Vn(i[m - 1].dot(i[m]), -1, 1));
                    s[m].applyMatrix4(l.makeRotationAxis(a, g))
                }
                o[m].crossVectors(i[m], s[m])
            }
            if (t === !0) {
                let m = Math.acos(Vn(s[0].dot(s[e]), -1, 1));
                m /= e,
                i[0].dot(a.crossVectors(s[0], s[e])) > 0 && (m = -m);
                for (let g = 1; g <= e; g++)
                    s[g].applyMatrix4(l.makeRotationAxis(i[g], m * g)),
                    o[g].crossVectors(i[g], s[g])
            }
            return {
                tangents: i,
                normals: s,
                binormals: o
            }
        }
        clone() {
            return new this.constructor().copy(this)
        }
        copy(e) {
            return this.arcLengthDivisions = e.arcLengthDivisions,
            this
        }
        toJSON() {
            let e = {
                metadata: {
                    version: 4.5,
                    type: "Curve",
                    generator: "Curve.toJSON"
                }
            };
            return e.arcLengthDivisions = this.arcLengthDivisions,
            e.type = this.type,
            e
        }
        fromJSON(e) {
            return this.arcLengthDivisions = e.arcLengthDivisions,
            this
        }
    }
      , Fo = class extends mi {
        constructor(e=0, t=0, n=1, i=1, s=0, o=Math.PI * 2, a=!1, l=0) {
            super(),
            this.isEllipseCurve = !0,
            this.type = "EllipseCurve",
            this.aX = e,
            this.aY = t,
            this.xRadius = n,
            this.yRadius = i,
            this.aStartAngle = s,
            this.aEndAngle = o,
            this.aClockwise = a,
            this.aRotation = l
        }
        getPoint(e, t) {
            let n = t || new Ie
              , i = Math.PI * 2
              , s = this.aEndAngle - this.aStartAngle
              , o = Math.abs(s) < Number.EPSILON;
            for (; s < 0; )
                s += i;
            for (; s > i; )
                s -= i;
            s < Number.EPSILON && (o ? s = 0 : s = i),
            this.aClockwise === !0 && !o && (s === i ? s = -i : s = s - i);
            let a = this.aStartAngle + e * s
              , l = this.aX + this.xRadius * Math.cos(a)
              , c = this.aY + this.yRadius * Math.sin(a);
            if (this.aRotation !== 0) {
                let u = Math.cos(this.aRotation)
                  , h = Math.sin(this.aRotation)
                  , f = l - this.aX
                  , m = c - this.aY;
                l = f * u - m * h + this.aX,
                c = f * h + m * u + this.aY
            }
            return n.set(l, c)
        }
        copy(e) {
            return super.copy(e),
            this.aX = e.aX,
            this.aY = e.aY,
            this.xRadius = e.xRadius,
            this.yRadius = e.yRadius,
            this.aStartAngle = e.aStartAngle,
            this.aEndAngle = e.aEndAngle,
            this.aClockwise = e.aClockwise,
            this.aRotation = e.aRotation,
            this
        }
        toJSON() {
            let e = super.toJSON();
            return e.aX = this.aX,
            e.aY = this.aY,
            e.xRadius = this.xRadius,
            e.yRadius = this.yRadius,
            e.aStartAngle = this.aStartAngle,
            e.aEndAngle = this.aEndAngle,
            e.aClockwise = this.aClockwise,
            e.aRotation = this.aRotation,
            e
        }
        fromJSON(e) {
            return super.fromJSON(e),
            this.aX = e.aX,
            this.aY = e.aY,
            this.xRadius = e.xRadius,
            this.yRadius = e.yRadius,
            this.aStartAngle = e.aStartAngle,
            this.aEndAngle = e.aEndAngle,
            this.aClockwise = e.aClockwise,
            this.aRotation = e.aRotation,
            this
        }
    }
      , gp = class extends Fo {
        constructor(e, t, n, i, s, o) {
            super(e, t, n, n, i, s, o),
            this.isArcCurve = !0,
            this.type = "ArcCurve"
        }
    }
    ;
    function kp() {
        let r = 0
          , e = 0
          , t = 0
          , n = 0;
        function i(s, o, a, l) {
            r = s,
            e = a,
            t = -3 * s + 3 * o - 2 * a - l,
            n = 2 * s - 2 * o + a + l
        }
        return {
            initCatmullRom: function(s, o, a, l, c) {
                i(o, a, c * (a - s), c * (l - o))
            },
            initNonuniformCatmullRom: function(s, o, a, l, c, u, h) {
                let f = (o - s) / c - (a - s) / (c + u) + (a - o) / u
                  , m = (a - o) / u - (l - o) / (u + h) + (l - a) / h;
                f *= u,
                m *= u,
                i(o, a, f, m)
            },
            calc: function(s) {
                let o = s * s
                  , a = o * s;
                return r + e * s + t * o + n * a
            }
        }
    }
    var fh = new ue
      , Wd = new kp
      , Xd = new kp
      , jd = new kp
      , vp = class extends mi {
        constructor(e=[], t=!1, n="centripetal", i=.5) {
            super(),
            this.isCatmullRomCurve3 = !0,
            this.type = "CatmullRomCurve3",
            this.points = e,
            this.closed = t,
            this.curveType = n,
            this.tension = i
        }
        getPoint(e, t=new ue) {
            let n = t
              , i = this.points
              , s = i.length
              , o = (s - (this.closed ? 0 : 1)) * e
              , a = Math.floor(o)
              , l = o - a;
            this.closed ? a += a > 0 ? 0 : (Math.floor(Math.abs(a) / s) + 1) * s : l === 0 && a === s - 1 && (a = s - 2,
            l = 1);
            let c, u;
            this.closed || a > 0 ? c = i[(a - 1) % s] : (fh.subVectors(i[0], i[1]).add(i[0]),
            c = fh);
            let h = i[a % s]
              , f = i[(a + 1) % s];
            if (this.closed || a + 2 < s ? u = i[(a + 2) % s] : (fh.subVectors(i[s - 1], i[s - 2]).add(i[s - 1]),
            u = fh),
            this.curveType === "centripetal" || this.curveType === "chordal") {
                let m = this.curveType === "chordal" ? .5 : .25
                  , g = Math.pow(c.distanceToSquared(h), m)
                  , v = Math.pow(h.distanceToSquared(f), m)
                  , p = Math.pow(f.distanceToSquared(u), m);
                v < 1e-4 && (v = 1),
                g < 1e-4 && (g = v),
                p < 1e-4 && (p = v),
                Wd.initNonuniformCatmullRom(c.x, h.x, f.x, u.x, g, v, p),
                Xd.initNonuniformCatmullRom(c.y, h.y, f.y, u.y, g, v, p),
                jd.initNonuniformCatmullRom(c.z, h.z, f.z, u.z, g, v, p)
            } else
                this.curveType === "catmullrom" && (Wd.initCatmullRom(c.x, h.x, f.x, u.x, this.tension),
                Xd.initCatmullRom(c.y, h.y, f.y, u.y, this.tension),
                jd.initCatmullRom(c.z, h.z, f.z, u.z, this.tension));
            return n.set(Wd.calc(l), Xd.calc(l), jd.calc(l)),
            n
        }
        copy(e) {
            super.copy(e),
            this.points = [];
            for (let t = 0, n = e.points.length; t < n; t++) {
                let i = e.points[t];
                this.points.push(i.clone())
            }
            return this.closed = e.closed,
            this.curveType = e.curveType,
            this.tension = e.tension,
            this
        }
        toJSON() {
            let e = super.toJSON();
            e.points = [];
            for (let t = 0, n = this.points.length; t < n; t++) {
                let i = this.points[t];
                e.points.push(i.toArray())
            }
            return e.closed = this.closed,
            e.curveType = this.curveType,
            e.tension = this.tension,
            e
        }
        fromJSON(e) {
            super.fromJSON(e),
            this.points = [];
            for (let t = 0, n = e.points.length; t < n; t++) {
                let i = e.points[t];
                this.points.push(new ue().fromArray(i))
            }
            return this.closed = e.closed,
            this.curveType = e.curveType,
            this.tension = e.tension,
            this
        }
    }
    ;
    function ev(r, e, t, n, i) {
        let s = (n - e) * .5
          , o = (i - t) * .5
          , a = r * r
          , l = r * a;
        return (2 * t - 2 * n + s + o) * l + (-3 * t + 3 * n - 2 * s - o) * a + s * r + t
    }
    function xS(r, e) {
        let t = 1 - r;
        return t * t * e
    }
    function _S(r, e) {
        return 2 * (1 - r) * r * e
    }
    function TS(r, e) {
        return r * r * e
    }
    function Ic(r, e, t, n) {
        return xS(r, e) + _S(r, t) + TS(r, n)
    }
    function bS(r, e) {
        let t = 1 - r;
        return t * t * t * e
    }
    function MS(r, e) {
        let t = 1 - r;
        return 3 * t * t * r * e
    }
    function ES(r, e) {
        return 3 * (1 - r) * r * r * e
    }
    function SS(r, e) {
        return r * r * r * e
    }
    function Rc(r, e, t, n, i) {
        return bS(r, e) + MS(r, t) + ES(r, n) + SS(r, i)
    }
    var Ah = class extends mi {
        constructor(e=new Ie, t=new Ie, n=new Ie, i=new Ie) {
            super(),
            this.isCubicBezierCurve = !0,
            this.type = "CubicBezierCurve",
            this.v0 = e,
            this.v1 = t,
            this.v2 = n,
            this.v3 = i
        }
        getPoint(e, t=new Ie) {
            let n = t
              , i = this.v0
              , s = this.v1
              , o = this.v2
              , a = this.v3;
            return n.set(Rc(e, i.x, s.x, o.x, a.x), Rc(e, i.y, s.y, o.y, a.y)),
            n
        }
        copy(e) {
            return super.copy(e),
            this.v0.copy(e.v0),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this.v3.copy(e.v3),
            this
        }
        toJSON() {
            let e = super.toJSON();
            return e.v0 = this.v0.toArray(),
            e.v1 = this.v1.toArray(),
            e.v2 = this.v2.toArray(),
            e.v3 = this.v3.toArray(),
            e
        }
        fromJSON(e) {
            return super.fromJSON(e),
            this.v0.fromArray(e.v0),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this.v3.fromArray(e.v3),
            this
        }
    }
      , yp = class extends mi {
        constructor(e=new ue, t=new ue, n=new ue, i=new ue) {
            super(),
            this.isCubicBezierCurve3 = !0,
            this.type = "CubicBezierCurve3",
            this.v0 = e,
            this.v1 = t,
            this.v2 = n,
            this.v3 = i
        }
        getPoint(e, t=new ue) {
            let n = t
              , i = this.v0
              , s = this.v1
              , o = this.v2
              , a = this.v3;
            return n.set(Rc(e, i.x, s.x, o.x, a.x), Rc(e, i.y, s.y, o.y, a.y), Rc(e, i.z, s.z, o.z, a.z)),
            n
        }
        copy(e) {
            return super.copy(e),
            this.v0.copy(e.v0),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this.v3.copy(e.v3),
            this
        }
        toJSON() {
            let e = super.toJSON();
            return e.v0 = this.v0.toArray(),
            e.v1 = this.v1.toArray(),
            e.v2 = this.v2.toArray(),
            e.v3 = this.v3.toArray(),
            e
        }
        fromJSON(e) {
            return super.fromJSON(e),
            this.v0.fromArray(e.v0),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this.v3.fromArray(e.v3),
            this
        }
    }
      , Uc = class extends mi {
        constructor(e=new Ie, t=new Ie) {
            super(),
            this.isLineCurve = !0,
            this.type = "LineCurve",
            this.v1 = e,
            this.v2 = t
        }
        getPoint(e, t=new Ie) {
            let n = t;
            return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1),
            n.multiplyScalar(e).add(this.v1)),
            n
        }
        getPointAt(e, t) {
            return this.getPoint(e, t)
        }
        getTangent(e, t=new Ie) {
            return t.subVectors(this.v2, this.v1).normalize()
        }
        getTangentAt(e, t) {
            return this.getTangent(e, t)
        }
        copy(e) {
            return super.copy(e),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this
        }
        toJSON() {
            let e = super.toJSON();
            return e.v1 = this.v1.toArray(),
            e.v2 = this.v2.toArray(),
            e
        }
        fromJSON(e) {
            return super.fromJSON(e),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this
        }
    }
      , xp = class extends mi {
        constructor(e=new ue, t=new ue) {
            super(),
            this.isLineCurve3 = !0,
            this.type = "LineCurve3",
            this.v1 = e,
            this.v2 = t
        }
        getPoint(e, t=new ue) {
            let n = t;
            return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1),
            n.multiplyScalar(e).add(this.v1)),
            n
        }
        getPointAt(e, t) {
            return this.getPoint(e, t)
        }
        getTangent(e, t=new ue) {
            return t.subVectors(this.v2, this.v1).normalize()
        }
        getTangentAt(e, t) {
            return this.getTangent(e, t)
        }
        copy(e) {
            return super.copy(e),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this
        }
        toJSON() {
            let e = super.toJSON();
            return e.v1 = this.v1.toArray(),
            e.v2 = this.v2.toArray(),
            e
        }
        fromJSON(e) {
            return super.fromJSON(e),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this
        }
    }
      , Ch = class extends mi {
        constructor(e=new Ie, t=new Ie, n=new Ie) {
            super(),
            this.isQuadraticBezierCurve = !0,
            this.type = "QuadraticBezierCurve",
            this.v0 = e,
            this.v1 = t,
            this.v2 = n
        }
        getPoint(e, t=new Ie) {
            let n = t
              , i = this.v0
              , s = this.v1
              , o = this.v2;
            return n.set(Ic(e, i.x, s.x, o.x), Ic(e, i.y, s.y, o.y)),
            n
        }
        copy(e) {
            return super.copy(e),
            this.v0.copy(e.v0),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this
        }
        toJSON() {
            let e = super.toJSON();
            return e.v0 = this.v0.toArray(),
            e.v1 = this.v1.toArray(),
            e.v2 = this.v2.toArray(),
            e
        }
        fromJSON(e) {
            return super.fromJSON(e),
            this.v0.fromArray(e.v0),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this
        }
    }
      , _p = class extends mi {
        constructor(e=new ue, t=new ue, n=new ue) {
            super(),
            this.isQuadraticBezierCurve3 = !0,
            this.type = "QuadraticBezierCurve3",
            this.v0 = e,
            this.v1 = t,
            this.v2 = n
        }
        getPoint(e, t=new ue) {
            let n = t
              , i = this.v0
              , s = this.v1
              , o = this.v2;
            return n.set(Ic(e, i.x, s.x, o.x), Ic(e, i.y, s.y, o.y), Ic(e, i.z, s.z, o.z)),
            n
        }
        copy(e) {
            return super.copy(e),
            this.v0.copy(e.v0),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this
        }
        toJSON() {
            let e = super.toJSON();
            return e.v0 = this.v0.toArray(),
            e.v1 = this.v1.toArray(),
            e.v2 = this.v2.toArray(),
            e
        }
        fromJSON(e) {
            return super.fromJSON(e),
            this.v0.fromArray(e.v0),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this
        }
    }
      , Ih = class extends mi {
        constructor(e=[]) {
            super(),
            this.isSplineCurve = !0,
            this.type = "SplineCurve",
            this.points = e
        }
        getPoint(e, t=new Ie) {
            let n = t
              , i = this.points
              , s = (i.length - 1) * e
              , o = Math.floor(s)
              , a = s - o
              , l = i[o === 0 ? o : o - 1]
              , c = i[o]
              , u = i[o > i.length - 2 ? i.length - 1 : o + 1]
              , h = i[o > i.length - 3 ? i.length - 1 : o + 2];
            return n.set(ev(a, l.x, c.x, u.x, h.x), ev(a, l.y, c.y, u.y, h.y)),
            n
        }
        copy(e) {
            super.copy(e),
            this.points = [];
            for (let t = 0, n = e.points.length; t < n; t++) {
                let i = e.points[t];
                this.points.push(i.clone())
            }
            return this
        }
        toJSON() {
            let e = super.toJSON();
            e.points = [];
            for (let t = 0, n = this.points.length; t < n; t++) {
                let i = this.points[t];
                e.points.push(i.toArray())
            }
            return e
        }
        fromJSON(e) {
            super.fromJSON(e),
            this.points = [];
            for (let t = 0, n = e.points.length; t < n; t++) {
                let i = e.points[t];
                this.points.push(new Ie().fromArray(i))
            }
            return this
        }
    }
      , Av = Object.freeze({
        __proto__: null,
        ArcCurve: gp,
        CatmullRomCurve3: vp,
        CubicBezierCurve: Ah,
        CubicBezierCurve3: yp,
        EllipseCurve: Fo,
        LineCurve: Uc,
        LineCurve3: xp,
        QuadraticBezierCurve: Ch,
        QuadraticBezierCurve3: _p,
        SplineCurve: Ih
    })
      , Tp = class extends mi {
        constructor() {
            super(),
            this.type = "CurvePath",
            this.curves = [],
            this.autoClose = !1
        }
        add(e) {
            this.curves.push(e)
        }
        closePath() {
            let e = this.curves[0].getPoint(0)
              , t = this.curves[this.curves.length - 1].getPoint(1);
            e.equals(t) || this.curves.push(new Uc(t,e))
        }
        getPoint(e, t) {
            let n = e * this.getLength()
              , i = this.getCurveLengths()
              , s = 0;
            for (; s < i.length; ) {
                if (i[s] >= n) {
                    let o = i[s] - n
                      , a = this.curves[s]
                      , l = a.getLength()
                      , c = l === 0 ? 0 : 1 - o / l;
                    return a.getPointAt(c, t)
                }
                s++
            }
            return null
        }
        getLength() {
            let e = this.getCurveLengths();
            return e[e.length - 1]
        }
        updateArcLengths() {
            this.needsUpdate = !0,
            this.cacheLengths = null,
            this.getCurveLengths()
        }
        getCurveLengths() {
            if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
                return this.cacheLengths;
            let e = []
              , t = 0;
            for (let n = 0, i = this.curves.length; n < i; n++)
                t += this.curves[n].getLength(),
                e.push(t);
            return this.cacheLengths = e,
            e
        }
        getSpacedPoints(e=40) {
            let t = [];
            for (let n = 0; n <= e; n++)
                t.push(this.getPoint(n / e));
            return this.autoClose && t.push(t[0]),
            t
        }
        getPoints(e=12) {
            let t = [], n;
            for (let i = 0, s = this.curves; i < s.length; i++) {
                let o = s[i]
                  , a = o.isEllipseCurve ? e * 2 : o.isLineCurve || o.isLineCurve3 ? 1 : o.isSplineCurve ? e * o.points.length : e
                  , l = o.getPoints(a);
                for (let c = 0; c < l.length; c++) {
                    let u = l[c];
                    n && n.equals(u) || (t.push(u),
                    n = u)
                }
            }
            return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]),
            t
        }
        copy(e) {
            super.copy(e),
            this.curves = [];
            for (let t = 0, n = e.curves.length; t < n; t++) {
                let i = e.curves[t];
                this.curves.push(i.clone())
            }
            return this.autoClose = e.autoClose,
            this
        }
        toJSON() {
            let e = super.toJSON();
            e.autoClose = this.autoClose,
            e.curves = [];
            for (let t = 0, n = this.curves.length; t < n; t++) {
                let i = this.curves[t];
                e.curves.push(i.toJSON())
            }
            return e
        }
        fromJSON(e) {
            super.fromJSON(e),
            this.autoClose = e.autoClose,
            this.curves = [];
            for (let t = 0, n = e.curves.length; t < n; t++) {
                let i = e.curves[t];
                this.curves.push(new Av[i.type]().fromJSON(i))
            }
            return this
        }
    }
      , vs = class extends Tp {
        constructor(e) {
            super(),
            this.type = "Path",
            this.currentPoint = new Ie,
            e && this.setFromPoints(e)
        }
        setFromPoints(e) {
            this.moveTo(e[0].x, e[0].y);
            for (let t = 1, n = e.length; t < n; t++)
                this.lineTo(e[t].x, e[t].y);
            return this
        }
        moveTo(e, t) {
            return this.currentPoint.set(e, t),
            this
        }
        lineTo(e, t) {
            let n = new Uc(this.currentPoint.clone(),new Ie(e,t));
            return this.curves.push(n),
            this.currentPoint.set(e, t),
            this
        }
        quadraticCurveTo(e, t, n, i) {
            let s = new Ch(this.currentPoint.clone(),new Ie(e,t),new Ie(n,i));
            return this.curves.push(s),
            this.currentPoint.set(n, i),
            this
        }
        bezierCurveTo(e, t, n, i, s, o) {
            let a = new Ah(this.currentPoint.clone(),new Ie(e,t),new Ie(n,i),new Ie(s,o));
            return this.curves.push(a),
            this.currentPoint.set(s, o),
            this
        }
        splineThru(e) {
            let t = [this.currentPoint.clone()].concat(e)
              , n = new Ih(t);
            return this.curves.push(n),
            this.currentPoint.copy(e[e.length - 1]),
            this
        }
        arc(e, t, n, i, s, o) {
            let a = this.currentPoint.x
              , l = this.currentPoint.y;
            return this.absarc(e + a, t + l, n, i, s, o),
            this
        }
        absarc(e, t, n, i, s, o) {
            return this.absellipse(e, t, n, n, i, s, o),
            this
        }
        ellipse(e, t, n, i, s, o, a, l) {
            let c = this.currentPoint.x
              , u = this.currentPoint.y;
            return this.absellipse(e + c, t + u, n, i, s, o, a, l),
            this
        }
        absellipse(e, t, n, i, s, o, a, l) {
            let c = new Fo(e,t,n,i,s,o,a,l);
            if (this.curves.length > 0) {
                let h = c.getPoint(0);
                h.equals(this.currentPoint) || this.lineTo(h.x, h.y)
            }
            this.curves.push(c);
            let u = c.getPoint(1);
            return this.currentPoint.copy(u),
            this
        }
        copy(e) {
            return super.copy(e),
            this.currentPoint.copy(e.currentPoint),
            this
        }
        toJSON() {
            let e = super.toJSON();
            return e.currentPoint = this.currentPoint.toArray(),
            e
        }
        fromJSON(e) {
            return super.fromJSON(e),
            this.currentPoint.fromArray(e.currentPoint),
            this
        }
    }
    ;
    var ko = class extends wt {
        constructor(e=1, t=1, n=1, i=32, s=1, o=!1, a=0, l=Math.PI * 2) {
            super(),
            this.type = "CylinderGeometry",
            this.parameters = {
                radiusTop: e,
                radiusBottom: t,
                height: n,
                radialSegments: i,
                heightSegments: s,
                openEnded: o,
                thetaStart: a,
                thetaLength: l
            };
            let c = this;
            i = Math.floor(i),
            s = Math.floor(s);
            let u = []
              , h = []
              , f = []
              , m = []
              , g = 0
              , v = []
              , p = n / 2
              , d = 0;
            x(),
            o === !1 && (e > 0 && y(!0),
            t > 0 && y(!1)),
            this.setIndex(u),
            this.setAttribute("position", new qe(h,3)),
            this.setAttribute("normal", new qe(f,3)),
            this.setAttribute("uv", new qe(m,2));
            function x() {
                let _ = new ue
                  , S = new ue
                  , N = 0
                  , I = (t - e) / n;
                for (let O = 0; O <= s; O++) {
                    let M = []
                      , R = O / s
                      , q = R * (t - e) + e;
                    for (let k = 0; k <= i; k++) {
                        let B = k / i
                          , P = B * l + a
                          , C = Math.sin(P)
                          , L = Math.cos(P);
                        S.x = q * C,
                        S.y = -R * n + p,
                        S.z = q * L,
                        h.push(S.x, S.y, S.z),
                        _.set(C, I, L).normalize(),
                        f.push(_.x, _.y, _.z),
                        m.push(B, 1 - R),
                        M.push(g++)
                    }
                    v.push(M)
                }
                for (let O = 0; O < i; O++)
                    for (let M = 0; M < s; M++) {
                        let R = v[M][O]
                          , q = v[M + 1][O]
                          , k = v[M + 1][O + 1]
                          , B = v[M][O + 1];
                        u.push(R, q, B),
                        u.push(q, k, B),
                        N += 6
                    }
                c.addGroup(d, N, 0),
                d += N
            }
            function y(_) {
                let S = g
                  , N = new Ie
                  , I = new ue
                  , O = 0
                  , M = _ === !0 ? e : t
                  , R = _ === !0 ? 1 : -1;
                for (let k = 1; k <= i; k++)
                    h.push(0, p * R, 0),
                    f.push(0, R, 0),
                    m.push(.5, .5),
                    g++;
                let q = g;
                for (let k = 0; k <= i; k++) {
                    let P = k / i * l + a
                      , C = Math.cos(P)
                      , L = Math.sin(P);
                    I.x = M * L,
                    I.y = p * R,
                    I.z = M * C,
                    h.push(I.x, I.y, I.z),
                    f.push(0, R, 0),
                    N.x = C * .5 + .5,
                    N.y = L * .5 * R + .5,
                    m.push(N.x, N.y),
                    g++
                }
                for (let k = 0; k < i; k++) {
                    let B = S + k
                      , P = q + k;
                    _ === !0 ? u.push(P, P + 1, B) : u.push(P + 1, P, B),
                    O += 3
                }
                c.addGroup(d, O, _ === !0 ? 1 : 2),
                d += O
            }
        }
        copy(e) {
            return super.copy(e),
            this.parameters = Object.assign({}, e.parameters),
            this
        }
        static fromJSON(e) {
            return new ko(e.radiusTop,e.radiusBottom,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)
        }
    }
      , ja = class extends ko {
        constructor(e=1, t=1, n=32, i=1, s=!1, o=0, a=Math.PI * 2) {
            super(0, e, t, n, i, s, o, a),
            this.type = "ConeGeometry",
            this.parameters = {
                radius: e,
                height: t,
                radialSegments: n,
                heightSegments: i,
                openEnded: s,
                thetaStart: o,
                thetaLength: a
            }
        }
        static fromJSON(e) {
            return new ja(e.radius,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)
        }
    }
    ;
    var dh = new ue
      , ph = new ue
      , qd = new ue
      , mh = new fi
      , Rh = class extends wt {
        constructor(e=null, t=1) {
            if (super(),
            this.type = "EdgesGeometry",
            this.parameters = {
                geometry: e,
                thresholdAngle: t
            },
            e !== null) {
                let i = Math.pow(10, 4)
                  , s = Math.cos(Na * t)
                  , o = e.getIndex()
                  , a = e.getAttribute("position")
                  , l = o ? o.count : a.count
                  , c = [0, 0, 0]
                  , u = ["a", "b", "c"]
                  , h = new Array(3)
                  , f = {}
                  , m = [];
                for (let g = 0; g < l; g += 3) {
                    o ? (c[0] = o.getX(g),
                    c[1] = o.getX(g + 1),
                    c[2] = o.getX(g + 2)) : (c[0] = g,
                    c[1] = g + 1,
                    c[2] = g + 2);
                    let {a: v, b: p, c: d} = mh;
                    if (v.fromBufferAttribute(a, c[0]),
                    p.fromBufferAttribute(a, c[1]),
                    d.fromBufferAttribute(a, c[2]),
                    mh.getNormal(qd),
                    h[0] = `${Math.round(v.x * i)},${Math.round(v.y * i)},${Math.round(v.z * i)}`,
                    h[1] = `${Math.round(p.x * i)},${Math.round(p.y * i)},${Math.round(p.z * i)}`,
                    h[2] = `${Math.round(d.x * i)},${Math.round(d.y * i)},${Math.round(d.z * i)}`,
                    !(h[0] === h[1] || h[1] === h[2] || h[2] === h[0]))
                        for (let x = 0; x < 3; x++) {
                            let y = (x + 1) % 3
                              , _ = h[x]
                              , S = h[y]
                              , N = mh[u[x]]
                              , I = mh[u[y]]
                              , O = `${_}_ ${S}`
                              , M = `${S}_ ${_}`;
                            M in f && f[M] ? (qd.dot(f[M].normal) <= s && (m.push(N.x, N.y, N.z),
                            m.push(I.x, I.y, I.z)),
                            f[M] = null) : O in f || (f[O] = {
                                index0: c[x],
                                index1: c[y],
                                normal: qd.clone()
                            })
                        }
                }
                for (let g in f)
                    if (f[g]) {
                        let {index0: v, index1: p} = f[g];
                        dh.fromBufferAttribute(a, v),
                        ph.fromBufferAttribute(a, p),
                        m.push(dh.x, dh.y, dh.z),
                        m.push(ph.x, ph.y, ph.z)
                    }
                this.setAttribute("position", new qe(m,3))
            }
        }
        copy(e) {
            return super.copy(e),
            this.parameters = Object.assign({}, e.parameters),
            this
        }
    }
      , Hs = class extends vs {
        constructor(e) {
            super(e),
            this.uuid = ys(),
            this.type = "Shape",
            this.holes = []
        }
        getPointsHoles(e) {
            let t = [];
            for (let n = 0, i = this.holes.length; n < i; n++)
                t[n] = this.holes[n].getPoints(e);
            return t
        }
        extractPoints(e) {
            return {
                shape: this.getPoints(e),
                holes: this.getPointsHoles(e)
            }
        }
        copy(e) {
            super.copy(e),
            this.holes = [];
            for (let t = 0, n = e.holes.length; t < n; t++) {
                let i = e.holes[t];
                this.holes.push(i.clone())
            }
            return this
        }
        toJSON() {
            let e = super.toJSON();
            e.uuid = this.uuid,
            e.holes = [];
            for (let t = 0, n = this.holes.length; t < n; t++) {
                let i = this.holes[t];
                e.holes.push(i.toJSON())
            }
            return e
        }
        fromJSON(e) {
            super.fromJSON(e),
            this.uuid = e.uuid,
            this.holes = [];
            for (let t = 0, n = e.holes.length; t < n; t++) {
                let i = e.holes[t];
                this.holes.push(new vs().fromJSON(i))
            }
            return this
        }
    }
      , wS = {
        triangulate: function(r, e, t=2) {
            let n = e && e.length
              , i = n ? e[0] * t : r.length
              , s = Cv(r, 0, i, t, !0)
              , o = [];
            if (!s || s.next === s.prev)
                return o;
            let a, l, c, u, h, f, m;
            if (n && (s = PS(r, e, s, t)),
            r.length > 80 * t) {
                a = c = r[0],
                l = u = r[1];
                for (let g = t; g < i; g += t)
                    h = r[g],
                    f = r[g + 1],
                    h < a && (a = h),
                    f < l && (l = f),
                    h > c && (c = h),
                    f > u && (u = f);
                m = Math.max(c - a, u - l),
                m = m !== 0 ? 32767 / m : 0
            }
            return Bc(s, o, t, a, l, m, 0),
            o
        }
    };
    function Cv(r, e, t, n, i) {
        let s, o;
        if (i === zS(r, e, t, n) > 0)
            for (s = e; s < t; s += n)
                o = tv(s, r[s], r[s + 1], o);
        else
            for (s = t - n; s >= e; s -= n)
                o = tv(s, r[s], r[s + 1], o);
        return o && zh(o, o.next) && (Vc(o),
        o = o.next),
        o
    }
    function Uo(r, e) {
        if (!r)
            return r;
        e || (e = r);
        let t = r, n;
        do
            if (n = !1,
            !t.steiner && (zh(t, t.next) || ln(t.prev, t, t.next) === 0)) {
                if (Vc(t),
                t = e = t.prev,
                t === t.next)
                    break;
                n = !0
            } else
                t = t.next;
        while (n || t !== e);
        return e
    }
    function Bc(r, e, t, n, i, s, o) {
        if (!r)
            return;
        !o && s && FS(r, n, i, s);
        let a = r, l, c;
        for (; r.prev !== r.next; ) {
            if (l = r.prev,
            c = r.next,
            s ? CS(r, n, i, s) : AS(r)) {
                e.push(l.i / t | 0),
                e.push(r.i / t | 0),
                e.push(c.i / t | 0),
                Vc(r),
                r = c.next,
                a = c.next;
                continue
            }
            if (r = c,
            r === a) {
                o ? o === 1 ? (r = IS(Uo(r), e, t),
                Bc(r, e, t, n, i, s, 2)) : o === 2 && RS(r, e, t, n, i, s) : Bc(Uo(r), e, t, n, i, s, 1);
                break
            }
        }
    }
    function AS(r) {
        let e = r.prev
          , t = r
          , n = r.next;
        if (ln(e, t, n) >= 0)
            return !1;
        let i = e.x
          , s = t.x
          , o = n.x
          , a = e.y
          , l = t.y
          , c = n.y
          , u = i < s ? i < o ? i : o : s < o ? s : o
          , h = a < l ? a < c ? a : c : l < c ? l : c
          , f = i > s ? i > o ? i : o : s > o ? s : o
          , m = a > l ? a > c ? a : c : l > c ? l : c
          , g = n.next;
        for (; g !== e; ) {
            if (g.x >= u && g.x <= f && g.y >= h && g.y <= m && Ra(i, a, s, l, o, c, g.x, g.y) && ln(g.prev, g, g.next) >= 0)
                return !1;
            g = g.next
        }
        return !0
    }
    function CS(r, e, t, n) {
        let i = r.prev
          , s = r
          , o = r.next;
        if (ln(i, s, o) >= 0)
            return !1;
        let a = i.x
          , l = s.x
          , c = o.x
          , u = i.y
          , h = s.y
          , f = o.y
          , m = a < l ? a < c ? a : c : l < c ? l : c
          , g = u < h ? u < f ? u : f : h < f ? h : f
          , v = a > l ? a > c ? a : c : l > c ? l : c
          , p = u > h ? u > f ? u : f : h > f ? h : f
          , d = bp(m, g, e, t, n)
          , x = bp(v, p, e, t, n)
          , y = r.prevZ
          , _ = r.nextZ;
        for (; y && y.z >= d && _ && _.z <= x; ) {
            if (y.x >= m && y.x <= v && y.y >= g && y.y <= p && y !== i && y !== o && Ra(a, u, l, h, c, f, y.x, y.y) && ln(y.prev, y, y.next) >= 0 || (y = y.prevZ,
            _.x >= m && _.x <= v && _.y >= g && _.y <= p && _ !== i && _ !== o && Ra(a, u, l, h, c, f, _.x, _.y) && ln(_.prev, _, _.next) >= 0))
                return !1;
            _ = _.nextZ
        }
        for (; y && y.z >= d; ) {
            if (y.x >= m && y.x <= v && y.y >= g && y.y <= p && y !== i && y !== o && Ra(a, u, l, h, c, f, y.x, y.y) && ln(y.prev, y, y.next) >= 0)
                return !1;
            y = y.prevZ
        }
        for (; _ && _.z <= x; ) {
            if (_.x >= m && _.x <= v && _.y >= g && _.y <= p && _ !== i && _ !== o && Ra(a, u, l, h, c, f, _.x, _.y) && ln(_.prev, _, _.next) >= 0)
                return !1;
            _ = _.nextZ
        }
        return !0
    }
    function IS(r, e, t) {
        let n = r;
        do {
            let i = n.prev
              , s = n.next.next;
            !zh(i, s) && Iv(i, n, n.next, s) && Gc(i, s) && Gc(s, i) && (e.push(i.i / t | 0),
            e.push(n.i / t | 0),
            e.push(s.i / t | 0),
            Vc(n),
            Vc(n.next),
            n = r = s),
            n = n.next
        } while (n !== r);
        return Uo(n)
    }
    function RS(r, e, t, n, i, s) {
        let o = r;
        do {
            let a = o.next.next;
            for (; a !== o.prev; ) {
                if (o.i !== a.i && BS(o, a)) {
                    let l = Rv(o, a);
                    o = Uo(o, o.next),
                    l = Uo(l, l.next),
                    Bc(o, e, t, n, i, s, 0),
                    Bc(l, e, t, n, i, s, 0);
                    return
                }
                a = a.next
            }
            o = o.next
        } while (o !== r)
    }
    function PS(r, e, t, n) {
        let i = [], s, o, a, l, c;
        for (s = 0,
        o = e.length; s < o; s++)
            a = e[s] * n,
            l = s < o - 1 ? e[s + 1] * n : r.length,
            c = Cv(r, a, l, n, !1),
            c === c.next && (c.steiner = !0),
            i.push(US(c));
        for (i.sort(LS),
        s = 0; s < i.length; s++)
            t = NS(i[s], t);
        return t
    }
    function LS(r, e) {
        return r.x - e.x
    }
    function NS(r, e) {
        let t = DS(r, e);
        if (!t)
            return e;
        let n = Rv(t, r);
        return Uo(n, n.next),
        Uo(t, t.next)
    }
    function DS(r, e) {
        let t = e, n = -1 / 0, i, s = r.x, o = r.y;
        do {
            if (o <= t.y && o >= t.next.y && t.next.y !== t.y) {
                let f = t.x + (o - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
                if (f <= s && f > n && (n = f,
                i = t.x < t.next.x ? t : t.next,
                f === s))
                    return i
            }
            t = t.next
        } while (t !== e);
        if (!i)
            return null;
        let a = i, l = i.x, c = i.y, u = 1 / 0, h;
        t = i;
        do
            s >= t.x && t.x >= l && s !== t.x && Ra(o < c ? s : n, o, l, c, o < c ? n : s, o, t.x, t.y) && (h = Math.abs(o - t.y) / (s - t.x),
            Gc(t, r) && (h < u || h === u && (t.x > i.x || t.x === i.x && OS(i, t))) && (i = t,
            u = h)),
            t = t.next;
        while (t !== a);
        return i
    }
    function OS(r, e) {
        return ln(r.prev, r, e.prev) < 0 && ln(e.next, r, r.next) < 0
    }
    function FS(r, e, t, n) {
        let i = r;
        do
            i.z === 0 && (i.z = bp(i.x, i.y, e, t, n)),
            i.prevZ = i.prev,
            i.nextZ = i.next,
            i = i.next;
        while (i !== r);
        i.prevZ.nextZ = null,
        i.prevZ = null,
        kS(i)
    }
    function kS(r) {
        let e, t, n, i, s, o, a, l, c = 1;
        do {
            for (t = r,
            r = null,
            s = null,
            o = 0; t; ) {
                for (o++,
                n = t,
                a = 0,
                e = 0; e < c && (a++,
                n = n.nextZ,
                !!n); e++)
                    ;
                for (l = c; a > 0 || l > 0 && n; )
                    a !== 0 && (l === 0 || !n || t.z <= n.z) ? (i = t,
                    t = t.nextZ,
                    a--) : (i = n,
                    n = n.nextZ,
                    l--),
                    s ? s.nextZ = i : r = i,
                    i.prevZ = s,
                    s = i;
                t = n
            }
            s.nextZ = null,
            c *= 2
        } while (o > 1);
        return r
    }
    function bp(r, e, t, n, i) {
        return r = (r - t) * i | 0,
        e = (e - n) * i | 0,
        r = (r | r << 8) & 16711935,
        r = (r | r << 4) & 252645135,
        r = (r | r << 2) & 858993459,
        r = (r | r << 1) & 1431655765,
        e = (e | e << 8) & 16711935,
        e = (e | e << 4) & 252645135,
        e = (e | e << 2) & 858993459,
        e = (e | e << 1) & 1431655765,
        r | e << 1
    }
    function US(r) {
        let e = r
          , t = r;
        do
            (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e),
            e = e.next;
        while (e !== r);
        return t
    }
    function Ra(r, e, t, n, i, s, o, a) {
        return (i - o) * (e - a) >= (r - o) * (s - a) && (r - o) * (n - a) >= (t - o) * (e - a) && (t - o) * (s - a) >= (i - o) * (n - a)
    }
    function BS(r, e) {
        return r.next.i !== e.i && r.prev.i !== e.i && !GS(r, e) && (Gc(r, e) && Gc(e, r) && VS(r, e) && (ln(r.prev, r, e.prev) || ln(r, e.prev, e)) || zh(r, e) && ln(r.prev, r, r.next) > 0 && ln(e.prev, e, e.next) > 0)
    }
    function ln(r, e, t) {
        return (e.y - r.y) * (t.x - e.x) - (e.x - r.x) * (t.y - e.y)
    }
    function zh(r, e) {
        return r.x === e.x && r.y === e.y
    }
    function Iv(r, e, t, n) {
        let i = vh(ln(r, e, t))
          , s = vh(ln(r, e, n))
          , o = vh(ln(t, n, r))
          , a = vh(ln(t, n, e));
        return !!(i !== s && o !== a || i === 0 && gh(r, t, e) || s === 0 && gh(r, n, e) || o === 0 && gh(t, r, n) || a === 0 && gh(t, e, n))
    }
    function gh(r, e, t) {
        return e.x <= Math.max(r.x, t.x) && e.x >= Math.min(r.x, t.x) && e.y <= Math.max(r.y, t.y) && e.y >= Math.min(r.y, t.y)
    }
    function vh(r) {
        return r > 0 ? 1 : r < 0 ? -1 : 0
    }
    function GS(r, e) {
        let t = r;
        do {
            if (t.i !== r.i && t.next.i !== r.i && t.i !== e.i && t.next.i !== e.i && Iv(t, t.next, r, e))
                return !0;
            t = t.next
        } while (t !== r);
        return !1
    }
    function Gc(r, e) {
        return ln(r.prev, r, r.next) < 0 ? ln(r, e, r.next) >= 0 && ln(r, r.prev, e) >= 0 : ln(r, e, r.prev) < 0 || ln(r, r.next, e) < 0
    }
    function VS(r, e) {
        let t = r
          , n = !1
          , i = (r.x + e.x) / 2
          , s = (r.y + e.y) / 2;
        do
            t.y > s != t.next.y > s && t.next.y !== t.y && i < (t.next.x - t.x) * (s - t.y) / (t.next.y - t.y) + t.x && (n = !n),
            t = t.next;
        while (t !== r);
        return n
    }
    function Rv(r, e) {
        let t = new Mp(r.i,r.x,r.y)
          , n = new Mp(e.i,e.x,e.y)
          , i = r.next
          , s = e.prev;
        return r.next = e,
        e.prev = r,
        t.next = i,
        i.prev = t,
        n.next = t,
        t.prev = n,
        s.next = n,
        n.prev = s,
        n
    }
    function tv(r, e, t, n) {
        let i = new Mp(r,e,t);
        return n ? (i.next = n.next,
        i.prev = n,
        n.next.prev = i,
        n.next = i) : (i.prev = i,
        i.next = i),
        i
    }
    function Vc(r) {
        r.next.prev = r.prev,
        r.prev.next = r.next,
        r.prevZ && (r.prevZ.nextZ = r.nextZ),
        r.nextZ && (r.nextZ.prevZ = r.prevZ)
    }
    function Mp(r, e, t) {
        this.i = r,
        this.x = e,
        this.y = t,
        this.prev = null,
        this.next = null,
        this.z = 0,
        this.prevZ = null,
        this.nextZ = null,
        this.steiner = !1
    }
    function zS(r, e, t, n) {
        let i = 0;
        for (let s = e, o = t - n; s < t; s += n)
            i += (r[o] - r[s]) * (r[s + 1] + r[o + 1]),
            o = s;
        return i
    }
    var ji = class {
        static area(e) {
            let t = e.length
              , n = 0;
            for (let i = t - 1, s = 0; s < t; i = s++)
                n += e[i].x * e[s].y - e[s].x * e[i].y;
            return n * .5
        }
        static isClockWise(e) {
            return ji.area(e) < 0
        }
        static triangulateShape(e, t) {
            let n = []
              , i = []
              , s = [];
            nv(e),
            iv(n, e);
            let o = e.length;
            t.forEach(nv);
            for (let l = 0; l < t.length; l++)
                i.push(o),
                o += t[l].length,
                iv(n, t[l]);
            let a = wS.triangulate(n, i);
            for (let l = 0; l < a.length; l += 3)
                s.push(a.slice(l, l + 3));
            return s
        }
    }
    ;
    function nv(r) {
        let e = r.length;
        e > 2 && r[e - 1].equals(r[0]) && r.pop()
    }
    function iv(r, e) {
        for (let t = 0; t < e.length; t++)
            r.push(e[t].x),
            r.push(e[t].y)
    }
    var qa = class extends wt {
        constructor(e=new Hs([new Ie(.5,.5), new Ie(-.5,.5), new Ie(-.5,-.5), new Ie(.5,-.5)]), t={}) {
            super(),
            this.type = "ExtrudeGeometry",
            this.parameters = {
                shapes: e,
                options: t
            },
            e = Array.isArray(e) ? e : [e];
            let n = this
              , i = []
              , s = [];
            for (let a = 0, l = e.length; a < l; a++) {
                let c = e[a];
                o(c)
            }
            this.setAttribute("position", new qe(i,3)),
            this.setAttribute("uv", new qe(s,2)),
            this.computeVertexNormals();
            function o(a) {
                let l = [], c = t.curveSegments !== void 0 ? t.curveSegments : 12, u = t.steps !== void 0 ? t.steps : 1, h = t.depth !== void 0 ? t.depth : 1, f = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0, m = t.bevelThickness !== void 0 ? t.bevelThickness : .2, g = t.bevelSize !== void 0 ? t.bevelSize : m - .1, v = t.bevelOffset !== void 0 ? t.bevelOffset : 0, p = t.bevelSegments !== void 0 ? t.bevelSegments : 3, d = t.extrudePath, x = t.UVGenerator !== void 0 ? t.UVGenerator : HS, y, _ = !1, S, N, I, O;
                d && (y = d.getSpacedPoints(u),
                _ = !0,
                f = !1,
                S = d.computeFrenetFrames(u, !1),
                N = new ue,
                I = new ue,
                O = new ue),
                f || (p = 0,
                m = 0,
                g = 0,
                v = 0);
                let M = a.extractPoints(c)
                  , R = M.shape
                  , q = M.holes;
                if (!ji.isClockWise(R)) {
                    R = R.reverse();
                    for (let J = 0, ae = q.length; J < ae; J++) {
                        let ie = q[J];
                        ji.isClockWise(ie) && (q[J] = ie.reverse())
                    }
                }
                let B = ji.triangulateShape(R, q)
                  , P = R;
                for (let J = 0, ae = q.length; J < ae; J++) {
                    let ie = q[J];
                    R = R.concat(ie)
                }
                function C(J, ae, ie) {
                    return ae || console.error("THREE.ExtrudeGeometry: vec does not exist"),
                    J.clone().addScaledVector(ae, ie)
                }
                let L = R.length
                  , F = B.length;
                function U(J, ae, ie) {
                    let me, ve, be, fe = J.x - ae.x, te = J.y - ae.y, Ee = ie.x - J.x, Le = ie.y - J.y, D = fe * fe + te * te, A = fe * Le - te * Ee;
                    if (Math.abs(A) > Number.EPSILON) {
                        let G = Math.sqrt(D)
                          , ne = Math.sqrt(Ee * Ee + Le * Le)
                          , Q = ae.x - te / G
                          , he = ae.y + fe / G
                          , de = ie.x - Le / ne
                          , ge = ie.y + Ee / ne
                          , le = ((de - Q) * Le - (ge - he) * Ee) / (fe * Le - te * Ee);
                        me = Q + fe * le - J.x,
                        ve = he + te * le - J.y;
                        let xe = me * me + ve * ve;
                        if (xe <= 2)
                            return new Ie(me,ve);
                        be = Math.sqrt(xe / 2)
                    } else {
                        let G = !1;
                        fe > Number.EPSILON ? Ee > Number.EPSILON && (G = !0) : fe < -Number.EPSILON ? Ee < -Number.EPSILON && (G = !0) : Math.sign(te) === Math.sign(Le) && (G = !0),
                        G ? (me = -te,
                        ve = fe,
                        be = Math.sqrt(D)) : (me = fe,
                        ve = te,
                        be = Math.sqrt(D / 2))
                    }
                    return new Ie(me / be,ve / be)
                }
                let W = [];
                for (let J = 0, ae = P.length, ie = ae - 1, me = J + 1; J < ae; J++,
                ie++,
                me++)
                    ie === ae && (ie = 0),
                    me === ae && (me = 0),
                    W[J] = U(P[J], P[ie], P[me]);
                let K = [], re, oe = W.concat();
                for (let J = 0, ae = q.length; J < ae; J++) {
                    let ie = q[J];
                    re = [];
                    for (let me = 0, ve = ie.length, be = ve - 1, fe = me + 1; me < ve; me++,
                    be++,
                    fe++)
                        be === ve && (be = 0),
                        fe === ve && (fe = 0),
                        re[me] = U(ie[me], ie[be], ie[fe]);
                    K.push(re),
                    oe = oe.concat(re)
                }
                for (let J = 0; J < p; J++) {
                    let ae = J / p
                      , ie = m * Math.cos(ae * Math.PI / 2)
                      , me = g * Math.sin(ae * Math.PI / 2) + v;
                    for (let ve = 0, be = P.length; ve < be; ve++) {
                        let fe = C(P[ve], W[ve], me);
                        T(fe.x, fe.y, -ie)
                    }
                    for (let ve = 0, be = q.length; ve < be; ve++) {
                        let fe = q[ve];
                        re = K[ve];
                        for (let te = 0, Ee = fe.length; te < Ee; te++) {
                            let Le = C(fe[te], re[te], me);
                            T(Le.x, Le.y, -ie)
                        }
                    }
                }
                let j = g + v;
                for (let J = 0; J < L; J++) {
                    let ae = f ? C(R[J], oe[J], j) : R[J];
                    _ ? (I.copy(S.normals[0]).multiplyScalar(ae.x),
                    N.copy(S.binormals[0]).multiplyScalar(ae.y),
                    O.copy(y[0]).add(I).add(N),
                    T(O.x, O.y, O.z)) : T(ae.x, ae.y, 0)
                }
                for (let J = 1; J <= u; J++)
                    for (let ae = 0; ae < L; ae++) {
                        let ie = f ? C(R[ae], oe[ae], j) : R[ae];
                        _ ? (I.copy(S.normals[J]).multiplyScalar(ie.x),
                        N.copy(S.binormals[J]).multiplyScalar(ie.y),
                        O.copy(y[J]).add(I).add(N),
                        T(O.x, O.y, O.z)) : T(ie.x, ie.y, h / u * J)
                    }
                for (let J = p - 1; J >= 0; J--) {
                    let ae = J / p
                      , ie = m * Math.cos(ae * Math.PI / 2)
                      , me = g * Math.sin(ae * Math.PI / 2) + v;
                    for (let ve = 0, be = P.length; ve < be; ve++) {
                        let fe = C(P[ve], W[ve], me);
                        T(fe.x, fe.y, h + ie)
                    }
                    for (let ve = 0, be = q.length; ve < be; ve++) {
                        let fe = q[ve];
                        re = K[ve];
                        for (let te = 0, Ee = fe.length; te < Ee; te++) {
                            let Le = C(fe[te], re[te], me);
                            _ ? T(Le.x, Le.y + y[u - 1].y, y[u - 1].x + ie) : T(Le.x, Le.y, h + ie)
                        }
                    }
                }
                w(),
                b();
                function w() {
                    let J = i.length / 3;
                    if (f) {
                        let ae = 0
                          , ie = L * ae;
                        for (let me = 0; me < F; me++) {
                            let ve = B[me];
                            H(ve[2] + ie, ve[1] + ie, ve[0] + ie)
                        }
                        ae = u + p * 2,
                        ie = L * ae;
                        for (let me = 0; me < F; me++) {
                            let ve = B[me];
                            H(ve[0] + ie, ve[1] + ie, ve[2] + ie)
                        }
                    } else {
                        for (let ae = 0; ae < F; ae++) {
                            let ie = B[ae];
                            H(ie[2], ie[1], ie[0])
                        }
                        for (let ae = 0; ae < F; ae++) {
                            let ie = B[ae];
                            H(ie[0] + L * u, ie[1] + L * u, ie[2] + L * u)
                        }
                    }
                    n.addGroup(J, i.length / 3 - J, 0)
                }
                function b() {
                    let J = i.length / 3
                      , ae = 0;
                    E(P, ae),
                    ae += P.length;
                    for (let ie = 0, me = q.length; ie < me; ie++) {
                        let ve = q[ie];
                        E(ve, ae),
                        ae += ve.length
                    }
                    n.addGroup(J, i.length / 3 - J, 1)
                }
                function E(J, ae) {
                    let ie = J.length;
                    for (; --ie >= 0; ) {
                        let me = ie
                          , ve = ie - 1;
                        ve < 0 && (ve = J.length - 1);
                        for (let be = 0, fe = u + p * 2; be < fe; be++) {
                            let te = L * be
                              , Ee = L * (be + 1)
                              , Le = ae + me + te
                              , D = ae + ve + te
                              , A = ae + ve + Ee
                              , G = ae + me + Ee;
                            Y(Le, D, A, G)
                        }
                    }
                }
                function T(J, ae, ie) {
                    l.push(J),
                    l.push(ae),
                    l.push(ie)
                }
                function H(J, ae, ie) {
                    X(J),
                    X(ae),
                    X(ie);
                    let me = i.length / 3
                      , ve = x.generateTopUV(n, i, me - 3, me - 2, me - 1);
                    ce(ve[0]),
                    ce(ve[1]),
                    ce(ve[2])
                }
                function Y(J, ae, ie, me) {
                    X(J),
                    X(ae),
                    X(me),
                    X(ae),
                    X(ie),
                    X(me);
                    let ve = i.length / 3
                      , be = x.generateSideWallUV(n, i, ve - 6, ve - 3, ve - 2, ve - 1);
                    ce(be[0]),
                    ce(be[1]),
                    ce(be[3]),
                    ce(be[1]),
                    ce(be[2]),
                    ce(be[3])
                }
                function X(J) {
                    i.push(l[J * 3 + 0]),
                    i.push(l[J * 3 + 1]),
                    i.push(l[J * 3 + 2])
                }
                function ce(J) {
                    s.push(J.x),
                    s.push(J.y)
                }
            }
        }
        copy(e) {
            return super.copy(e),
            this.parameters = Object.assign({}, e.parameters),
            this
        }
        toJSON() {
            let e = super.toJSON()
              , t = this.parameters.shapes
              , n = this.parameters.options;
            return WS(t, n, e)
        }
        static fromJSON(e, t) {
            let n = [];
            for (let s = 0, o = e.shapes.length; s < o; s++) {
                let a = t[e.shapes[s]];
                n.push(a)
            }
            let i = e.options.extrudePath;
            return i !== void 0 && (e.options.extrudePath = new Av[i.type]().fromJSON(i)),
            new qa(n,e.options)
        }
    }
      , HS = {
        generateTopUV: function(r, e, t, n, i) {
            let s = e[t * 3]
              , o = e[t * 3 + 1]
              , a = e[n * 3]
              , l = e[n * 3 + 1]
              , c = e[i * 3]
              , u = e[i * 3 + 1];
            return [new Ie(s,o), new Ie(a,l), new Ie(c,u)]
        },
        generateSideWallUV: function(r, e, t, n, i, s) {
            let o = e[t * 3]
              , a = e[t * 3 + 1]
              , l = e[t * 3 + 2]
              , c = e[n * 3]
              , u = e[n * 3 + 1]
              , h = e[n * 3 + 2]
              , f = e[i * 3]
              , m = e[i * 3 + 1]
              , g = e[i * 3 + 2]
              , v = e[s * 3]
              , p = e[s * 3 + 1]
              , d = e[s * 3 + 2];
            return Math.abs(a - u) < Math.abs(o - c) ? [new Ie(o,1 - l), new Ie(c,1 - h), new Ie(f,1 - g), new Ie(v,1 - d)] : [new Ie(a,1 - l), new Ie(u,1 - h), new Ie(m,1 - g), new Ie(p,1 - d)]
        }
    };
    function WS(r, e, t) {
        if (t.shapes = [],
        Array.isArray(r))
            for (let n = 0, i = r.length; n < i; n++) {
                let s = r[n];
                t.shapes.push(s.uuid)
            }
        else
            t.shapes.push(r.uuid);
        return t.options = Object.assign({}, e),
        e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()),
        t
    }
    var Ys = class extends wt {
        constructor(e=1, t=32, n=16, i=0, s=Math.PI * 2, o=0, a=Math.PI) {
            super(),
            this.type = "SphereGeometry",
            this.parameters = {
                radius: e,
                widthSegments: t,
                heightSegments: n,
                phiStart: i,
                phiLength: s,
                thetaStart: o,
                thetaLength: a
            },
            t = Math.max(3, Math.floor(t)),
            n = Math.max(2, Math.floor(n));
            let l = Math.min(o + a, Math.PI)
              , c = 0
              , u = []
              , h = new ue
              , f = new ue
              , m = []
              , g = []
              , v = []
              , p = [];
            for (let d = 0; d <= n; d++) {
                let x = []
                  , y = d / n
                  , _ = 0;
                d === 0 && o === 0 ? _ = .5 / t : d === n && l === Math.PI && (_ = -.5 / t);
                for (let S = 0; S <= t; S++) {
                    let N = S / t;
                    h.x = -e * Math.cos(i + N * s) * Math.sin(o + y * a),
                    h.y = e * Math.cos(o + y * a),
                    h.z = e * Math.sin(i + N * s) * Math.sin(o + y * a),
                    g.push(h.x, h.y, h.z),
                    f.copy(h).normalize(),
                    v.push(f.x, f.y, f.z),
                    p.push(N + _, 1 - y),
                    x.push(c++)
                }
                u.push(x)
            }
            for (let d = 0; d < n; d++)
                for (let x = 0; x < t; x++) {
                    let y = u[d][x + 1]
                      , _ = u[d][x]
                      , S = u[d + 1][x]
                      , N = u[d + 1][x + 1];
                    (d !== 0 || o > 0) && m.push(y, _, N),
                    (d !== n - 1 || l < Math.PI) && m.push(_, S, N)
                }
            this.setIndex(m),
            this.setAttribute("position", new qe(g,3)),
            this.setAttribute("normal", new qe(v,3)),
            this.setAttribute("uv", new qe(p,2))
        }
        copy(e) {
            return super.copy(e),
            this.parameters = Object.assign({}, e.parameters),
            this
        }
        static fromJSON(e) {
            return new Ys(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)
        }
    }
    ;
    var Ks = class extends ur {
        constructor(e) {
            super(),
            this.isMeshStandardMaterial = !0,
            this.defines = {
                STANDARD: ""
            },
            this.type = "MeshStandardMaterial",
            this.color = new $e(16777215),
            this.roughness = 1,
            this.metalness = 0,
            this.map = null,
            this.lightMap = null,
            this.lightMapIntensity = 1,
            this.aoMap = null,
            this.aoMapIntensity = 1,
            this.emissive = new $e(0),
            this.emissiveIntensity = 1,
            this.emissiveMap = null,
            this.bumpMap = null,
            this.bumpScale = 1,
            this.normalMap = null,
            this.normalMapType = Gh,
            this.normalScale = new Ie(1,1),
            this.displacementMap = null,
            this.displacementScale = 1,
            this.displacementBias = 0,
            this.roughnessMap = null,
            this.metalnessMap = null,
            this.alphaMap = null,
            this.envMap = null,
            this.envMapIntensity = 1,
            this.wireframe = !1,
            this.wireframeLinewidth = 1,
            this.wireframeLinecap = "round",
            this.wireframeLinejoin = "round",
            this.flatShading = !1,
            this.fog = !0,
            this.setValues(e)
        }
        copy(e) {
            return super.copy(e),
            this.defines = {
                STANDARD: ""
            },
            this.color.copy(e.color),
            this.roughness = e.roughness,
            this.metalness = e.metalness,
            this.map = e.map,
            this.lightMap = e.lightMap,
            this.lightMapIntensity = e.lightMapIntensity,
            this.aoMap = e.aoMap,
            this.aoMapIntensity = e.aoMapIntensity,
            this.emissive.copy(e.emissive),
            this.emissiveMap = e.emissiveMap,
            this.emissiveIntensity = e.emissiveIntensity,
            this.bumpMap = e.bumpMap,
            this.bumpScale = e.bumpScale,
            this.normalMap = e.normalMap,
            this.normalMapType = e.normalMapType,
            this.normalScale.copy(e.normalScale),
            this.displacementMap = e.displacementMap,
            this.displacementScale = e.displacementScale,
            this.displacementBias = e.displacementBias,
            this.roughnessMap = e.roughnessMap,
            this.metalnessMap = e.metalnessMap,
            this.alphaMap = e.alphaMap,
            this.envMap = e.envMap,
            this.envMapIntensity = e.envMapIntensity,
            this.wireframe = e.wireframe,
            this.wireframeLinewidth = e.wireframeLinewidth,
            this.wireframeLinecap = e.wireframeLinecap,
            this.wireframeLinejoin = e.wireframeLinejoin,
            this.flatShading = e.flatShading,
            this.fog = e.fog,
            this
        }
    }
    ;
    var sn = class extends ur {
        constructor(e) {
            super(),
            this.isMeshPhongMaterial = !0,
            this.type = "MeshPhongMaterial",
            this.color = new $e(16777215),
            this.specular = new $e(1118481),
            this.shininess = 30,
            this.map = null,
            this.lightMap = null,
            this.lightMapIntensity = 1,
            this.aoMap = null,
            this.aoMapIntensity = 1,
            this.emissive = new $e(0),
            this.emissiveIntensity = 1,
            this.emissiveMap = null,
            this.bumpMap = null,
            this.bumpScale = 1,
            this.normalMap = null,
            this.normalMapType = Gh,
            this.normalScale = new Ie(1,1),
            this.displacementMap = null,
            this.displacementScale = 1,
            this.displacementBias = 0,
            this.specularMap = null,
            this.alphaMap = null,
            this.envMap = null,
            this.combine = Uh,
            this.reflectivity = 1,
            this.refractionRatio = .98,
            this.wireframe = !1,
            this.wireframeLinewidth = 1,
            this.wireframeLinecap = "round",
            this.wireframeLinejoin = "round",
            this.flatShading = !1,
            this.fog = !0,
            this.setValues(e)
        }
        copy(e) {
            return super.copy(e),
            this.color.copy(e.color),
            this.specular.copy(e.specular),
            this.shininess = e.shininess,
            this.map = e.map,
            this.lightMap = e.lightMap,
            this.lightMapIntensity = e.lightMapIntensity,
            this.aoMap = e.aoMap,
            this.aoMapIntensity = e.aoMapIntensity,
            this.emissive.copy(e.emissive),
            this.emissiveMap = e.emissiveMap,
            this.emissiveIntensity = e.emissiveIntensity,
            this.bumpMap = e.bumpMap,
            this.bumpScale = e.bumpScale,
            this.normalMap = e.normalMap,
            this.normalMapType = e.normalMapType,
            this.normalScale.copy(e.normalScale),
            this.displacementMap = e.displacementMap,
            this.displacementScale = e.displacementScale,
            this.displacementBias = e.displacementBias,
            this.specularMap = e.specularMap,
            this.alphaMap = e.alphaMap,
            this.envMap = e.envMap,
            this.combine = e.combine,
            this.reflectivity = e.reflectivity,
            this.refractionRatio = e.refractionRatio,
            this.wireframe = e.wireframe,
            this.wireframeLinewidth = e.wireframeLinewidth,
            this.wireframeLinecap = e.wireframeLinecap,
            this.wireframeLinejoin = e.wireframeLinejoin,
            this.flatShading = e.flatShading,
            this.fog = e.fog,
            this
        }
    }
    ;
    var Ya = class extends ur {
        constructor(e) {
            super(),
            this.isMeshLambertMaterial = !0,
            this.type = "MeshLambertMaterial",
            this.color = new $e(16777215),
            this.map = null,
            this.lightMap = null,
            this.lightMapIntensity = 1,
            this.aoMap = null,
            this.aoMapIntensity = 1,
            this.emissive = new $e(0),
            this.emissiveIntensity = 1,
            this.emissiveMap = null,
            this.bumpMap = null,
            this.bumpScale = 1,
            this.normalMap = null,
            this.normalMapType = Gh,
            this.normalScale = new Ie(1,1),
            this.displacementMap = null,
            this.displacementScale = 1,
            this.displacementBias = 0,
            this.specularMap = null,
            this.alphaMap = null,
            this.envMap = null,
            this.combine = Uh,
            this.reflectivity = 1,
            this.refractionRatio = .98,
            this.wireframe = !1,
            this.wireframeLinewidth = 1,
            this.wireframeLinecap = "round",
            this.wireframeLinejoin = "round",
            this.flatShading = !1,
            this.fog = !0,
            this.setValues(e)
        }
        copy(e) {
            return super.copy(e),
            this.color.copy(e.color),
            this.map = e.map,
            this.lightMap = e.lightMap,
            this.lightMapIntensity = e.lightMapIntensity,
            this.aoMap = e.aoMap,
            this.aoMapIntensity = e.aoMapIntensity,
            this.emissive.copy(e.emissive),
            this.emissiveMap = e.emissiveMap,
            this.emissiveIntensity = e.emissiveIntensity,
            this.bumpMap = e.bumpMap,
            this.bumpScale = e.bumpScale,
            this.normalMap = e.normalMap,
            this.normalMapType = e.normalMapType,
            this.normalScale.copy(e.normalScale),
            this.displacementMap = e.displacementMap,
            this.displacementScale = e.displacementScale,
            this.displacementBias = e.displacementBias,
            this.specularMap = e.specularMap,
            this.alphaMap = e.alphaMap,
            this.envMap = e.envMap,
            this.combine = e.combine,
            this.reflectivity = e.reflectivity,
            this.refractionRatio = e.refractionRatio,
            this.wireframe = e.wireframe,
            this.wireframeLinewidth = e.wireframeLinewidth,
            this.wireframeLinecap = e.wireframeLinecap,
            this.wireframeLinejoin = e.wireframeLinejoin,
            this.flatShading = e.flatShading,
            this.fog = e.fog,
            this
        }
    }
    ;
    function Gs(r, e, t) {
        return Pv(r) ? new r.constructor(r.subarray(e, t !== void 0 ? t : r.length)) : r.slice(e, t)
    }
    function yh(r, e, t) {
        return !r || !t && r.constructor === e ? r : typeof e.BYTES_PER_ELEMENT == "number" ? new e(r) : Array.prototype.slice.call(r)
    }
    function Pv(r) {
        return ArrayBuffer.isView(r) && !(r instanceof DataView)
    }
    function XS(r) {
        function e(i, s) {
            return r[i] - r[s]
        }
        let t = r.length
          , n = new Array(t);
        for (let i = 0; i !== t; ++i)
            n[i] = i;
        return n.sort(e),
        n
    }
    function rv(r, e, t) {
        let n = r.length
          , i = new r.constructor(n);
        for (let s = 0, o = 0; o !== n; ++s) {
            let a = t[s] * e;
            for (let l = 0; l !== e; ++l)
                i[o++] = r[a + l]
        }
        return i
    }
    function Lv(r, e, t, n) {
        let i = 1
          , s = r[0];
        for (; s !== void 0 && s[n] === void 0; )
            s = r[i++];
        if (s === void 0)
            return;
        let o = s[n];
        if (o !== void 0)
            if (Array.isArray(o))
                do
                    o = s[n],
                    o !== void 0 && (e.push(s.time),
                    t.push.apply(t, o)),
                    s = r[i++];
                while (s !== void 0);
            else if (o.toArray !== void 0)
                do
                    o = s[n],
                    o !== void 0 && (e.push(s.time),
                    o.toArray(t, t.length)),
                    s = r[i++];
                while (s !== void 0);
            else
                do
                    o = s[n],
                    o !== void 0 && (e.push(s.time),
                    t.push(o)),
                    s = r[i++];
                while (s !== void 0)
    }
    var Ka = class {
        constructor(e, t, n, i) {
            this.parameterPositions = e,
            this._cachedIndex = 0,
            this.resultBuffer = i !== void 0 ? i : new t.constructor(n),
            this.sampleValues = t,
            this.valueSize = n,
            this.settings = null,
            this.DefaultSettings_ = {}
        }
        evaluate(e) {
            let t = this.parameterPositions
              , n = this._cachedIndex
              , i = t[n]
              , s = t[n - 1];
            e: {
                t: {
                    let o;
                    n: {
                        i: if (!(e < i)) {
                            for (let a = n + 2; ; ) {
                                if (i === void 0) {
                                    if (e < s)
                                        break i;
                                    return n = t.length,
                                    this._cachedIndex = n,
                                    this.copySampleValue_(n - 1)
                                }
                                if (n === a)
                                    break;
                                if (s = i,
                                i = t[++n],
                                e < i)
                                    break t
                            }
                            o = t.length;
                            break n
                        }
                        if (!(e >= s)) {
                            let a = t[1];
                            e < a && (n = 2,
                            s = a);
                            for (let l = n - 2; ; ) {
                                if (s === void 0)
                                    return this._cachedIndex = 0,
                                    this.copySampleValue_(0);
                                if (n === l)
                                    break;
                                if (i = s,
                                s = t[--n - 1],
                                e >= s)
                                    break t
                            }
                            o = n,
                            n = 0;
                            break n
                        }
                        break e
                    }
                    for (; n < o; ) {
                        let a = n + o >>> 1;
                        e < t[a] ? o = a : n = a + 1
                    }
                    if (i = t[n],
                    s = t[n - 1],
                    s === void 0)
                        return this._cachedIndex = 0,
                        this.copySampleValue_(0);
                    if (i === void 0)
                        return n = t.length,
                        this._cachedIndex = n,
                        this.copySampleValue_(n - 1)
                }
                this._cachedIndex = n,
                this.intervalChanged_(n, s, i)
            }
            return this.interpolate_(n, s, e, i)
        }
        getSettings_() {
            return this.settings || this.DefaultSettings_
        }
        copySampleValue_(e) {
            let t = this.resultBuffer
              , n = this.sampleValues
              , i = this.valueSize
              , s = e * i;
            for (let o = 0; o !== i; ++o)
                t[o] = n[s + o];
            return t
        }
        interpolate_() {
            throw new Error("call to abstract method")
        }
        intervalChanged_() {}
    }
      , Ep = class extends Ka {
        constructor(e, t, n, i) {
            super(e, t, n, i),
            this._weightPrev = -0,
            this._offsetPrev = -0,
            this._weightNext = -0,
            this._offsetNext = -0,
            this.DefaultSettings_ = {
                endingStart: e0,
                endingEnd: e0
            }
        }
        intervalChanged_(e, t, n) {
            let i = this.parameterPositions
              , s = e - 2
              , o = e + 1
              , a = i[s]
              , l = i[o];
            if (a === void 0)
                switch (this.getSettings_().endingStart) {
                case t0:
                    s = e,
                    a = 2 * t - n;
                    break;
                case n0:
                    s = i.length - 2,
                    a = t + i[s] - i[s + 1];
                    break;
                default:
                    s = e,
                    a = n
                }
            if (l === void 0)
                switch (this.getSettings_().endingEnd) {
                case t0:
                    o = e,
                    l = 2 * n - t;
                    break;
                case n0:
                    o = 1,
                    l = n + i[1] - i[0];
                    break;
                default:
                    o = e - 1,
                    l = t
                }
            let c = (n - t) * .5
              , u = this.valueSize;
            this._weightPrev = c / (t - a),
            this._weightNext = c / (l - n),
            this._offsetPrev = s * u,
            this._offsetNext = o * u
        }
        interpolate_(e, t, n, i) {
            let s = this.resultBuffer
              , o = this.sampleValues
              , a = this.valueSize
              , l = e * a
              , c = l - a
              , u = this._offsetPrev
              , h = this._offsetNext
              , f = this._weightPrev
              , m = this._weightNext
              , g = (n - t) / (i - t)
              , v = g * g
              , p = v * g
              , d = -f * p + 2 * f * v - f * g
              , x = (1 + f) * p + (-1.5 - 2 * f) * v + (-.5 + f) * g + 1
              , y = (-1 - m) * p + (1.5 + m) * v + .5 * g
              , _ = m * p - m * v;
            for (let S = 0; S !== a; ++S)
                s[S] = d * o[u + S] + x * o[c + S] + y * o[l + S] + _ * o[h + S];
            return s
        }
    }
      , Sp = class extends Ka {
        constructor(e, t, n, i) {
            super(e, t, n, i)
        }
        interpolate_(e, t, n, i) {
            let s = this.resultBuffer
              , o = this.sampleValues
              , a = this.valueSize
              , l = e * a
              , c = l - a
              , u = (n - t) / (i - t)
              , h = 1 - u;
            for (let f = 0; f !== a; ++f)
                s[f] = o[c + f] * h + o[l + f] * u;
            return s
        }
    }
      , wp = class extends Ka {
        constructor(e, t, n, i) {
            super(e, t, n, i)
        }
        interpolate_(e) {
            return this.copySampleValue_(e - 1)
        }
    }
      , Ki = class {
        constructor(e, t, n, i) {
            if (e === void 0)
                throw new Error("THREE.KeyframeTrack: track name is undefined");
            if (t === void 0 || t.length === 0)
                throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
            this.name = e,
            this.times = yh(t, this.TimeBufferType),
            this.values = yh(n, this.ValueBufferType),
            this.setInterpolation(i || this.DefaultInterpolation)
        }
        static toJSON(e) {
            let t = e.constructor, n;
            if (t.toJSON !== this.toJSON)
                n = t.toJSON(e);
            else {
                n = {
                    name: e.name,
                    times: yh(e.times, Array),
                    values: yh(e.values, Array)
                };
                let i = e.getInterpolation();
                i !== e.DefaultInterpolation && (n.interpolation = i)
            }
            return n.type = e.ValueTypeName,
            n
        }
        InterpolantFactoryMethodDiscrete(e) {
            return new wp(this.times,this.values,this.getValueSize(),e)
        }
        InterpolantFactoryMethodLinear(e) {
            return new Sp(this.times,this.values,this.getValueSize(),e)
        }
        InterpolantFactoryMethodSmooth(e) {
            return new Ep(this.times,this.values,this.getValueSize(),e)
        }
        setInterpolation(e) {
            let t;
            switch (e) {
            case xh:
                t = this.InterpolantFactoryMethodDiscrete;
                break;
            case _h:
                t = this.InterpolantFactoryMethodLinear;
                break;
            case Td:
                t = this.InterpolantFactoryMethodSmooth;
                break
            }
            if (t === void 0) {
                let n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                if (this.createInterpolant === void 0)
                    if (e !== this.DefaultInterpolation)
                        this.setInterpolation(this.DefaultInterpolation);
                    else
                        throw new Error(n);
                return console.warn("THREE.KeyframeTrack:", n),
                this
            }
            return this.createInterpolant = t,
            this
        }
        getInterpolation() {
            switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
                return xh;
            case this.InterpolantFactoryMethodLinear:
                return _h;
            case this.InterpolantFactoryMethodSmooth:
                return Td
            }
        }
        getValueSize() {
            return this.values.length / this.times.length
        }
        shift(e) {
            if (e !== 0) {
                let t = this.times;
                for (let n = 0, i = t.length; n !== i; ++n)
                    t[n] += e
            }
            return this
        }
        scale(e) {
            if (e !== 1) {
                let t = this.times;
                for (let n = 0, i = t.length; n !== i; ++n)
                    t[n] *= e
            }
            return this
        }
        trim(e, t) {
            let n = this.times
              , i = n.length
              , s = 0
              , o = i - 1;
            for (; s !== i && n[s] < e; )
                ++s;
            for (; o !== -1 && n[o] > t; )
                --o;
            if (++o,
            s !== 0 || o !== i) {
                s >= o && (o = Math.max(o, 1),
                s = o - 1);
                let a = this.getValueSize();
                this.times = Gs(n, s, o),
                this.values = Gs(this.values, s * a, o * a)
            }
            return this
        }
        validate() {
            let e = !0
              , t = this.getValueSize();
            t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
            e = !1);
            let n = this.times
              , i = this.values
              , s = n.length;
            s === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this),
            e = !1);
            let o = null;
            for (let a = 0; a !== s; a++) {
                let l = n[a];
                if (typeof l == "number" && isNaN(l)) {
                    console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, l),
                    e = !1;
                    break
                }
                if (o !== null && o > l) {
                    console.error("THREE.KeyframeTrack: Out of order keys.", this, a, l, o),
                    e = !1;
                    break
                }
                o = l
            }
            if (i !== void 0 && Pv(i))
                for (let a = 0, l = i.length; a !== l; ++a) {
                    let c = i[a];
                    if (isNaN(c)) {
                        console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, c),
                        e = !1;
                        break
                    }
                }
            return e
        }
        optimize() {
            let e = Gs(this.times)
              , t = Gs(this.values)
              , n = this.getValueSize()
              , i = this.getInterpolation() === Td
              , s = e.length - 1
              , o = 1;
            for (let a = 1; a < s; ++a) {
                let l = !1
                  , c = e[a]
                  , u = e[a + 1];
                if (c !== u && (a !== 1 || c !== e[0]))
                    if (i)
                        l = !0;
                    else {
                        let h = a * n
                          , f = h - n
                          , m = h + n;
                        for (let g = 0; g !== n; ++g) {
                            let v = t[h + g];
                            if (v !== t[f + g] || v !== t[m + g]) {
                                l = !0;
                                break
                            }
                        }
                    }
                if (l) {
                    if (a !== o) {
                        e[o] = e[a];
                        let h = a * n
                          , f = o * n;
                        for (let m = 0; m !== n; ++m)
                            t[f + m] = t[h + m]
                    }
                    ++o
                }
            }
            if (s > 0) {
                e[o] = e[s];
                for (let a = s * n, l = o * n, c = 0; c !== n; ++c)
                    t[l + c] = t[a + c];
                ++o
            }
            return o !== e.length ? (this.times = Gs(e, 0, o),
            this.values = Gs(t, 0, o * n)) : (this.times = e,
            this.values = t),
            this
        }
        clone() {
            let e = Gs(this.times, 0)
              , t = Gs(this.values, 0)
              , n = this.constructor
              , i = new n(this.name,e,t);
            return i.createInterpolant = this.createInterpolant,
            i
        }
    }
    ;
    Ki.prototype.TimeBufferType = Float32Array;
    Ki.prototype.ValueBufferType = Float32Array;
    Ki.prototype.DefaultInterpolation = _h;
    var Zs = class extends Ki {
    }
    ;
    Zs.prototype.ValueTypeName = "bool";
    Zs.prototype.ValueBufferType = Array;
    Zs.prototype.DefaultInterpolation = xh;
    Zs.prototype.InterpolantFactoryMethodLinear = void 0;
    Zs.prototype.InterpolantFactoryMethodSmooth = void 0;
    var Ph = class extends Ki {
    }
    ;
    Ph.prototype.ValueTypeName = "color";
    var Js = class extends Ki {
    }
    ;
    Js.prototype.ValueTypeName = "number";
    var Ap = class extends Ka {
        constructor(e, t, n, i) {
            super(e, t, n, i)
        }
        interpolate_(e, t, n, i) {
            let s = this.resultBuffer
              , o = this.sampleValues
              , a = this.valueSize
              , l = (n - t) / (i - t)
              , c = e * a;
            for (let u = c + a; c !== u; c += 4)
                Sn.slerpFlat(s, 0, o, c - a, o, c, l);
            return s
        }
    }
      , hr = class extends Ki {
        InterpolantFactoryMethodLinear(e) {
            return new Ap(this.times,this.values,this.getValueSize(),e)
        }
    }
    ;
    hr.prototype.ValueTypeName = "quaternion";
    hr.prototype.DefaultInterpolation = _h;
    hr.prototype.InterpolantFactoryMethodSmooth = void 0;
    var $s = class extends Ki {
    }
    ;
    $s.prototype.ValueTypeName = "string";
    $s.prototype.ValueBufferType = Array;
    $s.prototype.DefaultInterpolation = xh;
    $s.prototype.InterpolantFactoryMethodLinear = void 0;
    $s.prototype.InterpolantFactoryMethodSmooth = void 0;
    var fr = class extends Ki {
    }
    ;
    fr.prototype.ValueTypeName = "vector";
    var Bo = class {
        constructor(e, t=-1, n, i=h_) {
            this.name = e,
            this.tracks = n,
            this.duration = t,
            this.blendMode = i,
            this.uuid = ys(),
            this.duration < 0 && this.resetDuration()
        }
        static parse(e) {
            let t = []
              , n = e.tracks
              , i = 1 / (e.fps || 1);
            for (let o = 0, a = n.length; o !== a; ++o)
                t.push(qS(n[o]).scale(i));
            let s = new this(e.name,e.duration,t,e.blendMode);
            return s.uuid = e.uuid,
            s
        }
        static toJSON(e) {
            let t = []
              , n = e.tracks
              , i = {
                name: e.name,
                duration: e.duration,
                tracks: t,
                uuid: e.uuid,
                blendMode: e.blendMode
            };
            for (let s = 0, o = n.length; s !== o; ++s)
                t.push(Ki.toJSON(n[s]));
            return i
        }
        static CreateFromMorphTargetSequence(e, t, n, i) {
            let s = t.length
              , o = [];
            for (let a = 0; a < s; a++) {
                let l = []
                  , c = [];
                l.push((a + s - 1) % s, a, (a + 1) % s),
                c.push(0, 1, 0);
                let u = XS(l);
                l = rv(l, 1, u),
                c = rv(c, 1, u),
                !i && l[0] === 0 && (l.push(s),
                c.push(c[0])),
                o.push(new Js(".morphTargetInfluences[" + t[a].name + "]",l,c).scale(1 / n))
            }
            return new this(e,-1,o)
        }
        static findByName(e, t) {
            let n = e;
            if (!Array.isArray(e)) {
                let i = e;
                n = i.geometry && i.geometry.animations || i.animations
            }
            for (let i = 0; i < n.length; i++)
                if (n[i].name === t)
                    return n[i];
            return null
        }
        static CreateClipsFromMorphTargetSequences(e, t, n) {
            let i = {}
              , s = /^([\w-]*?)([\d]+)$/;
            for (let a = 0, l = e.length; a < l; a++) {
                let c = e[a]
                  , u = c.name.match(s);
                if (u && u.length > 1) {
                    let h = u[1]
                      , f = i[h];
                    f || (i[h] = f = []),
                    f.push(c)
                }
            }
            let o = [];
            for (let a in i)
                o.push(this.CreateFromMorphTargetSequence(a, i[a], t, n));
            return o
        }
        static parseAnimation(e, t) {
            if (!e)
                return console.error("THREE.AnimationClip: No animation in JSONLoader data."),
                null;
            let n = function(h, f, m, g, v) {
                if (m.length !== 0) {
                    let p = []
                      , d = [];
                    Lv(m, p, d, g),
                    p.length !== 0 && v.push(new h(f,p,d))
                }
            }
              , i = []
              , s = e.name || "default"
              , o = e.fps || 30
              , a = e.blendMode
              , l = e.length || -1
              , c = e.hierarchy || [];
            for (let h = 0; h < c.length; h++) {
                let f = c[h].keys;
                if (!(!f || f.length === 0))
                    if (f[0].morphTargets) {
                        let m = {}, g;
                        for (g = 0; g < f.length; g++)
                            if (f[g].morphTargets)
                                for (let v = 0; v < f[g].morphTargets.length; v++)
                                    m[f[g].morphTargets[v]] = -1;
                        for (let v in m) {
                            let p = []
                              , d = [];
                            for (let x = 0; x !== f[g].morphTargets.length; ++x) {
                                let y = f[g];
                                p.push(y.time),
                                d.push(y.morphTarget === v ? 1 : 0)
                            }
                            i.push(new Js(".morphTargetInfluence[" + v + "]",p,d))
                        }
                        l = m.length * o
                    } else {
                        let m = ".bones[" + t[h].name + "]";
                        n(fr, m + ".position", f, "pos", i),
                        n(hr, m + ".quaternion", f, "rot", i),
                        n(fr, m + ".scale", f, "scl", i)
                    }
            }
            return i.length === 0 ? null : new this(s,l,i,a)
        }
        resetDuration() {
            let e = this.tracks
              , t = 0;
            for (let n = 0, i = e.length; n !== i; ++n) {
                let s = this.tracks[n];
                t = Math.max(t, s.times[s.times.length - 1])
            }
            return this.duration = t,
            this
        }
        trim() {
            for (let e = 0; e < this.tracks.length; e++)
                this.tracks[e].trim(0, this.duration);
            return this
        }
        validate() {
            let e = !0;
            for (let t = 0; t < this.tracks.length; t++)
                e = e && this.tracks[t].validate();
            return e
        }
        optimize() {
            for (let e = 0; e < this.tracks.length; e++)
                this.tracks[e].optimize();
            return this
        }
        clone() {
            let e = [];
            for (let t = 0; t < this.tracks.length; t++)
                e.push(this.tracks[t].clone());
            return new this.constructor(this.name,this.duration,e,this.blendMode)
        }
        toJSON() {
            return this.constructor.toJSON(this)
        }
    }
    ;
    function jS(r) {
        switch (r.toLowerCase()) {
        case "scalar":
        case "double":
        case "float":
        case "number":
        case "integer":
            return Js;
        case "vector":
        case "vector2":
        case "vector3":
        case "vector4":
            return fr;
        case "color":
            return Ph;
        case "quaternion":
            return hr;
        case "bool":
        case "boolean":
            return Zs;
        case "string":
            return $s
        }
        throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + r)
    }
    function qS(r) {
        if (r.type === void 0)
            throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
        let e = jS(r.type);
        if (r.times === void 0) {
            let t = []
              , n = [];
            Lv(r.keys, t, n, "value"),
            r.times = t,
            r.values = n
        }
        return e.parse !== void 0 ? e.parse(r) : new e(r.name,r.times,r.values,r.interpolation)
    }
    var Lh = {
        enabled: !1,
        files: {},
        add: function(r, e) {
            this.enabled !== !1 && (this.files[r] = e)
        },
        get: function(r) {
            if (this.enabled !== !1)
                return this.files[r]
        },
        remove: function(r) {
            delete this.files[r]
        },
        clear: function() {
            this.files = {}
        }
    }
      , zc = class {
        constructor(e, t, n) {
            let i = this, s = !1, o = 0, a = 0, l, c = [];
            this.onStart = void 0,
            this.onLoad = e,
            this.onProgress = t,
            this.onError = n,
            this.itemStart = function(u) {
                a++,
                s === !1 && i.onStart !== void 0 && i.onStart(u, o, a),
                s = !0
            }
            ,
            this.itemEnd = function(u) {
                o++,
                i.onProgress !== void 0 && i.onProgress(u, o, a),
                o === a && (s = !1,
                i.onLoad !== void 0 && i.onLoad())
            }
            ,
            this.itemError = function(u) {
                i.onError !== void 0 && i.onError(u)
            }
            ,
            this.resolveURL = function(u) {
                return l ? l(u) : u
            }
            ,
            this.setURLModifier = function(u) {
                return l = u,
                this
            }
            ,
            this.addHandler = function(u, h) {
                return c.push(u, h),
                this
            }
            ,
            this.removeHandler = function(u) {
                let h = c.indexOf(u);
                return h !== -1 && c.splice(h, 2),
                this
            }
            ,
            this.getHandler = function(u) {
                for (let h = 0, f = c.length; h < f; h += 2) {
                    let m = c[h]
                      , g = c[h + 1];
                    if (m.global && (m.lastIndex = 0),
                    m.test(u))
                        return g
                }
                return null
            }
        }
    }
      , YS = new zc
      , Hn = class {
        constructor(e) {
            this.manager = e !== void 0 ? e : YS,
            this.crossOrigin = "anonymous",
            this.withCredentials = !1,
            this.path = "",
            this.resourcePath = "",
            this.requestHeader = {}
        }
        load() {}
        loadAsync(e, t) {
            let n = this;
            return new Promise(function(i, s) {
                n.load(e, i, t, s)
            }
            )
        }
        parse() {}
        setCrossOrigin(e) {
            return this.crossOrigin = e,
            this
        }
        setWithCredentials(e) {
            return this.withCredentials = e,
            this
        }
        setPath(e) {
            return this.path = e,
            this
        }
        setResourcePath(e) {
            return this.resourcePath = e,
            this
        }
        setRequestHeader(e) {
            return this.requestHeader = e,
            this
        }
    }
      , us = {}
      , Cp = class extends Error {
        constructor(e, t) {
            super(e),
            this.response = t
        }
    }
      , Ni = class extends Hn {
        constructor(e) {
            super(e)
        }
        load(e, t, n, i) {
            e === void 0 && (e = ""),
            this.path !== void 0 && (e = this.path + e),
            e = this.manager.resolveURL(e);
            let s = Lh.get(e);
            if (s !== void 0)
                return this.manager.itemStart(e),
                setTimeout(()=>{
                    t && t(s),
                    this.manager.itemEnd(e)
                }
                , 0),
                s;
            if (us[e] !== void 0) {
                us[e].push({
                    onLoad: t,
                    onProgress: n,
                    onError: i
                });
                return
            }
            us[e] = [],
            us[e].push({
                onLoad: t,
                onProgress: n,
                onError: i
            });
            let o = new Request(e,{
                headers: new Headers(this.requestHeader),
                credentials: this.withCredentials ? "include" : "same-origin"
            })
              , a = this.mimeType
              , l = this.responseType;
            fetch(o).then(c=>{
                if (c.status === 200 || c.status === 0) {
                    if (c.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."),
                    typeof ReadableStream > "u" || c.body === void 0 || c.body.getReader === void 0)
                        return c;
                    let u = us[e]
                      , h = c.body.getReader()
                      , f = c.headers.get("Content-Length") || c.headers.get("X-File-Size")
                      , m = f ? parseInt(f) : 0
                      , g = m !== 0
                      , v = 0
                      , p = new ReadableStream({
                        start(d) {
                            x();
                            function x() {
                                h.read().then(({done: y, value: _})=>{
                                    if (y)
                                        d.close();
                                    else {
                                        v += _.byteLength;
                                        let S = new ProgressEvent("progress",{
                                            lengthComputable: g,
                                            loaded: v,
                                            total: m
                                        });
                                        for (let N = 0, I = u.length; N < I; N++) {
                                            let O = u[N];
                                            O.onProgress && O.onProgress(S)
                                        }
                                        d.enqueue(_),
                                        x()
                                    }
                                }
                                )
                            }
                        }
                    });
                    return new Response(p)
                } else
                    throw new Cp(`fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`,c)
            }
            ).then(c=>{
                switch (l) {
                case "arraybuffer":
                    return c.arrayBuffer();
                case "blob":
                    return c.blob();
                case "document":
                    return c.text().then(u=>new DOMParser().parseFromString(u, a));
                case "json":
                    return c.json();
                default:
                    if (a === void 0)
                        return c.text();
                    {
                        let h = /charset="?([^;"\s]*)"?/i.exec(a)
                          , f = h && h[1] ? h[1].toLowerCase() : void 0
                          , m = new TextDecoder(f);
                        return c.arrayBuffer().then(g=>m.decode(g))
                    }
                }
            }
            ).then(c=>{
                Lh.add(e, c);
                let u = us[e];
                delete us[e];
                for (let h = 0, f = u.length; h < f; h++) {
                    let m = u[h];
                    m.onLoad && m.onLoad(c)
                }
            }
            ).catch(c=>{
                let u = us[e];
                if (u === void 0)
                    throw this.manager.itemError(e),
                    c;
                delete us[e];
                for (let h = 0, f = u.length; h < f; h++) {
                    let m = u[h];
                    m.onError && m.onError(c)
                }
                this.manager.itemError(e)
            }
            ).finally(()=>{
                this.manager.itemEnd(e)
            }
            ),
            this.manager.itemStart(e)
        }
        setResponseType(e) {
            return this.responseType = e,
            this
        }
        setMimeType(e) {
            return this.mimeType = e,
            this
        }
    }
    ;
    var Nh = class extends Hn {
        constructor(e) {
            super(e)
        }
        load(e, t, n, i) {
            this.path !== void 0 && (e = this.path + e),
            e = this.manager.resolveURL(e);
            let s = this
              , o = Lh.get(e);
            if (o !== void 0)
                return s.manager.itemStart(e),
                setTimeout(function() {
                    t && t(o),
                    s.manager.itemEnd(e)
                }, 0),
                o;
            let a = Nc("img");
            function l() {
                u(),
                Lh.add(e, this),
                t && t(this),
                s.manager.itemEnd(e)
            }
            function c(h) {
                u(),
                i && i(h),
                s.manager.itemError(e),
                s.manager.itemEnd(e)
            }
            function u() {
                a.removeEventListener("load", l, !1),
                a.removeEventListener("error", c, !1)
            }
            return a.addEventListener("load", l, !1),
            a.addEventListener("error", c, !1),
            e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (a.crossOrigin = this.crossOrigin),
            s.manager.itemStart(e),
            a.src = e,
            a
        }
    }
      , Dh = class extends Hn {
        constructor(e) {
            super(e)
        }
        load(e, t, n, i) {
            let s = new Oc
              , o = new Nh(this.manager);
            o.setCrossOrigin(this.crossOrigin),
            o.setPath(this.path);
            let a = 0;
            function l(c) {
                o.load(e[c], function(u) {
                    s.images[c] = u,
                    a++,
                    a === 6 && (s.needsUpdate = !0,
                    t && t(s))
                }, void 0, i)
            }
            for (let c = 0; c < e.length; ++c)
                l(c);
            return s
        }
    }
      , Oh = class extends Hn {
        constructor(e) {
            super(e)
        }
        load(e, t, n, i) {
            let s = this
              , o = new Xa
              , a = new Ni(this.manager);
            return a.setResponseType("arraybuffer"),
            a.setRequestHeader(this.requestHeader),
            a.setPath(this.path),
            a.setWithCredentials(s.withCredentials),
            a.load(e, function(l) {
                let c = s.parse(l);
                c && (c.image !== void 0 ? o.image = c.image : c.data !== void 0 && (o.image.width = c.width,
                o.image.height = c.height,
                o.image.data = c.data),
                o.wrapS = c.wrapS !== void 0 ? c.wrapS : Zt,
                o.wrapT = c.wrapT !== void 0 ? c.wrapT : Zt,
                o.magFilter = c.magFilter !== void 0 ? c.magFilter : bn,
                o.minFilter = c.minFilter !== void 0 ? c.minFilter : bn,
                o.anisotropy = c.anisotropy !== void 0 ? c.anisotropy : 1,
                c.colorSpace !== void 0 ? o.colorSpace = c.colorSpace : c.encoding !== void 0 && (o.encoding = c.encoding),
                c.flipY !== void 0 && (o.flipY = c.flipY),
                c.format !== void 0 && (o.format = c.format),
                c.type !== void 0 && (o.type = c.type),
                c.mipmaps !== void 0 && (o.mipmaps = c.mipmaps,
                o.minFilter = lr),
                c.mipmapCount === 1 && (o.minFilter = bn),
                c.generateMipmaps !== void 0 && (o.generateMipmaps = c.generateMipmaps),
                o.needsUpdate = !0,
                t && t(o, c))
            }, n, i),
            o
        }
    }
      , Zi = class extends Hn {
        constructor(e) {
            super(e)
        }
        load(e, t, n, i) {
            let s = new En
              , o = new Nh(this.manager);
            return o.setCrossOrigin(this.crossOrigin),
            o.setPath(this.path),
            o.load(e, function(a) {
                s.image = a,
                s.needsUpdate = !0,
                t !== void 0 && t(s)
            }, n, i),
            s
        }
    }
      , Za = class extends bt {
        constructor(e, t=1) {
            super(),
            this.isLight = !0,
            this.type = "Light",
            this.color = new $e(e),
            this.intensity = t
        }
        dispose() {}
        copy(e, t) {
            return super.copy(e, t),
            this.color.copy(e.color),
            this.intensity = e.intensity,
            this
        }
        toJSON(e) {
            let t = super.toJSON(e);
            return t.object.color = this.color.getHex(),
            t.object.intensity = this.intensity,
            this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()),
            this.distance !== void 0 && (t.object.distance = this.distance),
            this.angle !== void 0 && (t.object.angle = this.angle),
            this.decay !== void 0 && (t.object.decay = this.decay),
            this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
            this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
            t
        }
    }
    ;
    var Yd = new je
      , sv = new ue
      , ov = new ue
      , Hc = class {
        constructor(e) {
            this.camera = e,
            this.bias = 0,
            this.normalBias = 0,
            this.radius = 1,
            this.blurSamples = 8,
            this.mapSize = new Ie(512,512),
            this.map = null,
            this.mapPass = null,
            this.matrix = new je,
            this.autoUpdate = !0,
            this.needsUpdate = !1,
            this._frustum = new Fc,
            this._frameExtents = new Ie(1,1),
            this._viewportCount = 1,
            this._viewports = [new Lt(0,0,1,1)]
        }
        getViewportCount() {
            return this._viewportCount
        }
        getFrustum() {
            return this._frustum
        }
        updateMatrices(e) {
            let t = this.camera
              , n = this.matrix;
            sv.setFromMatrixPosition(e.matrixWorld),
            t.position.copy(sv),
            ov.setFromMatrixPosition(e.target.matrixWorld),
            t.lookAt(ov),
            t.updateMatrixWorld(),
            Yd.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
            this._frustum.setFromProjectionMatrix(Yd),
            n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
            n.multiply(Yd)
        }
        getViewport(e) {
            return this._viewports[e]
        }
        getFrameExtents() {
            return this._frameExtents
        }
        dispose() {
            this.map && this.map.dispose(),
            this.mapPass && this.mapPass.dispose()
        }
        copy(e) {
            return this.camera = e.camera.clone(),
            this.bias = e.bias,
            this.radius = e.radius,
            this.mapSize.copy(e.mapSize),
            this
        }
        clone() {
            return new this.constructor().copy(this)
        }
        toJSON() {
            let e = {};
            return this.bias !== 0 && (e.bias = this.bias),
            this.normalBias !== 0 && (e.normalBias = this.normalBias),
            this.radius !== 1 && (e.radius = this.radius),
            (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()),
            e.camera = this.camera.toJSON(!1).object,
            delete e.camera.matrix,
            e
        }
    }
      , Ip = class extends Hc {
        constructor() {
            super(new Qt(50,1,.5,500)),
            this.isSpotLightShadow = !0,
            this.focus = 1
        }
        updateMatrices(e) {
            let t = this.camera
              , n = Ga * 2 * e.angle * this.focus
              , i = this.mapSize.width / this.mapSize.height
              , s = e.distance || t.far;
            (n !== t.fov || i !== t.aspect || s !== t.far) && (t.fov = n,
            t.aspect = i,
            t.far = s,
            t.updateProjectionMatrix()),
            super.updateMatrices(e)
        }
        copy(e) {
            return super.copy(e),
            this.focus = e.focus,
            this
        }
    }
      , Ja = class extends Za {
        constructor(e, t, n=0, i=Math.PI / 3, s=0, o=2) {
            super(e, t),
            this.isSpotLight = !0,
            this.type = "SpotLight",
            this.position.copy(bt.DEFAULT_UP),
            this.updateMatrix(),
            this.target = new bt,
            this.distance = n,
            this.angle = i,
            this.penumbra = s,
            this.decay = o,
            this.map = null,
            this.shadow = new Ip
        }
        get power() {
            return this.intensity * Math.PI
        }
        set power(e) {
            this.intensity = e / Math.PI
        }
        dispose() {
            this.shadow.dispose()
        }
        copy(e, t) {
            return super.copy(e, t),
            this.distance = e.distance,
            this.angle = e.angle,
            this.penumbra = e.penumbra,
            this.decay = e.decay,
            this.target = e.target.clone(),
            this.shadow = e.shadow.clone(),
            this
        }
    }
      , av = new je
      , Mc = new ue
      , Kd = new ue
      , Rp = class extends Hc {
        constructor() {
            super(new Qt(90,1,.5,500)),
            this.isPointLightShadow = !0,
            this._frameExtents = new Ie(4,2),
            this._viewportCount = 6,
            this._viewports = [new Lt(2,1,1,1), new Lt(0,1,1,1), new Lt(3,1,1,1), new Lt(1,1,1,1), new Lt(3,0,1,1), new Lt(1,0,1,1)],
            this._cubeDirections = [new ue(1,0,0), new ue(-1,0,0), new ue(0,0,1), new ue(0,0,-1), new ue(0,1,0), new ue(0,-1,0)],
            this._cubeUps = [new ue(0,1,0), new ue(0,1,0), new ue(0,1,0), new ue(0,1,0), new ue(0,0,1), new ue(0,0,-1)]
        }
        updateMatrices(e, t=0) {
            let n = this.camera
              , i = this.matrix
              , s = e.distance || n.far;
            s !== n.far && (n.far = s,
            n.updateProjectionMatrix()),
            Mc.setFromMatrixPosition(e.matrixWorld),
            n.position.copy(Mc),
            Kd.copy(n.position),
            Kd.add(this._cubeDirections[t]),
            n.up.copy(this._cubeUps[t]),
            n.lookAt(Kd),
            n.updateMatrixWorld(),
            i.makeTranslation(-Mc.x, -Mc.y, -Mc.z),
            av.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
            this._frustum.setFromProjectionMatrix(av)
        }
    }
      , Go = class extends Za {
        constructor(e, t, n=0, i=2) {
            super(e, t),
            this.isPointLight = !0,
            this.type = "PointLight",
            this.distance = n,
            this.decay = i,
            this.shadow = new Rp
        }
        get power() {
            return this.intensity * 4 * Math.PI
        }
        set power(e) {
            this.intensity = e / (4 * Math.PI)
        }
        dispose() {
            this.shadow.dispose()
        }
        copy(e, t) {
            return super.copy(e, t),
            this.distance = e.distance,
            this.decay = e.decay,
            this.shadow = e.shadow.clone(),
            this
        }
    }
      , Pp = class extends Hc {
        constructor() {
            super(new Dr(-5,5,5,-5,.5,500)),
            this.isDirectionalLightShadow = !0
        }
    }
      , Fr = class extends Za {
        constructor(e, t) {
            super(e, t),
            this.isDirectionalLight = !0,
            this.type = "DirectionalLight",
            this.position.copy(bt.DEFAULT_UP),
            this.updateMatrix(),
            this.target = new bt,
            this.shadow = new Pp
        }
        dispose() {
            this.shadow.dispose()
        }
        copy(e) {
            return super.copy(e),
            this.target = e.target.clone(),
            this.shadow = e.shadow.clone(),
            this
        }
    }
      , kr = class extends Za {
        constructor(e, t) {
            super(e, t),
            this.isAmbientLight = !0,
            this.type = "AmbientLight"
        }
    }
    ;
    var Qs = class {
        static decodeText(e) {
            if (typeof TextDecoder < "u")
                return new TextDecoder().decode(e);
            let t = "";
            for (let n = 0, i = e.length; n < i; n++)
                t += String.fromCharCode(e[n]);
            try {
                return decodeURIComponent(escape(t))
            } catch {
                return t
            }
        }
        static extractUrlBase(e) {
            let t = e.lastIndexOf("/");
            return t === -1 ? "./" : e.slice(0, t + 1)
        }
        static resolveURL(e, t) {
            return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
            /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e)
        }
    }
    ;
    var Up = "\\[\\]\\.:\\/"
      , KS = new RegExp("[" + Up + "]","g")
      , Bp = "[^" + Up + "]"
      , ZS = "[^" + Up.replace("\\.", "") + "]"
      , JS = /((?:WC+[\/:])*)/.source.replace("WC", Bp)
      , $S = /(WCOD+)?/.source.replace("WCOD", ZS)
      , QS = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Bp)
      , ew = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Bp)
      , tw = new RegExp("^" + JS + $S + QS + ew + "$")
      , nw = ["material", "materials", "bones", "map"]
      , Lp = class {
        constructor(e, t, n) {
            let i = n || Nt.parseTrackName(t);
            this._targetGroup = e,
            this._bindings = e.subscribe_(t, i)
        }
        getValue(e, t) {
            this.bind();
            let n = this._targetGroup.nCachedObjects_
              , i = this._bindings[n];
            i !== void 0 && i.getValue(e, t)
        }
        setValue(e, t) {
            let n = this._bindings;
            for (let i = this._targetGroup.nCachedObjects_, s = n.length; i !== s; ++i)
                n[i].setValue(e, t)
        }
        bind() {
            let e = this._bindings;
            for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
                e[t].bind()
        }
        unbind() {
            let e = this._bindings;
            for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
                e[t].unbind()
        }
    }
      , Nt = class {
        constructor(e, t, n) {
            this.path = t,
            this.parsedPath = n || Nt.parseTrackName(t),
            this.node = Nt.findNode(e, this.parsedPath.nodeName),
            this.rootNode = e,
            this.getValue = this._getValue_unbound,
            this.setValue = this._setValue_unbound
        }
        static create(e, t, n) {
            return e && e.isAnimationObjectGroup ? new Nt.Composite(e,t,n) : new Nt(e,t,n)
        }
        static sanitizeNodeName(e) {
            return e.replace(/\s/g, "_").replace(KS, "")
        }
        static parseTrackName(e) {
            let t = tw.exec(e);
            if (t === null)
                throw new Error("PropertyBinding: Cannot parse trackName: " + e);
            let n = {
                nodeName: t[2],
                objectName: t[3],
                objectIndex: t[4],
                propertyName: t[5],
                propertyIndex: t[6]
            }
              , i = n.nodeName && n.nodeName.lastIndexOf(".");
            if (i !== void 0 && i !== -1) {
                let s = n.nodeName.substring(i + 1);
                nw.indexOf(s) !== -1 && (n.nodeName = n.nodeName.substring(0, i),
                n.objectName = s)
            }
            if (n.propertyName === null || n.propertyName.length === 0)
                throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
            return n
        }
        static findNode(e, t) {
            if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid)
                return e;
            if (e.skeleton) {
                let n = e.skeleton.getBoneByName(t);
                if (n !== void 0)
                    return n
            }
            if (e.children) {
                let n = function(s) {
                    for (let o = 0; o < s.length; o++) {
                        let a = s[o];
                        if (a.name === t || a.uuid === t)
                            return a;
                        let l = n(a.children);
                        if (l)
                            return l
                    }
                    return null
                }
                  , i = n(e.children);
                if (i)
                    return i
            }
            return null
        }
        _getValue_unavailable() {}
        _setValue_unavailable() {}
        _getValue_direct(e, t) {
            e[t] = this.targetObject[this.propertyName]
        }
        _getValue_array(e, t) {
            let n = this.resolvedProperty;
            for (let i = 0, s = n.length; i !== s; ++i)
                e[t++] = n[i]
        }
        _getValue_arrayElement(e, t) {
            e[t] = this.resolvedProperty[this.propertyIndex]
        }
        _getValue_toArray(e, t) {
            this.resolvedProperty.toArray(e, t)
        }
        _setValue_direct(e, t) {
            this.targetObject[this.propertyName] = e[t]
        }
        _setValue_direct_setNeedsUpdate(e, t) {
            this.targetObject[this.propertyName] = e[t],
            this.targetObject.needsUpdate = !0
        }
        _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
            this.targetObject[this.propertyName] = e[t],
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        _setValue_array(e, t) {
            let n = this.resolvedProperty;
            for (let i = 0, s = n.length; i !== s; ++i)
                n[i] = e[t++]
        }
        _setValue_array_setNeedsUpdate(e, t) {
            let n = this.resolvedProperty;
            for (let i = 0, s = n.length; i !== s; ++i)
                n[i] = e[t++];
            this.targetObject.needsUpdate = !0
        }
        _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
            let n = this.resolvedProperty;
            for (let i = 0, s = n.length; i !== s; ++i)
                n[i] = e[t++];
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        _setValue_arrayElement(e, t) {
            this.resolvedProperty[this.propertyIndex] = e[t]
        }
        _setValue_arrayElement_setNeedsUpdate(e, t) {
            this.resolvedProperty[this.propertyIndex] = e[t],
            this.targetObject.needsUpdate = !0
        }
        _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
            this.resolvedProperty[this.propertyIndex] = e[t],
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        _setValue_fromArray(e, t) {
            this.resolvedProperty.fromArray(e, t)
        }
        _setValue_fromArray_setNeedsUpdate(e, t) {
            this.resolvedProperty.fromArray(e, t),
            this.targetObject.needsUpdate = !0
        }
        _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
            this.resolvedProperty.fromArray(e, t),
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        _getValue_unbound(e, t) {
            this.bind(),
            this.getValue(e, t)
        }
        _setValue_unbound(e, t) {
            this.bind(),
            this.setValue(e, t)
        }
        bind() {
            let e = this.node
              , t = this.parsedPath
              , n = t.objectName
              , i = t.propertyName
              , s = t.propertyIndex;
            if (e || (e = Nt.findNode(this.rootNode, t.nodeName),
            this.node = e),
            this.getValue = this._getValue_unavailable,
            this.setValue = this._setValue_unavailable,
            !e) {
                console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
                return
            }
            if (n) {
                let c = t.objectIndex;
                switch (n) {
                case "materials":
                    if (!e.material) {
                        console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                        return
                    }
                    if (!e.material.materials) {
                        console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                        return
                    }
                    e = e.material.materials;
                    break;
                case "bones":
                    if (!e.skeleton) {
                        console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                        return
                    }
                    e = e.skeleton.bones;
                    for (let u = 0; u < e.length; u++)
                        if (e[u].name === c) {
                            c = u;
                            break
                        }
                    break;
                case "map":
                    if ("map"in e) {
                        e = e.map;
                        break
                    }
                    if (!e.material) {
                        console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                        return
                    }
                    if (!e.material.map) {
                        console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                        return
                    }
                    e = e.material.map;
                    break;
                default:
                    if (e[n] === void 0) {
                        console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                        return
                    }
                    e = e[n]
                }
                if (c !== void 0) {
                    if (e[c] === void 0) {
                        console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                        return
                    }
                    e = e[c]
                }
            }
            let o = e[i];
            if (o === void 0) {
                let c = t.nodeName;
                console.error("THREE.PropertyBinding: Trying to update property for track: " + c + "." + i + " but it wasn't found.", e);
                return
            }
            let a = this.Versioning.None;
            this.targetObject = e,
            e.needsUpdate !== void 0 ? a = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (a = this.Versioning.MatrixWorldNeedsUpdate);
            let l = this.BindingType.Direct;
            if (s !== void 0) {
                if (i === "morphTargetInfluences") {
                    if (!e.geometry) {
                        console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                        return
                    }
                    if (!e.geometry.morphAttributes) {
                        console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                        return
                    }
                    e.morphTargetDictionary[s] !== void 0 && (s = e.morphTargetDictionary[s])
                }
                l = this.BindingType.ArrayElement,
                this.resolvedProperty = o,
                this.propertyIndex = s
            } else
                o.fromArray !== void 0 && o.toArray !== void 0 ? (l = this.BindingType.HasFromToArray,
                this.resolvedProperty = o) : Array.isArray(o) ? (l = this.BindingType.EntireArray,
                this.resolvedProperty = o) : this.propertyName = i;
            this.getValue = this.GetterByBindingType[l],
            this.setValue = this.SetterByBindingTypeAndVersioning[l][a]
        }
        unbind() {
            this.node = null,
            this.getValue = this._getValue_unbound,
            this.setValue = this._setValue_unbound
        }
    }
    ;
    Nt.Composite = Lp;
    Nt.prototype.BindingType = {
        Direct: 0,
        EntireArray: 1,
        ArrayElement: 2,
        HasFromToArray: 3
    };
    Nt.prototype.Versioning = {
        None: 0,
        NeedsUpdate: 1,
        MatrixWorldNeedsUpdate: 2
    };
    Nt.prototype.GetterByBindingType = [Nt.prototype._getValue_direct, Nt.prototype._getValue_array, Nt.prototype._getValue_arrayElement, Nt.prototype._getValue_toArray];
    Nt.prototype.SetterByBindingTypeAndVersioning = [[Nt.prototype._setValue_direct, Nt.prototype._setValue_direct_setNeedsUpdate, Nt.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [Nt.prototype._setValue_array, Nt.prototype._setValue_array_setNeedsUpdate, Nt.prototype._setValue_array_setMatrixWorldNeedsUpdate], [Nt.prototype._setValue_arrayElement, Nt.prototype._setValue_arrayElement_setNeedsUpdate, Nt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [Nt.prototype._setValue_fromArray, Nt.prototype._setValue_fromArray_setNeedsUpdate, Nt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
    var KA = new Float32Array(1);
    var Fh = class {
        constructor(e, t, n=0, i=1 / 0) {
            this.ray = new Va(e,t),
            this.near = n,
            this.far = i,
            this.camera = null,
            this.layers = new Dc,
            this.params = {
                Mesh: {},
                Line: {
                    threshold: 1
                },
                LOD: {},
                Points: {
                    threshold: 1
                },
                Sprite: {}
            }
        }
        set(e, t) {
            this.ray.set(e, t)
        }
        setFromCamera(e, t) {
            t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
            this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(),
            this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t),
            this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld),
            this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type)
        }
        intersectObject(e, t=!0, n=[]) {
            return Np(e, this, n, t),
            n.sort(lv),
            n
        }
        intersectObjects(e, t=!0, n=[]) {
            for (let i = 0, s = e.length; i < s; i++)
                Np(e[i], this, n, t);
            return n.sort(lv),
            n
        }
    }
    ;
    function lv(r, e) {
        return r.distance - e.distance
    }
    function Np(r, e, t, n) {
        if (r.layers.test(e.layers) && r.raycast(e, t),
        n === !0) {
            let i = r.children;
            for (let s = 0, o = i.length; s < o; s++)
                Np(i[s], e, t, !0)
        }
    }
    var cv = new Ie
      , kh = class {
        constructor(e=new Ie(1 / 0,1 / 0), t=new Ie(-1 / 0,-1 / 0)) {
            this.isBox2 = !0,
            this.min = e,
            this.max = t
        }
        set(e, t) {
            return this.min.copy(e),
            this.max.copy(t),
            this
        }
        setFromPoints(e) {
            this.makeEmpty();
            for (let t = 0, n = e.length; t < n; t++)
                this.expandByPoint(e[t]);
            return this
        }
        setFromCenterAndSize(e, t) {
            let n = cv.copy(t).multiplyScalar(.5);
            return this.min.copy(e).sub(n),
            this.max.copy(e).add(n),
            this
        }
        clone() {
            return new this.constructor().copy(this)
        }
        copy(e) {
            return this.min.copy(e.min),
            this.max.copy(e.max),
            this
        }
        makeEmpty() {
            return this.min.x = this.min.y = 1 / 0,
            this.max.x = this.max.y = -1 / 0,
            this
        }
        isEmpty() {
            return this.max.x < this.min.x || this.max.y < this.min.y
        }
        getCenter(e) {
            return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
        }
        getSize(e) {
            return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
        }
        expandByPoint(e) {
            return this.min.min(e),
            this.max.max(e),
            this
        }
        expandByVector(e) {
            return this.min.sub(e),
            this.max.add(e),
            this
        }
        expandByScalar(e) {
            return this.min.addScalar(-e),
            this.max.addScalar(e),
            this
        }
        containsPoint(e) {
            return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y)
        }
        containsBox(e) {
            return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y
        }
        getParameter(e, t) {
            return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
        }
        intersectsBox(e) {
            return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y)
        }
        clampPoint(e, t) {
            return t.copy(e).clamp(this.min, this.max)
        }
        distanceToPoint(e) {
            return this.clampPoint(e, cv).distanceTo(e)
        }
        intersect(e) {
            return this.min.max(e.min),
            this.max.min(e.max),
            this.isEmpty() && this.makeEmpty(),
            this
        }
        union(e) {
            return this.min.min(e.min),
            this.max.max(e.max),
            this
        }
        translate(e) {
            return this.min.add(e),
            this.max.add(e),
            this
        }
        equals(e) {
            return e.min.equals(this.min) && e.max.equals(this.max)
        }
    }
    ;
    var Ur = class {
        constructor() {
            this.type = "ShapePath",
            this.color = new $e,
            this.subPaths = [],
            this.currentPath = null
        }
        moveTo(e, t) {
            return this.currentPath = new vs,
            this.subPaths.push(this.currentPath),
            this.currentPath.moveTo(e, t),
            this
        }
        lineTo(e, t) {
            return this.currentPath.lineTo(e, t),
            this
        }
        quadraticCurveTo(e, t, n, i) {
            return this.currentPath.quadraticCurveTo(e, t, n, i),
            this
        }
        bezierCurveTo(e, t, n, i, s, o) {
            return this.currentPath.bezierCurveTo(e, t, n, i, s, o),
            this
        }
        splineThru(e) {
            return this.currentPath.splineThru(e),
            this
        }
        toShapes(e) {
            function t(d) {
                let x = [];
                for (let y = 0, _ = d.length; y < _; y++) {
                    let S = d[y]
                      , N = new Hs;
                    N.curves = S.curves,
                    x.push(N)
                }
                return x
            }
            function n(d, x) {
                let y = x.length
                  , _ = !1;
                for (let S = y - 1, N = 0; N < y; S = N++) {
                    let I = x[S]
                      , O = x[N]
                      , M = O.x - I.x
                      , R = O.y - I.y;
                    if (Math.abs(R) > Number.EPSILON) {
                        if (R < 0 && (I = x[N],
                        M = -M,
                        O = x[S],
                        R = -R),
                        d.y < I.y || d.y > O.y)
                            continue;
                        if (d.y === I.y) {
                            if (d.x === I.x)
                                return !0
                        } else {
                            let q = R * (d.x - I.x) - M * (d.y - I.y);
                            if (q === 0)
                                return !0;
                            if (q < 0)
                                continue;
                            _ = !_
                        }
                    } else {
                        if (d.y !== I.y)
                            continue;
                        if (O.x <= d.x && d.x <= I.x || I.x <= d.x && d.x <= O.x)
                            return !0
                    }
                }
                return _
            }
            let i = ji.isClockWise
              , s = this.subPaths;
            if (s.length === 0)
                return [];
            let o, a, l, c = [];
            if (s.length === 1)
                return a = s[0],
                l = new Hs,
                l.curves = a.curves,
                c.push(l),
                c;
            let u = !i(s[0].getPoints());
            u = e ? !u : u;
            let h = [], f = [], m = [], g = 0, v;
            f[g] = void 0,
            m[g] = [];
            for (let d = 0, x = s.length; d < x; d++)
                a = s[d],
                v = a.getPoints(),
                o = i(v),
                o = e ? !o : o,
                o ? (!u && f[g] && g++,
                f[g] = {
                    s: new Hs,
                    p: v
                },
                f[g].s.curves = a.curves,
                u && g++,
                m[g] = []) : m[g].push({
                    h: a,
                    p: v[0]
                });
            if (!f[0])
                return t(s);
            if (f.length > 1) {
                let d = !1
                  , x = 0;
                for (let y = 0, _ = f.length; y < _; y++)
                    h[y] = [];
                for (let y = 0, _ = f.length; y < _; y++) {
                    let S = m[y];
                    for (let N = 0; N < S.length; N++) {
                        let I = S[N]
                          , O = !0;
                        for (let M = 0; M < f.length; M++)
                            n(I.p, f[M].p) && (y !== M && x++,
                            O ? (O = !1,
                            h[M].push(I)) : d = !0);
                        O && h[y].push(I)
                    }
                }
                x > 0 && d === !1 && (m = h)
            }
            let p;
            for (let d = 0, x = f.length; d < x; d++) {
                l = f[d].s,
                c.push(l),
                p = m[d];
                for (let y = 0, _ = p.length; y < _; y++)
                    l.holes.push(p[y].h)
            }
            return c
        }
    }
    ;
    typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{
        detail: {
            revision: Dp
        }
    }));
    typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = Dp);
    function Hh() {
        let r = document.createElement("canvas");
        document.body.appendChild(r);
        let e = {
            canvas: r,
            antialias: !0
        }
          , t = new Oo(e);
        t.outputColorSpace = di,
        t.setClearColor("#ffffff", 1),
        t.setSize(10, 10);
        let n = new Or
          , i = new kr(8947848);
        n.add(i);
        let s = new Fr(8947848);
        s.position.set(0, 0, 1),
        n.add(s);
        let o = new Qt(45,1,.1,1e3);
        o.position.set(0, 0, 1),
        o.up.set(0, 1, 0),
        o.lookAt(new ue(0,0,0)),
        n.add(o);
        let a = new Do(1,1)
          , l = new Ht(a,new sn({
            color: 13369344
        }));
        n.add(l),
        t.render(n, o);
        let c = t.getContext()
          , u = new Uint8Array(4);
        c.readPixels(5, 5, 1, 1, c.RGBA, c.UNSIGNED_BYTE, u),
        document.body.removeChild(r);
        let h = 50;
        return u[0] < h && u[1] < h && u[2] < h
    }
    var hn = {
        Phong: 1,
        Physical: 2
    };
    function Wh(r) {
        let e = 0
          , t = 0;
        for (let n = 0; n < r.MaterialCount(); n++) {
            let i = r.GetMaterial(n);
            i.type === nn.Phong ? e += 1 : i.type === nn.Physical && (t += 1)
        }
        return e >= t ? hn.Phong : hn.Physical
    }
    var Qa = class {
        Convert(e) {
            return null
        }
    }
      , el = class extends Qa {
        Convert(e) {
            return new $e().copyLinearToSRGB(e)
        }
    }
      , tl = class extends Qa {
        Convert(e) {
            return new $e().copySRGBToLinear(e)
        }
    }
    ;
    function Wc(r) {
        return Ii(r.r, r.g, r.b)
    }
    function Xn(r) {
        return new $e(r.r / 255,r.g / 255,r.b / 255)
    }
    function dr(r, e, t) {
        let n = new $t
          , i = r.attributes.position.array
          , s = r.attributes.position.itemSize || 3;
        for (let u = 0; u < i.length; u += s) {
            let h = i[u]
              , f = i[u + 1]
              , m = i[u + 2];
            n.AddVertex(new ze(h,f,m))
        }
        let o = r.attributes.color !== void 0;
        if (o) {
            let u = r.attributes.color.array
              , h = r.attributes.color.itemSize || 3;
            for (let f = 0; f < u.length; f += h) {
                let m = new $e(u[f],u[f + 1],u[f + 2]);
                t !== null && (m = t.Convert(m)),
                n.AddVertexColor(Wc(m))
            }
        }
        let a = r.attributes.normal !== void 0;
        if (a) {
            let u = r.attributes.normal.array
              , h = r.attributes.normal.itemSize || 3;
            for (let f = 0; f < u.length; f += h) {
                let m = u[f]
                  , g = u[f + 1]
                  , v = u[f + 2];
                n.AddNormal(new ze(m,g,v))
            }
        }
        let l = r.attributes.uv !== void 0;
        if (l) {
            let u = r.attributes.uv.array
              , h = r.attributes.uv.itemSize || 2;
            for (let f = 0; f < u.length; f += h) {
                let m = u[f]
                  , g = u[f + 1];
                n.AddTextureUV(new Pt(m,g))
            }
        }
        let c = null;
        if (r.index !== null)
            c = r.index.array;
        else {
            c = [];
            for (let u = 0; u < i.length / 3; u++)
                c.push(u)
        }
        for (let u = 0; u < c.length; u += 3) {
            let h = c[u]
              , f = c[u + 1]
              , m = c[u + 2]
              , g = new jt(h,f,m);
            o && g.SetVertexColors(h, f, m),
            a && g.SetNormals(h, f, m),
            l && g.SetTextureUVs(h, f, m),
            e !== null && g.SetMaterial(e),
            n.AddTriangle(g)
        }
        return n
    }
    function Xh(r) {
        r !== null && r.traverse(e=>{
            if (e.isMesh || e.isLineSegments) {
                if (Array.isArray(e.material))
                    for (let t of e.material)
                        t.dispose();
                else
                    e.material.dispose();
                e.userData = null,
                e.geometry.dispose()
            }
        }
        )
    }
    function jh(r, e) {
        function t(n, i) {
            for (let s of n)
                s.polygonOffset = i,
                s.polygonOffsetUnit = 1,
                s.polygonOffsetFactor = 1
        }
        t(r.material, e),
        r.userData.threeMaterials && t(r.userData.threeMaterials, e)
    }
    var eo = class {
        constructor(e) {
            this.scene = e,
            this.rootObject = null
        }
        IsEmpty() {
            return this.rootObject === null
        }
        SetRootObject(e) {
            this.rootObject !== null && this.Clear(),
            this.rootObject = e,
            this.scene.add(this.rootObject)
        }
        GetRootObject() {
            return this.rootObject
        }
        AddObject(e) {
            if (this.rootObject === null) {
                let t = new bt;
                this.SetRootObject(t)
            }
            this.rootObject.add(e)
        }
        Traverse(e) {
            this.rootObject !== null && this.rootObject.traverse(t=>{
                e(t)
            }
            )
        }
        UpdateWorldMatrix() {
            this.rootObject !== null && this.rootObject.updateWorldMatrix(!0, !0)
        }
        Clear() {
            Xh(this.rootObject),
            this.scene.remove(this.rootObject),
            this.rootObject = null
        }
    }
      , pr = class {
        constructor(e, t, n) {
            this.showEdges = e,
            this.edgeColor = t,
            this.edgeThreshold = n
        }
        Clone() {
            return new pr(this.showEdges,this.edgeColor.Clone(),this.edgeThreshold)
        }
    }
      , nl = class {
        constructor(e) {
            this.scene = e,
            this.mainModel = new eo(this.scene),
            this.edgeModel = new eo(this.scene),
            this.edgeSettings = new pr(!1,new rt(0,0,0),1)
        }
        SetMainObject(e) {
            this.mainModel.SetRootObject(e),
            this.edgeSettings.showEdges && this.GenerateEdgeModel()
        }
        UpdateWorldMatrix() {
            this.mainModel.UpdateWorldMatrix(),
            this.edgeModel.UpdateWorldMatrix()
        }
        SetEdgeSettings(e) {
            let t = !1;
            if (e.showEdges && (!this.edgeSettings.showEdges || this.edgeSettings.edgeThreshold !== e.edgeThreshold) && (t = !0),
            this.edgeSettings = e,
            !this.mainModel.IsEmpty())
                if (this.edgeSettings.showEdges)
                    if (t)
                        this.ClearEdgeModel(),
                        this.GenerateEdgeModel();
                    else {
                        let n = Xn(this.edgeSettings.edgeColor);
                        this.EnumerateEdges(i=>{
                            i.material.color = n
                        }
                        )
                    }
                else
                    this.ClearEdgeModel()
        }
        GenerateEdgeModel() {
            let e = Xn(this.edgeSettings.edgeColor);
            this.UpdateWorldMatrix(),
            this.EnumerateMeshes(t=>{
                jh(t, !0);
                let n = new Rh(t.geometry,this.edgeSettings.edgeThreshold)
                  , i = new qs(n,new pi({
                    color: e
                }));
                i.applyMatrix4(t.matrixWorld),
                i.userData = t.userData,
                i.visible = t.visible,
                this.edgeModel.AddObject(i)
            }
            )
        }
        GetBoundingBox(e) {
            let t = !1
              , n = new cr;
            return this.EnumerateMeshes(i=>{
                e(i.userData) && (n.union(new cr().setFromObject(i)),
                t = !0)
            }
            ),
            t ? n : null
        }
        GetBoundingSphere(e) {
            let t = this.GetBoundingBox(e);
            if (t === null)
                return null;
            let n = new Nr;
            return t.getBoundingSphere(n),
            n
        }
        Clear() {
            this.mainModel.Clear(),
            this.ClearEdgeModel()
        }
        ClearEdgeModel() {
            this.edgeModel.IsEmpty() || (this.EnumerateMeshes(e=>{
                jh(e, !1)
            }
            ),
            this.edgeModel.Clear())
        }
        EnumerateMeshes(e) {
            this.mainModel.Traverse(t=>{
                t.isMesh && e(t)
            }
            )
        }
        EnumerateEdges(e) {
            this.edgeModel.Traverse(t=>{
                t.isLineSegments && e(t)
            }
            )
        }
        GetMeshIntersectionUnderMouse(e, t, n, i) {
            if (this.mainModel.IsEmpty() || e.x < 0 || e.x > n || e.y < 0 || e.y > i)
                return null;
            let s = new Fh
              , o = new Ie;
            o.x = e.x / n * 2 - 1,
            o.y = -(e.y / i) * 2 + 1,
            s.setFromCamera(o, t);
            let a = s.intersectObject(this.mainModel.GetRootObject(), !0);
            for (let l = 0; l < a.length; l++) {
                let c = a[l];
                if (c.object.isMesh && c.object.visible)
                    return c
            }
            return null
        }
    }
    ;
    var Yt = {
        IntegerToString(r) {
            return r.toString()
        },
        StringToInteger(r) {
            return parseInt(r, 10)
        },
        NumberToString(r) {
            let e = 5;
            return r.toFixed(e)
        },
        StringToNumber(r) {
            return parseFloat(r)
        },
        ModelUrlsToString: function(r) {
            return r === null ? null : r.join(",")
        },
        StringToModelUrls: function(r) {
            return r === null || r.length === 0 ? null : r.split(",")
        },
        CameraToString: function(r) {
            return r === null ? null : [this.NumberToString(r.eye.x), this.NumberToString(r.eye.y), this.NumberToString(r.eye.z), this.NumberToString(r.center.x), this.NumberToString(r.center.y), this.NumberToString(r.center.z), this.NumberToString(r.up.x), this.NumberToString(r.up.y), this.NumberToString(r.up.z), this.NumberToString(r.fov)].join(",")
        },
        CameraModeToString: function(r) {
            return r === un.Perspective ? "perspective" : r === un.Orthographic ? "orthographic" : null
        },
        StringToCamera: function(r) {
            if (r === null || r.length === 0)
                return null;
            let e = r.split(",");
            if (e.length !== 9 && e.length !== 10)
                return null;
            let t = 45;
            return e.length >= 10 && (t = this.StringToNumber(e[9])),
            new Hi(new ze(this.StringToNumber(e[0]),this.StringToNumber(e[1]),this.StringToNumber(e[2])),new ze(this.StringToNumber(e[3]),this.StringToNumber(e[4]),this.StringToNumber(e[5])),new ze(this.StringToNumber(e[6]),this.StringToNumber(e[7]),this.StringToNumber(e[8])),t)
        },
        StringToCameraMode: function(r) {
            return r === "perspective" ? un.Perspective : r === "orthographic" ? un.Orthographic : null
        },
        RGBColorToString: function(r) {
            return r === null ? null : [this.IntegerToString(r.r), this.IntegerToString(r.g), this.IntegerToString(r.b)].join(",")
        },
        RGBAColorToString: function(r) {
            return r === null ? null : [this.IntegerToString(r.r), this.IntegerToString(r.g), this.IntegerToString(r.b), this.IntegerToString(r.a)].join(",")
        },
        StringToRGBColor: function(r) {
            if (r === null || r.length === 0)
                return null;
            let e = r.split(",");
            return e.length !== 3 ? null : new rt(this.StringToInteger(e[0]),this.StringToInteger(e[1]),this.StringToInteger(e[2]))
        },
        StringToRGBAColor: function(r) {
            if (r === null || r.length === 0)
                return null;
            let e = r.split(",");
            if (e.length !== 3 && e.length !== 4)
                return null;
            let t = new Nn(this.StringToInteger(e[0]),this.StringToInteger(e[1]),this.StringToInteger(e[2]),255);
            return e.length === 4 && (t.a = this.StringToInteger(e[3])),
            t
        },
        EnvironmentSettingsToString(r) {
            return r === null ? null : [r.environmentMapName, r.backgroundIsEnvMap ? "on" : "off"].join(",")
        },
        StringToEnvironmentSettings: function(r) {
            if (r === null || r.length === 0)
                return null;
            let e = r.split(",");
            return e.length !== 2 ? null : {
                environmentMapName: e[0],
                backgroundIsEnvMap: e[1] === "on"
            }
        },
        EdgeSettingsToString: function(r) {
            return r === null ? null : [r.showEdges ? "on" : "off", this.RGBColorToString(r.edgeColor), this.IntegerToString(r.edgeThreshold)].join(",")
        },
        StringToEdgeSettings: function(r) {
            if (r === null || r.length === 0)
                return null;
            let e = r.split(",");
            return e.length !== 5 ? null : new pr(e[0] === "on",new rt(this.StringToInteger(e[1]),this.StringToInteger(e[2]),this.StringToInteger(e[3])),this.StringToInteger(e[4]))
        }
    }
      , Xc = class {
        constructor(e) {
            this.separator = e,
            this.paramList = ""
        }
        AddModelUrls(e) {
            return this.AddUrlPart("model", Yt.ModelUrlsToString(e)),
            this
        }
        AddCamera(e) {
            return this.AddUrlPart("camera", Yt.CameraToString(e)),
            this
        }
        AddCameraMode(e) {
            return this.AddUrlPart("cameramode", Yt.CameraModeToString(e)),
            this
        }
        AddEnvironmentSettings(e) {
            return this.AddUrlPart("envsettings", Yt.EnvironmentSettingsToString(e)),
            this
        }
        AddBackgroundColor(e) {
            return this.AddUrlPart("backgroundcolor", Yt.RGBAColorToString(e)),
            this
        }
        AddDefaultColor(e) {
            return this.AddUrlPart("defaultcolor", Yt.RGBColorToString(e)),
            this
        }
        AddEdgeSettings(e) {
            return this.AddUrlPart("edgesettings", Yt.EdgeSettingsToString(e)),
            this
        }
        AddUrlPart(e, t) {
            e === null || t === null || (this.paramList.length > 0 && (this.paramList += this.separator),
            this.paramList += e + "=" + t)
        }
        GetParameterList() {
            return this.paramList
        }
    }
      , jc = class {
        constructor(e, t) {
            this.separator = t,
            this.paramList = e
        }
        GetModelUrls() {
            if (this.paramList.indexOf("=") === -1)
                return this.paramList.split(",");
            let e = this.GetKeywordParams("model");
            return Yt.StringToModelUrls(e)
        }
        GetCamera() {
            let e = this.GetKeywordParams("camera");
            return Yt.StringToCamera(e)
        }
        GetCameraMode() {
            let e = this.GetKeywordParams("cameramode");
            return Yt.StringToCameraMode(e)
        }
        GetEnvironmentSettings() {
            let e = this.GetKeywordParams("envsettings");
            return Yt.StringToEnvironmentSettings(e)
        }
        GetBackgroundColor() {
            let e = this.GetKeywordParams("backgroundcolor");
            return Yt.StringToRGBAColor(e)
        }
        GetDefaultColor() {
            let e = this.GetKeywordParams("defaultcolor");
            return Yt.StringToRGBColor(e)
        }
        GetEdgeSettings() {
            let e = this.GetKeywordParams("edgesettings");
            return Yt.StringToEdgeSettings(e)
        }
        GetKeywordParams(e) {
            if (this.paramList === null || this.paramList.length === 0)
                return null;
            let t = e + "="
              , n = this.paramList.split(this.separator);
            for (let i = 0; i < n.length; i++) {
                let s = n[i];
                if (s.startsWith(t))
                    return s.substring(t.length)
            }
            return null
        }
    }
    ;
    function il() {
        return new Xc("$")
    }
    function Br(r) {
        return new jc(r,"$")
    }
    function rl(r) {
        let e = il();
        return e.AddModelUrls(r),
        e.GetParameterList()
    }
    var Di = {
        Url: 1,
        File: 2,
        Decompressed: 3
    }
      , Dt = {
        Text: 1,
        Binary: 2
    };
    function pn(r) {
        let e = r
          , t = e.indexOf("?");
        t !== -1 && (e = e.substring(0, t));
        let n = e.lastIndexOf("/");
        return n === -1 && (n = e.lastIndexOf("\\")),
        n !== -1 && (e = e.substring(n + 1)),
        decodeURI(e)
    }
    function Oi(r) {
        let e = pn(r)
          , t = e.lastIndexOf(".");
        return t === -1 ? "" : e.substring(t + 1).toLowerCase()
    }
    function qh(r, e) {
        return new Promise((t,n)=>{
            let i = new XMLHttpRequest;
            i.open("GET", r, !0),
            i.onprogress = s=>{
                e(s.loaded, s.total)
            }
            ,
            i.onload = ()=>{
                i.status === 200 ? t(i.response) : n()
            }
            ,
            i.onerror = ()=>{
                n()
            }
            ,
            i.responseType = "arraybuffer",
            i.send(null)
        }
        )
    }
    function Yh(r, e) {
        return new Promise((t,n)=>{
            let i = new FileReader;
            i.onprogress = s=>{
                e(s.loaded, s.total)
            }
            ,
            i.onloadend = s=>{
                s.target.readyState === FileReader.DONE && t(s.target.result)
            }
            ,
            i.onerror = ()=>{
                n()
            }
            ,
            i.readAsArrayBuffer(r)
        }
        )
    }
    function to(r) {
        for (let e = 0; e < r.length; e++) {
            let t = r[e];
            if (t.search(/www\.dropbox\.com/u) !== -1) {
                t = t.replace("www.dropbox.com", "dl.dropbox.com");
                let n = t.indexOf("?");
                n !== -1 && (t = t.substring(0, n)),
                r[e] = t
            } else if (t.search(/github\.com/u) !== -1) {
                t = t.replace("github.com", "raw.githubusercontent.com"),
                t = t.replace("/blob", "");
                let n = t.indexOf("?");
                n !== -1 && (t = t.substring(0, n)),
                r[e] = t
            }
        }
    }
    function Kh(r) {
        let e = /^https?:\/\/\S+$/g;
        return r.match(e) !== null
    }
    var sl = class {
        constructor() {
            this.count = null,
            this.current = null,
            this.callbacks = null
        }
        Run(e, t) {
            this.count = e,
            this.current = 0,
            this.callbacks = t,
            e === 0 ? this.TaskReady() : this.RunOnce()
        }
        RunBatch(e, t, n) {
            let i = 0;
            e > 0 && (i = parseInt((e - 1) / t, 10) + 1),
            this.Run(i, {
                runTask: (s,o)=>{
                    let a = s * t
                      , l = Math.min((s + 1) * t, e) - 1;
                    n.runTask(a, l, o)
                }
                ,
                onReady: n.onReady
            })
        }
        RunOnce() {
            setTimeout(()=>{
                this.callbacks.runTask(this.current, this.TaskReady.bind(this))
            }
            , 0)
        }
        TaskReady() {
            this.current += 1,
            this.current < this.count ? this.RunOnce() : this.callbacks.onReady && this.callbacks.onReady()
        }
    }
    ;
    function _s(r) {
        setTimeout(()=>{
            r()
        }
        , 10)
    }
    function Zh(r, e) {
        new sl().Run(r, e)
    }
    function Jh(r, e, t) {
        new sl().RunBatch(r, e, t)
    }
    function $h(r) {
        function e(t) {
            t() && setTimeout(()=>{
                e(t)
            }
            , 10)
        }
        e(r)
    }
    var ol = class {
        constructor(e, t, n) {
            this.name = e,
            this.source = t,
            this.data = n
        }
    }
    ;
    function no(r) {
        let e = [];
        for (let t of r) {
            let n = pn(t);
            e.push(new ol(n,Di.Url,t))
        }
        return e
    }
    function al(r) {
        let e = [];
        for (let t of r) {
            let n = pn(t.name);
            e.push(new ol(n,Di.File,t))
        }
        return e
    }
    var Vo = class {
        constructor(e, t, n) {
            this.name = pn(e),
            this.extension = Oi(e),
            this.source = t,
            this.data = n,
            this.content = null
        }
        SetContent(e) {
            this.content = e
        }
    }
      , zo = class {
        constructor() {
            this.files = []
        }
        FillFromInputFiles(e) {
            this.files = [];
            for (let t of e) {
                let n = new Vo(t.name,t.source,t.data);
                this.files.push(n)
            }
        }
        ExtendFromFileList(e) {
            let t = e.GetFiles();
            for (let n = 0; n < t.length; n++) {
                let i = t[n];
                this.ContainsFileByPath(i.name) || this.files.push(i)
            }
        }
        GetFiles() {
            return this.files
        }
        GetContent(e) {
            Zh(this.files.length, {
                runTask: (t,n)=>{
                    e.onFileListProgress(t, this.files.length),
                    this.GetFileContent(this.files[t], {
                        onReady: n,
                        onProgress: e.onFileLoadProgress
                    })
                }
                ,
                onReady: e.onReady
            })
        }
        ContainsFileByPath(e) {
            return this.FindFileByPath(e) !== null
        }
        FindFileByPath(e) {
            let t = pn(e).toLowerCase();
            for (let n = 0; n < this.files.length; n++) {
                let i = this.files[n];
                if (i.name.toLowerCase() === t)
                    return i
            }
            return null
        }
        IsOnlyUrlSource() {
            if (this.files.length === 0)
                return !1;
            for (let e = 0; e < this.files.length; e++) {
                let t = this.files[e];
                if (t.source !== Di.Url && t.source !== Di.Decompressed)
                    return !1
            }
            return !0
        }
        AddFile(e) {
            this.files.push(e)
        }
        GetFileContent(e, t) {
            if (e.content !== null) {
                t.onReady();
                return
            }
            let n = null;
            if (e.source === Di.Url)
                n = qh(e.data, t.onProgress);
            else if (e.source === Di.File)
                n = Yh(e.data, t.onProgress);
            else {
                t.onReady();
                return
            }
            n.then(i=>{
                e.SetContent(i)
            }
            ).catch(()=>{}
            ).finally(()=>{
                t.onReady()
            }
            )
        }
    }
    ;
    var ri = class {
        constructor(e, t, n, i) {
            this.x = e,
            this.y = t,
            this.z = n,
            this.w = i
        }
    }
    ;
    function Nv(r, e) {
        return Ot(r.x, e.x) && Ot(r.y, e.y) && Ot(r.z, e.z) && Ot(r.w, e.w)
    }
    function ll(r) {
        return new ri(r[0],r[1],r[2],r[3])
    }
    function Qh(r, e) {
        let t = e / 2
          , n = Math.sin(t);
        return new ri(r.x * n,r.y * n,r.z * n,Math.cos(t))
    }
    function Dv(r, e, t, n) {
        let i = Math.cos(r / 2)
          , s = Math.cos(e / 2)
          , o = Math.cos(t / 2)
          , a = Math.sin(r / 2)
          , l = Math.sin(e / 2)
          , c = Math.sin(t / 2)
          , u = new ri(0,0,0,1);
        if (n === "XYZ")
            u.x = a * s * o + i * l * c,
            u.y = i * l * o - a * s * c,
            u.z = i * s * c + a * l * o,
            u.w = i * s * o - a * l * c;
        else if (n === "YXZ")
            u.x = a * s * o + i * l * c,
            u.y = i * l * o - a * s * c,
            u.z = i * s * c - a * l * o,
            u.w = i * s * o + a * l * c;
        else if (n === "ZXY")
            u.x = a * s * o - i * l * c,
            u.y = i * l * o + a * s * c,
            u.z = i * s * c + a * l * o,
            u.w = i * s * o - a * l * c;
        else if (n === "ZYX")
            u.x = a * s * o - i * l * c,
            u.y = i * l * o + a * s * c,
            u.z = i * s * c - a * l * o,
            u.w = i * s * o + a * l * c;
        else if (n === "YZX")
            u.x = a * s * o + i * l * c,
            u.y = i * l * o + a * s * c,
            u.z = i * s * c - a * l * o,
            u.w = i * s * o - a * l * c;
        else if (n === "XZY")
            u.x = a * s * o - i * l * c,
            u.y = i * l * o - a * s * c,
            u.z = i * s * c + a * l * o,
            u.w = i * s * o + a * l * c;
        else
            return null;
        return u
    }
    var Fi = class {
        constructor(e, t, n, i) {
            this.x = e,
            this.y = t,
            this.z = n,
            this.w = i
        }
        Clone() {
            return new Fi(this.x,this.y,this.z,this.w)
        }
    }
    ;
    var Ut = class {
        constructor(e) {
            this.matrix = null,
            e != null && (this.matrix = e)
        }
        IsValid() {
            return this.matrix !== null
        }
        Set(e) {
            return this.matrix = e,
            this
        }
        Get() {
            return this.matrix
        }
        Clone() {
            let e = [this.matrix[0], this.matrix[1], this.matrix[2], this.matrix[3], this.matrix[4], this.matrix[5], this.matrix[6], this.matrix[7], this.matrix[8], this.matrix[9], this.matrix[10], this.matrix[11], this.matrix[12], this.matrix[13], this.matrix[14], this.matrix[15]];
            return new Ut(e)
        }
        CreateIdentity() {
            return this.matrix = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
            this
        }
        IsIdentity() {
            let e = new Ut().CreateIdentity().Get();
            for (let t = 0; t < 16; t++)
                if (!Ot(this.matrix[t], e[t]))
                    return !1;
            return !0
        }
        CreateTranslation(e, t, n) {
            return this.matrix = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, e, t, n, 1],
            this
        }
        CreateRotation(e, t, n, i) {
            let s = e + e
              , o = t + t
              , a = n + n
              , l = e * s
              , c = e * o
              , u = e * a
              , h = t * o
              , f = t * a
              , m = n * a
              , g = i * s
              , v = i * o
              , p = i * a;
            return this.matrix = [1 - (h + m), c + p, u - v, 0, c - p, 1 - (l + m), f + g, 0, u + v, f - g, 1 - (l + h), 0, 0, 0, 0, 1],
            this
        }
        CreateRotationAxisAngle(e, t) {
            let n = Qh(e, t);
            return this.CreateRotation(n.x, n.y, n.z, n.w)
        }
        CreateScale(e, t, n) {
            return this.matrix = [e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1],
            this
        }
        ComposeTRS(e, t, n) {
            let i = e.x
              , s = e.y
              , o = e.z
              , a = t.x
              , l = t.y
              , c = t.z
              , u = t.w
              , h = n.x
              , f = n.y
              , m = n.z
              , g = a + a
              , v = l + l
              , p = c + c
              , d = a * g
              , x = a * v
              , y = a * p
              , _ = l * v
              , S = l * p
              , N = c * p
              , I = u * g
              , O = u * v
              , M = u * p;
            return this.matrix = [(1 - (_ + N)) * h, (x + M) * h, (y - O) * h, 0, (x - M) * f, (1 - (d + N)) * f, (S + I) * f, 0, (y + O) * m, (S - I) * m, (1 - (d + _)) * m, 0, i, s, o, 1],
            this
        }
        DecomposeTRS() {
            let e = new ze(this.matrix[12],this.matrix[13],this.matrix[14])
              , t = ca(this.matrix[0], this.matrix[1], this.matrix[2])
              , n = ca(this.matrix[4], this.matrix[5], this.matrix[6])
              , i = ca(this.matrix[8], this.matrix[9], this.matrix[10])
              , s = this.Determinant();
            ts(s) && (t *= -1);
            let o = new ze(t,n,i)
              , a = this.matrix[0] / t
              , l = this.matrix[4] / n
              , c = this.matrix[8] / i
              , u = this.matrix[1] / t
              , h = this.matrix[5] / n
              , f = this.matrix[9] / i
              , m = this.matrix[2] / t
              , g = this.matrix[6] / n
              , v = this.matrix[10] / i
              , p = null
              , d = a + h + v;
            if (d > 0) {
                let x = Math.sqrt(d + 1) * 2;
                p = new ri((g - f) / x,(c - m) / x,(u - l) / x,.25 * x)
            } else if (a > h && a > v) {
                let x = Math.sqrt(1 + a - h - v) * 2;
                p = new ri(.25 * x,(l + u) / x,(c + m) / x,(g - f) / x)
            } else if (h > v) {
                let x = Math.sqrt(1 + h - a - v) * 2;
                p = new ri((l + u) / x,.25 * x,(f + g) / x,(c - m) / x)
            } else {
                let x = Math.sqrt(1 + v - a - h) * 2;
                p = new ri((c + m) / x,(f + g) / x,.25 * x,(u - l) / x)
            }
            return {
                translation: e,
                rotation: p,
                scale: o
            }
        }
        Determinant() {
            let e = this.matrix[0]
              , t = this.matrix[1]
              , n = this.matrix[2]
              , i = this.matrix[3]
              , s = this.matrix[4]
              , o = this.matrix[5]
              , a = this.matrix[6]
              , l = this.matrix[7]
              , c = this.matrix[8]
              , u = this.matrix[9]
              , h = this.matrix[10]
              , f = this.matrix[11]
              , m = this.matrix[12]
              , g = this.matrix[13]
              , v = this.matrix[14]
              , p = this.matrix[15]
              , d = e * o - t * s
              , x = e * a - n * s
              , y = e * l - i * s
              , _ = t * a - n * o
              , S = t * l - i * o
              , N = n * l - i * a
              , I = c * g - u * m
              , O = c * v - h * m
              , M = c * p - f * m
              , R = u * v - h * g
              , q = u * p - f * g
              , k = h * p - f * v;
            return d * k - x * q + y * R + _ * M - S * O + N * I
        }
        Invert() {
            let e = this.matrix[0]
              , t = this.matrix[1]
              , n = this.matrix[2]
              , i = this.matrix[3]
              , s = this.matrix[4]
              , o = this.matrix[5]
              , a = this.matrix[6]
              , l = this.matrix[7]
              , c = this.matrix[8]
              , u = this.matrix[9]
              , h = this.matrix[10]
              , f = this.matrix[11]
              , m = this.matrix[12]
              , g = this.matrix[13]
              , v = this.matrix[14]
              , p = this.matrix[15]
              , d = e * o - t * s
              , x = e * a - n * s
              , y = e * l - i * s
              , _ = t * a - n * o
              , S = t * l - i * o
              , N = n * l - i * a
              , I = c * g - u * m
              , O = c * v - h * m
              , M = c * p - f * m
              , R = u * v - h * g
              , q = u * p - f * g
              , k = h * p - f * v
              , B = d * k - x * q + y * R + _ * M - S * O + N * I;
            if (Ot(B, 0))
                return null;
            let P = [(o * k - a * q + l * R) / B, (n * q - t * k - i * R) / B, (g * N - v * S + p * _) / B, (h * S - u * N - f * _) / B, (a * M - s * k - l * O) / B, (e * k - n * M + i * O) / B, (v * y - m * N - p * x) / B, (c * N - h * y + f * x) / B, (s * q - o * M + l * I) / B, (t * M - e * q - i * I) / B, (m * S - g * y + p * d) / B, (u * y - c * S - f * d) / B, (o * O - s * R - a * I) / B, (e * R - t * O + n * I) / B, (g * x - m * _ - v * d) / B, (c * _ - u * x + h * d) / B];
            return new Ut(P)
        }
        Transpose() {
            let e = [this.matrix[0], this.matrix[4], this.matrix[8], this.matrix[12], this.matrix[1], this.matrix[5], this.matrix[9], this.matrix[13], this.matrix[2], this.matrix[6], this.matrix[10], this.matrix[14], this.matrix[3], this.matrix[7], this.matrix[11], this.matrix[15]];
            return new Ut(e)
        }
        InvertTranspose() {
            let e = this.Invert();
            return e === null ? null : e.Transpose()
        }
        MultiplyVector(e) {
            let t = e.x
              , n = e.y
              , i = e.z
              , s = e.w
              , o = this.matrix[0]
              , a = this.matrix[1]
              , l = this.matrix[2]
              , c = this.matrix[3]
              , u = this.matrix[4]
              , h = this.matrix[5]
              , f = this.matrix[6]
              , m = this.matrix[7]
              , g = this.matrix[8]
              , v = this.matrix[9]
              , p = this.matrix[10]
              , d = this.matrix[11]
              , x = this.matrix[12]
              , y = this.matrix[13]
              , _ = this.matrix[14]
              , S = this.matrix[15];
            return new Fi(t * o + n * u + i * g + s * x,t * a + n * h + i * v + s * y,t * l + n * f + i * p + s * _,t * c + n * m + i * d + s * S)
        }
        MultiplyMatrix(e) {
            let t = this.matrix[0]
              , n = this.matrix[1]
              , i = this.matrix[2]
              , s = this.matrix[3]
              , o = this.matrix[4]
              , a = this.matrix[5]
              , l = this.matrix[6]
              , c = this.matrix[7]
              , u = this.matrix[8]
              , h = this.matrix[9]
              , f = this.matrix[10]
              , m = this.matrix[11]
              , g = this.matrix[12]
              , v = this.matrix[13]
              , p = this.matrix[14]
              , d = this.matrix[15]
              , x = e.matrix[0]
              , y = e.matrix[1]
              , _ = e.matrix[2]
              , S = e.matrix[3]
              , N = e.matrix[4]
              , I = e.matrix[5]
              , O = e.matrix[6]
              , M = e.matrix[7]
              , R = e.matrix[8]
              , q = e.matrix[9]
              , k = e.matrix[10]
              , B = e.matrix[11]
              , P = e.matrix[12]
              , C = e.matrix[13]
              , L = e.matrix[14]
              , F = e.matrix[15]
              , U = [t * x + n * N + i * R + s * P, t * y + n * I + i * q + s * C, t * _ + n * O + i * k + s * L, t * S + n * M + i * B + s * F, o * x + a * N + l * R + c * P, o * y + a * I + l * q + c * C, o * _ + a * O + l * k + c * L, o * S + a * M + l * B + c * F, u * x + h * N + f * R + m * P, u * y + h * I + f * q + m * C, u * _ + h * O + f * k + m * L, u * S + h * M + f * B + m * F, g * x + v * N + p * R + d * P, g * y + v * I + p * q + d * C, g * _ + v * O + p * k + d * L, g * S + v * M + p * B + d * F];
            return new Ut(U)
        }
    }
    ;
    function ef(r, e) {
        let t = r.Get()
          , n = e.Get();
        for (let i = 0; i < 16; i++)
            if (!Ot(t[i], n[i]))
                return !1;
        return !0
    }
    var en = class {
        constructor(e) {
            e != null ? this.matrix = e : (this.matrix = new Ut,
            this.matrix.CreateIdentity())
        }
        SetMatrix(e) {
            return this.matrix = e,
            this
        }
        GetMatrix() {
            return this.matrix
        }
        IsIdentity() {
            return this.matrix.IsIdentity()
        }
        AppendMatrix(e) {
            return this.matrix = this.matrix.MultiplyMatrix(e),
            this
        }
        Append(e) {
            return this.AppendMatrix(e.GetMatrix()),
            this
        }
        TransformCoord3D(e) {
            let t = new Fi(e.x,e.y,e.z,1)
              , n = this.matrix.MultiplyVector(t);
            return new ze(n.x,n.y,n.z)
        }
        Clone() {
            let e = this.matrix.Clone();
            return new en(e)
        }
    }
    ;
    function Ov(r, e) {
        return ef(r.GetMatrix(), e.GetMatrix())
    }
    var Gr = {
        Empty: 0,
        TriangleMesh: 1
    };
    function io(r) {
        return r.TriangleCount() > 0 ? Gr.TriangleMesh : Gr.Empty
    }
    function Ho(r, e, t) {
        let n = vn(e, r)
          , i = vn(t, r)
          , s = nr(n, i);
        return s.Normalize(),
        s
    }
    function Vr(r, e) {
        if (!e.IsIdentity()) {
            for (let t = 0; t < r.VertexCount(); t++) {
                let n = r.GetVertex(t)
                  , i = e.TransformCoord3D(n);
                n.x = i.x,
                n.y = i.y,
                n.z = i.z
            }
            if (r.NormalCount() > 0) {
                let t = e.GetMatrix().InvertTranspose();
                if (t !== null) {
                    let n = new en(t);
                    for (let i = 0; i < r.NormalCount(); i++) {
                        let s = r.GetNormal(i)
                          , o = n.TransformCoord3D(s);
                        s.x = o.x,
                        s.y = o.y,
                        s.z = o.z
                    }
                }
            }
        }
    }
    function tf(r) {
        for (let e = 0; e < r.TriangleCount(); e++) {
            let t = r.GetTriangle(e)
              , n = t.v1;
            t.v1 = t.v2,
            t.v2 = n
        }
    }
    var Wo = class {
        constructor(e, t) {
            this.min = e,
            this.max = t
        }
        GetMin() {
            return this.min
        }
        GetMax() {
            return this.max
        }
        GetCenter() {
            return new ze((this.min.x + this.max.x) / 2,(this.min.y + this.max.y) / 2,(this.min.z + this.max.z) / 2)
        }
    }
      , cl = class {
        constructor() {
            this.box = new Wo(new ze(1 / 0,1 / 0,1 / 0),new ze(-1 / 0,-1 / 0,-1 / 0)),
            this.isValid = !1
        }
        GetBox() {
            return this.isValid ? this.box : null
        }
        AddPoint(e) {
            this.box.min.x = Math.min(this.box.min.x, e.x),
            this.box.min.y = Math.min(this.box.min.y, e.y),
            this.box.min.z = Math.min(this.box.min.z, e.z),
            this.box.max.x = Math.max(this.box.max.x, e.x),
            this.box.max.y = Math.max(this.box.max.y, e.y),
            this.box.max.z = Math.max(this.box.max.z, e.z),
            this.isValid = !0
        }
    }
    ;
    var Xo = class {
        constructor(e, t) {
            this.boundingBox = e,
            this.level = t,
            this.pointItems = [],
            this.childNodes = []
        }
        AddPoint(e, t, n) {
            let i = this.FindNodeForPoint(e);
            if (i === null || i.FindPointDirectly(e) !== null)
                return !1;
            if (i.pointItems.length < n.maxPointsPerNode || i.level >= n.maxTreeDepth)
                return i.AddPointDirectly(e, t),
                !0;
            {
                i.CreateChildNodes();
                let s = i.pointItems;
                i.pointItems = [];
                for (let o = 0; o < s.length; o++) {
                    let a = s[o];
                    if (!i.AddPoint(a.point, a.data, n))
                        return !1
                }
                return i.AddPoint(e, t, n)
            }
        }
        FindPoint(e) {
            let t = this.FindNodeForPoint(e);
            return t === null ? null : t.FindPointDirectly(e)
        }
        AddPointDirectly(e, t) {
            this.pointItems.push({
                point: e,
                data: t
            })
        }
        FindPointDirectly(e) {
            for (let t = 0; t < this.pointItems.length; t++) {
                let n = this.pointItems[t];
                if (Ci(e, n.point))
                    return n.data
            }
            return null
        }
        FindNodeForPoint(e) {
            if (!this.IsPointInBounds(e))
                return null;
            if (this.childNodes.length === 0)
                return this;
            for (let t = 0; t < this.childNodes.length; t++) {
                let i = this.childNodes[t].FindNodeForPoint(e);
                if (i !== null)
                    return i
            }
            return null
        }
        CreateChildNodes() {
            function e(a, l, c, u, h, f, m) {
                let g = new Wo(new ze(l,c,u),new ze(l + h,c + f,u + m));
                a.childNodes.push(new Xo(g,a.level + 1))
            }
            let t = this.boundingBox.min
              , n = this.boundingBox.GetCenter()
              , i = (this.boundingBox.max.x - this.boundingBox.min.x) / 2
              , s = (this.boundingBox.max.y - this.boundingBox.min.y) / 2
              , o = (this.boundingBox.max.z - this.boundingBox.min.z) / 2;
            e(this, t.x, t.y, t.z, i, s, o),
            e(this, n.x, t.y, t.z, i, s, o),
            e(this, t.x, n.y, t.z, i, s, o),
            e(this, n.x, n.y, t.z, i, s, o),
            e(this, t.x, t.y, n.z, i, s, o),
            e(this, n.x, t.y, n.z, i, s, o),
            e(this, t.x, n.y, n.z, i, s, o),
            e(this, n.x, n.y, n.z, i, s, o)
        }
        IsPointInBounds(e) {
            return la(e.x, this.boundingBox.min.x) && la(e.y, this.boundingBox.min.y) && la(e.z, this.boundingBox.min.z) && aa(e.x, this.boundingBox.max.x) && aa(e.y, this.boundingBox.max.y) && aa(e.z, this.boundingBox.max.z)
        }
    }
      , ul = class {
        constructor(e, t) {
            this.options = {
                maxPointsPerNode: 10,
                maxTreeDepth: 10
            },
            t !== void 0 && (t.maxPointsPerNode !== void 0 && (this.options.maxPointsPerNode = t.maxPointsPerNode),
            t.maxTreeDepth !== void 0 && (this.options.maxTreeDepth = t.maxTreeDepth)),
            this.rootNode = new Xo(e,0)
        }
        AddPoint(e, t) {
            return this.rootNode.AddPoint(e, t, this.options)
        }
        FindPoint(e) {
            return this.rootNode.FindPoint(e)
        }
    }
    ;
    var gi = class {
        constructor(e, t) {
            this.nodeId = e,
            this.meshIndex = t
        }
        IsEqual(e) {
            return this.nodeId === e.nodeId && this.meshIndex === e.meshIndex
        }
        GetKey() {
            return this.nodeId.toString() + ":" + this.meshIndex.toString()
        }
    }
      , Ts = class extends Rr {
        constructor(e, t, n) {
            super(),
            this.id = e,
            this.node = t,
            this.mesh = n
        }
        GetId() {
            return this.id
        }
        GetTransformation() {
            return this.node.GetWorldTransformation()
        }
        GetMesh() {
            return this.mesh
        }
        VertexCount() {
            return this.mesh.VertexCount()
        }
        VertexColorCount() {
            return this.mesh.VertexColorCount()
        }
        NormalCount() {
            return this.mesh.NormalCount()
        }
        TextureUVCount() {
            return this.mesh.TextureUVCount()
        }
        TriangleCount() {
            return this.mesh.TriangleCount()
        }
        EnumerateVertices(e) {
            let t = this.node.GetWorldTransformation();
            t.IsIdentity() ? this.mesh.EnumerateVertices(e) : this.mesh.EnumerateVertices(n=>{
                let i = t.TransformCoord3D(n);
                e(i)
            }
            )
        }
        EnumerateTriangleVertexIndices(e) {
            this.mesh.EnumerateTriangleVertexIndices(e)
        }
        EnumerateTriangleVertices(e) {
            let t = this.node.GetWorldTransformation();
            t.IsIdentity() ? this.mesh.EnumerateTriangleVertices(e) : this.mesh.EnumerateTriangleVertices((n,i,s)=>{
                let o = t.TransformCoord3D(n)
                  , a = t.TransformCoord3D(i)
                  , l = t.TransformCoord3D(s);
                e(o, a, l)
            }
            )
        }
        PropertyGroupCount() {
            return this.mesh.PropertyGroupCount()
        }
        AddPropertyGroup(e) {
            return this.mesh.AddPropertyGroup(e)
        }
        GetPropertyGroup(e) {
            return this.mesh.GetPropertyGroup(e)
        }
        GetTransformedMesh() {
            let e = this.node.GetWorldTransformation()
              , t = this.mesh.Clone();
            return Vr(t, e),
            t
        }
    }
    ;
    var Gp = class {
        constructor() {
            this.nextId = 0
        }
        GenerateId() {
            let e = this.nextId;
            return this.nextId += 1,
            e
        }
    }
      , Fn = class {
        constructor() {
            this.name = "",
            this.parent = null,
            this.transformation = new en,
            this.childNodes = [],
            this.meshIndices = [],
            this.idGenerator = new Gp,
            this.id = this.idGenerator.GenerateId()
        }
        IsEmpty() {
            return this.childNodes.length === 0 && this.meshIndices.length === 0
        }
        IsMeshNode() {
            return this.childNodes.length === 0 && this.meshIndices.length === 1
        }
        GetId() {
            return this.id
        }
        GetName() {
            return this.name
        }
        SetName(e) {
            this.name = e
        }
        HasParent() {
            return this.parent !== null
        }
        GetParent() {
            return this.parent
        }
        GetTransformation() {
            return this.transformation
        }
        GetWorldTransformation() {
            let e = this.transformation.Clone()
              , t = this.parent;
            for (; t !== null; )
                e.Append(t.transformation),
                t = t.parent;
            return e
        }
        SetTransformation(e) {
            this.transformation = e
        }
        AddChildNode(e) {
            return e.parent = this,
            e.idGenerator = this.idGenerator,
            e.id = e.idGenerator.GenerateId(),
            this.childNodes.push(e),
            this.childNodes.length - 1
        }
        RemoveChildNode(e) {
            e.parent = null;
            let t = this.childNodes.indexOf(e);
            this.childNodes.splice(t, 1)
        }
        GetChildNodes() {
            return this.childNodes
        }
        ChildNodeCount() {
            return this.childNodes.length
        }
        GetChildNode(e) {
            return this.childNodes[e]
        }
        AddMeshIndex(e) {
            return this.meshIndices.push(e),
            this.meshIndices.length - 1
        }
        MeshIndexCount() {
            return this.meshIndices.length
        }
        GetMeshIndex(e) {
            return this.meshIndices[e]
        }
        GetMeshIndices() {
            return this.meshIndices
        }
        Enumerate(e) {
            e(this);
            for (let t of this.childNodes)
                t.Enumerate(e)
        }
        EnumerateChildren(e) {
            for (let t of this.childNodes)
                e(t),
                t.EnumerateChildren(e)
        }
        EnumerateMeshIndices(e) {
            for (let t of this.meshIndices)
                e(t);
            for (let t of this.childNodes)
                t.EnumerateMeshIndices(e)
        }
    }
    ;
    var zr = class extends Rr {
        constructor() {
            super(),
            this.root = new Fn,
            this.materials = [],
            this.meshes = []
        }
        GetRootNode() {
            return this.root
        }
        NodeCount() {
            let e = 0;
            return this.root.Enumerate(t=>{
                e += 1
            }
            ),
            e - 1
        }
        MaterialCount() {
            return this.materials.length
        }
        MeshCount() {
            return this.meshes.length
        }
        MeshInstanceCount() {
            let e = 0;
            return this.root.Enumerate(t=>{
                e += t.MeshIndexCount()
            }
            ),
            e
        }
        VertexCount() {
            let e = 0;
            return this.EnumerateMeshInstances(t=>{
                e += t.VertexCount()
            }
            ),
            e
        }
        VertexColorCount() {
            let e = 0;
            return this.EnumerateMeshInstances(t=>{
                e += t.VertexColorCount()
            }
            ),
            e
        }
        NormalCount() {
            let e = 0;
            return this.EnumerateMeshInstances(t=>{
                e += t.NormalCount()
            }
            ),
            e
        }
        TextureUVCount() {
            let e = 0;
            return this.EnumerateMeshInstances(t=>{
                e += t.TextureUVCount()
            }
            ),
            e
        }
        TriangleCount() {
            let e = 0;
            return this.EnumerateMeshInstances(t=>{
                e += t.TriangleCount()
            }
            ),
            e
        }
        AddMaterial(e) {
            return this.materials.push(e),
            this.materials.length - 1
        }
        GetMaterial(e) {
            return this.materials[e]
        }
        AddMesh(e) {
            return this.meshes.push(e),
            this.meshes.length - 1
        }
        AddMeshToRootNode(e) {
            let t = this.AddMesh(e);
            return this.root.AddMeshIndex(t),
            t
        }
        RemoveMesh(e) {
            this.meshes.splice(e, 1),
            this.root.Enumerate(t=>{
                for (let n = 0; n < t.meshIndices.length; n++)
                    t.meshIndices[n] === e ? (t.meshIndices.splice(n, 1),
                    n -= 1) : t.meshIndices[n] > e && (t.meshIndices[n] -= 1)
            }
            )
        }
        GetMesh(e) {
            return this.meshes[e]
        }
        GetMeshInstance(e) {
            let t = null;
            if (this.root.Enumerate(o=>{
                o.GetId() === e.nodeId && (t = o)
            }
            ),
            t === null || t.GetMeshIndices().indexOf(e.meshIndex) === -1)
                return null;
            let i = this.GetMesh(e.meshIndex)
              , s = new gi(t.GetId(),e.meshIndex);
            return new Ts(s,t,i)
        }
        EnumerateMeshes(e) {
            for (let t of this.meshes)
                e(t)
        }
        EnumerateMeshInstances(e) {
            this.root.Enumerate(t=>{
                for (let n of t.GetMeshIndices()) {
                    let i = new gi(t.GetId(),n)
                      , s = this.GetMesh(n)
                      , o = new Ts(i,t,s);
                    e(o)
                }
            }
            )
        }
        EnumerateTransformedMeshInstances(e) {
            this.EnumerateMeshInstances(t=>{
                let n = t.GetTransformedMesh();
                e(n)
            }
            )
        }
        EnumerateVertices(e) {
            this.EnumerateMeshInstances(t=>{
                t.EnumerateVertices(e)
            }
            )
        }
        EnumerateTriangleVertexIndices(e) {
            this.EnumerateMeshInstances(t=>{
                t.EnumerateTriangleVertexIndices(e)
            }
            )
        }
        EnumerateTriangleVertices(e) {
            this.EnumerateMeshInstances(t=>{
                t.EnumerateTriangleVertices(e)
            }
            )
        }
    }
    ;
    var qc = class {
        constructor() {
            this.edges = [],
            this.triangles = []
        }
    }
      , Yc = class {
        constructor(e, t) {
            this.vertex1 = e,
            this.vertex2 = t,
            this.triangles = []
        }
    }
      , Kc = class {
        constructor(e, t) {
            this.edge = e,
            this.reversed = t
        }
    }
      , Zc = class {
        constructor() {
            this.triEdge1 = null,
            this.triEdge2 = null,
            this.triEdge3 = null
        }
    }
      , hl = class {
        constructor() {
            this.vertices = [],
            this.edges = [],
            this.triangleEdges = [],
            this.triangles = [],
            this.edgeStartToEndVertexMap = new Map
        }
        AddVertex() {
            return this.vertices.push(new qc),
            this.vertices.length - 1
        }
        AddTriangle(e, t, n) {
            function i(c, u, h) {
                c[u].triangles.push(h)
            }
            function s(c, u, h, f) {
                let m = c[h]
                  , g = u[f];
                m.edges.push(g.edge)
            }
            function o(c, u, h, f) {
                let m = u[h];
                c[m.edge].triangles.push(f)
            }
            let a = this.triangles.length
              , l = new Zc;
            l.triEdge1 = this.AddTriangleEdge(e, t),
            l.triEdge2 = this.AddTriangleEdge(t, n),
            l.triEdge3 = this.AddTriangleEdge(n, e),
            i(this.vertices, e, a),
            i(this.vertices, t, a),
            i(this.vertices, n, a),
            s(this.vertices, this.triangleEdges, e, l.triEdge1),
            s(this.vertices, this.triangleEdges, t, l.triEdge2),
            s(this.vertices, this.triangleEdges, n, l.triEdge3),
            o(this.edges, this.triangleEdges, l.triEdge1, a),
            o(this.edges, this.triangleEdges, l.triEdge2, a),
            o(this.edges, this.triangleEdges, l.triEdge3, a),
            this.triangles.push(l)
        }
        AddTriangleEdge(e, t) {
            let n = e
              , i = t
              , s = !1;
            t < e && (n = t,
            i = e,
            s = !0);
            let o = this.AddEdge(n, i);
            return this.triangleEdges.push(new Kc(o,s)),
            this.triangleEdges.length - 1
        }
        AddEdge(e, t) {
            this.edgeStartToEndVertexMap.has(e) || this.edgeStartToEndVertexMap.set(e, []);
            let n = this.edgeStartToEndVertexMap.get(e);
            for (let s = 0; s < n.length; s++) {
                let o = n[s];
                if (o.endVertex === t)
                    return o.edgeIndex
            }
            let i = this.edges.length;
            return n.push({
                endVertex: t,
                edgeIndex: i
            }),
            this.edges.push(new Yc(e,t)),
            i
        }
    }
    ;
    function fl(r) {
        let e = !0;
        return r.EnumerateMeshInstances(t=>{
            io(t) !== Gr.Empty && (e = !1)
        }
        ),
        e
    }
    function Jc(r) {
        let e = new cl;
        return r.EnumerateVertices(t=>{
            e.AddPoint(t)
        }
        ),
        e.GetBox()
    }
    function Vp(r) {
        function e(s, o, a) {
            let l = o.FindPoint(s);
            return l === null && (l = a.AddVertex(),
            o.AddPoint(s, l)),
            l
        }
        let t = Jc(r)
          , n = new ul(t)
          , i = new hl;
        return r.EnumerateTriangleVertices((s,o,a)=>{
            let l = e(s, n, i)
              , c = e(o, n, i)
              , u = e(a, n, i);
            i.AddTriangle(l, c, u)
        }
        ),
        i
    }
    function $c(r) {
        function e(t, n, i) {
            let s = t.triangles[n]
              , o = t.triangleEdges[s.triEdge1]
              , a = t.triangleEdges[s.triEdge2]
              , l = t.triangleEdges[s.triEdge3];
            return o.edge === i ? o.reversed : a.edge === i ? a.reversed : l.edge === i ? l.reversed : null
        }
        if (r instanceof zr) {
            let t = !0;
            return r.EnumerateMeshInstances(n=>{
                t && (t = $c(n))
            }
            ),
            t
        } else {
            let t = Vp(r);
            for (let n = 0; n < t.edges.length; n++) {
                let i = t.edges[n];
                if (i.triangles.length !== 2)
                    return !1;
                let s = e(t, i.triangles[0], n)
                  , o = e(t, i.triangles[1], n);
                if (s === null || o === null || s === o)
                    return !1
            }
            return !0
        }
    }
    function nf(r) {
        for (let e = 0; e < r.MaterialCount(); e++) {
            let t = r.GetMaterial(e);
            if (t.isDefault && !t.vertexColors)
                return !0
        }
        return !1
    }
    function Qc(r, e) {
        for (let t = 0; t < r.MaterialCount(); t++) {
            let n = r.GetMaterial(t);
            n.isDefault && (n.color = e)
        }
    }
    function Hr(r) {
        return r != null
    }
    function Fv(r, e) {
        return r ?? e
    }
    function dl(r, e) {
        if (Hr(r))
            for (let t of Object.keys(r))
                Hr(r[t]) && (e[t] = r[t])
    }
    function rf(r) {
        return Object.keys(r).length === 0
    }
    function sf(r) {
        return r.replace(/</g, "&lt;").replace(/>/g, "&gt;")
    }
    var dt = {
        Text: 1,
        Integer: 2,
        Number: 3,
        Boolean: 4,
        Percent: 5,
        Color: 6
    }
      , yt = class {
        constructor(e, t, n) {
            this.type = e,
            this.name = t,
            this.value = n
        }
        Clone() {
            return this.type === dt.Color ? new yt(this.type,this.name,this.value.Clone()) : new yt(this.type,this.name,this.value)
        }
    }
      , kn = class {
        constructor(e) {
            this.name = e,
            this.properties = []
        }
        PropertyCount() {
            return this.properties.length
        }
        AddProperty(e) {
            this.properties.push(e)
        }
        GetProperty(e) {
            return this.properties[e]
        }
        Clone() {
            let e = new kn(this.name);
            for (let t of this.properties)
                e.AddProperty(t.Clone());
            return e
        }
    }
    ;
    function jo(r) {
        return r.type === dt.Text ? sf(r.value) : r.type === dt.Integer ? r.value.toLocaleString() : r.type === dt.Number ? r.value.toLocaleString(void 0, {
            minimumFractionDigits: 2,
            maximumFractionDigits: 2
        }) : r.type === dt.Boolean ? r.value ? "True" : "False" : r.type === dt.Percent ? parseInt(r.value * 100, 10).toString() + "%" : r.type === dt.Color ? "#" + ci(r.value) : null
    }
    var zp = class {
        constructor(e) {
            this.params = {
                getDefaultMaterialColor: ()=>new rt(0,0,0)
            },
            dl(e, this.params),
            this.defaultMaterialIndex = null
        }
        Finalize(e) {
            this.Reset(),
            this.FinalizeMeshes(e),
            this.FinalizeMaterials(e),
            this.FinalizeNodes(e)
        }
        FinalizeMaterials(e) {
            if (e.VertexColorCount() === 0)
                return;
            let t = new Map;
            for (let n = 0; n < e.MeshCount(); n++) {
                let i = e.GetMesh(n);
                for (let s = 0; s < i.TriangleCount(); s++) {
                    let o = i.GetTriangle(s)
                      , a = o.HasVertexColors();
                    t.has(o.mat) ? a || t.set(o.mat, !1) : t.set(o.mat, a)
                }
            }
            for (let[n,i] of t) {
                let s = e.GetMaterial(n);
                s.vertexColors = i
            }
        }
        FinalizeMeshes(e) {
            for (let t = 0; t < e.MeshCount(); t++) {
                let n = e.GetMesh(t);
                if (io(n) === Gr.Empty) {
                    e.RemoveMesh(t),
                    t = t - 1;
                    continue
                }
                this.FinalizeMesh(e, n)
            }
        }
        FinalizeMesh(e, t) {
            function n(s) {
                function o(c, u, h, f, m) {
                    function g(x, y) {
                        for (let _ = 0; _ < x.length; _++) {
                            let S = x[_];
                            if (Ci(S, y))
                                return !0
                        }
                        return !1
                    }
                    let v = []
                      , p = m.get(h);
                    for (let x = 0; x < p.length; x++) {
                        let y = p[x]
                          , _ = c.GetTriangle(y);
                        if (u.curve === _.curve) {
                            let S = f[y];
                            g(v, S) || v.push(S)
                        }
                    }
                    let d = new ze(0,0,0);
                    for (let x = 0; x < v.length; x++)
                        d = Gu(d, v[x]);
                    return d.MultiplyScalar(1 / v.length),
                    d.Normalize(),
                    c.AddNormal(d)
                }
                let a = []
                  , l = new Map;
                for (let c = 0; c < s.VertexCount(); c++)
                    l.set(c, []);
                for (let c = 0; c < s.TriangleCount(); c++) {
                    let u = s.GetTriangle(c)
                      , h = s.GetVertex(u.v0)
                      , f = s.GetVertex(u.v1)
                      , m = s.GetVertex(u.v2)
                      , g = Ho(h, f, m);
                    a.push(g),
                    l.get(u.v0).push(c),
                    l.get(u.v1).push(c),
                    l.get(u.v2).push(c)
                }
                for (let c = 0; c < s.TriangleCount(); c++) {
                    let u = s.GetTriangle(c);
                    if (!u.HasNormals()) {
                        let h = o(s, u, u.v0, a, l)
                          , f = o(s, u, u.v1, a, l)
                          , m = o(s, u, u.v2, a, l);
                        u.SetNormals(h, f, m)
                    }
                }
            }
            let i = {
                calculateCurveNormals: !1
            };
            for (let s = 0; s < t.TriangleCount(); s++) {
                let o = t.GetTriangle(s);
                this.FinalizeTriangle(t, o, i),
                o.mat === null && (o.mat = this.GetDefaultMaterialIndex(e))
            }
            i.calculateCurveNormals && n(t)
        }
        FinalizeTriangle(e, t, n) {
            if (!t.HasNormals())
                if (t.curve === null || t.curve === 0) {
                    let i = e.GetVertex(t.v0)
                      , s = e.GetVertex(t.v1)
                      , o = e.GetVertex(t.v2)
                      , a = Ho(i, s, o)
                      , l = e.AddNormal(a);
                    t.SetNormals(l, l, l)
                } else
                    n.calculateCurveNormals = !0;
            t.curve === null && (t.curve = 0)
        }
        FinalizeNodes(e) {
            let t = e.GetRootNode()
              , n = [];
            t.EnumerateChildren(i=>{
                i.IsEmpty() && n.push(i)
            }
            );
            for (let i = 0; i < n.length; i++) {
                let s = n[i]
                  , o = s.GetParent();
                o !== null && (o.RemoveChildNode(s),
                o.IsEmpty() && n.push(o))
            }
        }
        GetDefaultMaterialIndex(e) {
            if (this.defaultMaterialIndex === null) {
                let t = this.params.getDefaultMaterialColor()
                  , n = new xn;
                n.color = t,
                n.isDefault = !0,
                this.defaultMaterialIndex = e.AddMaterial(n)
            }
            return this.defaultMaterialIndex
        }
        Reset() {
            this.defaultMaterialIndex = null
        }
    }
    ;
    function of(r, e) {
        new zp(e).Finalize(r)
    }
    function kv(r) {
        function e(s) {
            return s != null
        }
        function t(s) {
            return !(!e(s) || isNaN(s))
        }
        function n(s, o) {
            return !(!t(s) || s < 0 || s >= o)
        }
        function i(s, o) {
            function a(l, c, u) {
                return !(!n(u.v0, c.VertexCount()) || !n(u.v1, c.VertexCount()) || !n(u.v2, c.VertexCount()) || u.HasVertexColors() && (!n(u.c0, c.VertexColorCount()) || !n(u.c1, c.VertexColorCount()) || !n(u.c2, c.VertexColorCount())) || !n(u.n0, c.NormalCount()) || !n(u.n1, c.NormalCount()) || !n(u.n2, c.NormalCount()) || u.HasTextureUVs() && (!n(u.u0, c.TextureUVCount()) || !n(u.u1, c.TextureUVCount()) || !n(u.u2, c.TextureUVCount())) || !n(u.mat, l.MaterialCount()) || !t(u.curve))
            }
            for (let l = 0; l < o.VertexCount(); l++) {
                let c = o.GetVertex(l);
                if (!t(c.x) || !t(c.y) || !t(c.z))
                    return !1
            }
            for (let l = 0; l < o.VertexColorCount(); l++) {
                let c = o.GetVertexColor(l);
                if (!t(c.r) || !t(c.g) || !t(c.b))
                    return !1
            }
            for (let l = 0; l < o.NormalCount(); l++) {
                let c = o.GetNormal(l);
                if (!t(c.x) || !t(c.y) || !t(c.z))
                    return !1
            }
            for (let l = 0; l < o.TextureUVCount(); l++) {
                let c = o.GetTextureUV(l);
                if (!t(c.x) || !t(c.y))
                    return !1
            }
            for (let l = 0; l < o.TriangleCount(); l++) {
                let c = o.GetTriangle(l);
                if (!a(s, o, c))
                    return !1
            }
            return !0
        }
        for (let s = 0; s < r.MeshCount(); s++) {
            let o = r.GetMesh(s);
            if (!i(r, o))
                return !1
        }
        return !0
    }
    var Kt = class {
        constructor() {
            this.name = null,
            this.extension = null,
            this.callbacks = null,
            this.model = null,
            this.error = null,
            this.message = null
        }
        Import(e, t, n, i) {
            this.Clear(),
            this.name = e,
            this.extension = t,
            this.callbacks = i,
            this.model = new zr,
            this.error = !1,
            this.message = null,
            this.ResetContent(),
            this.ImportContent(n, ()=>{
                this.CreateResult(i)
            }
            )
        }
        Clear() {
            this.name = null,
            this.extension = null,
            this.callbacks = null,
            this.model = null,
            this.error = null,
            this.message = null,
            this.ClearContent()
        }
        CreateResult(e) {
            if (this.error) {
                e.onError(),
                e.onComplete();
                return
            }
            if (fl(this.model)) {
                this.SetError("The model doesn't contain any meshes."),
                e.onError(),
                e.onComplete();
                return
            }
            of(this.model, {
                getDefaultMaterialColor: this.callbacks.getDefaultMaterialColor
            }),
            e.onSuccess(),
            e.onComplete()
        }
        CanImportExtension(e) {
            return !1
        }
        GetUpDirection() {
            return lt.Z
        }
        ClearContent() {}
        ResetContent() {}
        ImportContent(e, t) {}
        GetModel() {
            return this.model
        }
        SetError(e) {
            this.error = !0,
            e != null && (this.message = e)
        }
        WasError() {
            return this.error
        }
        GetErrorMessage() {
            return this.message
        }
    }
    ;
    function bs(r, e, t) {
        let n = r.substring(e)
          , i = n.indexOf(t);
        return i !== -1 && (n = n.substring(0, i)),
        n.trim()
    }
    function mr(r, e) {
        if (e !== null) {
            let t = r.indexOf(e);
            t !== -1 && (r = r.substring(0, t).trim())
        }
        return r.split(/\s+/u)
    }
    function yi(r, e) {
        function t(s, o) {
            let a = s.trim();
            a.length > 0 && o(a)
        }
        let n = 0
          , i = r.indexOf(`
`, n);
        for (; i !== -1; )
            t(r.substring(n, i), e),
            n = i + 1,
            i = r.indexOf(`
`, n);
        t(r.substring(n), e)
    }
    function Hp(r) {
        return (r & r - 1) === 0
    }
    function Uv(r) {
        if (Hp(r))
            return r;
        let e = Math.pow(2, Math.ceil(Math.log(r) / Math.log(2)));
        return parseInt(e, 10)
    }
    function xi(r) {
        r.transparent = !1,
        oa(r.opacity, 1) && (r.transparent = !0)
    }
    var vi = class {
        constructor(e) {
            this.model = e,
            this.colorToMaterialIndex = new Map
        }
        GetMaterialIndex(e, t, n, i) {
            let s = Cn(e) + Cn(t) + Cn(n)
              , o = i != null;
            if (o && (s += Cn(i)),
            this.colorToMaterialIndex.has(s))
                return this.colorToMaterialIndex.get(s);
            {
                let a = new xn;
                a.name = s.toUpperCase(),
                a.color = new rt(e,t,n),
                o && i < 255 && (a.opacity = i / 255,
                xi(a));
                let l = this.model.AddMaterial(a);
                return this.colorToMaterialIndex.set(s, l),
                l
            }
        }
    }
    ;
    var pl = class extends Kt {
        constructor() {
            super(),
            this.rhino = null
        }
        CanImportExtension(e) {
            return e === "3dm"
        }
        GetUpDirection() {
            return lt.Z
        }
        ClearContent() {
            this.instanceIdToObject = null,
            this.instanceIdToDefinition = null
        }
        ResetContent() {
            this.instanceIdToObject = new Map,
            this.instanceIdToDefinition = new Map
        }
        ImportContent(e, t) {
            this.rhino === null ? Ar("loaders/rhino3dm.min.js").then(()=>{
                rhino3dm().then(n=>{
                    this.rhino = n,
                    this.ImportRhinoContent(e),
                    t()
                }
                )
            }
            ).catch(()=>{
                this.SetError("Failed to load rhino3dm."),
                t()
            }
            ) : (this.ImportRhinoContent(e),
            t())
        }
        ImportRhinoContent(e) {
            let t = this.rhino.File3dm.fromByteArray(e);
            if (t === null) {
                this.SetError("Failed to read Rhino file.");
                return
            }
            this.ImportRhinoDocument(t),
            fl(this.model) && this.SetError("The model doesn't contain any 3D meshes. Try to save the model while you are in shaded view in Rhino.")
        }
        ImportRhinoDocument(e) {
            this.InitRhinoInstances(e),
            this.ImportRhinoUserStrings(e),
            this.ImportRhinoGeometry(e)
        }
        InitRhinoInstances(e) {
            let t = e.objects();
            for (let i = 0; i < t.count; i++) {
                let s = t.get(i)
                  , o = s.attributes();
                o.isInstanceDefinitionObject && this.instanceIdToObject.set(o.id, s)
            }
            let n = e.instanceDefinitions();
            for (let i = 0; i < n.count(); i++) {
                let s = n.get(i);
                this.instanceIdToDefinition.set(s.id, s)
            }
        }
        ImportRhinoUserStrings(e) {
            let t = e.strings();
            if (t.count() > 0) {
                let n = new kn("Document user texts");
                for (let i = 0; i < t.count(); i++) {
                    let s = t.get(i);
                    n.AddProperty(new yt(dt.Text,s[0],s[1]))
                }
                this.model.AddPropertyGroup(n)
            }
        }
        ImportRhinoGeometry(e) {
            let t = e.objects();
            for (let n = 0; n < t.count; n++) {
                let i = t.get(n);
                this.ImportRhinoGeometryObject(e, i, [])
            }
        }
        ImportRhinoGeometryObject(e, t, n) {
            let i = t.geometry()
              , s = t.attributes()
              , o = i.objectType;
            if (s.isInstanceDefinitionObject && n.length === 0)
                return;
            let a = null
              , l = !1;
            if (o === this.rhino.ObjectType.Mesh)
                a = i,
                l = !1;
            else if (o === this.rhino.ObjectType.Extrusion)
                a = i.getMesh(this.rhino.MeshType.Any),
                l = !0;
            else if (o === this.rhino.ObjectType.Brep) {
                a = new this.rhino.Mesh;
                let c = i.faces();
                for (let u = 0; u < c.count; u++) {
                    let h = c.get(u)
                      , f = h.getMesh(this.rhino.MeshType.Any);
                    f && (a.append(f),
                    f.delete()),
                    h.delete()
                }
                c.delete(),
                a.compact(),
                l = !0
            } else if (o === this.rhino.ObjectType.SubD)
                i.subdivide(3),
                a = this.rhino.Mesh.createFromSubDControlNet(i),
                l = !0;
            else if (o === this.rhino.ObjectType.InstanceReference) {
                let c = i.parentIdefId;
                if (this.instanceIdToDefinition.has(c)) {
                    let h = this.instanceIdToDefinition.get(c).getObjectIds();
                    for (let f = 0; f < h.length; f++) {
                        let m = h[f];
                        if (this.instanceIdToObject.has(m)) {
                            let g = this.instanceIdToObject.get(m);
                            n.push(t),
                            this.ImportRhinoGeometryObject(e, g, n),
                            n.pop()
                        }
                    }
                }
            }
            a !== null && (this.ImportRhinoMesh(e, a, t, n),
            l && a.delete())
        }
        ImportRhinoMesh(e, t, n, i) {
            let s = n.attributes()
              , o = this.GetMaterialIndex(e, n, i)
              , a = t.toThreejsJSON()
              , l = dr(a.data, o, null);
            l.SetName(s.name);
            let c = s.getUserStrings();
            if (c.length > 0) {
                let u = new kn("User texts");
                for (let h = 0; h < c.length; h++) {
                    let f = c[h];
                    u.AddProperty(new yt(dt.Text,f[0],f[1]))
                }
                l.AddPropertyGroup(u)
            }
            if (i.length !== 0) {
                let u = new Ut().CreateIdentity();
                for (let f = i.length - 1; f >= 0; f--) {
                    let v = i[f].geometry().xform.toFloatArray(!1)
                      , p = new Ut(v);
                    u = u.MultiplyMatrix(p)
                }
                let h = new en(u);
                Vr(l, h)
            }
            this.model.AddMeshToRootNode(l)
        }
        GetMaterialIndex(e, t, n) {
            function i(l, c, u) {
                let h = c.attributes();
                if (h.materialSource === l.ObjectMaterialSource.MaterialFromObject) {
                    let f = h.materialIndex;
                    if (f > -1)
                        return e.materials().get(f)
                } else if (h.materialSource === l.ObjectMaterialSource.MaterialFromLayer) {
                    let f = h.layerIndex;
                    if (f > -1) {
                        let g = e.layers().get(f).renderMaterialIndex;
                        if (g > -1)
                            return e.materials().get(g)
                    }
                } else if (h.materialSource === l.ObjectMaterialSource.MaterialFromParent && u.length !== 0)
                    return i(l, u[0], []);
                return null
            }
            function s(l, c) {
                function u(p, d) {
                    p.Set(d.r, d.g, d.b)
                }
                function h(p) {
                    return p.r === 0 && p.g === 0 && p.b === 0
                }
                function f(p) {
                    return p.r === 255 && p.g === 255 && p.b === 255
                }
                let m = null
                  , g = l.physicallyBased();
                g.supported ? (m = new Os,
                m.metalness = g.metallic ? 1 : 0,
                m.roughness = g.roughness) : (m = new xn,
                u(m.ambient, l.ambientColor),
                u(m.specular, l.specularColor)),
                m.name = l.name,
                u(m.color, l.diffuseColor),
                m.opacity = 1 - l.transparency,
                xi(m),
                h(m.color) && !f(l.reflectionColor) && u(m.color, l.reflectionColor),
                h(m.color) && !f(l.transparentColor) && u(m.color, l.transparentColor);
                let v = l.getBitmapTexture();
                if (v) {
                    let p = new ui
                      , d = pn(v.fileName)
                      , x = c.getFileBuffer(d);
                    p.name = d,
                    p.buffer = x,
                    m.diffuseMap = p
                }
                return m
            }
            function o(l, c, u) {
                let h = s(c, u);
                for (let f = 0; f < l.MaterialCount(); f++)
                    if (l.GetMaterial(f).IsEqual(h))
                        return f;
                return l.AddMaterial(h)
            }
            let a = i(this.rhino, t, n);
            return a === null ? null : o(this.model, a, this.callbacks)
        }
    }
    ;
    var si = class {
        constructor(e, t) {
            this.arrayBuffer = e,
            this.dataView = new DataView(e),
            this.isLittleEndian = t,
            this.position = 0
        }
        GetPosition() {
            return this.position
        }
        SetPosition(e) {
            this.position = e
        }
        GetByteLength() {
            return this.arrayBuffer.byteLength
        }
        Skip(e) {
            this.position = this.position + e
        }
        End() {
            return this.position >= this.arrayBuffer.byteLength
        }
        ReadArrayBuffer(e) {
            let t = new Uint8Array(this.arrayBuffer)
              , n = new ArrayBuffer(e)
              , i = new Uint8Array(n)
              , s = t.subarray(this.position, this.position + e);
            return i.set(s, 0),
            this.position += e,
            n
        }
        ReadBoolean8() {
            let e = this.dataView.getInt8(this.position);
            return this.position = this.position + 1,
            !!e
        }
        ReadCharacter8() {
            let e = this.dataView.getInt8(this.position);
            return this.position = this.position + 1,
            e
        }
        ReadUnsignedCharacter8() {
            let e = this.dataView.getUint8(this.position);
            return this.position = this.position + 1,
            e
        }
        ReadInteger16() {
            let e = this.dataView.getInt16(this.position, this.isLittleEndian);
            return this.position = this.position + 2,
            e
        }
        ReadUnsignedInteger16() {
            let e = this.dataView.getUint16(this.position, this.isLittleEndian);
            return this.position = this.position + 2,
            e
        }
        ReadInteger32() {
            let e = this.dataView.getInt32(this.position, this.isLittleEndian);
            return this.position = this.position + 4,
            e
        }
        ReadUnsignedInteger32() {
            let e = this.dataView.getUint32(this.position, this.isLittleEndian);
            return this.position = this.position + 4,
            e
        }
        ReadFloat32() {
            let e = this.dataView.getFloat32(this.position, this.isLittleEndian);
            return this.position = this.position + 4,
            e
        }
        ReadDouble64() {
            let e = this.dataView.getFloat64(this.position, this.isLittleEndian);
            return this.position = this.position + 8,
            e
        }
    }
    ;
    var xt = {
        MAIN3DS: 19789,
        EDIT3DS: 15677,
        EDIT_MATERIAL: 45055,
        MAT_NAME: 40960,
        MAT_AMBIENT: 40976,
        MAT_DIFFUSE: 40992,
        MAT_SPECULAR: 41008,
        MAT_SHININESS: 41024,
        MAT_SHININESS_STRENGTH: 41025,
        MAT_TRANSPARENCY: 41040,
        MAT_COLOR_F: 16,
        MAT_COLOR: 17,
        MAT_LIN_COLOR: 18,
        MAT_LIN_COLOR_F: 19,
        MAT_TEXMAP: 41472,
        MAT_TEXMAP_NAME: 41728,
        MAT_TEXMAP_UOFFSET: 41816,
        MAT_TEXMAP_VOFFSET: 41818,
        MAT_TEXMAP_USCALE: 41812,
        MAT_TEXMAP_VSCALE: 41814,
        MAT_TEXMAP_ROTATION: 41820,
        PERCENTAGE: 48,
        PERCENTAGE_F: 49,
        EDIT_OBJECT: 16384,
        OBJ_TRIMESH: 16640,
        OBJ_LIGHT: 17920,
        OBJ_CAMERA: 18176,
        TRI_VERTEX: 16656,
        TRI_TEXVERTEX: 16704,
        TRI_FACE: 16672,
        TRI_TRANSFORMATION: 16736,
        TRI_MATERIAL: 16688,
        TRI_SMOOTH: 16720,
        KF3DS: 45056,
        OBJECT_NODE: 45058,
        OBJECT_HIERARCHY: 45072,
        OBJECT_INSTANCE_NAME: 45073,
        OBJECT_PIVOT: 45075,
        OBJECT_POSITION: 45088,
        OBJECT_ROTATION: 45089,
        OBJECT_SCALE: 45090,
        OBJECT_ID: 45104
    }
      , Wp = class {
        constructor() {
            this.id = -1,
            this.name = "",
            this.flags = -1,
            this.parentId = -1,
            this.instanceName = "",
            this.pivot = [0, 0, 0],
            this.positions = [],
            this.rotations = [],
            this.scales = []
        }
    }
      , Xp = class {
        constructor() {
            this.nodes = [],
            this.nodeIdToNode = new Map
        }
        IsEmpty() {
            return this.nodes.length === 0
        }
        AddNode(e) {
            this.nodes.push(e),
            this.nodeIdToNode.set(e.nodeId, e)
        }
        GetNodes() {
            return this.nodes
        }
    }
      , ml = class extends Kt {
        constructor() {
            super()
        }
        CanImportExtension(e) {
            return e === "3ds"
        }
        GetUpDirection() {
            return lt.Z
        }
        ClearContent() {
            this.materialNameToIndex = null,
            this.meshNameToIndex = null,
            this.nodeList = null
        }
        ResetContent() {
            this.materialNameToIndex = new Map,
            this.meshNameToIndex = new Map,
            this.nodeList = new Xp
        }
        ImportContent(e, t) {
            this.ProcessBinary(e),
            t()
        }
        ProcessBinary(e) {
            let t = new si(e,!0)
              , n = t.GetByteLength();
            this.ReadChunks(t, n, (i,s)=>{
                i === xt.MAIN3DS ? this.ReadMainChunk(t, s) : this.SkipChunk(t, s)
            }
            )
        }
        ReadMainChunk(e, t) {
            let n = this.GetChunkEnd(e, t);
            this.ReadChunks(e, n, (i,s)=>{
                i === xt.EDIT3DS ? this.ReadEditorChunk(e, s) : i === xt.KF3DS ? this.ReadKeyFrameChunk(e, s) : this.SkipChunk(e, s)
            }
            ),
            this.BuildNodeHierarchy()
        }
        ReadEditorChunk(e, t) {
            let n = this.GetChunkEnd(e, t);
            this.ReadChunks(e, n, (i,s)=>{
                i === xt.EDIT_MATERIAL ? this.ReadMaterialChunk(e, s) : i === xt.EDIT_OBJECT ? this.ReadObjectChunk(e, s) : this.SkipChunk(e, s)
            }
            )
        }
        ReadMaterialChunk(e, t) {
            let n = new xn
              , i = this.GetChunkEnd(e, t)
              , s = null
              , o = null;
            this.ReadChunks(e, i, (l,c)=>{
                l === xt.MAT_NAME ? n.name = this.ReadName(e) : l === xt.MAT_AMBIENT ? n.ambient = this.ReadColorChunk(e, c) : l === xt.MAT_DIFFUSE ? n.color = this.ReadColorChunk(e, c) : l === xt.MAT_SPECULAR ? n.specular = this.ReadColorChunk(e, c) : l === xt.MAT_SHININESS ? s = this.ReadPercentageChunk(e, c) : l === xt.MAT_SHININESS_STRENGTH ? o = this.ReadPercentageChunk(e, c) : l === xt.MAT_TRANSPARENCY ? (n.opacity = 1 - this.ReadPercentageChunk(e, c),
                xi(n)) : l === xt.MAT_TEXMAP ? (n.diffuseMap = this.ReadTextureMapChunk(e, c),
                xi(n)) : this.SkipChunk(e, c)
            }
            ),
            s !== null && o !== null && (n.shininess = s * o / 10);
            let a = this.model.AddMaterial(n);
            this.materialNameToIndex.set(n.name, a)
        }
        ReadTextureMapChunk(e, t) {
            let n = new ui
              , i = this.GetChunkEnd(e, t);
            return this.ReadChunks(e, i, (s,o)=>{
                if (s === xt.MAT_TEXMAP_NAME) {
                    let a = this.ReadName(e)
                      , l = this.callbacks.getFileBuffer(a);
                    n.name = a,
                    n.buffer = l
                } else
                    s === xt.MAT_TEXMAP_UOFFSET ? n.offset.x = e.ReadFloat32() : s === xt.MAT_TEXMAP_VOFFSET ? n.offset.y = e.ReadFloat32() : s === xt.MAT_TEXMAP_USCALE ? n.scale.x = e.ReadFloat32() : s === xt.MAT_TEXMAP_VSCALE ? n.scale.y = e.ReadFloat32() : s === xt.MAT_TEXMAP_ROTATION ? n.rotation = e.ReadFloat32() * Cr : this.SkipChunk(e, o)
            }
            ),
            n
        }
        ReadColorChunk(e, t) {
            let n = new rt(0,0,0)
              , i = this.GetChunkEnd(e, t)
              , s = !1;
            return this.ReadChunks(e, i, (o,a)=>{
                o === xt.MAT_COLOR ? s || (n.r = e.ReadUnsignedCharacter8(),
                n.g = e.ReadUnsignedCharacter8(),
                n.b = e.ReadUnsignedCharacter8()) : o === xt.MAT_LIN_COLOR ? (n.r = e.ReadUnsignedCharacter8(),
                n.g = e.ReadUnsignedCharacter8(),
                n.b = e.ReadUnsignedCharacter8(),
                s = !0) : o === xt.MAT_COLOR_F ? s || (n.r = yn(e.ReadFloat32()),
                n.g = yn(e.ReadFloat32()),
                n.b = yn(e.ReadFloat32())) : o === xt.MAT_LIN_COLOR_F ? (n.r = yn(e.ReadFloat32()),
                n.g = yn(e.ReadFloat32()),
                n.b = yn(e.ReadFloat32()),
                s = !0) : this.SkipChunk(e, a)
            }
            ),
            n
        }
        ReadPercentageChunk(e, t) {
            let n = 0
              , i = this.GetChunkEnd(e, t);
            return this.ReadChunks(e, i, (s,o)=>{
                s === xt.PERCENTAGE ? n = e.ReadUnsignedInteger16() / 100 : s === xt.PERCENTAGE_F ? n = e.ReadFloat32() : this.SkipChunk(e, o)
            }
            ),
            n
        }
        ReadObjectChunk(e, t) {
            let n = this.GetChunkEnd(e, t)
              , i = this.ReadName(e);
            this.ReadChunks(e, n, (s,o)=>{
                s === xt.OBJ_TRIMESH ? this.ReadMeshChunk(e, o, i) : this.SkipChunk(e, o)
            }
            )
        }
        ReadMeshChunk(e, t, n) {
            function i(u, h) {
                if (!h.IsValid())
                    return;
                let f = h.Determinant()
                  , m = ts(f);
                m && (h = new Ut().CreateScale(-1, 1, 1).MultiplyMatrix(h));
                let g = h.Invert();
                if (g === null)
                    return;
                let v = new en(g);
                Vr(u, v),
                m && tf(u)
            }
            let s = new $t;
            s.SetName(n);
            let o = this.GetChunkEnd(e, t)
              , a = null;
            if (this.ReadChunks(e, o, (u,h)=>{
                u === xt.TRI_VERTEX ? this.ReadVerticesChunk(s, e) : u === xt.TRI_TEXVERTEX ? this.ReadTextureVerticesChunk(s, e) : u === xt.TRI_FACE ? this.ReadFacesChunk(s, e, h) : u === xt.TRI_TRANSFORMATION ? a = this.ReadTransformationChunk(e) : this.SkipChunk(e, h)
            }
            ),
            s.VertexCount() === s.TextureUVCount())
                for (let u = 0; u < s.TriangleCount(); u++) {
                    let h = s.GetTriangle(u);
                    h.SetTextureUVs(h.v0, h.v1, h.v2)
                }
            let l = new Ut(a);
            i(s, l);
            let c = this.model.AddMesh(s);
            this.meshNameToIndex.set(s.GetName(), c)
        }
        ReadVerticesChunk(e, t) {
            let n = t.ReadUnsignedInteger16();
            for (let i = 0; i < n; i++) {
                let s = t.ReadFloat32()
                  , o = t.ReadFloat32()
                  , a = t.ReadFloat32();
                e.AddVertex(new ze(s,o,a))
            }
        }
        ReadTextureVerticesChunk(e, t) {
            let n = t.ReadUnsignedInteger16();
            for (let i = 0; i < n; i++) {
                let s = t.ReadFloat32()
                  , o = t.ReadFloat32();
                e.AddTextureUV(new Pt(s,o))
            }
        }
        ReadFacesChunk(e, t, n) {
            let i = this.GetChunkEnd(t, n)
              , s = t.ReadUnsignedInteger16();
            for (let o = 0; o < s; o++) {
                let a = t.ReadUnsignedInteger16()
                  , l = t.ReadUnsignedInteger16()
                  , c = t.ReadUnsignedInteger16();
                t.ReadUnsignedInteger16(),
                e.AddTriangle(new jt(a,l,c))
            }
            this.ReadChunks(t, i, (o,a)=>{
                o === xt.TRI_MATERIAL ? this.ReadFaceMaterialsChunk(e, t) : o === xt.TRI_SMOOTH ? this.ReadFaceSmoothingGroupsChunk(e, s, t) : this.SkipChunk(t, a)
            }
            )
        }
        ReadFaceMaterialsChunk(e, t) {
            let n = this.ReadName(t)
              , i = this.materialNameToIndex.get(n)
              , s = t.ReadUnsignedInteger16();
            for (let o = 0; o < s; o++) {
                let a = t.ReadUnsignedInteger16()
                  , l = e.GetTriangle(a);
                i !== void 0 && (l.mat = i)
            }
        }
        ReadFaceSmoothingGroupsChunk(e, t, n) {
            for (let i = 0; i < t; i++) {
                let s = n.ReadUnsignedInteger32()
                  , o = e.GetTriangle(i);
                o.curve = s
            }
        }
        ReadTransformationChunk(e) {
            let t = [];
            for (let n = 0; n < 4; n++) {
                for (let i = 0; i < 3; i++)
                    t.push(e.ReadFloat32());
                n < 3 ? t.push(0) : t.push(1)
            }
            return t
        }
        ReadKeyFrameChunk(e, t) {
            let n = this.GetChunkEnd(e, t);
            this.ReadChunks(e, n, (i,s)=>{
                i === xt.OBJECT_NODE ? this.ReadObjectNodeChunk(e, s) : this.SkipChunk(e, s)
            }
            )
        }
        BuildNodeHierarchy() {
            function e(n, i) {
                function s(c) {
                    return c.positions.length === 0 ? [0, 0, 0] : c.positions[0]
                }
                function o(c) {
                    function u(f) {
                        let m = [0, 0, 0, 1]
                          , g = Math.sqrt(f[0] * f[0] + f[1] * f[1] + f[2] * f[2]);
                        if (g > 0) {
                            let v = f[3] * -.5
                              , p = Math.sin(v) / g;
                            m = [p * f[0], p * f[1], p * f[2], Math.cos(v)]
                        }
                        return m
                    }
                    if (c.rotations.length === 0)
                        return [0, 0, 0, 1];
                    let h = c.rotations[0];
                    return u(h)
                }
                function a(c) {
                    return c.scales.length === 0 ? [1, 1, 1] : c.scales[0]
                }
                let l = new Ut;
                if (l.ComposeTRS(Ns(s(n)), ll(o(n)), Ns(a(n))),
                i) {
                    let c = n.pivot;
                    l = new Ut().CreateTranslation(-c[0], -c[1], -c[2]).MultiplyMatrix(l)
                }
                return new en(l)
            }
            let t = this.model.GetRootNode();
            if (this.nodeList.IsEmpty())
                for (let n = 0; n < this.model.MeshCount(); n++)
                    t.AddMeshIndex(n);
            else {
                let n = new Map;
                for (let i of this.nodeList.GetNodes()) {
                    let s = new Fn;
                    i.name.length > 0 && i.name !== "$$$DUMMY" && (s.SetName(i.name),
                    i.instanceName.length > 0 && s.SetName(s.GetName() + " " + i.instanceName)),
                    i.parentId === 65535 || !n.has(i.parentId) ? t.AddChildNode(s) : n.get(i.parentId).AddChildNode(s),
                    n.set(i.id, s);
                    let o = this.meshNameToIndex.has(i.name);
                    s.SetTransformation(e(i, o)),
                    o && s.AddMeshIndex(this.meshNameToIndex.get(i.name))
                }
            }
        }
        ReadObjectNodeChunk(e, t) {
            function n(o, a, l) {
                let c = [];
                a.Skip(10);
                let u = a.ReadInteger32();
                for (let h = 0; h < u; h++) {
                    a.ReadInteger32(),
                    a.ReadUnsignedInteger16() !== 0 && a.ReadFloat32();
                    let m = null;
                    if (l === xt.OBJECT_ROTATION) {
                        let g = a.ReadFloat32();
                        m = o.ReadVector(a),
                        m[3] = g
                    } else
                        m = o.ReadVector(a);
                    c.push(m)
                }
                return c
            }
            let i = new Wp
              , s = this.GetChunkEnd(e, t);
            this.ReadChunks(e, s, (o,a)=>{
                o === xt.OBJECT_HIERARCHY ? (i.name = this.ReadName(e),
                i.flags = e.ReadUnsignedInteger32(),
                i.parentId = e.ReadUnsignedInteger16()) : o === xt.OBJECT_INSTANCE_NAME ? i.instanceName = this.ReadName(e) : o === xt.OBJECT_PIVOT ? i.pivot = this.ReadVector(e) : o === xt.OBJECT_POSITION ? i.positions = n(this, e, xt.OBJECT_POSITION) : o === xt.OBJECT_ROTATION ? i.rotations = n(this, e, xt.OBJECT_ROTATION) : o === xt.OBJECT_SCALE ? i.scales = n(this, e, xt.OBJECT_SCALE) : o === xt.OBJECT_ID ? i.id = e.ReadUnsignedInteger16() : this.SkipChunk(e, a)
            }
            ),
            this.nodeList.AddNode(i)
        }
        ReadName(e) {
            let t = ""
              , n = 0
              , i = 0;
            for (; i < 64 && (n = e.ReadCharacter8(),
            n !== 0); )
                t = t + String.fromCharCode(n),
                i = i + 1;
            return t
        }
        ReadVector(e) {
            return [e.ReadFloat32(), e.ReadFloat32(), e.ReadFloat32()]
        }
        ReadChunks(e, t, n) {
            for (; e.GetPosition() <= t - 6; ) {
                let i = e.ReadUnsignedInteger16()
                  , s = e.ReadUnsignedInteger32();
                n(i, s)
            }
        }
        GetChunkEnd(e, t) {
            return e.GetPosition() + t - 6
        }
        SkipChunk(e, t) {
            e.Skip(t - 6)
        }
    }
    ;
    function wn(r) {
        return new TextDecoder("utf-8").decode(r)
    }
    function Bv(r) {
        let e = ""
          , t = new Uint8Array(r);
        for (let n = 0; n < t.byteLength; n++)
            e += String.fromCharCode(t[n]);
        return e
    }
    function Gv(r) {
        let e = new ArrayBuffer(r.length)
          , t = new Uint8Array(e);
        for (let n = 0; n < r.length; n++)
            t[n] = r.charCodeAt(n);
        return e
    }
    function gl(r) {
        return new TextEncoder().encode(r).buffer
    }
    function qo(r) {
        let e = "data:";
        if (!r.startsWith(e))
            return null;
        let t = r.indexOf(";");
        if (t === -1)
            return null;
        let n = r.indexOf(",");
        if (n === -1)
            return null;
        let i = r.substring(e.length, e.length + t - 5)
          , s = atob(r.substring(n + 1))
          , o = new ArrayBuffer(s.length)
          , a = new Uint8Array(o);
        for (let l = 0; l < s.length; l++)
            a[l] = s.charCodeAt(l);
        return {
            mimeType: i,
            buffer: o
        }
    }
    function ro(r) {
        if (r == null)
            return "";
        let e = r.split("/");
        return e.length === 0 ? "" : e[e.length - 1]
    }
    function Ms(r) {
        let e = new Blob([r]);
        return URL.createObjectURL(e)
    }
    function af(r, e) {
        let t = new Blob([r],{
            type: e
        });
        return URL.createObjectURL(t)
    }
    function lf(r) {
        URL.revokeObjectURL(r)
    }
    var _i = {
        BYTE: 5120,
        UNSIGNED_BYTE: 5121,
        SHORT: 5122,
        UNSIGNED_SHORT: 5123,
        UNSIGNED_INT: 5125,
        FLOAT: 5126
    }
      , gr = {
        SCALAR: 0,
        VEC2: 1,
        VEC3: 2,
        VEC4: 3,
        MAT2: 4,
        MAT3: 5,
        MAT4: 6
    }
      , Yo = {
        POINTS: 0,
        LINES: 1,
        LINE_LOOP: 2,
        LINE_STRIP: 3,
        TRIANGLES: 4,
        TRIANGLE_STRIP: 5,
        TRIANGLE_FAN: 6
    }
      , jp = {
        GLTF_STRING: 1179937895,
        JSON_CHUNK_TYPE: 1313821514,
        BINARY_CHUNK_TYPE: 5130562
    };
    function eu(r) {
        return Ii(bo(r[0]), bo(r[1]), bo(r[2]))
    }
    function iw(r, e) {
        function t(n, i) {
            let s = n;
            return i === _i.UNSIGNED_BYTE ? s /= 255 : i === _i.UNSIGNED_SHORT && (s /= 65535),
            yn(bo(s))
        }
        return new rt(t(r[0], e),t(r[1], e),t(r[2], e))
    }
    var qp = class {
        constructor(e) {
            this.reader = new si(e,!0),
            this.componentType = null,
            this.dataType = null,
            this.byteStride = null,
            this.dataCount = null,
            this.sparseReader = null
        }
        SetComponentType(e) {
            this.componentType = e
        }
        SetDataType(e) {
            e === "SCALAR" ? this.dataType = gr.SCALAR : e === "VEC2" ? this.dataType = gr.VEC2 : e === "VEC3" ? this.dataType = gr.VEC3 : e === "VEC4" ? this.dataType = gr.VEC4 : e === "MAT2" ? this.dataType = gr.MAT2 : e === "MAT3" ? this.dataType = gr.MAT3 : e === "MAT4" && (this.dataType = gr.MAT4)
        }
        SetByteStride(e) {
            this.byteStride = e
        }
        SetDataCount(e) {
            this.dataCount = e
        }
        SetSparseReader(e, t) {
            this.sparseReader = {
                indexReader: e,
                valueReader: t
            }
        }
        ReadArrayBuffer(e) {
            return this.reader.ReadArrayBuffer(e)
        }
        GetDataCount() {
            return this.dataCount
        }
        ReadData() {
            if (this.dataType === null)
                return null;
            if (this.dataType === gr.SCALAR) {
                let e = this.ReadComponent();
                return this.SkipBytesByStride(1),
                e
            } else if (this.dataType === gr.VEC2) {
                let e = this.ReadComponent()
                  , t = this.ReadComponent();
                return this.SkipBytesByStride(2),
                new Pt(e,t)
            } else if (this.dataType === gr.VEC3) {
                let e = this.ReadComponent()
                  , t = this.ReadComponent()
                  , n = this.ReadComponent();
                return this.SkipBytesByStride(3),
                new ze(e,t,n)
            } else if (this.dataType === gr.VEC4) {
                let e = this.ReadComponent()
                  , t = this.ReadComponent()
                  , n = this.ReadComponent()
                  , i = this.ReadComponent();
                return this.SkipBytesByStride(4),
                new Fi(e,t,n,i)
            }
            return null
        }
        EnumerateData(e) {
            if (this.sparseReader === null)
                for (let t = 0; t < this.dataCount; t++)
                    e(this.ReadData());
            else {
                let t = [];
                for (let i = 0; i < this.sparseReader.indexReader.GetDataCount(); i++) {
                    let s = this.sparseReader.indexReader.ReadData()
                      , o = this.sparseReader.valueReader.ReadData();
                    t.push({
                        index: s,
                        value: o
                    })
                }
                let n = 0;
                for (let i = 0; i < this.dataCount; i++) {
                    let s = this.ReadData();
                    n < t.length && t[n].index === i ? (e(t[n].value),
                    n += 1) : e(s)
                }
            }
        }
        SkipBytes(e) {
            this.reader.Skip(e)
        }
        ReadComponent() {
            return this.componentType === null ? null : this.componentType === _i.BYTE ? this.reader.ReadCharacter8() : this.componentType === _i.UNSIGNED_BYTE ? this.reader.ReadUnsignedCharacter8() : this.componentType === _i.SHORT ? this.reader.ReadInteger16() : this.componentType === _i.UNSIGNED_SHORT ? this.reader.ReadUnsignedInteger16() : this.componentType === _i.UNSIGNED_INT ? this.reader.ReadInteger32() : this.componentType === _i.FLOAT ? this.reader.ReadFloat32() : null
        }
        SkipBytesByStride(e) {
            if (this.byteStride === null)
                return;
            let t = e * this.GetComponentSize();
            this.reader.Skip(this.byteStride - t)
        }
        GetComponentSize() {
            return this.componentType === _i.BYTE || this.componentType === _i.UNSIGNED_BYTE ? 1 : this.componentType === _i.SHORT || this.componentType === _i.UNSIGNED_SHORT ? 2 : this.componentType === _i.UNSIGNED_INT || this.componentType === _i.FLOAT ? 4 : 0
        }
    }
      , Yp = class {
        constructor() {
            this.supportedExtensions = ["KHR_draco_mesh_compression", "KHR_materials_pbrSpecularGlossiness", "KHR_texture_transform"],
            this.draco = null
        }
        LoadLibraries(e, t) {
            if (e === void 0) {
                t.onSuccess();
                return
            }
            this.draco === null && e.indexOf("KHR_draco_mesh_compression") !== -1 ? Ar("loaders/draco_decoder.js").then(()=>{
                DracoDecoderModule().then(n=>{
                    this.draco = n,
                    t.onSuccess()
                }
                )
            }
            ).catch(()=>{
                t.onError("Failed to load draco decoder.")
            }
            ) : t.onSuccess()
        }
        GetUnsupportedExtensions(e) {
            let t = [];
            if (e === void 0)
                return t;
            for (let n = 0; n < e.length; n++) {
                let i = e[n];
                this.supportedExtensions.indexOf(i) === -1 && t.push(i)
            }
            return t
        }
        ProcessMaterial(e, t, n) {
            if (e.extensions === void 0)
                return null;
            let i = e.extensions.KHR_materials_pbrSpecularGlossiness;
            if (i === void 0)
                return null;
            let s = new xn
              , o = i.diffuseFactor;
            o !== void 0 && (s.color = eu(o),
            s.opacity = o[3]);
            let a = i.diffuseTexture;
            a !== void 0 && (s.diffuseMap = n(a));
            let l = i.specularFactor;
            l !== void 0 && (s.specular = eu(l));
            let c = i.specularGlossinessTexture;
            c !== void 0 && (s.specularMap = n(c));
            let u = i.glossinessFactor;
            return u !== void 0 && (s.shininess = u),
            s
        }
        ProcessTexture(e, t) {
            if (e.extensions === void 0)
                return;
            let n = e.extensions.KHR_texture_transform;
            n !== void 0 && (n.offset !== void 0 && (t.offset.x = n.offset[0],
            t.offset.y = -n.offset[1]),
            n.scale !== void 0 && (t.scale.x = n.scale[0],
            t.scale.y = n.scale[1]),
            n.rotation !== void 0 && (t.rotation = -n.rotation))
        }
        ProcessPrimitive(e, t, n, i) {
            function s(k, B, P, C, L) {
                let F = B.GetAttributeByUniqueId(P, C)
                  , U = F.num_components()
                  , K = P.num_points() * U
                  , re = K * 4
                  , oe = k._malloc(re);
                B.GetAttributeDataArrayForAllPoints(P, F, k.DT_FLOAT32, re, oe);
                let j = new Float32Array(k.HEAPF32.buffer,oe,K).slice();
                if (U === 2)
                    for (let w = 0; w < j.length; w += 2)
                        L(new Pt(j[w + 0],j[w + 1]));
                else if (U === 3)
                    for (let w = 0; w < j.length; w += 3)
                        L(new ze(j[w + 0],j[w + 1],j[w + 2]));
                else if (U === 4)
                    for (let w = 0; w < j.length; w += 4)
                        L(new Fi(j[w + 0],j[w + 1],j[w + 2],j[w + 3]));
                k._free(oe)
            }
            if (this.draco === null || n.extensions === void 0 || n.extensions.KHR_draco_mesh_compression === void 0)
                return !1;
            let o = new this.draco.Decoder
              , a = new this.draco.DecoderBuffer
              , l = n.extensions.KHR_draco_mesh_compression
              , c = t.bufferViews[l.bufferView]
              , h = e.GetReaderFromBufferView(c).ReadArrayBuffer(c.byteLength);
            if (a.Init(new Int8Array(h), h.byteLength),
            o.GetEncodedGeometryType(a) !== this.draco.TRIANGULAR_MESH)
                return !0;
            let m = new this.draco.Mesh;
            if (!o.DecodeBufferToMesh(a, m).ok())
                return !0;
            let v = l.attributes.POSITION !== void 0
              , p = !1
              , d = l.attributes.NORMAL !== void 0
              , x = l.attributes.TEXCOORD_0 !== void 0;
            if (!v)
                return !0;
            let y = i.VertexCount()
              , _ = i.VertexColorCount()
              , S = i.NormalCount()
              , N = i.TextureUVCount();
            s(this.draco, o, m, l.attributes.POSITION, k=>{
                i.AddVertex(k)
            }
            ),
            d && s(this.draco, o, m, l.attributes.NORMAL, k=>{
                i.AddNormal(k)
            }
            ),
            x && s(this.draco, o, m, l.attributes.TEXCOORD_0, k=>{
                k.y = -k.y,
                i.AddTextureUV(k)
            }
            );
            let O = m.num_faces() * 3
              , M = O * 4
              , R = this.draco._malloc(M);
            o.GetTrianglesUInt32Array(m, M, R);
            let q = new Uint32Array(this.draco.HEAPU32.buffer,R,O).slice();
            for (let k = 0; k < q.length; k += 3) {
                let B = q[k]
                  , P = q[k + 1]
                  , C = q[k + 2];
                e.AddTriangle(n, i, B, P, C, p, d, x, y, _, S, N)
            }
            return this.draco._free(R),
            !0
        }
    }
      , vl = class extends Kt {
        constructor() {
            super(),
            this.gltfExtensions = new Yp
        }
        CanImportExtension(e) {
            return e === "gltf" || e === "glb"
        }
        GetUpDirection() {
            return lt.Y
        }
        ClearContent() {
            this.bufferContents = null,
            this.imageIndexToTextureParams = null
        }
        ResetContent() {
            this.bufferContents = [],
            this.imageIndexToTextureParams = new Map
        }
        ImportContent(e, t) {
            this.extension === "gltf" ? this.ProcessGltf(e, t) : this.extension === "glb" && this.ProcessBinaryGltf(e, t)
        }
        ProcessGltf(e, t) {
            let n = wn(e)
              , i = JSON.parse(n);
            if (i.asset.version !== "2.0") {
                this.SetError("Invalid glTF version."),
                t();
                return
            }
            for (let s = 0; s < i.buffers.length; s++) {
                let o = null
                  , a = i.buffers[s]
                  , l = qo(a.uri);
                if (l !== null)
                    o = l.buffer;
                else {
                    let c = this.callbacks.getFileBuffer(a.uri);
                    c !== null && (o = c)
                }
                if (o === null) {
                    this.SetError("One of the requested buffers is missing."),
                    t();
                    return
                }
                this.bufferContents.push(o)
            }
            this.ProcessMainFile(i, t)
        }
        ProcessBinaryGltf(e, t) {
            function n(c) {
                let u = c.ReadUnsignedInteger32()
                  , h = c.ReadUnsignedInteger32()
                  , f = c.ReadArrayBuffer(u);
                return {
                    type: h,
                    buffer: f
                }
            }
            let i = new si(e,!0);
            if (i.ReadUnsignedInteger32() !== jp.GLTF_STRING) {
                this.SetError("Invalid glTF file."),
                t();
                return
            }
            if (i.ReadUnsignedInteger32() !== 2) {
                this.SetError("Invalid glTF version."),
                t();
                return
            }
            if (i.ReadUnsignedInteger32() !== i.GetByteLength()) {
                this.SetError("Invalid glTF file."),
                t();
                return
            }
            let l = null;
            for (; !i.End(); ) {
                let c = n(i);
                c.type === jp.JSON_CHUNK_TYPE ? l = wn(c.buffer) : c.type === jp.BINARY_CHUNK_TYPE && this.bufferContents.push(c.buffer)
            }
            if (l !== null) {
                let c = JSON.parse(l);
                this.ProcessMainFile(c, t)
            }
        }
        ProcessMainFile(e, t) {
            let n = this.gltfExtensions.GetUnsupportedExtensions(e.extensionsRequired);
            if (n.length > 0) {
                this.SetError("Unsupported extension: " + n.join(", ") + "."),
                t();
                return
            }
            this.gltfExtensions.LoadLibraries(e.extensionsRequired, {
                onSuccess: ()=>{
                    this.ImportModel(e),
                    t()
                }
                ,
                onError: i=>{
                    this.SetError(i),
                    t()
                }
            })
        }
        ImportModel(e) {
            let t = e.materials;
            if (t !== void 0)
                for (let i of t)
                    this.ImportMaterial(e, i);
            let n = e.meshes;
            if (n !== void 0)
                for (let i of n)
                    this.ImportMesh(e, i);
            this.ImportProperties(this.model, e.asset, "Asset properties"),
            this.ImportScene(e)
        }
        ImportProperties(e, t, n) {
            if (t == null)
                return;
            let i = new kn(n);
            for (let s in t)
                if (Object.prototype.hasOwnProperty.call(t, s)) {
                    let o = null
                      , a = t[s];
                    typeof a == "string" ? o = new yt(dt.Text,s,a) : typeof a == "number" && (Number.isInteger(a) ? o = new yt(dt.Integer,s,a) : o = new yt(dt.Number,s,a)),
                    o !== null && i.AddProperty(o)
                }
            i.PropertyCount() !== 0 && e.AddPropertyGroup(i)
        }
        GetDefaultScene(e) {
            let t = e.scene || 0;
            return t >= e.scenes.length ? null : e.scenes[t]
        }
        ImportMaterial(e, t) {
            let n = new Os;
            if (t.name !== void 0 && (n.name = t.name),
            n.color = eu([1, 1, 1]),
            t.pbrMetallicRoughness !== void 0) {
                let s = t.pbrMetallicRoughness.baseColorFactor;
                s !== void 0 && (n.color = eu(s),
                n.opacity = s[3]);
                let o = t.pbrMetallicRoughness.metallicFactor;
                o !== void 0 && (n.metalness = o);
                let a = t.pbrMetallicRoughness.roughnessFactor;
                a !== void 0 && (n.roughness = a);
                let l = t.emissiveFactor;
                l !== void 0 && (n.emissive = eu(l)),
                n.diffuseMap = this.ImportTexture(e, t.pbrMetallicRoughness.baseColorTexture),
                n.metalnessMap = this.ImportTexture(e, t.pbrMetallicRoughness.metallicRoughnessTexture),
                n.normalMap = this.ImportTexture(e, t.normalTexture),
                n.emissiveMap = this.ImportTexture(e, t.emissiveTexture),
                n.diffuseMap !== null && (n.multiplyDiffuseMap = !0);
                let c = t.alphaMode;
                c !== void 0 && (c === "BLEND" ? n.transparent = !0 : c === "MASK" && (n.transparent = !0,
                n.alphaTest = t.alphaCutoff || .5))
            }
            let i = this.gltfExtensions.ProcessMaterial(t, n, s=>this.ImportTexture(e, s));
            i !== null && (n = i),
            this.model.AddMaterial(n)
        }
        ImportTexture(e, t) {
            if (t == null)
                return null;
            let n = new ui
              , s = e.textures[t.index].source
              , o = e.images[s]
              , a = null;
            if (this.imageIndexToTextureParams.has(s))
                a = this.imageIndexToTextureParams.get(s);
            else {
                a = {
                    name: null,
                    mimeType: null,
                    buffer: null
                };
                let l = s.toString();
                if (o.uri !== void 0) {
                    let c = qo(o.uri);
                    if (c !== null)
                        a.name = "Embedded_" + l + "." + ro(c.mimeType),
                        a.mimeType = c.mimeType,
                        a.buffer = c.buffer;
                    else {
                        let u = this.callbacks.getFileBuffer(o.uri);
                        a.name = o.uri,
                        a.buffer = u
                    }
                } else if (o.bufferView !== void 0) {
                    let c = e.bufferViews[o.bufferView]
                      , u = this.GetReaderFromBufferView(c);
                    if (u !== null) {
                        let h = u.ReadArrayBuffer(c.byteLength);
                        a.name = "Binary_" + l + "." + ro(o.mimeType),
                        a.mimeType = o.mimeType,
                        a.buffer = h
                    }
                }
                this.imageIndexToTextureParams.set(s, a)
            }
            return n.name = a.name,
            n.mimeType = a.mimeType,
            n.buffer = a.buffer,
            this.gltfExtensions.ProcessTexture(t, n),
            n
        }
        ImportMesh(e, t) {
            let n = new $t;
            this.model.AddMesh(n),
            t.name !== void 0 && n.SetName(t.name);
            for (let i = 0; i < t.primitives.length; i++) {
                let s = t.primitives[i];
                this.ImportPrimitive(e, s, n)
            }
            this.ImportProperties(n, t.extras, "Mesh properties")
        }
        ImportPrimitive(e, t, n) {
            function i(d, x, y) {
                let _ = x.attributes[y];
                if (_ === void 0)
                    return !1;
                let S = d.accessors[_];
                return !(S === void 0 || S.count === 0)
            }
            if (this.gltfExtensions.ProcessPrimitive(this, e, t, n) || t.attributes === void 0)
                return;
            let s = i(e, t, "POSITION")
              , o = i(e, t, "COLOR_0")
              , a = i(e, t, "NORMAL")
              , l = i(e, t, "TEXCOORD_0")
              , c = t.indices !== void 0
              , u = Yo.TRIANGLES;
            if (t.mode !== void 0 && (u = t.mode),
            u !== Yo.TRIANGLES && u !== Yo.TRIANGLE_STRIP && u !== Yo.TRIANGLE_FAN)
                return;
            let h = n.VertexCount()
              , f = n.VertexColorCount()
              , m = n.NormalCount()
              , g = n.TextureUVCount();
            if (s) {
                let d = e.accessors[t.attributes.POSITION]
                  , x = this.GetReaderFromAccessor(e, d);
                if (x === null)
                    return;
                x.EnumerateData(y=>{
                    n.AddVertex(y)
                }
                )
            } else
                return;
            let v = n.VertexCount() - h;
            if (o) {
                let d = e.accessors[t.attributes.COLOR_0]
                  , x = this.GetReaderFromAccessor(e, d);
                if (x === null)
                    return;
                x.EnumerateData(y=>{
                    let _ = iw([y.x, y.y, y.z], x.componentType);
                    n.AddVertexColor(_)
                }
                ),
                n.VertexColorCount() - f !== v && (o = !1)
            }
            if (a) {
                let d = e.accessors[t.attributes.NORMAL]
                  , x = this.GetReaderFromAccessor(e, d);
                if (x === null)
                    return;
                x.EnumerateData(y=>{
                    n.AddNormal(y)
                }
                ),
                n.NormalCount() - m !== v && (a = !1)
            }
            if (l) {
                let d = e.accessors[t.attributes.TEXCOORD_0]
                  , x = this.GetReaderFromAccessor(e, d);
                if (x === null)
                    return;
                x.EnumerateData(y=>{
                    y.y = -y.y,
                    n.AddTextureUV(y)
                }
                ),
                n.TextureUVCount() - g !== v && (l = !1)
            }
            let p = [];
            if (c) {
                let d = e.accessors[t.indices]
                  , x = this.GetReaderFromAccessor(e, d);
                if (x === null)
                    return;
                x.EnumerateData(y=>{
                    p.push(y)
                }
                )
            } else {
                let d = n.VertexCount() - h;
                for (let x = 0; x < d; x++)
                    p.push(x)
            }
            if (u === Yo.TRIANGLES)
                for (let d = 0; d < p.length; d += 3) {
                    let x = p[d]
                      , y = p[d + 1]
                      , _ = p[d + 2];
                    this.AddTriangle(t, n, x, y, _, o, a, l, h, f, m, g)
                }
            else if (u === Yo.TRIANGLE_STRIP)
                for (let d = 0; d < p.length - 2; d++) {
                    let x = p[d]
                      , y = p[d + 1]
                      , _ = p[d + 2];
                    if (d % 2 === 1) {
                        let S = y;
                        y = _,
                        _ = S
                    }
                    this.AddTriangle(t, n, x, y, _, o, a, l, h, f, m, g)
                }
            else if (u === Yo.TRIANGLE_FAN)
                for (let d = 1; d < p.length - 1; d++) {
                    let x = p[0]
                      , y = p[d]
                      , _ = p[d + 1];
                    this.AddTriangle(t, n, x, y, _, o, a, l, h, f, m, g)
                }
        }
        AddTriangle(e, t, n, i, s, o, a, l, c, u, h, f) {
            let m = new jt(c + n,c + i,c + s);
            o && m.SetVertexColors(u + n, u + i, u + s),
            a && m.SetNormals(h + n, h + i, h + s),
            l && m.SetTextureUVs(f + n, f + i, f + s),
            e.material !== void 0 && (m.mat = e.material),
            t.AddTriangle(m)
        }
        ImportScene(e) {
            let t = this.GetDefaultScene(e);
            if (t === null)
                return;
            let n = this.model.GetRootNode();
            for (let i of t.nodes) {
                let s = e.nodes[i];
                this.ImportNode(e, s, n)
            }
            this.ImportProperties(this.model, t.extras, "Scene properties")
        }
        ImportNode(e, t, n) {
            function i(o) {
                let a = new Ut().CreateIdentity();
                if (o.matrix !== void 0)
                    a.Set(o.matrix);
                else {
                    let l = [0, 0, 0]
                      , c = [0, 0, 0, 1]
                      , u = [1, 1, 1];
                    o.translation !== void 0 && (l = o.translation),
                    o.rotation !== void 0 && (c = o.rotation),
                    o.scale !== void 0 && (u = o.scale),
                    a.ComposeTRS(Ns(l), ll(c), Ns(u))
                }
                return new en(a)
            }
            if (t.children === void 0 && t.mesh === void 0)
                return;
            let s = new Fn;
            if (t.name !== void 0 && s.SetName(t.name),
            s.SetTransformation(i(t)),
            n.AddChildNode(s),
            t.children !== void 0)
                for (let o of t.children) {
                    let a = e.nodes[o];
                    this.ImportNode(e, a, s)
                }
            if (t.mesh !== void 0) {
                let o = this.model.GetMesh(t.mesh);
                this.ImportProperties(o, t.extras, "Node properties"),
                s.AddMeshIndex(t.mesh)
            }
        }
        GetReaderFromBufferView(e) {
            let t = e.buffer || 0
              , n = this.bufferContents[t];
            if (n == null)
                return null;
            let i = new qp(n);
            i.SkipBytes(e.byteOffset || 0);
            let s = e.byteStride;
            return s !== void 0 && s !== 0 && i.SetByteStride(s),
            i
        }
        GetReaderFromAccessor(e, t) {
            let n = t.bufferView || 0
              , i = e.bufferViews[n]
              , s = this.GetReaderFromBufferView(i);
            if (s === null)
                return null;
            if (s.SetComponentType(t.componentType),
            s.SetDataType(t.type),
            s.SetDataCount(t.count),
            s.SkipBytes(t.byteOffset || 0),
            t.sparse !== void 0) {
                let o = this.GetReaderFromSparseAccessor(e, t.sparse.indices, t.sparse.indices.componentType, "SCALAR", t.sparse.count)
                  , a = this.GetReaderFromSparseAccessor(e, t.sparse.values, t.componentType, t.type, t.sparse.count);
                o !== null && a !== null && s.SetSparseReader(o, a)
            }
            return s
        }
        GetReaderFromSparseAccessor(e, t, n, i, s) {
            if (t.bufferView === void 0)
                return null;
            let o = e.bufferViews[t.bufferView]
              , a = this.GetReaderFromBufferView(o);
            return a === null ? null : (a.SetComponentType(n),
            a.SetDataType(i),
            a.SetDataCount(s),
            a.SkipBytes(t.byteOffset || 0),
            a)
        }
    }
    ;
    var yl = class extends Kt {
        constructor() {
            super(),
            this.ifc = null
        }
        CanImportExtension(e) {
            return e === "ifc"
        }
        GetUpDirection() {
            return lt.Y
        }
        ClearContent() {
            this.expressIDToMesh = null,
            this.colorToMaterial = null
        }
        ResetContent() {
            this.expressIDToMesh = new Map,
            this.colorToMaterial = new vi(this.model)
        }
        ImportContent(e, t) {
            this.ifc === null ? Ar("loaders/web-ifc-api-browser.js").then(()=>{
                this.ifc = new WebIFC.IfcAPI,
                this.ifc.Init().then(()=>{
                    this.ImportIfcContent(e),
                    t()
                }
                )
            }
            ).catch(()=>{
                this.SetError("Failed to load web-ifc."),
                t()
            }
            ) : (this.ImportIfcContent(e),
            t())
        }
        ImportIfcContent(e) {
            let t = new Uint8Array(e)
              , n = this.ifc.OpenModel(t, {
                COORDINATE_TO_ORIGIN: !0
            })
              , i = this.ifc.LoadAllGeometry(n);
            for (let s = 0; s < i.size(); s++) {
                let o = i.get(s);
                o.geometries.size() > 0 && this.ImportIfcMesh(n, o)
            }
            this.ImportProperties(n),
            this.ifc.CloseModel(n)
        }
        ImportIfcMesh(e, t) {
            let n = new $t;
            n.SetName("Mesh " + t.expressID.toString());
            let i = 0
              , s = t.geometries;
            for (let o = 0; o < s.size(); o++) {
                let a = s.get(o)
                  , l = this.ifc.GetGeometry(e, a.geometryExpressID)
                  , c = this.ifc.GetVertexArray(l.GetVertexData(), l.GetVertexDataSize())
                  , u = this.ifc.GetIndexArray(l.GetIndexData(), l.GetIndexDataSize())
                  , h = this.GetMaterialIndexByColor(a.color)
                  , f = new Ut(a.flatTransformation)
                  , m = new en(f);
                for (let g = 0; g < c.length; g += 6) {
                    let v = c[g]
                      , p = c[g + 1]
                      , d = c[g + 2]
                      , x = new ze(v,p,d)
                      , y = m.TransformCoord3D(x);
                    n.AddVertex(y)
                }
                for (let g = 0; g < u.length; g += 3) {
                    let v = u[g]
                      , p = u[g + 1]
                      , d = u[g + 2]
                      , x = new jt(i + v,i + p,i + d);
                    x.SetMaterial(h),
                    n.AddTriangle(x)
                }
                i += c.length / 6
            }
            this.expressIDToMesh.set(t.expressID, n),
            this.model.AddMeshToRootNode(n)
        }
        ImportProperties(e) {
            let t = this.ifc.GetLineIDsWithType(e, WebIFC.IFCRELDEFINESBYPROPERTIES);
            for (let n = 0; n < t.size(); n++) {
                let i = t.get(n)
                  , s = this.ifc.GetLine(e, i);
                Array.isArray(s.RelatingPropertyDefinition) || s.RelatedObjects.forEach(o=>{
                    let a = null;
                    if (this.expressIDToMesh.has(o.value) ? a = this.expressIDToMesh.get(o.value) : this.ifc.GetLine(e, o.value, !0).type === WebIFC.IFCBUILDING && (a = this.model),
                    a === null)
                        return;
                    let l = s.RelatingPropertyDefinition
                      , c = this.ifc.GetLine(e, l.value, !0);
                    if (!c || !c.HasProperties)
                        return;
                    let u = new kn(c.Name.value);
                    c.HasProperties.forEach(h=>{
                        if (!h || !h.Name || !h.NominalValue || !h.NominalValue.constructor || h.type !== WebIFC.IFCPROPERTYSINGLEVALUE)
                            return;
                        let f = this.GetIFCString(h.Name.value)
                          , m = null
                          , g = null;
                        switch (h.NominalValue.constructor.name) {
                        case "IfcText":
                        case "IfcLabel":
                        case "IfcIdentifier":
                        case WebIFC.IFCLABEL:
                            m = new yt(dt.Text,f,this.GetIFCString(h.NominalValue.value));
                            break;
                        case "IfcBoolean":
                        case "IfcLogical":
                            g = "Unknown",
                            h.NominalValue.value === "T" ? g = "True" : h.NominalValue.value === "F" && (g = "False"),
                            m = new yt(dt.Text,f,g);
                            break;
                        case "IfcInteger":
                        case "IfcCountMeasure":
                            m = new yt(dt.Integer,f,h.NominalValue.value);
                            break;
                        case "IfcReal":
                        case "IfcLengthMeasure":
                        case "IfcPositiveLengthMeasure":
                        case "IfcAreaMeasure":
                        case "IfcVolumeMeasure":
                        case "IfcRatioMeasure":
                        case "IfcPositiveRATIOMeasure":
                        case "IfcMassMeasure":
                        case "IfcMassPerLengthMeasure":
                        case "IfcPlaneAngleMeasure":
                        case "IfcThermalTransmittanceMeasure":
                            m = new yt(dt.Number,f,h.NominalValue.value);
                            break;
                        default:
                            console.log(h);
                            break
                        }
                        m !== null && u.AddProperty(m)
                    }
                    ),
                    u.PropertyCount() > 0 && a.AddPropertyGroup(u)
                }
                )
            }
        }
        GetMaterialIndexByColor(e) {
            let t = Ii(e.x, e.y, e.z)
              , n = parseInt(e.w * 255, 10);
            return this.colorToMaterial.GetMaterialIndex(t.r, t.g, t.b, n)
        }
        GetIFCString(e) {
            let t = this.DecodeIFCString(e);
            return t.length === 0 && (t = "-"),
            t
        }
        DecodeIFCString(e) {
            let t = /\\X2\\(.*?)\\X0\\/uig
              , n = e
              , i = t.exec(e);
            for (; i; ) {
                let s = String.fromCharCode(parseInt(i[1], 16));
                n = n.replace(i[0], s),
                i = t.exec(e)
            }
            return n
        }
    }
    ;
    var Kp = class {
        constructor(e) {
            this.mesh = e,
            this.globalToMeshVertices = new Map,
            this.globalToMeshVertexColors = new Map,
            this.globalToMeshNormals = new Map,
            this.globalToMeshUvs = new Map
        }
        AddVertex(e, t) {
            return this.GetLocalIndex(e, t, this.globalToMeshVertices, n=>this.mesh.AddVertex(new ze(n.x,n.y,n.z)))
        }
        AddVertexColor(e, t) {
            return this.GetLocalIndex(e, t, this.globalToMeshVertexColors, n=>this.mesh.AddVertexColor(new rt(n.r,n.g,n.b)))
        }
        AddNormal(e, t) {
            return this.GetLocalIndex(e, t, this.globalToMeshNormals, n=>this.mesh.AddNormal(new ze(n.x,n.y,n.z)))
        }
        AddUV(e, t) {
            return this.GetLocalIndex(e, t, this.globalToMeshUvs, n=>this.mesh.AddTextureUV(new Pt(n.x,n.y)))
        }
        AddTriangle(e) {
            this.mesh.AddTriangle(e)
        }
        GetLocalIndex(e, t, n, i) {
            if (isNaN(e) || e < 0 || e >= t.length)
                return null;
            if (n.has(e))
                return n.get(e);
            {
                let s = t[e]
                  , o = i(s);
                return n.set(e, o),
                o
            }
        }
    }
    ;
    function cf(r, e, t) {
        return Ii(parseFloat(r), parseFloat(e), parseFloat(t))
    }
    var xl = class extends Kt {
        constructor() {
            super()
        }
        CanImportExtension(e) {
            return e === "obj"
        }
        GetUpDirection() {
            return lt.Y
        }
        ClearContent() {
            this.globalVertices = null,
            this.globalVertexColors = null,
            this.globalNormals = null,
            this.globalUvs = null,
            this.currentMeshConverter = null,
            this.currentMaterial = null,
            this.currentMaterialIndex = null,
            this.meshNameToConverter = null,
            this.materialNameToIndex = null
        }
        ResetContent() {
            this.globalVertices = [],
            this.globalVertexColors = [],
            this.globalNormals = [],
            this.globalUvs = [],
            this.currentMeshConverter = null,
            this.currentMaterial = null,
            this.currentMaterialIndex = null,
            this.meshNameToConverter = new Map,
            this.materialNameToIndex = new Map
        }
        ImportContent(e, t) {
            let n = wn(e);
            yi(n, i=>{
                this.WasError() || this.ProcessLine(i)
            }
            ),
            t()
        }
        ProcessLine(e) {
            if (e[0] === "#")
                return;
            let t = mr(e, "#");
            if (t.length === 0)
                return;
            let n = t[0].toLowerCase();
            t.shift(),
            !this.ProcessMeshParameter(n, t, e) && this.ProcessMaterialParameter(n, t, e)
        }
        AddNewMesh(e) {
            if (this.meshNameToConverter.has(e))
                this.currentMeshConverter = this.meshNameToConverter.get(e);
            else {
                let t = new $t;
                t.SetName(e),
                this.model.AddMeshToRootNode(t),
                this.currentMeshConverter = new Kp(t),
                this.meshNameToConverter.set(e, this.currentMeshConverter)
            }
        }
        ProcessMeshParameter(e, t, n) {
            if (e === "g" || e === "o") {
                if (t.length === 0)
                    return !0;
                let i = bs(n, e.length, "#");
                return this.AddNewMesh(i),
                !0
            } else {
                if (e === "v")
                    return t.length < 3 || (this.globalVertices.push(new ze(parseFloat(t[0]),parseFloat(t[1]),parseFloat(t[2]))),
                    t.length >= 6 && this.globalVertexColors.push(cf(t[3], t[4], t[5]))),
                    !0;
                if (e === "vn")
                    return t.length < 3 || this.globalNormals.push(new ze(parseFloat(t[0]),parseFloat(t[1]),parseFloat(t[2]))),
                    !0;
                if (e === "vt")
                    return t.length < 2 || this.globalUvs.push(new Pt(parseFloat(t[0]),parseFloat(t[1]))),
                    !0;
                if (e === "f")
                    return t.length < 3 || this.ProcessFace(t),
                    !0
            }
            return !1
        }
        ProcessMaterialParameter(e, t, n) {
            function i(o) {
                let a = new Map
                  , l = null;
                for (let c = 0; c < o.length - 1; c++) {
                    let u = o[c];
                    if (u.startsWith("-")) {
                        l = u,
                        a.set(l, []);
                        continue
                    }
                    l !== null && a.get(l).push(u)
                }
                return a
            }
            function s(o, a) {
                let l = new ui
                  , c = o[o.length - 1]
                  , u = a.getFileBuffer(c);
                l.name = c,
                l.buffer = u;
                let h = i(o);
                if (h.has("-o")) {
                    let f = h.get("-o");
                    f.length > 0 && (l.offset.x = parseFloat(f[0])),
                    f.length > 1 && (l.offset.y = parseFloat(f[1]))
                }
                if (h.has("-s")) {
                    let f = h.get("-s");
                    f.length > 0 && (l.scale.x = parseFloat(f[0])),
                    f.length > 1 && (l.scale.y = parseFloat(f[1]))
                }
                return l
            }
            if (e === "newmtl") {
                if (t.length === 0)
                    return !0;
                let o = new xn
                  , a = bs(n, e.length, "#")
                  , l = this.model.AddMaterial(o);
                return o.name = a,
                this.currentMaterial = o,
                this.materialNameToIndex.set(a, l),
                !0
            } else if (e === "usemtl") {
                if (t.length === 0)
                    return !0;
                let o = bs(n, e.length, "#");
                return this.materialNameToIndex.has(o) && (this.currentMaterialIndex = this.materialNameToIndex.get(o)),
                !0
            } else if (e === "mtllib") {
                if (t.length === 0)
                    return !0;
                let o = bs(n, e.length, "#")
                  , a = this.callbacks.getFileBuffer(o);
                if (a !== null) {
                    let l = wn(a);
                    yi(l, c=>{
                        this.WasError() || this.ProcessLine(c)
                    }
                    )
                }
                return !0
            } else {
                if (e === "map_kd")
                    return this.currentMaterial === null || t.length === 0 || (this.currentMaterial.diffuseMap = s(t, this.callbacks),
                    xi(this.currentMaterial)),
                    !0;
                if (e === "map_ks")
                    return this.currentMaterial === null || t.length === 0 || (this.currentMaterial.specularMap = s(t, this.callbacks)),
                    !0;
                if (e === "map_bump" || e === "bump")
                    return this.currentMaterial === null || t.length === 0 || (this.currentMaterial.bumpMap = s(t, this.callbacks)),
                    !0;
                if (e === "ka")
                    return this.currentMaterial === null || t.length < 3 || (this.currentMaterial.ambient = cf(t[0], t[1], t[2])),
                    !0;
                if (e === "kd")
                    return this.currentMaterial === null || t.length < 3 || (this.currentMaterial.color = cf(t[0], t[1], t[2])),
                    !0;
                if (e === "ks")
                    return this.currentMaterial === null || t.length < 3 || (this.currentMaterial.specular = cf(t[0], t[1], t[2])),
                    !0;
                if (e === "ns")
                    return this.currentMaterial === null || t.length < 1 || (this.currentMaterial.shininess = parseFloat(t[0]) / 1e3),
                    !0;
                if (e === "tr")
                    return this.currentMaterial === null || t.length < 1 || (this.currentMaterial.opacity = 1 - parseFloat(t[0]),
                    xi(this.currentMaterial)),
                    !0;
                if (e === "d")
                    return this.currentMaterial === null || t.length < 1 || (this.currentMaterial.opacity = parseFloat(t[0]),
                    xi(this.currentMaterial)),
                    !0
            }
            return !1
        }
        ProcessFace(e) {
            function t(a, l) {
                return a > 0 ? a - 1 : l + a
            }
            let n = []
              , i = []
              , s = []
              , o = [];
            for (let a = 0; a < e.length; a++) {
                let l = e[a].split("/");
                n.push(t(parseInt(l[0], 10), this.globalVertices.length)),
                this.globalVertices.length === this.globalVertexColors.length && i.push(t(parseInt(l[0], 10), this.globalVertices.length)),
                l.length > 1 && l[1].length > 0 && o.push(t(parseInt(l[1], 10), this.globalUvs.length)),
                l.length > 2 && l[2].length > 0 && s.push(t(parseInt(l[2], 10), this.globalNormals.length))
            }
            this.currentMeshConverter === null && this.AddNewMesh("");
            for (let a = 0; a < n.length - 2; a++) {
                let l = this.currentMeshConverter.AddVertex(n[0], this.globalVertices)
                  , c = this.currentMeshConverter.AddVertex(n[a + 1], this.globalVertices)
                  , u = this.currentMeshConverter.AddVertex(n[a + 2], this.globalVertices);
                if (l === null || c === null || u === null) {
                    this.SetError("Invalid vertex index.");
                    break
                }
                let h = new jt(l,c,u);
                if (i.length === n.length) {
                    let f = this.currentMeshConverter.AddVertexColor(i[0], this.globalVertexColors)
                      , m = this.currentMeshConverter.AddVertexColor(i[a + 1], this.globalVertexColors)
                      , g = this.currentMeshConverter.AddVertexColor(i[a + 2], this.globalVertexColors);
                    if (f === null || m === null || g === null) {
                        this.SetError("Invalid vertex color index.");
                        break
                    }
                    h.SetVertexColors(f, m, g)
                }
                if (s.length === n.length) {
                    let f = this.currentMeshConverter.AddNormal(s[0], this.globalNormals)
                      , m = this.currentMeshConverter.AddNormal(s[a + 1], this.globalNormals)
                      , g = this.currentMeshConverter.AddNormal(s[a + 2], this.globalNormals);
                    if (f === null || m === null || g === null) {
                        this.SetError("Invalid normal index.");
                        break
                    }
                    h.SetNormals(f, m, g)
                }
                if (o.length === n.length) {
                    let f = this.currentMeshConverter.AddUV(o[0], this.globalUvs)
                      , m = this.currentMeshConverter.AddUV(o[a + 1], this.globalUvs)
                      , g = this.currentMeshConverter.AddUV(o[a + 2], this.globalUvs);
                    if (f === null || m === null || g === null) {
                        this.SetError("Invalid uv index.");
                        break
                    }
                    h.SetTextureUVs(f, m, g)
                }
                this.currentMaterialIndex !== null && (h.mat = this.currentMaterialIndex),
                this.currentMeshConverter.AddTriangle(h)
            }
        }
    }
    ;
    var _l = class extends Kt {
        constructor() {
            super()
        }
        CanImportExtension(e) {
            return e === "off"
        }
        GetUpDirection() {
            return lt.Y
        }
        ClearContent() {
            this.mesh = null,
            this.status = null,
            this.colorToMaterial = null
        }
        ResetContent() {
            this.mesh = new $t,
            this.model.AddMeshToRootNode(this.mesh),
            this.status = {
                vertexCount: 0,
                faceCount: 0,
                foundVertex: 0,
                foundFace: 0
            },
            this.colorToMaterial = new vi(this.model)
        }
        ImportContent(e, t) {
            let n = wn(e);
            yi(n, i=>{
                this.WasError() || this.ProcessLine(i)
            }
            ),
            t()
        }
        ProcessLine(e) {
            function t(s) {
                return s.indexOf(".") !== -1 ? yn(parseFloat(s)) : parseInt(s, 10)
            }
            if (e[0] === "#")
                return;
            let n = mr(e, "#");
            if (n.length === 0 || n[0] === "OFF")
                return;
            if (this.status.vertexCount === 0 && this.status.faceCount === 0) {
                n.length > 1 && (this.status.vertexCount = parseInt(n[0], 10),
                this.status.faceCount = parseInt(n[1], 10));
                return
            }
            if (this.status.foundVertex < this.status.vertexCount) {
                n.length >= 3 && (this.mesh.AddVertex(new ze(parseFloat(n[0]),parseFloat(n[1]),parseFloat(n[2]))),
                this.status.foundVertex += 1),
                n.length >= 6 && this.mesh.AddVertexColor(new rt(t(n[3]),t(n[4]),t(n[5])));
                return
            }
            let i = this.mesh.VertexCount() === this.mesh.VertexColorCount();
            if (this.status.foundFace < this.status.faceCount) {
                if (n.length >= 4) {
                    let s = parseInt(n[0], 10);
                    if (n.length < s + 1)
                        return;
                    let o = null;
                    if (!i && n.length >= s + 4) {
                        let a = new rt(t(n[s + 1]),t(n[s + 2]),t(n[s + 3]));
                        o = this.colorToMaterial.GetMaterialIndex(a.r, a.g, a.b)
                    }
                    for (let a = 0; a < s - 2; a++) {
                        let l = parseInt(n[1])
                          , c = parseInt(n[a + 2])
                          , u = parseInt(n[a + 3])
                          , h = new jt(l,c,u);
                        i ? h.SetVertexColors(l, c, u) : h.SetMaterial(o),
                        this.mesh.AddTriangle(h)
                    }
                    this.status.foundFace += 1
                }
                return
            }
        }
    }
    ;
    var so = {
        Ok: 1,
        NoVertices: 2,
        NoFaces: 3,
        UnknownError: 4
    }
      , Zp = class {
        constructor() {
            this.format = null,
            this.elements = []
        }
        SetFormat(e) {
            this.format = e
        }
        AddElement(e, t) {
            this.elements.push({
                name: e,
                count: t,
                format: []
            })
        }
        GetElements() {
            return this.elements
        }
        AddSingleFormat(e, t) {
            this.elements[this.elements.length - 1].format.push({
                name: t,
                isSingle: !0,
                elemType: e
            })
        }
        AddListFormat(e, t, n) {
            this.elements[this.elements.length - 1].format.push({
                name: n,
                isSingle: !1,
                countType: e,
                elemType: t
            })
        }
        GetElement(e) {
            for (let t = 0; t < this.elements.length; t++) {
                let n = this.elements[t];
                if (n.name === e)
                    return n
            }
            return null
        }
        Check() {
            let e = this.GetElement("vertex");
            if (e === null || e.length === 0 || e.format.length < 3)
                return so.NoVertices;
            let t = this.GetElement("face");
            if (this.format === "ascii") {
                if (t === null || t.count === 0 || t.format.length < 0)
                    return so.NoFaces
            } else if (this.format === "binary_little_endian" || this.format === "binary_big_endian") {
                let n = this.GetElement("tristrips")
                  , i = t !== null && t.count > 0 && t.format.length > 0
                  , s = n !== null && n.count > 0 && n.format.length > 0;
                if (!i && !s)
                    return so.NoFaces
            } else
                return so.UnknownError;
            return so.Ok
        }
    }
      , Jp = class {
        constructor(e) {
            this.model = e,
            this.colorToMaterial = new Map
        }
        GetMaterialIndexByColor(e) {
            let t = "Color " + Cn(e[0]) + Cn(e[1]) + Cn(e[2]) + Cn(e[3]);
            if (this.colorToMaterial.has(t))
                return this.colorToMaterial.get(t);
            {
                let n = new xn;
                n.name = t,
                n.color = new rt(e[0],e[1],e[2]),
                n.opacity = e[3] / 255,
                xi(n);
                let i = this.model.AddMaterial(n);
                return this.colorToMaterial.set(t, i),
                i
            }
        }
    }
      , Tl = class extends Kt {
        constructor() {
            super()
        }
        CanImportExtension(e) {
            return e === "ply"
        }
        GetUpDirection() {
            return lt.Y
        }
        ClearContent() {
            this.mesh = null
        }
        ResetContent() {
            this.mesh = new $t,
            this.model.AddMeshToRootNode(this.mesh)
        }
        ImportContent(e, t) {
            let n = this.GetHeaderContent(e)
              , i = this.ReadHeader(n)
              , s = i.Check();
            if (s === so.Ok)
                if (i.format === "ascii") {
                    let o = wn(e);
                    o = o.substring(n.length),
                    this.ReadAsciiContent(i, o)
                } else
                    (i.format === "binary_little_endian" || i.format === "binary_big_endian") && this.ReadBinaryContent(i, e, n.length);
            else
                s === so.NoVertices ? this.SetError("The model contains no vertices.") : s === so.NoFaces ? this.SetError("The model contains no faces.") : this.SetError("Invalid header information.");
            t()
        }
        GetHeaderContent(e) {
            let t = ""
              , n = new Uint8Array(e)
              , i = 0;
            for (i = 0; i < e.byteLength && (t += String.fromCharCode(n[i]),
            !t.endsWith("end_header")); i++)
                ;
            for (i += 1; i < e.byteLength; ) {
                let s = String.fromCharCode(n[i]);
                if (t += s,
                i += 1,
                s === `
`)
                    break
            }
            return t
        }
        ReadHeader(e) {
            let t = new Zp;
            return yi(e, n=>{
                let i = mr(n, null);
                i.length === 0 || i[0] === "comment" || i[0] !== "ply" && (i[0] === "format" && i.length >= 2 ? t.SetFormat(i[1]) : i[0] === "element" && i.length >= 3 ? t.AddElement(i[1], parseInt(i[2], 10)) : i[0] === "property" && i.length >= 3 && (i[1] === "list" && i.length >= 5 ? t.AddListFormat(i[2], i[3], i[4]) : t.AddSingleFormat(i[1], i[2])))
            }
            ),
            t
        }
        ReadAsciiContent(e, t) {
            let n = e.GetElement("vertex")
              , i = e.GetElement("face")
              , s = 0
              , o = 0;
            yi(t, a=>{
                if (this.WasError())
                    return;
                let l = mr(a, null);
                if (!(l.length === 0 || l[0] === "comment")) {
                    if (s < n.count) {
                        l.length >= 3 && (this.mesh.AddVertex(new ze(parseFloat(l[0]),parseFloat(l[1]),parseFloat(l[2]))),
                        s += 1);
                        return
                    }
                    if (i !== null && o < i.count) {
                        if (l.length >= 4) {
                            let c = parseInt(l[0], 10);
                            if (l.length < c + 1)
                                return;
                            for (let u = 0; u < c - 2; u++) {
                                let h = parseInt(l[1])
                                  , f = parseInt(l[u + 2])
                                  , m = parseInt(l[u + 3])
                                  , g = new jt(h,f,m);
                                this.mesh.AddTriangle(g)
                            }
                            o += 1
                        }
                        return
                    }
                }
            }
            )
        }
        ReadBinaryContent(e, t, n) {
            function i(u, h) {
                function f(m, g) {
                    return g === "char" || g === "int8" ? m.ReadCharacter8() : g === "uchar" || g === "uint8" ? m.ReadUnsignedCharacter8() : g === "short" || g === "int16" ? m.ReadInteger16() : g === "ushort" || g === "uint16" ? m.ReadUnsignedInteger16() : g === "int" || g === "int32" ? m.ReadInteger32() : g === "uint" || g === "uint32" ? m.ReadUnsignedInteger32() : g === "float" || g === "float32" ? m.ReadFloat32() : g === "double" || g === "double64" ? m.ReadDouble64() : null
                }
                if (h.isSingle)
                    return f(u, h.elemType);
                {
                    let m = []
                      , g = f(u, h.countType);
                    for (let v = 0; v < g; v++)
                        m.push(f(u, h.elemType));
                    return m
                }
            }
            function s(u, h, f) {
                for (let m = f; m < h.length; m++)
                    i(u, h[m])
            }
            function o(u, h, f) {
                let m = null
                  , g = null
                  , v = null
                  , p = 255;
                for (let d = f; d < h.length; d++) {
                    let x = h[d]
                      , y = i(u, x);
                    x.name === "red" ? m = y : x.name === "green" ? g = y : x.name === "blue" ? v = y : x.name === "alpha" && (p = y)
                }
                return m !== null && g !== null && v !== null ? [m, g, v, p] : null
            }
            let a = null;
            if (e.format === "binary_little_endian")
                a = new si(t,!0);
            else if (e.format === "binary_big_endian")
                a = new si(t,!1);
            else
                return;
            a.Skip(n);
            let l = new Jp(this.model)
              , c = e.GetElements();
            for (let u = 0; u < c.length; u++) {
                let h = c[u];
                if (h.name === "vertex")
                    for (let f = 0; f < h.count; f++) {
                        let m = i(a, h.format[0])
                          , g = i(a, h.format[1])
                          , v = i(a, h.format[2])
                          , p = o(a, h.format, 3);
                        p !== null && this.mesh.AddVertexColor(new rt(p[0],p[1],p[2])),
                        this.mesh.AddVertex(new ze(m,g,v))
                    }
                else if (h.name === "face")
                    for (let f = 0; f < h.count; f++) {
                        let m = i(a, h.format[0])
                          , g = o(a, h.format, 1);
                        for (let v = 0; v < m.length - 2; v++) {
                            let p = m[0]
                              , d = m[v + 1]
                              , x = m[v + 2]
                              , y = new jt(p,d,x);
                            g !== null ? y.mat = l.GetMaterialIndexByColor(g) : this.mesh.VertexColorCount() > 0 && y.SetVertexColors(p, d, x),
                            this.mesh.AddTriangle(y)
                        }
                    }
                else if (h.name === "tristrips")
                    for (let f = 0; f < h.count; f++) {
                        let m = i(a, h.format[0]);
                        s(a, h.format, 1);
                        let g = !0;
                        for (let v = 0; v < m.length - 2; v++) {
                            let p = m[v]
                              , d = m[v + 1]
                              , x = m[v + 2];
                            if (x === -1) {
                                v += 2,
                                g = !0;
                                continue
                            }
                            if (!g) {
                                let _ = d;
                                d = x,
                                x = _
                            }
                            g = !g;
                            let y = new jt(p,d,x);
                            this.mesh.AddTriangle(y)
                        }
                    }
                else
                    s(a, h.format, 0)
            }
        }
    }
    ;
    var bl = class extends Kt {
        constructor() {
            super(),
            this.worker = null
        }
        CanImportExtension(e) {
            return e === "stp" || e === "step" || e === "igs" || e === "iges" || e === "brp" || e === "brep"
        }
        GetUpDirection() {
            return lt.Y
        }
        ClearContent() {
            this.worker !== null && (this.worker.terminate(),
            this.worker = null)
        }
        ResetContent() {
            this.worker = null
        }
        ImportContent(e, t) {
            let n = _o("loaders/occt-import-js-worker.js");
            this.worker = new Worker(n),
            this.worker.addEventListener("message", o=>{
                this.ImportResultJson(o.data, t)
            }
            ),
            this.worker.addEventListener("error", o=>{
                this.SetError("Failed to load occt-import-js."),
                t()
            }
            );
            let i = null;
            if (this.extension === "stp" || this.extension === "step")
                i = "step";
            else if (this.extension === "igs" || this.extension === "iges")
                i = "iges";
            else if (this.extension === "brp" || this.extension === "brep")
                i = "brep";
            else {
                t();
                return
            }
            let s = new Uint8Array(e);
            this.worker.postMessage({
                format: i,
                buffer: s,
                params: null
            })
        }
        ImportResultJson(e, t) {
            if (!e.success) {
                t();
                return
            }
            let n = new vi(this.model)
              , i = this.model.GetRootNode();
            this.ImportNode(e, e.root, i, n),
            t()
        }
        ImportNode(e, t, n, i) {
            for (let s of t.meshes) {
                let o = e.meshes[s]
                  , a = this.ImportMesh(o, i)
                  , l = this.model.AddMesh(a);
                n.AddMeshIndex(l)
            }
            for (let s of t.children) {
                let o = new Fn;
                o.SetName(s.name),
                n.AddChildNode(o),
                this.ImportNode(e, s, o, i)
            }
        }
        ImportMesh(e, t) {
            let n = null;
            if (e.color) {
                let s = Ii(e.color[0], e.color[1], e.color[2]);
                n = t.GetMaterialIndex(s.r, s.g, s.b, null)
            }
            let i = dr(e, n, null);
            e.name && i.SetName(e.name);
            for (let s of e.brep_faces) {
                if (s.color === null)
                    continue;
                let o = Ii(s.color[0], s.color[1], s.color[2])
                  , a = t.GetMaterialIndex(o.r, o.g, o.b, null);
                for (let l = s.first; l <= s.last; l++)
                    i.GetTriangle(l).SetMaterial(a)
            }
            return i
        }
    }
    ;
    var Ml = class extends Kt {
        constructor() {
            super()
        }
        CanImportExtension(e) {
            return e === "stl"
        }
        GetUpDirection() {
            return lt.Z
        }
        ClearContent() {
            this.mesh = null,
            this.triangle = null
        }
        ResetContent() {
            this.mesh = new $t,
            this.model.AddMeshToRootNode(this.mesh),
            this.triangle = null
        }
        ImportContent(e, t) {
            if (this.IsBinaryStlFile(e))
                this.ProcessBinary(e);
            else {
                let n = wn(e);
                yi(n, i=>{
                    this.WasError() || this.ProcessLine(i)
                }
                )
            }
            t()
        }
        IsBinaryStlFile(e) {
            let t = e.byteLength;
            if (t < 84)
                return !1;
            let n = new si(e,!0);
            n.Skip(80);
            let i = n.ReadUnsignedInteger32();
            return t === i * 50 + 84
        }
        ProcessLine(e) {
            if (e[0] === "#")
                return;
            let t = mr(e, "#");
            if (t.length === 0)
                return;
            let n = t[0];
            if (n === "solid") {
                if (t.length > 1) {
                    let i = bs(e, n.length, "#");
                    this.mesh.SetName(i)
                }
                return
            }
            if (n === "facet") {
                if (this.triangle = new jt(-1,-1,-1),
                t.length >= 5 && t[1] === "normal") {
                    let i = new ze(parseFloat(t[2]),parseFloat(t[3]),parseFloat(t[4]));
                    if (zi(i.Length())) {
                        let s = this.mesh.AddNormal(i);
                        this.triangle.SetNormals(s, s, s)
                    }
                }
                return
            }
            if (n === "vertex" && this.triangle !== null) {
                if (t.length >= 4) {
                    let i = this.mesh.AddVertex(new ze(parseFloat(t[1]),parseFloat(t[2]),parseFloat(t[3])));
                    this.triangle.v0 === -1 ? this.triangle.v0 = i : this.triangle.v1 === -1 ? this.triangle.v1 = i : this.triangle.v2 === -1 && (this.triangle.v2 = i)
                }
                return
            }
            if (n === "endfacet" && this.triangle !== null) {
                this.triangle.v0 !== -1 && this.triangle.v1 !== -1 && this.triangle.v2 !== null && this.mesh.AddTriangle(this.triangle),
                this.triangle = null;
                return
            }
        }
        ProcessBinary(e) {
            function t(o) {
                let a = new ze;
                return a.x = o.ReadFloat32(),
                a.y = o.ReadFloat32(),
                a.z = o.ReadFloat32(),
                a
            }
            function n(o, a) {
                let l = t(a);
                return o.AddVertex(l)
            }
            let i = new si(e,!0);
            i.Skip(80);
            let s = i.ReadUnsignedInteger32();
            for (let o = 0; o < s; o++) {
                let a = t(i)
                  , l = n(this.mesh, i)
                  , c = n(this.mesh, i)
                  , u = n(this.mesh, i);
                i.Skip(2);
                let h = new jt(l,c,u);
                if (zi(a.Length())) {
                    let f = this.mesh.AddNormal(a);
                    h.SetNormals(f, f, f)
                }
                this.mesh.AddTriangle(h)
            }
        }
    }
    ;
    var El = class extends Kt {
        constructor() {
            super()
        }
        CanImportExtension(e) {
            return e === "bim"
        }
        GetUpDirection() {
            return lt.Z
        }
        ClearContent() {
            this.meshIdToMesh = null,
            this.colorToMaterial = null
        }
        ResetContent() {
            this.meshIdToMesh = new Map,
            this.colorToMaterial = new vi(this.model)
        }
        ImportContent(e, t) {
            let n = wn(e)
              , i = null;
            try {
                i = JSON.parse(n)
            } catch {
                this.SetError("Failed to parse bim file."),
                t();
                return
            }
            for (let s of i.meshes)
                this.meshIdToMesh.set(s.mesh_id, s);
            this.ImportProperties(i, this.model);
            for (let s of i.elements) {
                let o = this.ImportElement(s);
                o.SetName(s.type),
                this.ImportProperties(s, o)
            }
            t()
        }
        ImportElement(e) {
            let t = this.colorToMaterial.GetMaterialIndex(e.color.r, e.color.g, e.color.b, e.color.a)
              , n = this.model.GetRootNode()
              , i = this.meshIdToMesh.get(e.mesh_id)
              , s = this.ImportMesh(i, f=>e.face_colors ? this.colorToMaterial.GetMaterialIndex(e.face_colors[f * 4 + 0], e.face_colors[f * 4 + 1], e.face_colors[f * 4 + 2], e.face_colors[f * 4 + 3]) : t)
              , o = this.model.AddMesh(s)
              , a = new Fn;
            a.AddMeshIndex(o);
            let l = new ze(0,0,0);
            e.vector && (l = new ze(e.vector.x,e.vector.y,e.vector.z));
            let c = new ri(0,0,0,1);
            e.rotation && (c = new ri(e.rotation.qx,e.rotation.qy,e.rotation.qz,e.rotation.qw));
            let u = new ze(1,1,1)
              , h = new Ut().ComposeTRS(l, c, u);
            return a.SetTransformation(new en(h)),
            n.AddChildNode(a),
            s
        }
        ImportMesh(e, t) {
            let n = new $t;
            for (let i = 0; i < e.coordinates.length; i += 3)
                n.AddVertex(new ze(e.coordinates[i + 0],e.coordinates[i + 1],e.coordinates[i + 2]));
            for (let i = 0; i < e.indices.length; i += 3) {
                let s = new jt(e.indices[i + 0],e.indices[i + 1],e.indices[i + 2]);
                s.SetMaterial(t(i / 3)),
                n.AddTriangle(s)
            }
            return n
        }
        ImportProperties(e, t) {
            function n(o, a, l) {
                if (l == null)
                    return;
                let c = new yt(dt.Text,a,l);
                o.AddProperty(c)
            }
            if (!e.info || rf(e.info))
                return;
            let i = e.info
              , s = new kn("Info");
            n(s, "Guid", e.guid),
            n(s, "Type", e.type);
            for (let o in i)
                Object.prototype.hasOwnProperty.call(i, o) && typeof i[o] == "string" && n(s, o, i[o]);
            t.AddPropertyGroup(s)
        }
    }
    ;
    var oo = class extends Oh {
        constructor(e) {
            super(e)
        }
        parse(e) {
            function t(L) {
                switch (L.image_type) {
                case f:
                case v:
                    (L.colormap_length > 256 || L.colormap_size !== 24 || L.colormap_type !== 1) && console.error("THREE.TGALoader: Invalid type colormap data for indexed type.");
                    break;
                case m:
                case g:
                case p:
                case d:
                    L.colormap_type && console.error("THREE.TGALoader: Invalid type colormap data for colormap type.");
                    break;
                case h:
                    console.error("THREE.TGALoader: No data.");
                default:
                    console.error('THREE.TGALoader: Invalid type "%s".', L.image_type)
                }
                (L.width <= 0 || L.height <= 0) && console.error("THREE.TGALoader: Invalid image size."),
                L.pixel_size !== 8 && L.pixel_size !== 16 && L.pixel_size !== 24 && L.pixel_size !== 32 && console.error('THREE.TGALoader: Invalid pixel size "%s".', L.pixel_size)
            }
            function n(L, F, U, W, K) {
                let re, oe, j = U.pixel_size >> 3, w = U.width * U.height * j;
                if (F && (oe = K.subarray(W, W += U.colormap_length * (U.colormap_size >> 3))),
                L) {
                    re = new Uint8Array(w);
                    let b, E, T, H = 0, Y = new Uint8Array(j);
                    for (; H < w; )
                        if (b = K[W++],
                        E = (b & 127) + 1,
                        b & 128) {
                            for (T = 0; T < j; ++T)
                                Y[T] = K[W++];
                            for (T = 0; T < E; ++T)
                                re.set(Y, H + T * j);
                            H += j * E
                        } else {
                            for (E *= j,
                            T = 0; T < E; ++T)
                                re[H + T] = K[W++];
                            H += E
                        }
                } else
                    re = K.subarray(W, W += F ? U.width * U.height : w);
                return {
                    pixel_data: re,
                    palettes: oe
                }
            }
            function i(L, F, U, W, K, re, oe, j, w) {
                let b = w, E, T = 0, H, Y, X = R.width;
                for (Y = F; Y !== W; Y += U)
                    for (H = K; H !== oe; H += re,
                    T++)
                        E = j[T],
                        L[(H + X * Y) * 4 + 3] = 255,
                        L[(H + X * Y) * 4 + 2] = b[E * 3 + 0],
                        L[(H + X * Y) * 4 + 1] = b[E * 3 + 1],
                        L[(H + X * Y) * 4 + 0] = b[E * 3 + 2];
                return L
            }
            function s(L, F, U, W, K, re, oe, j) {
                let w, b = 0, E, T, H = R.width;
                for (T = F; T !== W; T += U)
                    for (E = K; E !== oe; E += re,
                    b += 2)
                        w = j[b + 0] + (j[b + 1] << 8),
                        L[(E + H * T) * 4 + 0] = (w & 31744) >> 7,
                        L[(E + H * T) * 4 + 1] = (w & 992) >> 2,
                        L[(E + H * T) * 4 + 2] = (w & 31) << 3,
                        L[(E + H * T) * 4 + 3] = w & 32768 ? 0 : 255;
                return L
            }
            function o(L, F, U, W, K, re, oe, j) {
                let w = 0, b, E, T = R.width;
                for (E = F; E !== W; E += U)
                    for (b = K; b !== oe; b += re,
                    w += 3)
                        L[(b + T * E) * 4 + 3] = 255,
                        L[(b + T * E) * 4 + 2] = j[w + 0],
                        L[(b + T * E) * 4 + 1] = j[w + 1],
                        L[(b + T * E) * 4 + 0] = j[w + 2];
                return L
            }
            function a(L, F, U, W, K, re, oe, j) {
                let w = 0, b, E, T = R.width;
                for (E = F; E !== W; E += U)
                    for (b = K; b !== oe; b += re,
                    w += 4)
                        L[(b + T * E) * 4 + 2] = j[w + 0],
                        L[(b + T * E) * 4 + 1] = j[w + 1],
                        L[(b + T * E) * 4 + 0] = j[w + 2],
                        L[(b + T * E) * 4 + 3] = j[w + 3];
                return L
            }
            function l(L, F, U, W, K, re, oe, j) {
                let w, b = 0, E, T, H = R.width;
                for (T = F; T !== W; T += U)
                    for (E = K; E !== oe; E += re,
                    b++)
                        w = j[b],
                        L[(E + H * T) * 4 + 0] = w,
                        L[(E + H * T) * 4 + 1] = w,
                        L[(E + H * T) * 4 + 2] = w,
                        L[(E + H * T) * 4 + 3] = 255;
                return L
            }
            function c(L, F, U, W, K, re, oe, j) {
                let w = 0, b, E, T = R.width;
                for (E = F; E !== W; E += U)
                    for (b = K; b !== oe; b += re,
                    w += 2)
                        L[(b + T * E) * 4 + 0] = j[w + 0],
                        L[(b + T * E) * 4 + 1] = j[w + 0],
                        L[(b + T * E) * 4 + 2] = j[w + 0],
                        L[(b + T * E) * 4 + 3] = j[w + 1];
                return L
            }
            function u(L, F, U, W, K) {
                let re, oe, j, w, b, E;
                switch ((R.flags & x) >> y) {
                default:
                case N:
                    re = 0,
                    j = 1,
                    b = F,
                    oe = 0,
                    w = 1,
                    E = U;
                    break;
                case _:
                    re = 0,
                    j = 1,
                    b = F,
                    oe = U - 1,
                    w = -1,
                    E = -1;
                    break;
                case I:
                    re = F - 1,
                    j = -1,
                    b = -1,
                    oe = 0,
                    w = 1,
                    E = U;
                    break;
                case S:
                    re = F - 1,
                    j = -1,
                    b = -1,
                    oe = U - 1,
                    w = -1,
                    E = -1;
                    break
                }
                if (B)
                    switch (R.pixel_size) {
                    case 8:
                        l(L, oe, w, E, re, j, b, W);
                        break;
                    case 16:
                        c(L, oe, w, E, re, j, b, W);
                        break;
                    default:
                        console.error("THREE.TGALoader: Format not supported.");
                        break
                    }
                else
                    switch (R.pixel_size) {
                    case 8:
                        i(L, oe, w, E, re, j, b, W, K);
                        break;
                    case 16:
                        s(L, oe, w, E, re, j, b, W);
                        break;
                    case 24:
                        o(L, oe, w, E, re, j, b, W);
                        break;
                    case 32:
                        a(L, oe, w, E, re, j, b, W);
                        break;
                    default:
                        console.error("THREE.TGALoader: Format not supported.");
                        break
                    }
                return L
            }
            let h = 0
              , f = 1
              , m = 2
              , g = 3
              , v = 9
              , p = 10
              , d = 11
              , x = 48
              , y = 4
              , _ = 0
              , S = 1
              , N = 2
              , I = 3;
            e.length < 19 && console.error("THREE.TGALoader: Not enough data to contain header.");
            let O = 0
              , M = new Uint8Array(e)
              , R = {
                id_length: M[O++],
                colormap_type: M[O++],
                image_type: M[O++],
                colormap_index: M[O++] | M[O++] << 8,
                colormap_length: M[O++] | M[O++] << 8,
                colormap_size: M[O++],
                origin: [M[O++] | M[O++] << 8, M[O++] | M[O++] << 8],
                width: M[O++] | M[O++] << 8,
                height: M[O++] | M[O++] << 8,
                pixel_size: M[O++],
                flags: M[O++]
            };
            t(R),
            R.id_length + O > e.length && console.error("THREE.TGALoader: No data."),
            O += R.id_length;
            let q = !1
              , k = !1
              , B = !1;
            switch (R.image_type) {
            case v:
                q = !0,
                k = !0;
                break;
            case f:
                k = !0;
                break;
            case p:
                q = !0;
                break;
            case m:
                break;
            case d:
                q = !0,
                B = !0;
                break;
            case g:
                B = !0;
                break
            }
            let P = new Uint8Array(R.width * R.height * 4)
              , C = n(q, k, R, O, M);
            return u(P, R.width, R.height, C.pixel_data, C.palettes),
            {
                data: P,
                width: R.width,
                height: R.height,
                flipY: !0,
                generateMipmaps: !0,
                minFilter: lr
            }
        }
    }
    ;
    var Vv = function(r) {
        return URL.createObjectURL(new Blob([r],{
            type: "text/javascript"
        }))
    }
      , rw = function(r) {
        return new Worker(r)
    };
    try {
        URL.revokeObjectURL(Vv(""))
    } catch {
        Vv = function(e) {
            return "data:application/javascript;charset=UTF-8," + encodeURI(e)
        }
        ,
        rw = function(e) {
            return new Worker(e,{
                type: "module"
            })
        }
    }
    var ki = Uint8Array
      , ao = Uint16Array
      , tm = Uint32Array
      , zv = new ki([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0])
      , Hv = new ki([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0])
      , sw = new ki([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
      , Wv = function(r, e) {
        for (var t = new ao(31), n = 0; n < 31; ++n)
            t[n] = e += 1 << r[n - 1];
        for (var i = new tm(t[30]), n = 1; n < 30; ++n)
            for (var s = t[n]; s < t[n + 1]; ++s)
                i[s] = s - t[n] << 5 | n;
        return [t, i]
    }
      , Xv = Wv(zv, 2)
      , jv = Xv[0]
      , ow = Xv[1];
    jv[28] = 258,
    ow[258] = 28;
    var qv = Wv(Hv, 0)
      , aw = qv[0]
      , kR = qv[1]
      , nm = new ao(32768);
    for (Bt = 0; Bt < 32768; ++Bt)
        Es = (Bt & 43690) >>> 1 | (Bt & 21845) << 1,
        Es = (Es & 52428) >>> 2 | (Es & 13107) << 2,
        Es = (Es & 61680) >>> 4 | (Es & 3855) << 4,
        nm[Bt] = ((Es & 65280) >>> 8 | (Es & 255) << 8) >>> 1;
    var Es, Bt, tu = function(r, e, t) {
        for (var n = r.length, i = 0, s = new ao(e); i < n; ++i)
            ++s[r[i] - 1];
        var o = new ao(e);
        for (i = 0; i < e; ++i)
            o[i] = o[i - 1] + s[i - 1] << 1;
        var a;
        if (t) {
            a = new ao(1 << e);
            var l = 15 - e;
            for (i = 0; i < n; ++i)
                if (r[i])
                    for (var c = i << 4 | r[i], u = e - r[i], h = o[r[i] - 1]++ << u, f = h | (1 << u) - 1; h <= f; ++h)
                        a[nm[h] >>> l] = c
        } else
            for (a = new ao(n),
            i = 0; i < n; ++i)
                r[i] && (a[i] = nm[o[r[i] - 1]++] >>> 15 - r[i]);
        return a
    }, nu = new ki(288);
    for (Bt = 0; Bt < 144; ++Bt)
        nu[Bt] = 8;
    var Bt;
    for (Bt = 144; Bt < 256; ++Bt)
        nu[Bt] = 9;
    var Bt;
    for (Bt = 256; Bt < 280; ++Bt)
        nu[Bt] = 7;
    var Bt;
    for (Bt = 280; Bt < 288; ++Bt)
        nu[Bt] = 8;
    var Bt, Yv = new ki(32);
    for (Bt = 0; Bt < 32; ++Bt)
        Yv[Bt] = 5;
    var Bt;
    var lw = tu(nu, 9, 1);
    var cw = tu(Yv, 5, 1)
      , $p = function(r) {
        for (var e = r[0], t = 1; t < r.length; ++t)
            r[t] > e && (e = r[t]);
        return e
    }
      , vr = function(r, e, t) {
        var n = e / 8 | 0;
        return (r[n] | r[n + 1] << 8) >> (e & 7) & t
    }
      , Qp = function(r, e) {
        var t = e / 8 | 0;
        return (r[t] | r[t + 1] << 8 | r[t + 2] << 16) >> (e & 7)
    }
      , uw = function(r) {
        return (r / 8 | 0) + (r & 7 && 1)
    }
      , rm = function(r, e, t) {
        (e == null || e < 0) && (e = 0),
        (t == null || t > r.length) && (t = r.length);
        var n = new (r instanceof ao ? ao : r instanceof tm ? tm : ki)(t - e);
        return n.set(r.subarray(e, t)),
        n
    }
      , Kv = function(r, e, t) {
        var n = r.length;
        if (!n || t && !t.l && n < 5)
            return e || new ki(0);
        var i = !e || t
          , s = !t || t.i;
        t || (t = {}),
        e || (e = new ki(n * 3));
        var o = function(E) {
            var T = e.length;
            if (E > T) {
                var H = new ki(Math.max(T * 2, E));
                H.set(e),
                e = H
            }
        }
          , a = t.f || 0
          , l = t.p || 0
          , c = t.b || 0
          , u = t.l
          , h = t.d
          , f = t.m
          , m = t.n
          , g = n * 8;
        do {
            if (!u) {
                t.f = a = vr(r, l, 1);
                var v = vr(r, l + 1, 3);
                if (l += 3,
                v)
                    if (v == 1)
                        u = lw,
                        h = cw,
                        f = 9,
                        m = 5;
                    else if (v == 2) {
                        var y = vr(r, l, 31) + 257
                          , _ = vr(r, l + 10, 15) + 4
                          , S = y + vr(r, l + 5, 31) + 1;
                        l += 14;
                        for (var N = new ki(S), I = new ki(19), O = 0; O < _; ++O)
                            I[sw[O]] = vr(r, l + O * 3, 7);
                        l += _ * 3;
                        for (var M = $p(I), R = (1 << M) - 1, q = tu(I, M, 1), O = 0; O < S; ) {
                            var k = q[vr(r, l, R)];
                            l += k & 15;
                            var p = k >>> 4;
                            if (p < 16)
                                N[O++] = p;
                            else {
                                var B = 0
                                  , P = 0;
                                for (p == 16 ? (P = 3 + vr(r, l, 3),
                                l += 2,
                                B = N[O - 1]) : p == 17 ? (P = 3 + vr(r, l, 7),
                                l += 3) : p == 18 && (P = 11 + vr(r, l, 127),
                                l += 7); P--; )
                                    N[O++] = B
                            }
                        }
                        var C = N.subarray(0, y)
                          , L = N.subarray(y);
                        f = $p(C),
                        m = $p(L),
                        u = tu(C, f, 1),
                        h = tu(L, m, 1)
                    } else
                        throw "invalid block type";
                else {
                    var p = uw(l) + 4
                      , d = r[p - 4] | r[p - 3] << 8
                      , x = p + d;
                    if (x > n) {
                        if (s)
                            throw "unexpected EOF";
                        break
                    }
                    i && o(c + d),
                    e.set(r.subarray(p, x), c),
                    t.b = c += d,
                    t.p = l = x * 8;
                    continue
                }
                if (l > g) {
                    if (s)
                        throw "unexpected EOF";
                    break
                }
            }
            i && o(c + 131072);
            for (var F = (1 << f) - 1, U = (1 << m) - 1, W = l; ; W = l) {
                var B = u[Qp(r, l) & F]
                  , K = B >>> 4;
                if (l += B & 15,
                l > g) {
                    if (s)
                        throw "unexpected EOF";
                    break
                }
                if (!B)
                    throw "invalid length/literal";
                if (K < 256)
                    e[c++] = K;
                else if (K == 256) {
                    W = l,
                    u = null;
                    break
                } else {
                    var re = K - 254;
                    if (K > 264) {
                        var O = K - 257
                          , oe = zv[O];
                        re = vr(r, l, (1 << oe) - 1) + jv[O],
                        l += oe
                    }
                    var j = h[Qp(r, l) & U]
                      , w = j >>> 4;
                    if (!j)
                        throw "invalid distance";
                    l += j & 15;
                    var L = aw[w];
                    if (w > 3) {
                        var oe = Hv[w];
                        L += Qp(r, l) & (1 << oe) - 1,
                        l += oe
                    }
                    if (l > g) {
                        if (s)
                            throw "unexpected EOF";
                        break
                    }
                    i && o(c + 131072);
                    for (var b = c + re; c < b; c += 4)
                        e[c] = e[c - L],
                        e[c + 1] = e[c + 1 - L],
                        e[c + 2] = e[c + 2 - L],
                        e[c + 3] = e[c + 3 - L];
                    c = b
                }
            }
            t.l = u,
            t.p = W,
            t.b = c,
            u && (a = 1,
            t.m = f,
            t.d = h,
            t.n = m)
        } while (!a);
        return c == e.length ? e : rm(e, 0, c)
    };
    var hw = new ki(0);
    var Wr = function(r, e) {
        return r[e] | r[e + 1] << 8
    }
      , yr = function(r, e) {
        return (r[e] | r[e + 1] << 8 | r[e + 2] << 16 | r[e + 3] << 24) >>> 0
    }
      , em = function(r, e) {
        return yr(r, e) + yr(r, e + 4) * 4294967296
    };
    var fw = function(r) {
        if ((r[0] & 15) != 8 || r[0] >>> 4 > 7 || (r[0] << 8 | r[1]) % 31)
            throw "invalid zlib data";
        if (r[1] & 32)
            throw "invalid zlib data: preset dictionaries not supported"
    };
    function dw(r, e) {
        return Kv(r, e)
    }
    function Zv(r, e) {
        return Kv((fw(r),
        r.subarray(2, -4)), e)
    }
    var im = typeof TextDecoder < "u" && new TextDecoder
      , pw = 0;
    try {
        im.decode(hw, {
            stream: !0
        }),
        pw = 1
    } catch {}
    var mw = function(r) {
        for (var e = "", t = 0; ; ) {
            var n = r[t++]
              , i = (n > 127) + (n > 223) + (n > 239);
            if (t + i > r.length)
                return [e, rm(r, t - 1)];
            i ? i == 3 ? (n = ((n & 15) << 18 | (r[t++] & 63) << 12 | (r[t++] & 63) << 6 | r[t++] & 63) - 65536,
            e += String.fromCharCode(55296 | n >> 10, 56320 | n & 1023)) : i & 1 ? e += String.fromCharCode((n & 31) << 6 | r[t++] & 63) : e += String.fromCharCode((n & 15) << 12 | (r[t++] & 63) << 6 | r[t++] & 63) : e += String.fromCharCode(n)
        }
    };
    function gw(r, e) {
        if (e) {
            for (var t = "", n = 0; n < r.length; n += 16384)
                t += String.fromCharCode.apply(null, r.subarray(n, n + 16384));
            return t
        } else {
            if (im)
                return im.decode(r);
            var i = mw(r)
              , s = i[0]
              , o = i[1];
            if (o.length)
                throw "invalid utf-8 data";
            return s
        }
    }
    var vw = function(r, e) {
        return e + 30 + Wr(r, e + 26) + Wr(r, e + 28)
    }
      , yw = function(r, e, t) {
        var n = Wr(r, e + 28)
          , i = gw(r.subarray(e + 46, e + 46 + n), !(Wr(r, e + 8) & 2048))
          , s = e + 46 + n
          , o = yr(r, e + 20)
          , a = t && o == 4294967295 ? xw(r, s) : [o, yr(r, e + 24), yr(r, e + 42)]
          , l = a[0]
          , c = a[1]
          , u = a[2];
        return [Wr(r, e + 10), l, c, i, s + Wr(r, e + 30) + Wr(r, e + 32), u]
    }
      , xw = function(r, e) {
        for (; Wr(r, e) != 1; e += 4 + Wr(r, e + 2))
            ;
        return [em(r, e + 12), em(r, e + 4), em(r, e + 20)]
    };
    function Jv(r) {
        for (var e = {}, t = r.length - 22; yr(r, t) != 101010256; --t)
            if (!t || r.length - t > 65558)
                throw "invalid zip file";
        var n = Wr(r, t + 8);
        if (!n)
            return {};
        var i = yr(r, t + 16)
          , s = i == 4294967295;
        if (s) {
            if (t = yr(r, t - 12),
            yr(r, t) != 101075792)
                throw "invalid zip file";
            n = yr(r, t + 32),
            i = yr(r, t + 48)
        }
        for (var o = 0; o < n; ++o) {
            var a = yw(r, i, s)
              , l = a[0]
              , c = a[1]
              , u = a[2]
              , h = a[3]
              , f = a[4]
              , m = a[5]
              , g = vw(r, m);
            if (i = f,
            !l)
                e[h] = rm(r, g, g + c);
            else if (l == 8)
                e[h] = dw(r.subarray(g, g + c), new ki(u));
            else
                throw "unknown compression type " + l
        }
        return e
    }
    function Qv(r, e, t) {
        let n = t.length - r - 1;
        if (e >= t[n])
            return n - 1;
        if (e <= t[r])
            return r;
        let i = r
          , s = n
          , o = Math.floor((i + s) / 2);
        for (; e < t[o] || e >= t[o + 1]; )
            e < t[o] ? s = o : i = o,
            o = Math.floor((i + s) / 2);
        return o
    }
    function _w(r, e, t, n) {
        let i = []
          , s = []
          , o = [];
        i[0] = 1;
        for (let a = 1; a <= t; ++a) {
            s[a] = e - n[r + 1 - a],
            o[a] = n[r + a] - e;
            let l = 0;
            for (let c = 0; c < a; ++c) {
                let u = o[c + 1]
                  , h = s[a - c]
                  , f = i[c] / (u + h);
                i[c] = l + u * f,
                l = h * f
            }
            i[a] = l
        }
        return i
    }
    function ey(r, e, t, n) {
        let i = Qv(r, n, e)
          , s = _w(i, n, r, e)
          , o = new Lt(0,0,0,0);
        for (let a = 0; a <= r; ++a) {
            let l = t[i - r + a]
              , c = s[a]
              , u = l.w * c;
            o.x += l.x * u,
            o.y += l.y * u,
            o.z += l.z * u,
            o.w += l.w * c
        }
        return o
    }
    function Tw(r, e, t, n, i) {
        let s = [];
        for (let h = 0; h <= t; ++h)
            s[h] = 0;
        let o = [];
        for (let h = 0; h <= n; ++h)
            o[h] = s.slice(0);
        let a = [];
        for (let h = 0; h <= t; ++h)
            a[h] = s.slice(0);
        a[0][0] = 1;
        let l = s.slice(0)
          , c = s.slice(0);
        for (let h = 1; h <= t; ++h) {
            l[h] = e - i[r + 1 - h],
            c[h] = i[r + h] - e;
            let f = 0;
            for (let m = 0; m < h; ++m) {
                let g = c[m + 1]
                  , v = l[h - m];
                a[h][m] = g + v;
                let p = a[m][h - 1] / a[h][m];
                a[m][h] = f + g * p,
                f = v * p
            }
            a[h][h] = f
        }
        for (let h = 0; h <= t; ++h)
            o[0][h] = a[h][t];
        for (let h = 0; h <= t; ++h) {
            let f = 0
              , m = 1
              , g = [];
            for (let v = 0; v <= t; ++v)
                g[v] = s.slice(0);
            g[0][0] = 1;
            for (let v = 1; v <= n; ++v) {
                let p = 0
                  , d = h - v
                  , x = t - v;
                h >= v && (g[m][0] = g[f][0] / a[x + 1][d],
                p = g[m][0] * a[d][x]);
                let y = d >= -1 ? 1 : -d
                  , _ = h - 1 <= x ? v - 1 : t - h;
                for (let N = y; N <= _; ++N)
                    g[m][N] = (g[f][N] - g[f][N - 1]) / a[x + 1][d + N],
                    p += g[m][N] * a[d + N][x];
                h <= x && (g[m][v] = -g[f][v - 1] / a[x + 1][h],
                p += g[m][v] * a[h][x]),
                o[v][h] = p;
                let S = f;
                f = m,
                m = S
            }
        }
        let u = t;
        for (let h = 1; h <= n; ++h) {
            for (let f = 0; f <= t; ++f)
                o[h][f] *= u;
            u *= t - h
        }
        return o
    }
    function bw(r, e, t, n, i) {
        let s = i < r ? i : r
          , o = []
          , a = Qv(r, n, e)
          , l = Tw(a, n, r, s, e)
          , c = [];
        for (let u = 0; u < t.length; ++u) {
            let h = t[u].clone()
              , f = h.w;
            h.x *= f,
            h.y *= f,
            h.z *= f,
            c[u] = h
        }
        for (let u = 0; u <= s; ++u) {
            let h = c[a - r].clone().multiplyScalar(l[u][0]);
            for (let f = 1; f <= r; ++f)
                h.add(c[a - r + f].clone().multiplyScalar(l[u][f]));
            o[u] = h
        }
        for (let u = s + 1; u <= i + 1; ++u)
            o[u] = new Lt(0,0,0);
        return o
    }
    function Mw(r, e) {
        let t = 1;
        for (let i = 2; i <= r; ++i)
            t *= i;
        let n = 1;
        for (let i = 2; i <= e; ++i)
            n *= i;
        for (let i = 2; i <= r - e; ++i)
            n *= i;
        return t / n
    }
    function Ew(r) {
        let e = r.length
          , t = []
          , n = [];
        for (let s = 0; s < e; ++s) {
            let o = r[s];
            t[s] = new ue(o.x,o.y,o.z),
            n[s] = o.w
        }
        let i = [];
        for (let s = 0; s < e; ++s) {
            let o = t[s].clone();
            for (let a = 1; a <= s; ++a)
                o.sub(i[s - a].clone().multiplyScalar(Mw(s, a) * n[a]));
            i[s] = o.divideScalar(n[0])
        }
        return i
    }
    function ty(r, e, t, n, i) {
        let s = bw(r, e, t, n, i);
        return Ew(s)
    }
    var uf = class extends mi {
        constructor(e, t, n, i, s) {
            super(),
            this.degree = e,
            this.knots = t,
            this.controlPoints = [],
            this.startKnot = i || 0,
            this.endKnot = s || this.knots.length - 1;
            for (let o = 0; o < n.length; ++o) {
                let a = n[o];
                this.controlPoints[o] = new Lt(a.x,a.y,a.z,a.w)
            }
        }
        getPoint(e, t=new ue) {
            let n = t
              , i = this.knots[this.startKnot] + e * (this.knots[this.endKnot] - this.knots[this.startKnot])
              , s = ey(this.degree, this.knots, this.controlPoints, i);
            return s.w !== 1 && s.divideScalar(s.w),
            n.set(s.x, s.y, s.z)
        }
        getTangent(e, t=new ue) {
            let n = t
              , i = this.knots[0] + e * (this.knots[this.knots.length - 1] - this.knots[0])
              , s = ty(this.degree, this.knots, this.controlPoints, i, 1);
            return n.copy(s[1]).normalize(),
            n
        }
    }
    ;
    var Ct, mn, Ti, ff = class extends Hn {
        constructor(e) {
            super(e)
        }
        load(e, t, n, i) {
            let s = this
              , o = s.path === "" ? Qs.extractUrlBase(e) : s.path
              , a = new Ni(this.manager);
            a.setPath(s.path),
            a.setResponseType("arraybuffer"),
            a.setRequestHeader(s.requestHeader),
            a.setWithCredentials(s.withCredentials),
            a.load(e, function(l) {
                try {
                    t(s.parse(l, o))
                } catch (c) {
                    i ? i(c) : console.error(c),
                    s.manager.itemError(e)
                }
            }, n, i)
        }
        parse(e, t) {
            if (ww(e))
                Ct = new hm().parse(e);
            else {
                let i = oy(e);
                if (!Aw(i))
                    throw new Error("THREE.FBXLoader: Unknown format.");
                if (ny(i) < 7e3)
                    throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + ny(i));
                Ct = new um().parse(i)
            }
            let n = new Zi(this.manager).setPath(this.resourcePath || t).setCrossOrigin(this.crossOrigin);
            return new am(n,this.manager).parse(Ct)
        }
    }
    , am = class {
        constructor(e, t) {
            this.textureLoader = e,
            this.manager = t
        }
        parse() {
            mn = this.parseConnections();
            let e = this.parseImages()
              , t = this.parseTextures(e)
              , n = this.parseMaterials(t)
              , i = this.parseDeformers()
              , s = new lm().parse(i);
            return this.parseScene(i, s, n),
            Ti
        }
        parseConnections() {
            let e = new Map;
            return "Connections"in Ct && Ct.Connections.connections.forEach(function(n) {
                let i = n[0]
                  , s = n[1]
                  , o = n[2];
                e.has(i) || e.set(i, {
                    parents: [],
                    children: []
                });
                let a = {
                    ID: s,
                    relationship: o
                };
                e.get(i).parents.push(a),
                e.has(s) || e.set(s, {
                    parents: [],
                    children: []
                });
                let l = {
                    ID: i,
                    relationship: o
                };
                e.get(s).children.push(l)
            }),
            e
        }
        parseImages() {
            let e = {}
              , t = {};
            if ("Video"in Ct.Objects) {
                let n = Ct.Objects.Video;
                for (let i in n) {
                    let s = n[i]
                      , o = parseInt(i);
                    if (e[o] = s.RelativeFilename || s.Filename,
                    "Content"in s) {
                        let a = s.Content instanceof ArrayBuffer && s.Content.byteLength > 0
                          , l = typeof s.Content == "string" && s.Content !== "";
                        if (a || l) {
                            let c = this.parseImage(n[i]);
                            t[s.RelativeFilename || s.Filename] = c
                        }
                    }
                }
            }
            for (let n in e) {
                let i = e[n];
                t[i] !== void 0 ? e[n] = t[i] : e[n] = e[n].split("\\").pop()
            }
            return e
        }
        parseImage(e) {
            let t = e.Content, n = e.RelativeFilename || e.Filename, i = n.slice(n.lastIndexOf(".") + 1).toLowerCase(), s;
            switch (i) {
            case "bmp":
                s = "image/bmp";
                break;
            case "jpg":
            case "jpeg":
                s = "image/jpeg";
                break;
            case "png":
                s = "image/png";
                break;
            case "tif":
                s = "image/tiff";
                break;
            case "tga":
                this.manager.getHandler(".tga") === null && console.warn("FBXLoader: TGA loader not found, skipping ", n),
                s = "image/tga";
                break;
            default:
                console.warn('FBXLoader: Image type "' + i + '" is not supported.');
                return
            }
            if (typeof t == "string")
                return "data:" + s + ";base64," + t;
            {
                let o = new Uint8Array(t);
                return window.URL.createObjectURL(new Blob([o],{
                    type: s
                }))
            }
        }
        parseTextures(e) {
            let t = new Map;
            if ("Texture"in Ct.Objects) {
                let n = Ct.Objects.Texture;
                for (let i in n) {
                    let s = this.parseTexture(n[i], e);
                    t.set(parseInt(i), s)
                }
            }
            return t
        }
        parseTexture(e, t) {
            let n = this.loadTexture(e, t);
            n.ID = e.id,
            n.name = e.attrName;
            let i = e.WrapModeU
              , s = e.WrapModeV
              , o = i !== void 0 ? i.value : 0
              , a = s !== void 0 ? s.value : 0;
            if (n.wrapS = o === 0 ? rn : Zt,
            n.wrapT = a === 0 ? rn : Zt,
            "Scaling"in e) {
                let l = e.Scaling.value;
                n.repeat.x = l[0],
                n.repeat.y = l[1]
            }
            if ("Translation"in e) {
                let l = e.Translation.value;
                n.offset.x = l[0],
                n.offset.y = l[1]
            }
            return n
        }
        loadTexture(e, t) {
            let n, i = this.textureLoader.path, s = mn.get(e.id).children;
            s !== void 0 && s.length > 0 && t[s[0].ID] !== void 0 && (n = t[s[0].ID],
            (n.indexOf("blob:") === 0 || n.indexOf("data:") === 0) && this.textureLoader.setPath(void 0));
            let o, a = e.FileName.slice(-3).toLowerCase();
            if (a === "tga") {
                let l = this.manager.getHandler(".tga");
                l === null ? (console.warn("FBXLoader: TGA loader not found, creating placeholder texture for", e.RelativeFilename),
                o = new En) : (l.setPath(this.textureLoader.path),
                o = l.load(n))
            } else
                a === "psd" ? (console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for", e.RelativeFilename),
                o = new En) : o = this.textureLoader.load(n);
            return this.textureLoader.setPath(i),
            o
        }
        parseMaterials(e) {
            let t = new Map;
            if ("Material"in Ct.Objects) {
                let n = Ct.Objects.Material;
                for (let i in n) {
                    let s = this.parseMaterial(n[i], e);
                    s !== null && t.set(parseInt(i), s)
                }
            }
            return t
        }
        parseMaterial(e, t) {
            let n = e.id
              , i = e.attrName
              , s = e.ShadingModel;
            if (typeof s == "object" && (s = s.value),
            !mn.has(n))
                return null;
            let o = this.parseParameters(e, t, n), a;
            switch (s.toLowerCase()) {
            case "phong":
                a = new sn;
                break;
            case "lambert":
                a = new Ya;
                break;
            default:
                console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', s),
                a = new sn;
                break
            }
            return a.setValues(o),
            a.name = i,
            a
        }
        parseParameters(e, t, n) {
            let i = {};
            e.BumpFactor && (i.bumpScale = e.BumpFactor.value),
            e.Diffuse ? i.color = new $e().fromArray(e.Diffuse.value).convertSRGBToLinear() : e.DiffuseColor && (e.DiffuseColor.type === "Color" || e.DiffuseColor.type === "ColorRGB") && (i.color = new $e().fromArray(e.DiffuseColor.value).convertSRGBToLinear()),
            e.DisplacementFactor && (i.displacementScale = e.DisplacementFactor.value),
            e.Emissive ? i.emissive = new $e().fromArray(e.Emissive.value).convertSRGBToLinear() : e.EmissiveColor && (e.EmissiveColor.type === "Color" || e.EmissiveColor.type === "ColorRGB") && (i.emissive = new $e().fromArray(e.EmissiveColor.value).convertSRGBToLinear()),
            e.EmissiveFactor && (i.emissiveIntensity = parseFloat(e.EmissiveFactor.value)),
            e.Opacity && (i.opacity = parseFloat(e.Opacity.value)),
            i.opacity < 1 && (i.transparent = !0),
            e.ReflectionFactor && (i.reflectivity = e.ReflectionFactor.value),
            e.Shininess && (i.shininess = e.Shininess.value),
            e.Specular ? i.specular = new $e().fromArray(e.Specular.value).convertSRGBToLinear() : e.SpecularColor && e.SpecularColor.type === "Color" && (i.specular = new $e().fromArray(e.SpecularColor.value).convertSRGBToLinear());
            let s = this;
            return mn.get(n).children.forEach(function(o) {
                let a = o.relationship;
                switch (a) {
                case "Bump":
                    i.bumpMap = s.getTexture(t, o.ID);
                    break;
                case "Maya|TEX_ao_map":
                    i.aoMap = s.getTexture(t, o.ID);
                    break;
                case "DiffuseColor":
                case "Maya|TEX_color_map":
                    i.map = s.getTexture(t, o.ID),
                    i.map !== void 0 && (i.map.colorSpace = ct);
                    break;
                case "DisplacementColor":
                    i.displacementMap = s.getTexture(t, o.ID);
                    break;
                case "EmissiveColor":
                    i.emissiveMap = s.getTexture(t, o.ID),
                    i.emissiveMap !== void 0 && (i.emissiveMap.colorSpace = ct);
                    break;
                case "NormalMap":
                case "Maya|TEX_normal_map":
                    i.normalMap = s.getTexture(t, o.ID);
                    break;
                case "ReflectionColor":
                    i.envMap = s.getTexture(t, o.ID),
                    i.envMap !== void 0 && (i.envMap.mapping = Pc,
                    i.envMap.colorSpace = ct);
                    break;
                case "SpecularColor":
                    i.specularMap = s.getTexture(t, o.ID),
                    i.specularMap !== void 0 && (i.specularMap.colorSpace = ct);
                    break;
                case "TransparentColor":
                case "TransparencyFactor":
                    i.alphaMap = s.getTexture(t, o.ID),
                    i.transparent = !0;
                    break;
                case "AmbientColor":
                case "ShininessExponent":
                case "SpecularFactor":
                case "VectorDisplacementColor":
                default:
                    console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.", a);
                    break
                }
            }),
            i
        }
        getTexture(e, t) {
            return "LayeredTexture"in Ct.Objects && t in Ct.Objects.LayeredTexture && (console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."),
            t = mn.get(t).children[0].ID),
            e.get(t)
        }
        parseDeformers() {
            let e = {}
              , t = {};
            if ("Deformer"in Ct.Objects) {
                let n = Ct.Objects.Deformer;
                for (let i in n) {
                    let s = n[i]
                      , o = mn.get(parseInt(i));
                    if (s.attrType === "Skin") {
                        let a = this.parseSkeleton(o, n);
                        a.ID = i,
                        o.parents.length > 1 && console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."),
                        a.geometryID = o.parents[0].ID,
                        e[i] = a
                    } else if (s.attrType === "BlendShape") {
                        let a = {
                            id: i
                        };
                        a.rawTargets = this.parseMorphTargets(o, n),
                        a.id = i,
                        o.parents.length > 1 && console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."),
                        t[i] = a
                    }
                }
            }
            return {
                skeletons: e,
                morphTargets: t
            }
        }
        parseSkeleton(e, t) {
            let n = [];
            return e.children.forEach(function(i) {
                let s = t[i.ID];
                if (s.attrType !== "Cluster")
                    return;
                let o = {
                    ID: i.ID,
                    indices: [],
                    weights: [],
                    transformLink: new je().fromArray(s.TransformLink.a)
                };
                "Indexes"in s && (o.indices = s.Indexes.a,
                o.weights = s.Weights.a),
                n.push(o)
            }),
            {
                rawBones: n,
                bones: []
            }
        }
        parseMorphTargets(e, t) {
            let n = [];
            for (let i = 0; i < e.children.length; i++) {
                let s = e.children[i]
                  , o = t[s.ID]
                  , a = {
                    name: o.attrName,
                    initialWeight: o.DeformPercent,
                    id: o.id,
                    fullWeights: o.FullWeights.a
                };
                if (o.attrType !== "BlendShapeChannel")
                    return;
                a.geoID = mn.get(parseInt(s.ID)).children.filter(function(l) {
                    return l.relationship === void 0
                })[0].ID,
                n.push(a)
            }
            return n
        }
        parseScene(e, t, n) {
            Ti = new In;
            let i = this.parseModels(e.skeletons, t, n)
              , s = Ct.Objects.Model
              , o = this;
            i.forEach(function(l) {
                let c = s[l.ID];
                o.setLookAtProperties(l, c),
                mn.get(l.ID).parents.forEach(function(h) {
                    let f = i.get(h.ID);
                    f !== void 0 && f.add(l)
                }),
                l.parent === null && Ti.add(l)
            }),
            this.bindSkeleton(e.skeletons, t, i),
            this.createAmbientLight(),
            Ti.traverse(function(l) {
                if (l.userData.transformData) {
                    l.parent && (l.userData.transformData.parentMatrix = l.parent.matrix,
                    l.userData.transformData.parentMatrixWorld = l.parent.matrixWorld);
                    let c = ry(l.userData.transformData);
                    l.applyMatrix4(c),
                    l.updateWorldMatrix()
                }
            });
            let a = new cm().parse();
            Ti.children.length === 1 && Ti.children[0].isGroup && (Ti.children[0].animations = a,
            Ti = Ti.children[0]),
            Ti.animations = a
        }
        parseModels(e, t, n) {
            let i = new Map
              , s = Ct.Objects.Model;
            for (let o in s) {
                let a = parseInt(o)
                  , l = s[o]
                  , c = mn.get(a)
                  , u = this.buildSkeleton(c, e, a, l.attrName);
                if (!u) {
                    switch (l.attrType) {
                    case "Camera":
                        u = this.createCamera(c);
                        break;
                    case "Light":
                        u = this.createLight(c);
                        break;
                    case "Mesh":
                        u = this.createMesh(c, t, n);
                        break;
                    case "NurbsCurve":
                        u = this.createCurve(c, t);
                        break;
                    case "LimbNode":
                    case "Root":
                        u = new Xs;
                        break;
                    case "Null":
                    default:
                        u = new In;
                        break
                    }
                    u.name = l.attrName ? Nt.sanitizeNodeName(l.attrName) : "",
                    u.ID = a
                }
                this.getTransformData(u, l),
                i.set(a, u)
            }
            return i
        }
        buildSkeleton(e, t, n, i) {
            let s = null;
            return e.parents.forEach(function(o) {
                for (let a in t) {
                    let l = t[a];
                    l.rawBones.forEach(function(c, u) {
                        if (c.ID === o.ID) {
                            let h = s;
                            s = new Xs,
                            s.matrixWorld.copy(c.transformLink),
                            s.name = i ? Nt.sanitizeNodeName(i) : "",
                            s.ID = n,
                            l.bones[u] = s,
                            h !== null && s.add(h)
                        }
                    })
                }
            }),
            s
        }
        createCamera(e) {
            let t, n;
            if (e.children.forEach(function(i) {
                let s = Ct.Objects.NodeAttribute[i.ID];
                s !== void 0 && (n = s)
            }),
            n === void 0)
                t = new bt;
            else {
                let i = 0;
                n.CameraProjectionType !== void 0 && n.CameraProjectionType.value === 1 && (i = 1);
                let s = 1;
                n.NearPlane !== void 0 && (s = n.NearPlane.value / 1e3);
                let o = 1e3;
                n.FarPlane !== void 0 && (o = n.FarPlane.value / 1e3);
                let a = window.innerWidth
                  , l = window.innerHeight;
                n.AspectWidth !== void 0 && n.AspectHeight !== void 0 && (a = n.AspectWidth.value,
                l = n.AspectHeight.value);
                let c = a / l
                  , u = 45;
                n.FieldOfView !== void 0 && (u = n.FieldOfView.value);
                let h = n.FocalLength ? n.FocalLength.value : null;
                switch (i) {
                case 0:
                    t = new Qt(u,c,s,o),
                    h !== null && t.setFocalLength(h);
                    break;
                case 1:
                    t = new Dr(-a / 2,a / 2,l / 2,-l / 2,s,o);
                    break;
                default:
                    console.warn("THREE.FBXLoader: Unknown camera type " + i + "."),
                    t = new bt;
                    break
                }
            }
            return t
        }
        createLight(e) {
            let t, n;
            if (e.children.forEach(function(i) {
                let s = Ct.Objects.NodeAttribute[i.ID];
                s !== void 0 && (n = s)
            }),
            n === void 0)
                t = new bt;
            else {
                let i;
                n.LightType === void 0 ? i = 0 : i = n.LightType.value;
                let s = 16777215;
                n.Color !== void 0 && (s = new $e().fromArray(n.Color.value).convertSRGBToLinear());
                let o = n.Intensity === void 0 ? 1 : n.Intensity.value / 100;
                n.CastLightOnObject !== void 0 && n.CastLightOnObject.value === 0 && (o = 0);
                let a = 0;
                n.FarAttenuationEnd !== void 0 && (n.EnableFarAttenuation !== void 0 && n.EnableFarAttenuation.value === 0 ? a = 0 : a = n.FarAttenuationEnd.value);
                let l = 1;
                switch (i) {
                case 0:
                    t = new Go(s,o,a,l);
                    break;
                case 1:
                    t = new Fr(s,o);
                    break;
                case 2:
                    let c = Math.PI / 3;
                    n.InnerAngle !== void 0 && (c = Wn.degToRad(n.InnerAngle.value));
                    let u = 0;
                    n.OuterAngle !== void 0 && (u = Wn.degToRad(n.OuterAngle.value),
                    u = Math.max(u, 1)),
                    t = new Ja(s,o,a,c,u,l);
                    break;
                default:
                    console.warn("THREE.FBXLoader: Unknown light type " + n.LightType.value + ", defaulting to a PointLight."),
                    t = new Go(s,o);
                    break
                }
                n.CastShadows !== void 0 && n.CastShadows.value === 1 && (t.castShadow = !0)
            }
            return t
        }
        createMesh(e, t, n) {
            let i, s = null, o = null, a = [];
            return e.children.forEach(function(l) {
                t.has(l.ID) && (s = t.get(l.ID)),
                n.has(l.ID) && a.push(n.get(l.ID))
            }),
            a.length > 1 ? o = a : a.length > 0 ? o = a[0] : (o = new sn({
                color: 13421772
            }),
            a.push(o)),
            "color"in s.attributes && a.forEach(function(l) {
                l.vertexColors = !0
            }),
            s.FBX_Deformer ? (i = new Wa(s,o),
            i.normalizeSkinWeights()) : i = new Ht(s,o),
            i
        }
        createCurve(e, t) {
            let n = e.children.reduce(function(s, o) {
                return t.has(o.ID) && (s = t.get(o.ID)),
                s
            }, null)
              , i = new pi({
                color: 3342591,
                linewidth: 1
            });
            return new gs(n,i)
        }
        getTransformData(e, t) {
            let n = {};
            "InheritType"in t && (n.inheritType = parseInt(t.InheritType.value)),
            "RotationOrder"in t ? n.eulerOrder = sy(t.RotationOrder.value) : n.eulerOrder = "ZYX",
            "Lcl_Translation"in t && (n.translation = t.Lcl_Translation.value),
            "PreRotation"in t && (n.preRotation = t.PreRotation.value),
            "Lcl_Rotation"in t && (n.rotation = t.Lcl_Rotation.value),
            "PostRotation"in t && (n.postRotation = t.PostRotation.value),
            "Lcl_Scaling"in t && (n.scale = t.Lcl_Scaling.value),
            "ScalingOffset"in t && (n.scalingOffset = t.ScalingOffset.value),
            "ScalingPivot"in t && (n.scalingPivot = t.ScalingPivot.value),
            "RotationOffset"in t && (n.rotationOffset = t.RotationOffset.value),
            "RotationPivot"in t && (n.rotationPivot = t.RotationPivot.value),
            e.userData.transformData = n
        }
        setLookAtProperties(e, t) {
            "LookAtProperty"in t && mn.get(e.ID).children.forEach(function(i) {
                if (i.relationship === "LookAtProperty") {
                    let s = Ct.Objects.Model[i.ID];
                    if ("Lcl_Translation"in s) {
                        let o = s.Lcl_Translation.value;
                        e.target !== void 0 ? (e.target.position.fromArray(o),
                        Ti.add(e.target)) : e.lookAt(new ue().fromArray(o))
                    }
                }
            })
        }
        bindSkeleton(e, t, n) {
            let i = this.parsePoseNodes();
            for (let s in e) {
                let o = e[s];
                mn.get(parseInt(o.ID)).parents.forEach(function(l) {
                    if (t.has(l.ID)) {
                        let c = l.ID;
                        mn.get(c).parents.forEach(function(h) {
                            n.has(h.ID) && n.get(h.ID).bind(new js(o.bones), i[h.ID])
                        })
                    }
                })
            }
        }
        parsePoseNodes() {
            let e = {};
            if ("Pose"in Ct.Objects) {
                let t = Ct.Objects.Pose;
                for (let n in t)
                    if (t[n].attrType === "BindPose" && t[n].NbPoseNodes > 0) {
                        let i = t[n].PoseNode;
                        Array.isArray(i) ? i.forEach(function(s) {
                            e[s.Node] = new je().fromArray(s.Matrix.a)
                        }) : e[i.Node] = new je().fromArray(i.Matrix.a)
                    }
            }
            return e
        }
        createAmbientLight() {
            if ("GlobalSettings"in Ct && "AmbientColor"in Ct.GlobalSettings) {
                let e = Ct.GlobalSettings.AmbientColor.value
                  , t = e[0]
                  , n = e[1]
                  , i = e[2];
                if (t !== 0 || n !== 0 || i !== 0) {
                    let s = new $e(t,n,i).convertSRGBToLinear();
                    Ti.add(new kr(s,1))
                }
            }
        }
    }
    , lm = class {
        constructor() {
            this.negativeMaterialIndices = !1
        }
        parse(e) {
            let t = new Map;
            if ("Geometry"in Ct.Objects) {
                let n = Ct.Objects.Geometry;
                for (let i in n) {
                    let s = mn.get(parseInt(i))
                      , o = this.parseGeometry(s, n[i], e);
                    t.set(parseInt(i), o)
                }
            }
            return this.negativeMaterialIndices === !0 && console.warn("THREE.FBXLoader: The FBX file contains invalid (negative) material indices. The asset might not render as expected."),
            t
        }
        parseGeometry(e, t, n) {
            switch (t.attrType) {
            case "Mesh":
                return this.parseMeshGeometry(e, t, n);
            case "NurbsCurve":
                return this.parseNurbsGeometry(t)
            }
        }
        parseMeshGeometry(e, t, n) {
            let i = n.skeletons
              , s = []
              , o = e.parents.map(function(h) {
                return Ct.Objects.Model[h.ID]
            });
            if (o.length === 0)
                return;
            let a = e.children.reduce(function(h, f) {
                return i[f.ID] !== void 0 && (h = i[f.ID]),
                h
            }, null);
            e.children.forEach(function(h) {
                n.morphTargets[h.ID] !== void 0 && s.push(n.morphTargets[h.ID])
            });
            let l = o[0]
              , c = {};
            "RotationOrder"in l && (c.eulerOrder = sy(l.RotationOrder.value)),
            "InheritType"in l && (c.inheritType = parseInt(l.InheritType.value)),
            "GeometricTranslation"in l && (c.translation = l.GeometricTranslation.value),
            "GeometricRotation"in l && (c.rotation = l.GeometricRotation.value),
            "GeometricScaling"in l && (c.scale = l.GeometricScaling.value);
            let u = ry(c);
            return this.genGeometry(t, a, s, u)
        }
        genGeometry(e, t, n, i) {
            let s = new wt;
            e.attrName && (s.name = e.attrName);
            let o = this.parseGeoNode(e, t)
              , a = this.genBuffers(o)
              , l = new qe(a.vertex,3);
            if (l.applyMatrix4(i),
            s.setAttribute("position", l),
            a.colors.length > 0 && s.setAttribute("color", new qe(a.colors,3)),
            t && (s.setAttribute("skinIndex", new za(a.weightsIndices,4)),
            s.setAttribute("skinWeight", new qe(a.vertexWeights,4)),
            s.FBX_Deformer = t),
            a.normal.length > 0) {
                let c = new vt().getNormalMatrix(i)
                  , u = new qe(a.normal,3);
                u.applyNormalMatrix(c),
                s.setAttribute("normal", u)
            }
            if (a.uvs.forEach(function(c, u) {
                let h = u === 0 ? "uv" : `uv ${u}`;
                s.setAttribute(h, new qe(a.uvs[u],2))
            }),
            o.material && o.material.mappingType !== "AllSame") {
                let c = a.materialIndex[0]
                  , u = 0;
                if (a.materialIndex.forEach(function(h, f) {
                    h !== c && (s.addGroup(u, f - u, c),
                    c = h,
                    u = f)
                }),
                s.groups.length > 0) {
                    let h = s.groups[s.groups.length - 1]
                      , f = h.start + h.count;
                    f !== a.materialIndex.length && s.addGroup(f, a.materialIndex.length - f, c)
                }
                s.groups.length === 0 && s.addGroup(0, a.materialIndex.length, a.materialIndex[0])
            }
            return this.addMorphTargets(s, e, n, i),
            s
        }
        parseGeoNode(e, t) {
            let n = {};
            if (n.vertexPositions = e.Vertices !== void 0 ? e.Vertices.a : [],
            n.vertexIndices = e.PolygonVertexIndex !== void 0 ? e.PolygonVertexIndex.a : [],
            e.LayerElementColor && (n.color = this.parseVertexColors(e.LayerElementColor[0])),
            e.LayerElementMaterial && (n.material = this.parseMaterialIndices(e.LayerElementMaterial[0])),
            e.LayerElementNormal && (n.normal = this.parseNormals(e.LayerElementNormal[0])),
            e.LayerElementUV) {
                n.uv = [];
                let i = 0;
                for (; e.LayerElementUV[i]; )
                    e.LayerElementUV[i].UV && n.uv.push(this.parseUVs(e.LayerElementUV[i])),
                    i++
            }
            return n.weightTable = {},
            t !== null && (n.skeleton = t,
            t.rawBones.forEach(function(i, s) {
                i.indices.forEach(function(o, a) {
                    n.weightTable[o] === void 0 && (n.weightTable[o] = []),
                    n.weightTable[o].push({
                        id: s,
                        weight: i.weights[a]
                    })
                })
            })),
            n
        }
        genBuffers(e) {
            let t = {
                vertex: [],
                normal: [],
                colors: [],
                uvs: [],
                materialIndex: [],
                vertexWeights: [],
                weightsIndices: []
            }
              , n = 0
              , i = 0
              , s = !1
              , o = []
              , a = []
              , l = []
              , c = []
              , u = []
              , h = []
              , f = this;
            return e.vertexIndices.forEach(function(m, g) {
                let v, p = !1;
                m < 0 && (m = m ^ -1,
                p = !0);
                let d = []
                  , x = [];
                if (o.push(m * 3, m * 3 + 1, m * 3 + 2),
                e.color) {
                    let y = hf(g, n, m, e.color);
                    l.push(y[0], y[1], y[2])
                }
                if (e.skeleton) {
                    if (e.weightTable[m] !== void 0 && e.weightTable[m].forEach(function(y) {
                        x.push(y.weight),
                        d.push(y.id)
                    }),
                    x.length > 4) {
                        s || (console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."),
                        s = !0);
                        let y = [0, 0, 0, 0]
                          , _ = [0, 0, 0, 0];
                        x.forEach(function(S, N) {
                            let I = S
                              , O = d[N];
                            _.forEach(function(M, R, q) {
                                if (I > M) {
                                    q[R] = I,
                                    I = M;
                                    let k = y[R];
                                    y[R] = O,
                                    O = k
                                }
                            })
                        }),
                        d = y,
                        x = _
                    }
                    for (; x.length < 4; )
                        x.push(0),
                        d.push(0);
                    for (let y = 0; y < 4; ++y)
                        u.push(x[y]),
                        h.push(d[y])
                }
                if (e.normal) {
                    let y = hf(g, n, m, e.normal);
                    a.push(y[0], y[1], y[2])
                }
                e.material && e.material.mappingType !== "AllSame" && (v = hf(g, n, m, e.material)[0],
                v < 0 && (f.negativeMaterialIndices = !0,
                v = 0)),
                e.uv && e.uv.forEach(function(y, _) {
                    let S = hf(g, n, m, y);
                    c[_] === void 0 && (c[_] = []),
                    c[_].push(S[0]),
                    c[_].push(S[1])
                }),
                i++,
                p && (i > 4 && console.warn("THREE.FBXLoader: Polygons with more than four sides are not supported. Make sure to triangulate the geometry during export."),
                f.genFace(t, e, o, v, a, l, c, u, h, i),
                n++,
                i = 0,
                o = [],
                a = [],
                l = [],
                c = [],
                u = [],
                h = [])
            }),
            t
        }
        genFace(e, t, n, i, s, o, a, l, c, u) {
            for (let h = 2; h < u; h++)
                e.vertex.push(t.vertexPositions[n[0]]),
                e.vertex.push(t.vertexPositions[n[1]]),
                e.vertex.push(t.vertexPositions[n[2]]),
                e.vertex.push(t.vertexPositions[n[(h - 1) * 3]]),
                e.vertex.push(t.vertexPositions[n[(h - 1) * 3 + 1]]),
                e.vertex.push(t.vertexPositions[n[(h - 1) * 3 + 2]]),
                e.vertex.push(t.vertexPositions[n[h * 3]]),
                e.vertex.push(t.vertexPositions[n[h * 3 + 1]]),
                e.vertex.push(t.vertexPositions[n[h * 3 + 2]]),
                t.skeleton && (e.vertexWeights.push(l[0]),
                e.vertexWeights.push(l[1]),
                e.vertexWeights.push(l[2]),
                e.vertexWeights.push(l[3]),
                e.vertexWeights.push(l[(h - 1) * 4]),
                e.vertexWeights.push(l[(h - 1) * 4 + 1]),
                e.vertexWeights.push(l[(h - 1) * 4 + 2]),
                e.vertexWeights.push(l[(h - 1) * 4 + 3]),
                e.vertexWeights.push(l[h * 4]),
                e.vertexWeights.push(l[h * 4 + 1]),
                e.vertexWeights.push(l[h * 4 + 2]),
                e.vertexWeights.push(l[h * 4 + 3]),
                e.weightsIndices.push(c[0]),
                e.weightsIndices.push(c[1]),
                e.weightsIndices.push(c[2]),
                e.weightsIndices.push(c[3]),
                e.weightsIndices.push(c[(h - 1) * 4]),
                e.weightsIndices.push(c[(h - 1) * 4 + 1]),
                e.weightsIndices.push(c[(h - 1) * 4 + 2]),
                e.weightsIndices.push(c[(h - 1) * 4 + 3]),
                e.weightsIndices.push(c[h * 4]),
                e.weightsIndices.push(c[h * 4 + 1]),
                e.weightsIndices.push(c[h * 4 + 2]),
                e.weightsIndices.push(c[h * 4 + 3])),
                t.color && (e.colors.push(o[0]),
                e.colors.push(o[1]),
                e.colors.push(o[2]),
                e.colors.push(o[(h - 1) * 3]),
                e.colors.push(o[(h - 1) * 3 + 1]),
                e.colors.push(o[(h - 1) * 3 + 2]),
                e.colors.push(o[h * 3]),
                e.colors.push(o[h * 3 + 1]),
                e.colors.push(o[h * 3 + 2])),
                t.material && t.material.mappingType !== "AllSame" && (e.materialIndex.push(i),
                e.materialIndex.push(i),
                e.materialIndex.push(i)),
                t.normal && (e.normal.push(s[0]),
                e.normal.push(s[1]),
                e.normal.push(s[2]),
                e.normal.push(s[(h - 1) * 3]),
                e.normal.push(s[(h - 1) * 3 + 1]),
                e.normal.push(s[(h - 1) * 3 + 2]),
                e.normal.push(s[h * 3]),
                e.normal.push(s[h * 3 + 1]),
                e.normal.push(s[h * 3 + 2])),
                t.uv && t.uv.forEach(function(f, m) {
                    e.uvs[m] === void 0 && (e.uvs[m] = []),
                    e.uvs[m].push(a[m][0]),
                    e.uvs[m].push(a[m][1]),
                    e.uvs[m].push(a[m][(h - 1) * 2]),
                    e.uvs[m].push(a[m][(h - 1) * 2 + 1]),
                    e.uvs[m].push(a[m][h * 2]),
                    e.uvs[m].push(a[m][h * 2 + 1])
                })
        }
        addMorphTargets(e, t, n, i) {
            if (n.length === 0)
                return;
            e.morphTargetsRelative = !0,
            e.morphAttributes.position = [];
            let s = this;
            n.forEach(function(o) {
                o.rawTargets.forEach(function(a) {
                    let l = Ct.Objects.Geometry[a.geoID];
                    l !== void 0 && s.genMorphGeometry(e, t, l, i, a.name)
                })
            })
        }
        genMorphGeometry(e, t, n, i, s) {
            let o = t.PolygonVertexIndex !== void 0 ? t.PolygonVertexIndex.a : []
              , a = n.Vertices !== void 0 ? n.Vertices.a : []
              , l = n.Indexes !== void 0 ? n.Indexes.a : []
              , c = e.attributes.position.count * 3
              , u = new Float32Array(c);
            for (let g = 0; g < l.length; g++) {
                let v = l[g] * 3;
                u[v] = a[g * 3],
                u[v + 1] = a[g * 3 + 1],
                u[v + 2] = a[g * 3 + 2]
            }
            let h = {
                vertexIndices: o,
                vertexPositions: u
            }
              , f = this.genBuffers(h)
              , m = new qe(f.vertex,3);
            m.name = s || n.attrName,
            m.applyMatrix4(i),
            e.morphAttributes.position.push(m)
        }
        parseNormals(e) {
            let t = e.MappingInformationType
              , n = e.ReferenceInformationType
              , i = e.Normals.a
              , s = [];
            return n === "IndexToDirect" && ("NormalIndex"in e ? s = e.NormalIndex.a : "NormalsIndex"in e && (s = e.NormalsIndex.a)),
            {
                dataSize: 3,
                buffer: i,
                indices: s,
                mappingType: t,
                referenceType: n
            }
        }
        parseUVs(e) {
            let t = e.MappingInformationType
              , n = e.ReferenceInformationType
              , i = e.UV.a
              , s = [];
            return n === "IndexToDirect" && (s = e.UVIndex.a),
            {
                dataSize: 2,
                buffer: i,
                indices: s,
                mappingType: t,
                referenceType: n
            }
        }
        parseVertexColors(e) {
            let t = e.MappingInformationType
              , n = e.ReferenceInformationType
              , i = e.Colors.a
              , s = [];
            n === "IndexToDirect" && (s = e.ColorIndex.a);
            for (let o = 0, a = new $e; o < i.length; o += 4)
                a.fromArray(i, o).convertSRGBToLinear().toArray(i, o);
            return {
                dataSize: 4,
                buffer: i,
                indices: s,
                mappingType: t,
                referenceType: n
            }
        }
        parseMaterialIndices(e) {
            let t = e.MappingInformationType
              , n = e.ReferenceInformationType;
            if (t === "NoMappingInformation")
                return {
                    dataSize: 1,
                    buffer: [0],
                    indices: [0],
                    mappingType: "AllSame",
                    referenceType: n
                };
            let i = e.Materials.a
              , s = [];
            for (let o = 0; o < i.length; ++o)
                s.push(o);
            return {
                dataSize: 1,
                buffer: i,
                indices: s,
                mappingType: t,
                referenceType: n
            }
        }
        parseNurbsGeometry(e) {
            let t = parseInt(e.Order);
            if (isNaN(t))
                return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", e.Order, e.id),
                new wt;
            let n = t - 1
              , i = e.KnotVector.a
              , s = []
              , o = e.Points.a;
            for (let h = 0, f = o.length; h < f; h += 4)
                s.push(new Lt().fromArray(o, h));
            let a, l;
            if (e.Form === "Closed")
                s.push(s[0]);
            else if (e.Form === "Periodic") {
                a = n,
                l = i.length - 1 - a;
                for (let h = 0; h < n; ++h)
                    s.push(s[h])
            }
            let u = new uf(n,i,s,a,l).getPoints(s.length * 12);
            return new wt().setFromPoints(u)
        }
    }
    , cm = class {
        parse() {
            let e = []
              , t = this.parseClips();
            if (t !== void 0)
                for (let n in t) {
                    let i = t[n]
                      , s = this.addClip(i);
                    e.push(s)
                }
            return e
        }
        parseClips() {
            if (Ct.Objects.AnimationCurve === void 0)
                return;
            let e = this.parseAnimationCurveNodes();
            this.parseAnimationCurves(e);
            let t = this.parseAnimationLayers(e);
            return this.parseAnimStacks(t)
        }
        parseAnimationCurveNodes() {
            let e = Ct.Objects.AnimationCurveNode
              , t = new Map;
            for (let n in e) {
                let i = e[n];
                if (i.attrName.match(/S|R|T|DeformPercent/) !== null) {
                    let s = {
                        id: i.id,
                        attr: i.attrName,
                        curves: {}
                    };
                    t.set(s.id, s)
                }
            }
            return t
        }
        parseAnimationCurves(e) {
            let t = Ct.Objects.AnimationCurve;
            for (let n in t) {
                let i = {
                    id: t[n].id,
                    times: t[n].KeyTime.a.map(Cw),
                    values: t[n].KeyValueFloat.a
                }
                  , s = mn.get(i.id);
                if (s !== void 0) {
                    let o = s.parents[0].ID
                      , a = s.parents[0].relationship;
                    a.match(/X/) ? e.get(o).curves.x = i : a.match(/Y/) ? e.get(o).curves.y = i : a.match(/Z/) ? e.get(o).curves.z = i : a.match(/DeformPercent/) && e.has(o) && (e.get(o).curves.morph = i)
                }
            }
        }
        parseAnimationLayers(e) {
            let t = Ct.Objects.AnimationLayer
              , n = new Map;
            for (let i in t) {
                let s = []
                  , o = mn.get(parseInt(i));
                o !== void 0 && (o.children.forEach(function(l, c) {
                    if (e.has(l.ID)) {
                        let u = e.get(l.ID);
                        if (u.curves.x !== void 0 || u.curves.y !== void 0 || u.curves.z !== void 0) {
                            if (s[c] === void 0) {
                                let h = mn.get(l.ID).parents.filter(function(f) {
                                    return f.relationship !== void 0
                                })[0].ID;
                                if (h !== void 0) {
                                    let f = Ct.Objects.Model[h.toString()];
                                    if (f === void 0) {
                                        console.warn("THREE.FBXLoader: Encountered a unused curve.", l);
                                        return
                                    }
                                    let m = {
                                        modelName: f.attrName ? Nt.sanitizeNodeName(f.attrName) : "",
                                        ID: f.id,
                                        initialPosition: [0, 0, 0],
                                        initialRotation: [0, 0, 0],
                                        initialScale: [1, 1, 1]
                                    };
                                    Ti.traverse(function(g) {
                                        g.ID === f.id && (m.transform = g.matrix,
                                        g.userData.transformData && (m.eulerOrder = g.userData.transformData.eulerOrder))
                                    }),
                                    m.transform || (m.transform = new je),
                                    "PreRotation"in f && (m.preRotation = f.PreRotation.value),
                                    "PostRotation"in f && (m.postRotation = f.PostRotation.value),
                                    s[c] = m
                                }
                            }
                            s[c] && (s[c][u.attr] = u)
                        } else if (u.curves.morph !== void 0) {
                            if (s[c] === void 0) {
                                let h = mn.get(l.ID).parents.filter(function(d) {
                                    return d.relationship !== void 0
                                })[0].ID
                                  , f = mn.get(h).parents[0].ID
                                  , m = mn.get(f).parents[0].ID
                                  , g = mn.get(m).parents[0].ID
                                  , v = Ct.Objects.Model[g]
                                  , p = {
                                    modelName: v.attrName ? Nt.sanitizeNodeName(v.attrName) : "",
                                    morphName: Ct.Objects.Deformer[h].attrName
                                };
                                s[c] = p
                            }
                            s[c][u.attr] = u
                        }
                    }
                }),
                n.set(parseInt(i), s))
            }
            return n
        }
        parseAnimStacks(e) {
            let t = Ct.Objects.AnimationStack
              , n = {};
            for (let i in t) {
                let s = mn.get(parseInt(i)).children;
                s.length > 1 && console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");
                let o = e.get(s[0].ID);
                n[i] = {
                    name: t[i].attrName,
                    layer: o
                }
            }
            return n
        }
        addClip(e) {
            let t = []
              , n = this;
            return e.layer.forEach(function(i) {
                t = t.concat(n.generateTracks(i))
            }),
            new Bo(e.name,-1,t)
        }
        generateTracks(e) {
            let t = []
              , n = new ue
              , i = new Sn
              , s = new ue;
            if (e.transform && e.transform.decompose(n, i, s),
            n = n.toArray(),
            i = new ii().setFromQuaternion(i, e.eulerOrder).toArray(),
            s = s.toArray(),
            e.T !== void 0 && Object.keys(e.T.curves).length > 0) {
                let o = this.generateVectorTrack(e.modelName, e.T.curves, n, "position");
                o !== void 0 && t.push(o)
            }
            if (e.R !== void 0 && Object.keys(e.R.curves).length > 0) {
                let o = this.generateRotationTrack(e.modelName, e.R.curves, i, e.preRotation, e.postRotation, e.eulerOrder);
                o !== void 0 && t.push(o)
            }
            if (e.S !== void 0 && Object.keys(e.S.curves).length > 0) {
                let o = this.generateVectorTrack(e.modelName, e.S.curves, s, "scale");
                o !== void 0 && t.push(o)
            }
            if (e.DeformPercent !== void 0) {
                let o = this.generateMorphTrack(e);
                o !== void 0 && t.push(o)
            }
            return t
        }
        generateVectorTrack(e, t, n, i) {
            let s = this.getTimesForAllAxes(t)
              , o = this.getKeyframeTrackValues(s, t, n);
            return new fr(e + "." + i,s,o)
        }
        generateRotationTrack(e, t, n, i, s, o) {
            t.x !== void 0 && (this.interpolateRotations(t.x),
            t.x.values = t.x.values.map(Wn.degToRad)),
            t.y !== void 0 && (this.interpolateRotations(t.y),
            t.y.values = t.y.values.map(Wn.degToRad)),
            t.z !== void 0 && (this.interpolateRotations(t.z),
            t.z.values = t.z.values.map(Wn.degToRad));
            let a = this.getTimesForAllAxes(t)
              , l = this.getKeyframeTrackValues(a, t, n);
            i !== void 0 && (i = i.map(Wn.degToRad),
            i.push(o),
            i = new ii().fromArray(i),
            i = new Sn().setFromEuler(i)),
            s !== void 0 && (s = s.map(Wn.degToRad),
            s.push(o),
            s = new ii().fromArray(s),
            s = new Sn().setFromEuler(s).invert());
            let c = new Sn
              , u = new ii
              , h = [];
            for (let f = 0; f < l.length; f += 3)
                u.set(l[f], l[f + 1], l[f + 2], o),
                c.setFromEuler(u),
                i !== void 0 && c.premultiply(i),
                s !== void 0 && c.multiply(s),
                c.toArray(h, f / 3 * 4);
            return new hr(e + ".quaternion",a,h)
        }
        generateMorphTrack(e) {
            let t = e.DeformPercent.curves.morph
              , n = t.values.map(function(s) {
                return s / 100
            })
              , i = Ti.getObjectByName(e.modelName).morphTargetDictionary[e.morphName];
            return new Js(e.modelName + ".morphTargetInfluences[" + i + "]",t.times,n)
        }
        getTimesForAllAxes(e) {
            let t = [];
            if (e.x !== void 0 && (t = t.concat(e.x.times)),
            e.y !== void 0 && (t = t.concat(e.y.times)),
            e.z !== void 0 && (t = t.concat(e.z.times)),
            t = t.sort(function(n, i) {
                return n - i
            }),
            t.length > 1) {
                let n = 1
                  , i = t[0];
                for (let s = 1; s < t.length; s++) {
                    let o = t[s];
                    o !== i && (t[n] = o,
                    i = o,
                    n++)
                }
                t = t.slice(0, n)
            }
            return t
        }
        getKeyframeTrackValues(e, t, n) {
            let i = n
              , s = []
              , o = -1
              , a = -1
              , l = -1;
            return e.forEach(function(c) {
                if (t.x && (o = t.x.times.indexOf(c)),
                t.y && (a = t.y.times.indexOf(c)),
                t.z && (l = t.z.times.indexOf(c)),
                o !== -1) {
                    let u = t.x.values[o];
                    s.push(u),
                    i[0] = u
                } else
                    s.push(i[0]);
                if (a !== -1) {
                    let u = t.y.values[a];
                    s.push(u),
                    i[1] = u
                } else
                    s.push(i[1]);
                if (l !== -1) {
                    let u = t.z.values[l];
                    s.push(u),
                    i[2] = u
                } else
                    s.push(i[2])
            }),
            s
        }
        interpolateRotations(e) {
            for (let t = 1; t < e.values.length; t++) {
                let n = e.values[t - 1]
                  , i = e.values[t] - n
                  , s = Math.abs(i);
                if (s >= 180) {
                    let o = s / 180
                      , a = i / o
                      , l = n + a
                      , c = e.times[t - 1]
                      , h = (e.times[t] - c) / o
                      , f = c + h
                      , m = []
                      , g = [];
                    for (; f < e.times[t]; )
                        m.push(f),
                        f += h,
                        g.push(l),
                        l += a;
                    e.times = iy(e.times, t, m),
                    e.values = iy(e.values, t, g)
                }
            }
        }
    }
    , um = class {
        getPrevNode() {
            return this.nodeStack[this.currentIndent - 2]
        }
        getCurrentNode() {
            return this.nodeStack[this.currentIndent - 1]
        }
        getCurrentProp() {
            return this.currentProp
        }
        pushStack(e) {
            this.nodeStack.push(e),
            this.currentIndent += 1
        }
        popStack() {
            this.nodeStack.pop(),
            this.currentIndent -= 1
        }
        setCurrentProp(e, t) {
            this.currentProp = e,
            this.currentPropName = t
        }
        parse(e) {
            this.currentIndent = 0,
            this.allNodes = new pf,
            this.nodeStack = [],
            this.currentProp = [],
            this.currentPropName = "";
            let t = this
              , n = e.split(/[\r\n]+/);
            return n.forEach(function(i, s) {
                let o = i.match(/^[\s\t]*;/)
                  , a = i.match(/^[\s\t]*$/);
                if (o || a)
                    return;
                let l = i.match("^\\t{" + t.currentIndent + "}(\\w+):(.*){", "")
                  , c = i.match("^\\t{" + t.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)")
                  , u = i.match("^\\t{" + (t.currentIndent - 1) + "}}");
                l ? t.parseNodeBegin(i, l) : c ? t.parseNodeProperty(i, c, n[++s]) : u ? t.popStack() : i.match(/^[^\s\t}]/) && t.parseNodePropertyContinued(i)
            }),
            this.allNodes
        }
        parseNodeBegin(e, t) {
            let n = t[1].trim().replace(/^"/, "").replace(/"$/, "")
              , i = t[2].split(",").map(function(l) {
                return l.trim().replace(/^"/, "").replace(/"$/, "")
            })
              , s = {
                name: n
            }
              , o = this.parseNodeAttr(i)
              , a = this.getCurrentNode();
            this.currentIndent === 0 ? this.allNodes.add(n, s) : n in a ? (n === "PoseNode" ? a.PoseNode.push(s) : a[n].id !== void 0 && (a[n] = {},
            a[n][a[n].id] = a[n]),
            o.id !== "" && (a[n][o.id] = s)) : typeof o.id == "number" ? (a[n] = {},
            a[n][o.id] = s) : n !== "Properties70" && (n === "PoseNode" ? a[n] = [s] : a[n] = s),
            typeof o.id == "number" && (s.id = o.id),
            o.name !== "" && (s.attrName = o.name),
            o.type !== "" && (s.attrType = o.type),
            this.pushStack(s)
        }
        parseNodeAttr(e) {
            let t = e[0];
            e[0] !== "" && (t = parseInt(e[0]),
            isNaN(t) && (t = e[0]));
            let n = ""
              , i = "";
            return e.length > 1 && (n = e[1].replace(/^(\w+)::/, ""),
            i = e[2]),
            {
                id: t,
                name: n,
                type: i
            }
        }
        parseNodeProperty(e, t, n) {
            let i = t[1].replace(/^"/, "").replace(/"$/, "").trim()
              , s = t[2].replace(/^"/, "").replace(/"$/, "").trim();
            i === "Content" && s === "," && (s = n.replace(/"/g, "").replace(/,$/, "").trim());
            let o = this.getCurrentNode();
            if (o.name === "Properties70") {
                this.parseNodeSpecialProperty(e, i, s);
                return
            }
            if (i === "C") {
                let l = s.split(",").slice(1)
                  , c = parseInt(l[0])
                  , u = parseInt(l[1])
                  , h = s.split(",").slice(3);
                h = h.map(function(f) {
                    return f.trim().replace(/^"/, "")
                }),
                i = "connections",
                s = [c, u],
                Rw(s, h),
                o[i] === void 0 && (o[i] = [])
            }
            i === "Node" && (o.id = s),
            i in o && Array.isArray(o[i]) ? o[i].push(s) : i !== "a" ? o[i] = s : o.a = s,
            this.setCurrentProp(o, i),
            i === "a" && s.slice(-1) !== "," && (o.a = om(s))
        }
        parseNodePropertyContinued(e) {
            let t = this.getCurrentNode();
            t.a += e,
            e.slice(-1) !== "," && (t.a = om(t.a))
        }
        parseNodeSpecialProperty(e, t, n) {
            let i = n.split('",').map(function(u) {
                return u.trim().replace(/^\"/, "").replace(/\s/, "_")
            })
              , s = i[0]
              , o = i[1]
              , a = i[2]
              , l = i[3]
              , c = i[4];
            switch (o) {
            case "int":
            case "enum":
            case "bool":
            case "ULongLong":
            case "double":
            case "Number":
            case "FieldOfView":
                c = parseFloat(c);
                break;
            case "Color":
            case "ColorRGB":
            case "Vector3D":
            case "Lcl_Translation":
            case "Lcl_Rotation":
            case "Lcl_Scaling":
                c = om(c);
                break
            }
            this.getPrevNode()[s] = {
                type: o,
                type2: a,
                flag: l,
                value: c
            },
            this.setCurrentProp(this.getPrevNode(), s)
        }
    }
    , hm = class {
        parse(e) {
            let t = new df(e);
            t.skip(23);
            let n = t.getUint32();
            if (n < 6400)
                throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + n);
            let i = new pf;
            for (; !this.endOfContent(t); ) {
                let s = this.parseNode(t, n);
                s !== null && i.add(s.name, s)
            }
            return i
        }
        endOfContent(e) {
            return e.size() % 16 === 0 ? (e.getOffset() + 160 + 16 & -16) >= e.size() : e.getOffset() + 160 + 16 >= e.size()
        }
        parseNode(e, t) {
            let n = {}
              , i = t >= 7500 ? e.getUint64() : e.getUint32()
              , s = t >= 7500 ? e.getUint64() : e.getUint32();
            t >= 7500 ? e.getUint64() : e.getUint32();
            let o = e.getUint8()
              , a = e.getString(o);
            if (i === 0)
                return null;
            let l = [];
            for (let f = 0; f < s; f++)
                l.push(this.parseProperty(e));
            let c = l.length > 0 ? l[0] : ""
              , u = l.length > 1 ? l[1] : ""
              , h = l.length > 2 ? l[2] : "";
            for (n.singleProperty = s === 1 && e.getOffset() === i; i > e.getOffset(); ) {
                let f = this.parseNode(e, t);
                f !== null && this.parseSubNode(a, n, f)
            }
            return n.propertyList = l,
            typeof c == "number" && (n.id = c),
            u !== "" && (n.attrName = u),
            h !== "" && (n.attrType = h),
            a !== "" && (n.name = a),
            n
        }
        parseSubNode(e, t, n) {
            if (n.singleProperty === !0) {
                let i = n.propertyList[0];
                Array.isArray(i) ? (t[n.name] = n,
                n.a = i) : t[n.name] = i
            } else if (e === "Connections" && n.name === "C") {
                let i = [];
                n.propertyList.forEach(function(s, o) {
                    o !== 0 && i.push(s)
                }),
                t.connections === void 0 && (t.connections = []),
                t.connections.push(i)
            } else if (n.name === "Properties70")
                Object.keys(n).forEach(function(s) {
                    t[s] = n[s]
                });
            else if (e === "Properties70" && n.name === "P") {
                let i = n.propertyList[0], s = n.propertyList[1], o = n.propertyList[2], a = n.propertyList[3], l;
                i.indexOf("Lcl ") === 0 && (i = i.replace("Lcl ", "Lcl_")),
                s.indexOf("Lcl ") === 0 && (s = s.replace("Lcl ", "Lcl_")),
                s === "Color" || s === "ColorRGB" || s === "Vector" || s === "Vector3D" || s.indexOf("Lcl_") === 0 ? l = [n.propertyList[4], n.propertyList[5], n.propertyList[6]] : l = n.propertyList[4],
                t[i] = {
                    type: s,
                    type2: o,
                    flag: a,
                    value: l
                }
            } else
                t[n.name] === void 0 ? typeof n.id == "number" ? (t[n.name] = {},
                t[n.name][n.id] = n) : t[n.name] = n : n.name === "PoseNode" ? (Array.isArray(t[n.name]) || (t[n.name] = [t[n.name]]),
                t[n.name].push(n)) : t[n.name][n.id] === void 0 && (t[n.name][n.id] = n)
        }
        parseProperty(e) {
            let t = e.getString(1), n;
            switch (t) {
            case "C":
                return e.getBoolean();
            case "D":
                return e.getFloat64();
            case "F":
                return e.getFloat32();
            case "I":
                return e.getInt32();
            case "L":
                return e.getInt64();
            case "R":
                return n = e.getUint32(),
                e.getArrayBuffer(n);
            case "S":
                return n = e.getUint32(),
                e.getString(n);
            case "Y":
                return e.getInt16();
            case "b":
            case "c":
            case "d":
            case "f":
            case "i":
            case "l":
                let i = e.getUint32()
                  , s = e.getUint32()
                  , o = e.getUint32();
                if (s === 0)
                    switch (t) {
                    case "b":
                    case "c":
                        return e.getBooleanArray(i);
                    case "d":
                        return e.getFloat64Array(i);
                    case "f":
                        return e.getFloat32Array(i);
                    case "i":
                        return e.getInt32Array(i);
                    case "l":
                        return e.getInt64Array(i)
                    }
                let a = Zv(new Uint8Array(e.getArrayBuffer(o)))
                  , l = new df(a.buffer);
                switch (t) {
                case "b":
                case "c":
                    return l.getBooleanArray(i);
                case "d":
                    return l.getFloat64Array(i);
                case "f":
                    return l.getFloat32Array(i);
                case "i":
                    return l.getInt32Array(i);
                case "l":
                    return l.getInt64Array(i)
                }
                break;
            default:
                throw new Error("THREE.FBXLoader: Unknown property type " + t)
            }
        }
    }
    , df = class {
        constructor(e, t) {
            this.dv = new DataView(e),
            this.offset = 0,
            this.littleEndian = t !== void 0 ? t : !0,
            this._textDecoder = new TextDecoder
        }
        getOffset() {
            return this.offset
        }
        size() {
            return this.dv.buffer.byteLength
        }
        skip(e) {
            this.offset += e
        }
        getBoolean() {
            return (this.getUint8() & 1) === 1
        }
        getBooleanArray(e) {
            let t = [];
            for (let n = 0; n < e; n++)
                t.push(this.getBoolean());
            return t
        }
        getUint8() {
            let e = this.dv.getUint8(this.offset);
            return this.offset += 1,
            e
        }
        getInt16() {
            let e = this.dv.getInt16(this.offset, this.littleEndian);
            return this.offset += 2,
            e
        }
        getInt32() {
            let e = this.dv.getInt32(this.offset, this.littleEndian);
            return this.offset += 4,
            e
        }
        getInt32Array(e) {
            let t = [];
            for (let n = 0; n < e; n++)
                t.push(this.getInt32());
            return t
        }
        getUint32() {
            let e = this.dv.getUint32(this.offset, this.littleEndian);
            return this.offset += 4,
            e
        }
        getInt64() {
            let e, t;
            return this.littleEndian ? (e = this.getUint32(),
            t = this.getUint32()) : (t = this.getUint32(),
            e = this.getUint32()),
            t & 2147483648 ? (t = ~t & 4294967295,
            e = ~e & 4294967295,
            e === 4294967295 && (t = t + 1 & 4294967295),
            e = e + 1 & 4294967295,
            -(t * 4294967296 + e)) : t * 4294967296 + e
        }
        getInt64Array(e) {
            let t = [];
            for (let n = 0; n < e; n++)
                t.push(this.getInt64());
            return t
        }
        getUint64() {
            let e, t;
            return this.littleEndian ? (e = this.getUint32(),
            t = this.getUint32()) : (t = this.getUint32(),
            e = this.getUint32()),
            t * 4294967296 + e
        }
        getFloat32() {
            let e = this.dv.getFloat32(this.offset, this.littleEndian);
            return this.offset += 4,
            e
        }
        getFloat32Array(e) {
            let t = [];
            for (let n = 0; n < e; n++)
                t.push(this.getFloat32());
            return t
        }
        getFloat64() {
            let e = this.dv.getFloat64(this.offset, this.littleEndian);
            return this.offset += 8,
            e
        }
        getFloat64Array(e) {
            let t = [];
            for (let n = 0; n < e; n++)
                t.push(this.getFloat64());
            return t
        }
        getArrayBuffer(e) {
            let t = this.dv.buffer.slice(this.offset, this.offset + e);
            return this.offset += e,
            t
        }
        getString(e) {
            let t = this.offset
              , n = new Uint8Array(this.dv.buffer,t,e);
            this.skip(e);
            let i = n.indexOf(0);
            return i >= 0 && (n = new Uint8Array(this.dv.buffer,t,i)),
            this._textDecoder.decode(n)
        }
    }
    , pf = class {
        add(e, t) {
            this[e] = t
        }
    }
    ;
    function ww(r) {
        let e = "Kaydara FBX Binary  \0";
        return r.byteLength >= e.length && e === oy(r, 0, e.length)
    }
    function Aw(r) {
        let e = ["K", "a", "y", "d", "a", "r", "a", "\\", "F", "B", "X", "\\", "B", "i", "n", "a", "r", "y", "\\", "\\"]
          , t = 0;
        function n(i) {
            let s = r[i - 1];
            return r = r.slice(t + i),
            t++,
            s
        }
        for (let i = 0; i < e.length; ++i)
            if (n(1) === e[i])
                return !1;
        return !0
    }
    function ny(r) {
        let e = /FBXVersion: (\d+)/
          , t = r.match(e);
        if (t)
            return parseInt(t[1]);
        throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.")
    }
    function Cw(r) {
        return r / 46186158e3
    }
    var Iw = [];
    function hf(r, e, t, n) {
        let i;
        switch (n.mappingType) {
        case "ByPolygonVertex":
            i = r;
            break;
        case "ByPolygon":
            i = e;
            break;
        case "ByVertice":
            i = t;
            break;
        case "AllSame":
            i = n.indices[0];
            break;
        default:
            console.warn("THREE.FBXLoader: unknown attribute mapping type " + n.mappingType)
        }
        n.referenceType === "IndexToDirect" && (i = n.indices[i]);
        let s = i * n.dataSize
          , o = s + n.dataSize;
        return Pw(Iw, n.buffer, s, o)
    }
    var sm = new ii
      , Sl = new ue;
    function ry(r) {
        let e = new je
          , t = new je
          , n = new je
          , i = new je
          , s = new je
          , o = new je
          , a = new je
          , l = new je
          , c = new je
          , u = new je
          , h = new je
          , f = new je
          , m = r.inheritType ? r.inheritType : 0;
        if (r.translation && e.setPosition(Sl.fromArray(r.translation)),
        r.preRotation) {
            let R = r.preRotation.map(Wn.degToRad);
            R.push(r.eulerOrder || ii.DEFAULT_ORDER),
            t.makeRotationFromEuler(sm.fromArray(R))
        }
        if (r.rotation) {
            let R = r.rotation.map(Wn.degToRad);
            R.push(r.eulerOrder || ii.DEFAULT_ORDER),
            n.makeRotationFromEuler(sm.fromArray(R))
        }
        if (r.postRotation) {
            let R = r.postRotation.map(Wn.degToRad);
            R.push(r.eulerOrder || ii.DEFAULT_ORDER),
            i.makeRotationFromEuler(sm.fromArray(R)),
            i.invert()
        }
        r.scale && s.scale(Sl.fromArray(r.scale)),
        r.scalingOffset && a.setPosition(Sl.fromArray(r.scalingOffset)),
        r.scalingPivot && o.setPosition(Sl.fromArray(r.scalingPivot)),
        r.rotationOffset && l.setPosition(Sl.fromArray(r.rotationOffset)),
        r.rotationPivot && c.setPosition(Sl.fromArray(r.rotationPivot)),
        r.parentMatrixWorld && (h.copy(r.parentMatrix),
        u.copy(r.parentMatrixWorld));
        let g = t.clone().multiply(n).multiply(i)
          , v = new je;
        v.extractRotation(u);
        let p = new je;
        p.copyPosition(u);
        let d = p.clone().invert().multiply(u)
          , x = v.clone().invert().multiply(d)
          , y = s
          , _ = new je;
        if (m === 0)
            _.copy(v).multiply(g).multiply(x).multiply(y);
        else if (m === 1)
            _.copy(v).multiply(x).multiply(g).multiply(y);
        else {
            let q = new je().scale(new ue().setFromMatrixScale(h)).clone().invert()
              , k = x.clone().multiply(q);
            _.copy(v).multiply(g).multiply(k).multiply(y)
        }
        let S = c.clone().invert()
          , N = o.clone().invert()
          , I = e.clone().multiply(l).multiply(c).multiply(t).multiply(n).multiply(i).multiply(S).multiply(a).multiply(o).multiply(s).multiply(N)
          , O = new je().copyPosition(I)
          , M = u.clone().multiply(O);
        return f.copyPosition(M),
        I = f.clone().multiply(_),
        I.premultiply(u.invert()),
        I
    }
    function sy(r) {
        r = r || 0;
        let e = ["ZYX", "YZX", "XZY", "ZXY", "YXZ", "XYZ"];
        return r === 6 ? (console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."),
        e[0]) : e[r]
    }
    function om(r) {
        return r.split(",").map(function(t) {
            return parseFloat(t)
        })
    }
    function oy(r, e, t) {
        return e === void 0 && (e = 0),
        t === void 0 && (t = r.byteLength),
        new TextDecoder().decode(new Uint8Array(r,e,t))
    }
    function Rw(r, e) {
        for (let t = 0, n = r.length, i = e.length; t < i; t++,
        n++)
            r[n] = e[t]
    }
    function Pw(r, e, t, n) {
        for (let i = t, s = 0; i < n; i++,
        s++)
            r[s] = e[i];
        return r
    }
    function iy(r, e, t) {
        return r.slice(0, e).concat(t).concat(r.slice(e))
    }
    var mf = class extends Hn {
        constructor(e) {
            super(e)
        }
        load(e, t, n, i) {
            let s = this
              , o = s.path === "" ? Qs.extractUrlBase(e) : s.path
              , a = new Ni(s.manager);
            a.setPath(s.path),
            a.setRequestHeader(s.requestHeader),
            a.setWithCredentials(s.withCredentials),
            a.load(e, function(l) {
                try {
                    t(s.parse(l, o))
                } catch (c) {
                    i ? i(c) : console.error(c),
                    s.manager.itemError(e)
                }
            }, n, i)
        }
        parse(e, t) {
            function n(z, V) {
                let $ = []
                  , Z = z.childNodes;
                for (let ee = 0, Se = Z.length; ee < Se; ee++) {
                    let Re = Z[ee];
                    Re.nodeName === V && $.push(Re)
                }
                return $
            }
            function i(z) {
                if (z.length === 0)
                    return [];
                let V = z.trim().split(/\s+/)
                  , $ = new Array(V.length);
                for (let Z = 0, ee = V.length; Z < ee; Z++)
                    $[Z] = V[Z];
                return $
            }
            function s(z) {
                if (z.length === 0)
                    return [];
                let V = z.trim().split(/\s+/)
                  , $ = new Array(V.length);
                for (let Z = 0, ee = V.length; Z < ee; Z++)
                    $[Z] = parseFloat(V[Z]);
                return $
            }
            function o(z) {
                if (z.length === 0)
                    return [];
                let V = z.trim().split(/\s+/)
                  , $ = new Array(V.length);
                for (let Z = 0, ee = V.length; Z < ee; Z++)
                    $[Z] = parseInt(V[Z]);
                return $
            }
            function a(z) {
                return z.substring(1)
            }
            function l() {
                return "three_default_" + ux++
            }
            function c(z) {
                return Object.keys(z).length === 0
            }
            function u(z) {
                return {
                    unit: h(n(z, "unit")[0]),
                    upAxis: f(n(z, "up_axis")[0])
                }
            }
            function h(z) {
                return z !== void 0 && z.hasAttribute("meter") === !0 ? parseFloat(z.getAttribute("meter")) : 1
            }
            function f(z) {
                return z !== void 0 ? z.textContent : "Y_UP"
            }
            function m(z, V, $, Z) {
                let ee = n(z, V)[0];
                if (ee !== void 0) {
                    let Se = n(ee, $);
                    for (let Re = 0; Re < Se.length; Re++)
                        Z(Se[Re])
                }
            }
            function g(z, V) {
                for (let $ in z) {
                    let Z = z[$];
                    Z.build = V(z[$])
                }
            }
            function v(z, V) {
                return z.build !== void 0 || (z.build = V(z)),
                z.build
            }
            function p(z) {
                let V = {
                    sources: {},
                    samplers: {},
                    channels: {}
                }
                  , $ = !1;
                for (let Z = 0, ee = z.childNodes.length; Z < ee; Z++) {
                    let Se = z.childNodes[Z];
                    if (Se.nodeType !== 1)
                        continue;
                    let Re;
                    switch (Se.nodeName) {
                    case "source":
                        Re = Se.getAttribute("id"),
                        V.sources[Re] = we(Se);
                        break;
                    case "sampler":
                        Re = Se.getAttribute("id"),
                        V.samplers[Re] = d(Se);
                        break;
                    case "channel":
                        Re = Se.getAttribute("target"),
                        V.channels[Re] = x(Se);
                        break;
                    case "animation":
                        p(Se),
                        $ = !0;
                        break;
                    default:
                        console.log(Se)
                    }
                }
                $ === !1 && (ft.animations[z.getAttribute("id") || Wn.generateUUID()] = V)
            }
            function d(z) {
                let V = {
                    inputs: {}
                };
                for (let $ = 0, Z = z.childNodes.length; $ < Z; $++) {
                    let ee = z.childNodes[$];
                    if (ee.nodeType === 1)
                        switch (ee.nodeName) {
                        case "input":
                            let Se = a(ee.getAttribute("source"))
                              , Re = ee.getAttribute("semantic");
                            V.inputs[Re] = Se;
                            break
                        }
                }
                return V
            }
            function x(z) {
                let V = {}
                  , Z = z.getAttribute("target").split("/")
                  , ee = Z.shift()
                  , Se = Z.shift()
                  , Re = Se.indexOf("(") !== -1
                  , Je = Se.indexOf(".") !== -1;
                if (Je)
                    Z = Se.split("."),
                    Se = Z.shift(),
                    V.member = Z.shift();
                else if (Re) {
                    let Ge = Se.split("(");
                    Se = Ge.shift();
                    for (let Xe = 0; Xe < Ge.length; Xe++)
                        Ge[Xe] = parseInt(Ge[Xe].replace(/\)/, ""));
                    V.indices = Ge
                }
                return V.id = ee,
                V.sid = Se,
                V.arraySyntax = Re,
                V.memberSyntax = Je,
                V.sampler = a(z.getAttribute("source")),
                V
            }
            function y(z) {
                let V = []
                  , $ = z.channels
                  , Z = z.samplers
                  , ee = z.sources;
                for (let Se in $)
                    if ($.hasOwnProperty(Se)) {
                        let Re = $[Se]
                          , Je = Z[Re.sampler]
                          , Ge = Je.inputs.INPUT
                          , Xe = Je.inputs.OUTPUT
                          , it = ee[Ge]
                          , Oe = ee[Xe]
                          , nt = S(Re, it, Oe);
                        R(nt, V)
                    }
                return V
            }
            function _(z) {
                return v(ft.animations[z], y)
            }
            function S(z, V, $) {
                let Z = ft.nodes[z.id], ee = cn(Z.id), Se = Z.transforms[z.sid], Re = Z.matrix.clone().transpose(), Je, Ge, Xe, it, Oe, nt, et = {};
                switch (Se) {
                case "matrix":
                    for (Xe = 0,
                    it = V.array.length; Xe < it; Xe++)
                        if (Je = V.array[Xe],
                        Ge = Xe * $.stride,
                        et[Je] === void 0 && (et[Je] = {}),
                        z.arraySyntax === !0) {
                            let an = $.array[Ge]
                              , Xt = z.indices[0] + 4 * z.indices[1];
                            et[Je][Xt] = an
                        } else
                            for (Oe = 0,
                            nt = $.stride; Oe < nt; Oe++)
                                et[Je][Oe] = $.array[Ge + Oe];
                    break;
                case "translate":
                    console.warn('THREE.ColladaLoader: Animation transform type "%s" not yet implemented.', Se);
                    break;
                case "rotate":
                    console.warn('THREE.ColladaLoader: Animation transform type "%s" not yet implemented.', Se);
                    break;
                case "scale":
                    console.warn('THREE.ColladaLoader: Animation transform type "%s" not yet implemented.', Se);
                    break
                }
                let ut = N(et, Re);
                return {
                    name: ee.uuid,
                    keyframes: ut
                }
            }
            function N(z, V) {
                let $ = [];
                for (let ee in z)
                    $.push({
                        time: parseFloat(ee),
                        value: z[ee]
                    });
                $.sort(Z);
                for (let ee = 0; ee < 16; ee++)
                    q($, ee, V.elements[ee]);
                return $;
                function Z(ee, Se) {
                    return ee.time - Se.time
                }
            }
            let I = new ue
              , O = new ue
              , M = new Sn;
            function R(z, V) {
                let $ = z.keyframes
                  , Z = z.name
                  , ee = []
                  , Se = []
                  , Re = []
                  , Je = [];
                for (let Ge = 0, Xe = $.length; Ge < Xe; Ge++) {
                    let it = $[Ge]
                      , Oe = it.time
                      , nt = it.value;
                    Wt.fromArray(nt).transpose(),
                    Wt.decompose(I, M, O),
                    ee.push(Oe),
                    Se.push(I.x, I.y, I.z),
                    Re.push(M.x, M.y, M.z, M.w),
                    Je.push(O.x, O.y, O.z)
                }
                return Se.length > 0 && V.push(new fr(Z + ".position",ee,Se)),
                Re.length > 0 && V.push(new hr(Z + ".quaternion",ee,Re)),
                Je.length > 0 && V.push(new fr(Z + ".scale",ee,Je)),
                V
            }
            function q(z, V, $) {
                let Z, ee = !0, Se, Re;
                for (Se = 0,
                Re = z.length; Se < Re; Se++)
                    Z = z[Se],
                    Z.value[V] === void 0 ? Z.value[V] = null : ee = !1;
                if (ee === !0)
                    for (Se = 0,
                    Re = z.length; Se < Re; Se++)
                        Z = z[Se],
                        Z.value[V] = $;
                else
                    k(z, V)
            }
            function k(z, V) {
                let $, Z;
                for (let ee = 0, Se = z.length; ee < Se; ee++) {
                    let Re = z[ee];
                    if (Re.value[V] === null) {
                        if ($ = B(z, ee, V),
                        Z = P(z, ee, V),
                        $ === null) {
                            Re.value[V] = Z.value[V];
                            continue
                        }
                        if (Z === null) {
                            Re.value[V] = $.value[V];
                            continue
                        }
                        C(Re, $, Z, V)
                    }
                }
            }
            function B(z, V, $) {
                for (; V >= 0; ) {
                    let Z = z[V];
                    if (Z.value[$] !== null)
                        return Z;
                    V--
                }
                return null
            }
            function P(z, V, $) {
                for (; V < z.length; ) {
                    let Z = z[V];
                    if (Z.value[$] !== null)
                        return Z;
                    V++
                }
                return null
            }
            function C(z, V, $, Z) {
                if ($.time - V.time === 0) {
                    z.value[Z] = V.value[Z];
                    return
                }
                z.value[Z] = (z.time - V.time) * ($.value[Z] - V.value[Z]) / ($.time - V.time) + V.value[Z]
            }
            function L(z) {
                let V = {
                    name: z.getAttribute("id") || "default",
                    start: parseFloat(z.getAttribute("start") || 0),
                    end: parseFloat(z.getAttribute("end") || 0),
                    animations: []
                };
                for (let $ = 0, Z = z.childNodes.length; $ < Z; $++) {
                    let ee = z.childNodes[$];
                    if (ee.nodeType === 1)
                        switch (ee.nodeName) {
                        case "instance_animation":
                            V.animations.push(a(ee.getAttribute("url")));
                            break
                        }
                }
                ft.clips[z.getAttribute("id")] = V
            }
            function F(z) {
                let V = []
                  , $ = z.name
                  , Z = z.end - z.start || -1
                  , ee = z.animations;
                for (let Se = 0, Re = ee.length; Se < Re; Se++) {
                    let Je = _(ee[Se]);
                    for (let Ge = 0, Xe = Je.length; Ge < Xe; Ge++)
                        V.push(Je[Ge])
                }
                return new Bo($,Z,V)
            }
            function U(z) {
                return v(ft.clips[z], F)
            }
            function W(z) {
                let V = {};
                for (let $ = 0, Z = z.childNodes.length; $ < Z; $++) {
                    let ee = z.childNodes[$];
                    if (ee.nodeType === 1)
                        switch (ee.nodeName) {
                        case "skin":
                            V.id = a(ee.getAttribute("source")),
                            V.skin = K(ee);
                            break;
                        case "morph":
                            V.id = a(ee.getAttribute("source")),
                            console.warn("THREE.ColladaLoader: Morph target animation not supported yet.");
                            break
                        }
                }
                ft.controllers[z.getAttribute("id")] = V
            }
            function K(z) {
                let V = {
                    sources: {}
                };
                for (let $ = 0, Z = z.childNodes.length; $ < Z; $++) {
                    let ee = z.childNodes[$];
                    if (ee.nodeType === 1)
                        switch (ee.nodeName) {
                        case "bind_shape_matrix":
                            V.bindShapeMatrix = s(ee.textContent);
                            break;
                        case "source":
                            let Se = ee.getAttribute("id");
                            V.sources[Se] = we(ee);
                            break;
                        case "joints":
                            V.joints = re(ee);
                            break;
                        case "vertex_weights":
                            V.vertexWeights = oe(ee);
                            break
                        }
                }
                return V
            }
            function re(z) {
                let V = {
                    inputs: {}
                };
                for (let $ = 0, Z = z.childNodes.length; $ < Z; $++) {
                    let ee = z.childNodes[$];
                    if (ee.nodeType === 1)
                        switch (ee.nodeName) {
                        case "input":
                            let Se = ee.getAttribute("semantic")
                              , Re = a(ee.getAttribute("source"));
                            V.inputs[Se] = Re;
                            break
                        }
                }
                return V
            }
            function oe(z) {
                let V = {
                    inputs: {}
                };
                for (let $ = 0, Z = z.childNodes.length; $ < Z; $++) {
                    let ee = z.childNodes[$];
                    if (ee.nodeType === 1)
                        switch (ee.nodeName) {
                        case "input":
                            let Se = ee.getAttribute("semantic")
                              , Re = a(ee.getAttribute("source"))
                              , Je = parseInt(ee.getAttribute("offset"));
                            V.inputs[Se] = {
                                id: Re,
                                offset: Je
                            };
                            break;
                        case "vcount":
                            V.vcount = o(ee.textContent);
                            break;
                        case "v":
                            V.v = o(ee.textContent);
                            break
                        }
                }
                return V
            }
            function j(z) {
                let V = {
                    id: z.id
                }
                  , $ = ft.geometries[V.id];
                return z.skin !== void 0 && (V.skin = w(z.skin),
                $.sources.skinIndices = V.skin.indices,
                $.sources.skinWeights = V.skin.weights),
                V
            }
            function w(z) {
                let $ = {
                    joints: [],
                    indices: {
                        array: [],
                        stride: 4
                    },
                    weights: {
                        array: [],
                        stride: 4
                    }
                }, Z = z.sources, ee = z.vertexWeights, Se = ee.vcount, Re = ee.v, Je = ee.inputs.JOINT.offset, Ge = ee.inputs.WEIGHT.offset, Xe = z.sources[z.joints.inputs.JOINT], it = z.sources[z.joints.inputs.INV_BIND_MATRIX], Oe = Z[ee.inputs.WEIGHT.id].array, nt = 0, et, ut, st;
                for (et = 0,
                st = Se.length; et < st; et++) {
                    let Xt = Se[et]
                      , Ft = [];
                    for (ut = 0; ut < Xt; ut++) {
                        let kt = Re[nt + Je]
                          , es = Re[nt + Ge]
                          , li = Oe[es];
                        Ft.push({
                            index: kt,
                            weight: li
                        }),
                        nt += 2
                    }
                    for (Ft.sort(an),
                    ut = 0; ut < 4; ut++) {
                        let kt = Ft[ut];
                        kt !== void 0 ? ($.indices.array.push(kt.index),
                        $.weights.array.push(kt.weight)) : ($.indices.array.push(0),
                        $.weights.array.push(0))
                    }
                }
                for (z.bindShapeMatrix ? $.bindMatrix = new je().fromArray(z.bindShapeMatrix).transpose() : $.bindMatrix = new je().identity(),
                et = 0,
                st = Xe.array.length; et < st; et++) {
                    let Xt = Xe.array[et]
                      , Ft = new je().fromArray(it.array, et * it.stride).transpose();
                    $.joints.push({
                        name: Xt,
                        boneInverse: Ft
                    })
                }
                return $;
                function an(Xt, Ft) {
                    return Ft.weight - Xt.weight
                }
            }
            function b(z) {
                return v(ft.controllers[z], j)
            }
            function E(z) {
                let V = {
                    init_from: n(z, "init_from")[0].textContent
                };
                ft.images[z.getAttribute("id")] = V
            }
            function T(z) {
                return z.build !== void 0 ? z.build : z.init_from
            }
            function H(z) {
                let V = ft.images[z];
                return V !== void 0 ? v(V, T) : (console.warn("THREE.ColladaLoader: Couldn't find image with ID:", z),
                null)
            }
            function Y(z) {
                let V = {};
                for (let $ = 0, Z = z.childNodes.length; $ < Z; $++) {
                    let ee = z.childNodes[$];
                    if (ee.nodeType === 1)
                        switch (ee.nodeName) {
                        case "profile_COMMON":
                            V.profile = X(ee);
                            break
                        }
                }
                ft.effects[z.getAttribute("id")] = V
            }
            function X(z) {
                let V = {
                    surfaces: {},
                    samplers: {}
                };
                for (let $ = 0, Z = z.childNodes.length; $ < Z; $++) {
                    let ee = z.childNodes[$];
                    if (ee.nodeType === 1)
                        switch (ee.nodeName) {
                        case "newparam":
                            ce(ee, V);
                            break;
                        case "technique":
                            V.technique = ie(ee);
                            break;
                        case "extra":
                            V.extra = Ee(ee);
                            break
                        }
                }
                return V
            }
            function ce(z, V) {
                let $ = z.getAttribute("sid");
                for (let Z = 0, ee = z.childNodes.length; Z < ee; Z++) {
                    let Se = z.childNodes[Z];
                    if (Se.nodeType === 1)
                        switch (Se.nodeName) {
                        case "surface":
                            V.surfaces[$] = J(Se);
                            break;
                        case "sampler2D":
                            V.samplers[$] = ae(Se);
                            break
                        }
                }
            }
            function J(z) {
                let V = {};
                for (let $ = 0, Z = z.childNodes.length; $ < Z; $++) {
                    let ee = z.childNodes[$];
                    if (ee.nodeType === 1)
                        switch (ee.nodeName) {
                        case "init_from":
                            V.init_from = ee.textContent;
                            break
                        }
                }
                return V
            }
            function ae(z) {
                let V = {};
                for (let $ = 0, Z = z.childNodes.length; $ < Z; $++) {
                    let ee = z.childNodes[$];
                    if (ee.nodeType === 1)
                        switch (ee.nodeName) {
                        case "source":
                            V.source = ee.textContent;
                            break
                        }
                }
                return V
            }
            function ie(z) {
                let V = {};
                for (let $ = 0, Z = z.childNodes.length; $ < Z; $++) {
                    let ee = z.childNodes[$];
                    if (ee.nodeType === 1)
                        switch (ee.nodeName) {
                        case "constant":
                        case "lambert":
                        case "blinn":
                        case "phong":
                            V.type = ee.nodeName,
                            V.parameters = me(ee);
                            break;
                        case "extra":
                            V.extra = Ee(ee);
                            break
                        }
                }
                return V
            }
            function me(z) {
                let V = {};
                for (let $ = 0, Z = z.childNodes.length; $ < Z; $++) {
                    let ee = z.childNodes[$];
                    if (ee.nodeType === 1)
                        switch (ee.nodeName) {
                        case "emission":
                        case "diffuse":
                        case "specular":
                        case "bump":
                        case "ambient":
                        case "shininess":
                        case "transparency":
                            V[ee.nodeName] = ve(ee);
                            break;
                        case "transparent":
                            V[ee.nodeName] = {
                                opaque: ee.hasAttribute("opaque") ? ee.getAttribute("opaque") : "A_ONE",
                                data: ve(ee)
                            };
                            break
                        }
                }
                return V
            }
            function ve(z) {
                let V = {};
                for (let $ = 0, Z = z.childNodes.length; $ < Z; $++) {
                    let ee = z.childNodes[$];
                    if (ee.nodeType === 1)
                        switch (ee.nodeName) {
                        case "color":
                            V[ee.nodeName] = s(ee.textContent);
                            break;
                        case "float":
                            V[ee.nodeName] = parseFloat(ee.textContent);
                            break;
                        case "texture":
                            V[ee.nodeName] = {
                                id: ee.getAttribute("texture"),
                                extra: be(ee)
                            };
                            break
                        }
                }
                return V
            }
            function be(z) {
                let V = {
                    technique: {}
                };
                for (let $ = 0, Z = z.childNodes.length; $ < Z; $++) {
                    let ee = z.childNodes[$];
                    if (ee.nodeType === 1)
                        switch (ee.nodeName) {
                        case "extra":
                            fe(ee, V);
                            break
                        }
                }
                return V
            }
            function fe(z, V) {
                for (let $ = 0, Z = z.childNodes.length; $ < Z; $++) {
                    let ee = z.childNodes[$];
                    if (ee.nodeType === 1)
                        switch (ee.nodeName) {
                        case "technique":
                            te(ee, V);
                            break
                        }
                }
            }
            function te(z, V) {
                for (let $ = 0, Z = z.childNodes.length; $ < Z; $++) {
                    let ee = z.childNodes[$];
                    if (ee.nodeType === 1)
                        switch (ee.nodeName) {
                        case "repeatU":
                        case "repeatV":
                        case "offsetU":
                        case "offsetV":
                            V.technique[ee.nodeName] = parseFloat(ee.textContent);
                            break;
                        case "wrapU":
                        case "wrapV":
                            ee.textContent.toUpperCase() === "TRUE" ? V.technique[ee.nodeName] = 1 : ee.textContent.toUpperCase() === "FALSE" ? V.technique[ee.nodeName] = 0 : V.technique[ee.nodeName] = parseInt(ee.textContent);
                            break;
                        case "bump":
                            V[ee.nodeName] = D(ee);
                            break
                        }
                }
            }
            function Ee(z) {
                let V = {};
                for (let $ = 0, Z = z.childNodes.length; $ < Z; $++) {
                    let ee = z.childNodes[$];
                    if (ee.nodeType === 1)
                        switch (ee.nodeName) {
                        case "technique":
                            V.technique = Le(ee);
                            break
                        }
                }
                return V
            }
            function Le(z) {
                let V = {};
                for (let $ = 0, Z = z.childNodes.length; $ < Z; $++) {
                    let ee = z.childNodes[$];
                    if (ee.nodeType === 1)
                        switch (ee.nodeName) {
                        case "double_sided":
                            V[ee.nodeName] = parseInt(ee.textContent);
                            break;
                        case "bump":
                            V[ee.nodeName] = D(ee);
                            break
                        }
                }
                return V
            }
            function D(z) {
                let V = {};
                for (let $ = 0, Z = z.childNodes.length; $ < Z; $++) {
                    let ee = z.childNodes[$];
                    if (ee.nodeType === 1)
                        switch (ee.nodeName) {
                        case "texture":
                            V[ee.nodeName] = {
                                id: ee.getAttribute("texture"),
                                texcoord: ee.getAttribute("texcoord"),
                                extra: be(ee)
                            };
                            break
                        }
                }
                return V
            }
            function A(z) {
                return z
            }
            function G(z) {
                return v(ft.effects[z], A)
            }
            function ne(z) {
                let V = {
                    name: z.getAttribute("name")
                };
                for (let $ = 0, Z = z.childNodes.length; $ < Z; $++) {
                    let ee = z.childNodes[$];
                    if (ee.nodeType === 1)
                        switch (ee.nodeName) {
                        case "instance_effect":
                            V.url = a(ee.getAttribute("url"));
                            break
                        }
                }
                ft.materials[z.getAttribute("id")] = V
            }
            function Q(z) {
                let V, $ = z.slice((z.lastIndexOf(".") - 1 >>> 0) + 2);
                switch ($ = $.toLowerCase(),
                $) {
                case "tga":
                    V = pd;
                    break;
                default:
                    V = fg
                }
                return V
            }
            function he(z) {
                let V = G(z.url), $ = V.profile.technique, Z;
                switch ($.type) {
                case "phong":
                case "blinn":
                    Z = new sn;
                    break;
                case "lambert":
                    Z = new Ya;
                    break;
                default:
                    Z = new Yi;
                    break
                }
                Z.name = z.name || "";
                function ee(Ge, Xe=null) {
                    let it = V.profile.samplers[Ge.id]
                      , Oe = null;
                    if (it !== void 0) {
                        let nt = V.profile.surfaces[it.source];
                        Oe = H(nt.init_from)
                    } else
                        console.warn("THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530)."),
                        Oe = H(Ge.id);
                    if (Oe !== null) {
                        let nt = Q(Oe);
                        if (nt !== void 0) {
                            let et = nt.load(Oe)
                              , ut = Ge.extra;
                            if (ut !== void 0 && ut.technique !== void 0 && c(ut.technique) === !1) {
                                let st = ut.technique;
                                et.wrapS = st.wrapU ? rn : Zt,
                                et.wrapT = st.wrapV ? rn : Zt,
                                et.offset.set(st.offsetU || 0, st.offsetV || 0),
                                et.repeat.set(st.repeatU || 1, st.repeatV || 1)
                            } else
                                et.wrapS = rn,
                                et.wrapT = rn;
                            return Xe !== null && (et.colorSpace = Xe),
                            et
                        } else
                            return console.warn("THREE.ColladaLoader: Loader for texture %s not found.", Oe),
                            null
                    } else
                        return console.warn("THREE.ColladaLoader: Couldn't create texture with ID:", Ge.id),
                        null
                }
                let Se = $.parameters;
                for (let Ge in Se) {
                    let Xe = Se[Ge];
                    switch (Ge) {
                    case "diffuse":
                        Xe.color && Z.color.fromArray(Xe.color),
                        Xe.texture && (Z.map = ee(Xe.texture, ct));
                        break;
                    case "specular":
                        Xe.color && Z.specular && Z.specular.fromArray(Xe.color),
                        Xe.texture && (Z.specularMap = ee(Xe.texture));
                        break;
                    case "bump":
                        Xe.texture && (Z.normalMap = ee(Xe.texture));
                        break;
                    case "ambient":
                        Xe.texture && (Z.lightMap = ee(Xe.texture, ct));
                        break;
                    case "shininess":
                        Xe.float && Z.shininess && (Z.shininess = Xe.float);
                        break;
                    case "emission":
                        Xe.color && Z.emissive && Z.emissive.fromArray(Xe.color),
                        Xe.texture && (Z.emissiveMap = ee(Xe.texture, ct));
                        break
                    }
                }
                Z.color.convertSRGBToLinear(),
                Z.specular && Z.specular.convertSRGBToLinear(),
                Z.emissive && Z.emissive.convertSRGBToLinear();
                let Re = Se.transparent
                  , Je = Se.transparency;
                if (Je === void 0 && Re && (Je = {
                    float: 1
                }),
                Re === void 0 && Je && (Re = {
                    opaque: "A_ONE",
                    data: {
                        color: [1, 1, 1, 1]
                    }
                }),
                Re && Je)
                    if (Re.data.texture)
                        Z.transparent = !0;
                    else {
                        let Ge = Re.data.color;
                        switch (Re.opaque) {
                        case "A_ONE":
                            Z.opacity = Ge[3] * Je.float;
                            break;
                        case "RGB_ZERO":
                            Z.opacity = 1 - Ge[0] * Je.float;
                            break;
                        case "A_ZERO":
                            Z.opacity = 1 - Ge[3] * Je.float;
                            break;
                        case "RGB_ONE":
                            Z.opacity = Ge[0] * Je.float;
                            break;
                        default:
                            console.warn('THREE.ColladaLoader: Invalid opaque type "%s" of transparent tag.', Re.opaque)
                        }
                        Z.opacity < 1 && (Z.transparent = !0)
                    }
                if ($.extra !== void 0 && $.extra.technique !== void 0) {
                    let Ge = $.extra.technique;
                    for (let Xe in Ge) {
                        let it = Ge[Xe];
                        switch (Xe) {
                        case "double_sided":
                            Z.side = it === 1 ? On : qi;
                            break;
                        case "bump":
                            Z.normalMap = ee(it.texture),
                            Z.normalScale = new Ie(1,1);
                            break
                        }
                    }
                }
                return Z
            }
            function de(z) {
                return v(ft.materials[z], he)
            }
            function ge(z) {
                let V = {
                    name: z.getAttribute("name")
                };
                for (let $ = 0, Z = z.childNodes.length; $ < Z; $++) {
                    let ee = z.childNodes[$];
                    if (ee.nodeType === 1)
                        switch (ee.nodeName) {
                        case "optics":
                            V.optics = le(ee);
                            break
                        }
                }
                ft.cameras[z.getAttribute("id")] = V
            }
            function le(z) {
                for (let V = 0; V < z.childNodes.length; V++) {
                    let $ = z.childNodes[V];
                    switch ($.nodeName) {
                    case "technique_common":
                        return xe($)
                    }
                }
                return {}
            }
            function xe(z) {
                let V = {};
                for (let $ = 0; $ < z.childNodes.length; $++) {
                    let Z = z.childNodes[$];
                    switch (Z.nodeName) {
                    case "perspective":
                    case "orthographic":
                        V.technique = Z.nodeName,
                        V.parameters = Me(Z);
                        break
                    }
                }
                return V
            }
            function Me(z) {
                let V = {};
                for (let $ = 0; $ < z.childNodes.length; $++) {
                    let Z = z.childNodes[$];
                    switch (Z.nodeName) {
                    case "xfov":
                    case "yfov":
                    case "xmag":
                    case "ymag":
                    case "znear":
                    case "zfar":
                    case "aspect_ratio":
                        V[Z.nodeName] = parseFloat(Z.textContent);
                        break
                    }
                }
                return V
            }
            function Ne(z) {
                let V;
                switch (z.optics.technique) {
                case "perspective":
                    V = new Qt(z.optics.parameters.yfov,z.optics.parameters.aspect_ratio,z.optics.parameters.znear,z.optics.parameters.zfar);
                    break;
                case "orthographic":
                    let $ = z.optics.parameters.ymag
                      , Z = z.optics.parameters.xmag
                      , ee = z.optics.parameters.aspect_ratio;
                    Z = Z === void 0 ? $ * ee : Z,
                    $ = $ === void 0 ? Z / ee : $,
                    Z *= .5,
                    $ *= .5,
                    V = new Dr(-Z,Z,$,-$,z.optics.parameters.znear,z.optics.parameters.zfar);
                    break;
                default:
                    V = new Qt;
                    break
                }
                return V.name = z.name || "",
                V
            }
            function De(z) {
                let V = ft.cameras[z];
                return V !== void 0 ? v(V, Ne) : (console.warn("THREE.ColladaLoader: Couldn't find camera with ID:", z),
                null)
            }
            function Ve(z) {
                let V = {};
                for (let $ = 0, Z = z.childNodes.length; $ < Z; $++) {
                    let ee = z.childNodes[$];
                    if (ee.nodeType === 1)
                        switch (ee.nodeName) {
                        case "technique_common":
                            V = Ze(ee);
                            break
                        }
                }
                ft.lights[z.getAttribute("id")] = V
            }
            function Ze(z) {
                let V = {};
                for (let $ = 0, Z = z.childNodes.length; $ < Z; $++) {
                    let ee = z.childNodes[$];
                    if (ee.nodeType === 1)
                        switch (ee.nodeName) {
                        case "directional":
                        case "point":
                        case "spot":
                        case "ambient":
                            V.technique = ee.nodeName,
                            V.parameters = We(ee)
                        }
                }
                return V
            }
            function We(z) {
                let V = {};
                for (let $ = 0, Z = z.childNodes.length; $ < Z; $++) {
                    let ee = z.childNodes[$];
                    if (ee.nodeType === 1)
                        switch (ee.nodeName) {
                        case "color":
                            let Se = s(ee.textContent);
                            V.color = new $e().fromArray(Se).convertSRGBToLinear();
                            break;
                        case "falloff_angle":
                            V.falloffAngle = parseFloat(ee.textContent);
                            break;
                        case "quadratic_attenuation":
                            let Re = parseFloat(ee.textContent);
                            V.distance = Re ? Math.sqrt(1 / Re) : 0;
                            break
                        }
                }
                return V
            }
            function Qe(z) {
                let V;
                switch (z.technique) {
                case "directional":
                    V = new Fr;
                    break;
                case "point":
                    V = new Go;
                    break;
                case "spot":
                    V = new Ja;
                    break;
                case "ambient":
                    V = new kr;
                    break
                }
                return z.parameters.color && V.color.copy(z.parameters.color),
                z.parameters.distance && (V.distance = z.parameters.distance),
                V
            }
            function pe(z) {
                let V = ft.lights[z];
                return V !== void 0 ? v(V, Qe) : (console.warn("THREE.ColladaLoader: Couldn't find light with ID:", z),
                null)
            }
            function _e(z) {
                let V = {
                    name: z.getAttribute("name"),
                    sources: {},
                    vertices: {},
                    primitives: []
                }
                  , $ = n(z, "mesh")[0];
                if ($ !== void 0) {
                    for (let Z = 0; Z < $.childNodes.length; Z++) {
                        let ee = $.childNodes[Z];
                        if (ee.nodeType !== 1)
                            continue;
                        let Se = ee.getAttribute("id");
                        switch (ee.nodeName) {
                        case "source":
                            V.sources[Se] = we(ee);
                            break;
                        case "vertices":
                            V.vertices = Fe(ee);
                            break;
                        case "polygons":
                            console.warn("THREE.ColladaLoader: Unsupported primitive type: ", ee.nodeName);
                            break;
                        case "lines":
                        case "linestrips":
                        case "polylist":
                        case "triangles":
                            V.primitives.push(Ue(ee));
                            break;
                        default:
                            console.log(ee)
                        }
                    }
                    ft.geometries[z.getAttribute("id")] = V
                }
            }
            function we(z) {
                let V = {
                    array: [],
                    stride: 3
                };
                for (let $ = 0; $ < z.childNodes.length; $++) {
                    let Z = z.childNodes[$];
                    if (Z.nodeType === 1)
                        switch (Z.nodeName) {
                        case "float_array":
                            V.array = s(Z.textContent);
                            break;
                        case "Name_array":
                            V.array = i(Z.textContent);
                            break;
                        case "technique_common":
                            let ee = n(Z, "accessor")[0];
                            ee !== void 0 && (V.stride = parseInt(ee.getAttribute("stride")));
                            break
                        }
                }
                return V
            }
            function Fe(z) {
                let V = {};
                for (let $ = 0; $ < z.childNodes.length; $++) {
                    let Z = z.childNodes[$];
                    Z.nodeType === 1 && (V[Z.getAttribute("semantic")] = a(Z.getAttribute("source")))
                }
                return V
            }
            function Ue(z) {
                let V = {
                    type: z.nodeName,
                    material: z.getAttribute("material"),
                    count: parseInt(z.getAttribute("count")),
                    inputs: {},
                    stride: 0,
                    hasUV: !1
                };
                for (let $ = 0, Z = z.childNodes.length; $ < Z; $++) {
                    let ee = z.childNodes[$];
                    if (ee.nodeType === 1)
                        switch (ee.nodeName) {
                        case "input":
                            let Se = a(ee.getAttribute("source"))
                              , Re = ee.getAttribute("semantic")
                              , Je = parseInt(ee.getAttribute("offset"))
                              , Ge = parseInt(ee.getAttribute("set"))
                              , Xe = Ge > 0 ? Re + Ge : Re;
                            V.inputs[Xe] = {
                                id: Se,
                                offset: Je
                            },
                            V.stride = Math.max(V.stride, Je + 1),
                            Re === "TEXCOORD" && (V.hasUV = !0);
                            break;
                        case "vcount":
                            V.vcount = o(ee.textContent);
                            break;
                        case "p":
                            V.p = o(ee.textContent);
                            break
                        }
                }
                return V
            }
            function pt(z) {
                let V = {};
                for (let $ = 0; $ < z.length; $++) {
                    let Z = z[$];
                    V[Z.type] === void 0 && (V[Z.type] = []),
                    V[Z.type].push(Z)
                }
                return V
            }
            function mt(z) {
                let V = 0;
                for (let $ = 0, Z = z.length; $ < Z; $++)
                    z[$].hasUV === !0 && V++;
                V > 0 && V < z.length && (z.uvsNeedsFix = !0)
            }
            function ot(z) {
                let V = {}
                  , $ = z.sources
                  , Z = z.vertices
                  , ee = z.primitives;
                if (ee.length === 0)
                    return {};
                let Se = pt(ee);
                for (let Re in Se) {
                    let Je = Se[Re];
                    mt(Je),
                    V[Re] = Ke(Je, $, Z)
                }
                return V
            }
            function Ke(z, V, $) {
                let Z = {}
                  , ee = {
                    array: [],
                    stride: 0
                }
                  , Se = {
                    array: [],
                    stride: 0
                }
                  , Re = {
                    array: [],
                    stride: 0
                }
                  , Je = {
                    array: [],
                    stride: 0
                }
                  , Ge = {
                    array: [],
                    stride: 0
                }
                  , Xe = {
                    array: [],
                    stride: 4
                }
                  , it = {
                    array: [],
                    stride: 4
                }
                  , Oe = new wt
                  , nt = []
                  , et = 0;
                for (let ut = 0; ut < z.length; ut++) {
                    let st = z[ut]
                      , an = st.inputs
                      , Xt = 0;
                    switch (st.type) {
                    case "lines":
                    case "linestrips":
                        Xt = st.count * 2;
                        break;
                    case "triangles":
                        Xt = st.count * 3;
                        break;
                    case "polylist":
                        for (let Ft = 0; Ft < st.count; Ft++) {
                            let kt = st.vcount[Ft];
                            switch (kt) {
                            case 3:
                                Xt += 3;
                                break;
                            case 4:
                                Xt += 6;
                                break;
                            default:
                                Xt += (kt - 2) * 3;
                                break
                            }
                        }
                        break;
                    default:
                        console.warn("THREE.ColladaLoader: Unknow primitive type:", st.type)
                    }
                    Oe.addGroup(et, Xt, ut),
                    et += Xt,
                    st.material && nt.push(st.material);
                    for (let Ft in an) {
                        let kt = an[Ft];
                        switch (Ft) {
                        case "VERTEX":
                            for (let es in $) {
                                let li = $[es];
                                switch (es) {
                                case "POSITION":
                                    let sa = ee.array.length;
                                    if (ke(st, V[li], kt.offset, ee.array),
                                    ee.stride = V[li].stride,
                                    V.skinWeights && V.skinIndices && (ke(st, V.skinIndices, kt.offset, Xe.array),
                                    ke(st, V.skinWeights, kt.offset, it.array)),
                                    st.hasUV === !1 && z.uvsNeedsFix === !0) {
                                        let hx = (ee.array.length - sa) / ee.stride;
                                        for (let pg = 0; pg < hx; pg++)
                                            Re.array.push(0, 0)
                                    }
                                    break;
                                case "NORMAL":
                                    ke(st, V[li], kt.offset, Se.array),
                                    Se.stride = V[li].stride;
                                    break;
                                case "COLOR":
                                    ke(st, V[li], kt.offset, Ge.array),
                                    Ge.stride = V[li].stride;
                                    break;
                                case "TEXCOORD":
                                    ke(st, V[li], kt.offset, Re.array),
                                    Re.stride = V[li].stride;
                                    break;
                                case "TEXCOORD1":
                                    ke(st, V[li], kt.offset, Je.array),
                                    Re.stride = V[li].stride;
                                    break;
                                default:
                                    console.warn('THREE.ColladaLoader: Semantic "%s" not handled in geometry build process.', es)
                                }
                            }
                            break;
                        case "NORMAL":
                            ke(st, V[kt.id], kt.offset, Se.array),
                            Se.stride = V[kt.id].stride;
                            break;
                        case "COLOR":
                            ke(st, V[kt.id], kt.offset, Ge.array, !0),
                            Ge.stride = V[kt.id].stride;
                            break;
                        case "TEXCOORD":
                            ke(st, V[kt.id], kt.offset, Re.array),
                            Re.stride = V[kt.id].stride;
                            break;
                        case "TEXCOORD1":
                            ke(st, V[kt.id], kt.offset, Je.array),
                            Je.stride = V[kt.id].stride;
                            break
                        }
                    }
                }
                return ee.array.length > 0 && Oe.setAttribute("position", new qe(ee.array,ee.stride)),
                Se.array.length > 0 && Oe.setAttribute("normal", new qe(Se.array,Se.stride)),
                Ge.array.length > 0 && Oe.setAttribute("color", new qe(Ge.array,Ge.stride)),
                Re.array.length > 0 && Oe.setAttribute("uv", new qe(Re.array,Re.stride)),
                Je.array.length > 0 && Oe.setAttribute("uv1", new qe(Je.array,Je.stride)),
                Xe.array.length > 0 && Oe.setAttribute("skinIndex", new qe(Xe.array,Xe.stride)),
                it.array.length > 0 && Oe.setAttribute("skinWeight", new qe(it.array,it.stride)),
                Z.data = Oe,
                Z.type = z[0].type,
                Z.materialKeys = nt,
                Z
            }
            function ke(z, V, $, Z, ee=!1) {
                let Se = z.p
                  , Re = z.stride
                  , Je = z.vcount;
                function Ge(Oe) {
                    let nt = Se[Oe + $] * it
                      , et = nt + it;
                    for (; nt < et; nt++)
                        Z.push(Xe[nt]);
                    if (ee) {
                        let ut = Z.length - it - 1;
                        Nu.setRGB(Z[ut + 0], Z[ut + 1], Z[ut + 2]).convertSRGBToLinear(),
                        Z[ut + 0] = Nu.r,
                        Z[ut + 1] = Nu.g,
                        Z[ut + 2] = Nu.b
                    }
                }
                let Xe = V.array
                  , it = V.stride;
                if (z.vcount !== void 0) {
                    let Oe = 0;
                    for (let nt = 0, et = Je.length; nt < et; nt++) {
                        let ut = Je[nt];
                        if (ut === 4) {
                            let st = Oe + Re * 0
                              , an = Oe + Re * 1
                              , Xt = Oe + Re * 2
                              , Ft = Oe + Re * 3;
                            Ge(st),
                            Ge(an),
                            Ge(Ft),
                            Ge(an),
                            Ge(Xt),
                            Ge(Ft)
                        } else if (ut === 3) {
                            let st = Oe + Re * 0
                              , an = Oe + Re * 1
                              , Xt = Oe + Re * 2;
                            Ge(st),
                            Ge(an),
                            Ge(Xt)
                        } else if (ut > 4)
                            for (let st = 1, an = ut - 2; st <= an; st++) {
                                let Xt = Oe + Re * 0
                                  , Ft = Oe + Re * st
                                  , kt = Oe + Re * (st + 1);
                                Ge(Xt),
                                Ge(Ft),
                                Ge(kt)
                            }
                        Oe += Re * ut
                    }
                } else
                    for (let Oe = 0, nt = Se.length; Oe < nt; Oe += Re)
                        Ge(Oe)
            }
            function Be(z) {
                return v(ft.geometries[z], ot)
            }
            function Ye(z) {
                let V = {
                    name: z.getAttribute("name") || "",
                    joints: {},
                    links: []
                };
                for (let $ = 0; $ < z.childNodes.length; $++) {
                    let Z = z.childNodes[$];
                    if (Z.nodeType === 1)
                        switch (Z.nodeName) {
                        case "technique_common":
                            Gi(Z, V);
                            break
                        }
                }
                ft.kinematicsModels[z.getAttribute("id")] = V
            }
            function tt(z) {
                return z.build !== void 0 ? z.build : z
            }
            function qt(z) {
                return v(ft.kinematicsModels[z], tt)
            }
            function Gi(z, V) {
                for (let $ = 0; $ < z.childNodes.length; $++) {
                    let Z = z.childNodes[$];
                    if (Z.nodeType === 1)
                        switch (Z.nodeName) {
                        case "joint":
                            V.joints[Z.getAttribute("sid")] = Vi(Z);
                            break;
                        case "link":
                            V.links.push(se(Z));
                            break
                        }
                }
            }
            function Vi(z) {
                let V;
                for (let $ = 0; $ < z.childNodes.length; $++) {
                    let Z = z.childNodes[$];
                    if (Z.nodeType === 1)
                        switch (Z.nodeName) {
                        case "prismatic":
                        case "revolute":
                            V = xo(Z);
                            break
                        }
                }
                return V
            }
            function xo(z) {
                let V = {
                    sid: z.getAttribute("sid"),
                    name: z.getAttribute("name") || "",
                    axis: new ue,
                    limits: {
                        min: 0,
                        max: 0
                    },
                    type: z.nodeName,
                    static: !1,
                    zeroPosition: 0,
                    middlePosition: 0
                };
                for (let $ = 0; $ < z.childNodes.length; $++) {
                    let Z = z.childNodes[$];
                    if (Z.nodeType === 1)
                        switch (Z.nodeName) {
                        case "axis":
                            let ee = s(Z.textContent);
                            V.axis.fromArray(ee);
                            break;
                        case "limits":
                            let Se = Z.getElementsByTagName("max")[0]
                              , Re = Z.getElementsByTagName("min")[0];
                            V.limits.max = parseFloat(Se.textContent),
                            V.limits.min = parseFloat(Re.textContent);
                            break
                        }
                }
                return V.limits.min >= V.limits.max && (V.static = !0),
                V.middlePosition = (V.limits.min + V.limits.max) / 2,
                V
            }
            function se(z) {
                let V = {
                    sid: z.getAttribute("sid"),
                    name: z.getAttribute("name") || "",
                    attachments: [],
                    transforms: []
                };
                for (let $ = 0; $ < z.childNodes.length; $++) {
                    let Z = z.childNodes[$];
                    if (Z.nodeType === 1)
                        switch (Z.nodeName) {
                        case "attachment_full":
                            V.attachments.push(Te(Z));
                            break;
                        case "matrix":
                        case "translate":
                        case "rotate":
                            V.transforms.push(Ae(Z));
                            break
                        }
                }
                return V
            }
            function Te(z) {
                let V = {
                    joint: z.getAttribute("joint").split("/").pop(),
                    transforms: [],
                    links: []
                };
                for (let $ = 0; $ < z.childNodes.length; $++) {
                    let Z = z.childNodes[$];
                    if (Z.nodeType === 1)
                        switch (Z.nodeName) {
                        case "link":
                            V.links.push(se(Z));
                            break;
                        case "matrix":
                        case "translate":
                        case "rotate":
                            V.transforms.push(Ae(Z));
                            break
                        }
                }
                return V
            }
            function Ae(z) {
                let V = {
                    type: z.nodeName
                }
                  , $ = s(z.textContent);
                switch (V.type) {
                case "matrix":
                    V.obj = new je,
                    V.obj.fromArray($).transpose();
                    break;
                case "translate":
                    V.obj = new ue,
                    V.obj.fromArray($);
                    break;
                case "rotate":
                    V.obj = new ue,
                    V.obj.fromArray($),
                    V.angle = Wn.degToRad($[3]);
                    break
                }
                return V
            }
            function ye(z) {
                let V = {
                    name: z.getAttribute("name") || "",
                    rigidBodies: {}
                };
                for (let $ = 0; $ < z.childNodes.length; $++) {
                    let Z = z.childNodes[$];
                    if (Z.nodeType === 1)
                        switch (Z.nodeName) {
                        case "rigid_body":
                            V.rigidBodies[Z.getAttribute("name")] = {},
                            Pe(Z, V.rigidBodies[Z.getAttribute("name")]);
                            break
                        }
                }
                ft.physicsModels[z.getAttribute("id")] = V
            }
            function Pe(z, V) {
                for (let $ = 0; $ < z.childNodes.length; $++) {
                    let Z = z.childNodes[$];
                    if (Z.nodeType === 1)
                        switch (Z.nodeName) {
                        case "technique_common":
                            at(Z, V);
                            break
                        }
                }
            }
            function at(z, V) {
                for (let $ = 0; $ < z.childNodes.length; $++) {
                    let Z = z.childNodes[$];
                    if (Z.nodeType === 1)
                        switch (Z.nodeName) {
                        case "inertia":
                            V.inertia = s(Z.textContent);
                            break;
                        case "mass":
                            V.mass = s(Z.textContent)[0];
                            break
                        }
                }
            }
            function ht(z) {
                let V = {
                    bindJointAxis: []
                };
                for (let $ = 0; $ < z.childNodes.length; $++) {
                    let Z = z.childNodes[$];
                    if (Z.nodeType === 1)
                        switch (Z.nodeName) {
                        case "bind_joint_axis":
                            V.bindJointAxis.push(gt(Z));
                            break
                        }
                }
                ft.kinematicsScenes[a(z.getAttribute("url"))] = V
            }
            function gt(z) {
                let V = {
                    target: z.getAttribute("target").split("/").pop()
                };
                for (let $ = 0; $ < z.childNodes.length; $++) {
                    let Z = z.childNodes[$];
                    if (Z.nodeType === 1)
                        switch (Z.nodeName) {
                        case "axis":
                            let ee = Z.getElementsByTagName("param")[0];
                            V.axis = ee.textContent;
                            let Se = V.axis.split("inst_").pop().split("axis")[0];
                            V.jointIndex = Se.substring(0, Se.length - 1);
                            break
                        }
                }
                return V
            }
            function Tt(z) {
                return z.build !== void 0 ? z.build : z
            }
            function Mt(z) {
                return v(ft.kinematicsScenes[z], Tt)
            }
            function Et() {
                let z = Object.keys(ft.kinematicsModels)[0]
                  , V = Object.keys(ft.kinematicsScenes)[0]
                  , $ = Object.keys(ft.visualScenes)[0];
                if (z === void 0 || V === void 0)
                    return;
                let Z = qt(z)
                  , ee = Mt(V)
                  , Se = ra($)
                  , Re = ee.bindJointAxis
                  , Je = {};
                for (let it = 0, Oe = Re.length; it < Oe; it++) {
                    let nt = Re[it]
                      , et = An.querySelector('[sid="' + nt.target + '"]');
                    if (et) {
                        let ut = et.parentElement;
                        Ge(nt.jointIndex, ut)
                    }
                }
                function Ge(it, Oe) {
                    let nt = Oe.getAttribute("name")
                      , et = Z.joints[it];
                    Se.traverse(function(ut) {
                        ut.name === nt && (Je[it] = {
                            object: ut,
                            transforms: At(Oe),
                            joint: et,
                            position: et.zeroPosition
                        })
                    })
                }
                let Xe = new je;
                dg = {
                    joints: Z && Z.joints,
                    getJointValue: function(it) {
                        let Oe = Je[it];
                        if (Oe)
                            return Oe.position;
                        console.warn("THREE.ColladaLoader: Joint " + it + " doesn't exist.")
                    },
                    setJointValue: function(it, Oe) {
                        let nt = Je[it];
                        if (nt) {
                            let et = nt.joint;
                            if (Oe > et.limits.max || Oe < et.limits.min)
                                console.warn("THREE.ColladaLoader: Joint " + it + " value " + Oe + " outside of limits (min: " + et.limits.min + ", max: " + et.limits.max + ").");
                            else if (et.static)
                                console.warn("THREE.ColladaLoader: Joint " + it + " is static.");
                            else {
                                let ut = nt.object
                                  , st = et.axis
                                  , an = nt.transforms;
                                Wt.identity();
                                for (let Xt = 0; Xt < an.length; Xt++) {
                                    let Ft = an[Xt];
                                    if (Ft.sid && Ft.sid.indexOf(it) !== -1)
                                        switch (et.type) {
                                        case "revolute":
                                            Wt.multiply(Xe.makeRotationAxis(st, Wn.degToRad(Oe)));
                                            break;
                                        case "prismatic":
                                            Wt.multiply(Xe.makeTranslation(st.x * Oe, st.y * Oe, st.z * Oe));
                                            break;
                                        default:
                                            console.warn("THREE.ColladaLoader: Unknown joint type: " + et.type);
                                            break
                                        }
                                    else
                                        switch (Ft.type) {
                                        case "matrix":
                                            Wt.multiply(Ft.obj);
                                            break;
                                        case "translate":
                                            Wt.multiply(Xe.makeTranslation(Ft.obj.x, Ft.obj.y, Ft.obj.z));
                                            break;
                                        case "scale":
                                            Wt.scale(Ft.obj);
                                            break;
                                        case "rotate":
                                            Wt.multiply(Xe.makeRotationAxis(Ft.obj, Ft.angle));
                                            break
                                        }
                                }
                                ut.matrix.copy(Wt),
                                ut.matrix.decompose(ut.position, ut.quaternion, ut.scale),
                                Je[it].position = Oe
                            }
                        } else
                            console.log("THREE.ColladaLoader: " + it + " does not exist.")
                    }
                }
            }
            function At(z) {
                let V = []
                  , $ = An.querySelector('[id="' + z.id + '"]');
                for (let Z = 0; Z < $.childNodes.length; Z++) {
                    let ee = $.childNodes[Z];
                    if (ee.nodeType !== 1)
                        continue;
                    let Se, Re;
                    switch (ee.nodeName) {
                    case "matrix":
                        Se = s(ee.textContent);
                        let Je = new je().fromArray(Se).transpose();
                        V.push({
                            sid: ee.getAttribute("sid"),
                            type: ee.nodeName,
                            obj: Je
                        });
                        break;
                    case "translate":
                    case "scale":
                        Se = s(ee.textContent),
                        Re = new ue().fromArray(Se),
                        V.push({
                            sid: ee.getAttribute("sid"),
                            type: ee.nodeName,
                            obj: Re
                        });
                        break;
                    case "rotate":
                        Se = s(ee.textContent),
                        Re = new ue().fromArray(Se);
                        let Ge = Wn.degToRad(Se[3]);
                        V.push({
                            sid: ee.getAttribute("sid"),
                            type: ee.nodeName,
                            obj: Re,
                            angle: Ge
                        });
                        break
                    }
                }
                return V
            }
            function zt(z) {
                let V = z.getElementsByTagName("node");
                for (let $ = 0; $ < V.length; $++) {
                    let Z = V[$];
                    Z.hasAttribute("id") === !1 && Z.setAttribute("id", l())
                }
            }
            let Wt = new je
              , Ln = new ue;
            function tr(z) {
                let V = {
                    name: z.getAttribute("name") || "",
                    type: z.getAttribute("type"),
                    id: z.getAttribute("id"),
                    sid: z.getAttribute("sid"),
                    matrix: new je,
                    nodes: [],
                    instanceCameras: [],
                    instanceControllers: [],
                    instanceLights: [],
                    instanceGeometries: [],
                    instanceNodes: [],
                    transforms: {}
                };
                for (let $ = 0; $ < z.childNodes.length; $++) {
                    let Z = z.childNodes[$];
                    if (Z.nodeType !== 1)
                        continue;
                    let ee;
                    switch (Z.nodeName) {
                    case "node":
                        V.nodes.push(Z.getAttribute("id")),
                        tr(Z);
                        break;
                    case "instance_camera":
                        V.instanceCameras.push(a(Z.getAttribute("url")));
                        break;
                    case "instance_controller":
                        V.instanceControllers.push(on(Z));
                        break;
                    case "instance_light":
                        V.instanceLights.push(a(Z.getAttribute("url")));
                        break;
                    case "instance_geometry":
                        V.instanceGeometries.push(on(Z));
                        break;
                    case "instance_node":
                        V.instanceNodes.push(a(Z.getAttribute("url")));
                        break;
                    case "matrix":
                        ee = s(Z.textContent),
                        V.matrix.multiply(Wt.fromArray(ee).transpose()),
                        V.transforms[Z.getAttribute("sid")] = Z.nodeName;
                        break;
                    case "translate":
                        ee = s(Z.textContent),
                        Ln.fromArray(ee),
                        V.matrix.multiply(Wt.makeTranslation(Ln.x, Ln.y, Ln.z)),
                        V.transforms[Z.getAttribute("sid")] = Z.nodeName;
                        break;
                    case "rotate":
                        ee = s(Z.textContent);
                        let Se = Wn.degToRad(ee[3]);
                        V.matrix.multiply(Wt.makeRotationAxis(Ln.fromArray(ee), Se)),
                        V.transforms[Z.getAttribute("sid")] = Z.nodeName;
                        break;
                    case "scale":
                        ee = s(Z.textContent),
                        V.matrix.scale(Ln.fromArray(ee)),
                        V.transforms[Z.getAttribute("sid")] = Z.nodeName;
                        break;
                    case "extra":
                        break;
                    default:
                        console.log(Z)
                    }
                }
                return na(V.id) ? console.warn("THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.", V.id) : ft.nodes[V.id] = V,
                V
            }
            function on(z) {
                let V = {
                    id: a(z.getAttribute("url")),
                    materials: {},
                    skeletons: []
                };
                for (let $ = 0; $ < z.childNodes.length; $++) {
                    let Z = z.childNodes[$];
                    switch (Z.nodeName) {
                    case "bind_material":
                        let ee = Z.getElementsByTagName("instance_material");
                        for (let Se = 0; Se < ee.length; Se++) {
                            let Re = ee[Se]
                              , Je = Re.getAttribute("symbol")
                              , Ge = Re.getAttribute("target");
                            V.materials[Je] = a(Ge)
                        }
                        break;
                    case "skeleton":
                        V.skeletons.push(a(Z.textContent));
                        break;
                    default:
                        break
                    }
                }
                return V
            }
            function Rt(z, V) {
                let $ = [], Z = [], ee, Se, Re;
                for (ee = 0; ee < z.length; ee++) {
                    let Xe = z[ee], it;
                    if (na(Xe))
                        it = cn(Xe),
                        ta(it, V, $);
                    else if (ei(Xe)) {
                        let nt = ft.visualScenes[Xe].children;
                        for (let et = 0; et < nt.length; et++) {
                            let ut = nt[et];
                            if (ut.type === "JOINT") {
                                let st = cn(ut.id);
                                ta(st, V, $)
                            }
                        }
                    } else
                        console.error("THREE.ColladaLoader: Unable to find root bone of skeleton with ID:", Xe)
                }
                for (ee = 0; ee < V.length; ee++)
                    for (Se = 0; Se < $.length; Se++)
                        if (Re = $[Se],
                        Re.bone.name === V[ee].name) {
                            Z[ee] = Re,
                            Re.processed = !0;
                            break
                        }
                for (ee = 0; ee < $.length; ee++)
                    Re = $[ee],
                    Re.processed === !1 && (Z.push(Re),
                    Re.processed = !0);
                let Je = []
                  , Ge = [];
                for (ee = 0; ee < Z.length; ee++)
                    Re = Z[ee],
                    Je.push(Re.bone),
                    Ge.push(Re.boneInverse);
                return new js(Je,Ge)
            }
            function ta(z, V, $) {
                z.traverse(function(Z) {
                    if (Z.isBone === !0) {
                        let ee;
                        for (let Se = 0; Se < V.length; Se++) {
                            let Re = V[Se];
                            if (Re.name === Z.name) {
                                ee = Re.boneInverse;
                                break
                            }
                        }
                        ee === void 0 && (ee = new je),
                        $.push({
                            bone: Z,
                            boneInverse: ee,
                            processed: !1
                        })
                    }
                })
            }
            function gn(z) {
                let V = []
                  , $ = z.matrix
                  , Z = z.nodes
                  , ee = z.type
                  , Se = z.instanceCameras
                  , Re = z.instanceControllers
                  , Je = z.instanceLights
                  , Ge = z.instanceGeometries
                  , Xe = z.instanceNodes;
                for (let Oe = 0, nt = Z.length; Oe < nt; Oe++)
                    V.push(cn(Z[Oe]));
                for (let Oe = 0, nt = Se.length; Oe < nt; Oe++) {
                    let et = De(Se[Oe]);
                    et !== null && V.push(et.clone())
                }
                for (let Oe = 0, nt = Re.length; Oe < nt; Oe++) {
                    let et = Re[Oe]
                      , ut = b(et.id)
                      , st = Be(ut.id)
                      , an = Ls(st, et.materials)
                      , Xt = et.skeletons
                      , Ft = ut.skin.joints
                      , kt = Rt(Xt, Ft);
                    for (let es = 0, li = an.length; es < li; es++) {
                        let sa = an[es];
                        sa.isSkinnedMesh && (sa.bind(kt, ut.skin.bindMatrix),
                        sa.normalizeSkinWeights()),
                        V.push(sa)
                    }
                }
                for (let Oe = 0, nt = Je.length; Oe < nt; Oe++) {
                    let et = pe(Je[Oe]);
                    et !== null && V.push(et.clone())
                }
                for (let Oe = 0, nt = Ge.length; Oe < nt; Oe++) {
                    let et = Ge[Oe]
                      , ut = Be(et.id)
                      , st = Ls(ut, et.materials);
                    for (let an = 0, Xt = st.length; an < Xt; an++)
                        V.push(st[an])
                }
                for (let Oe = 0, nt = Xe.length; Oe < nt; Oe++)
                    V.push(cn(Xe[Oe]).clone());
                let it;
                if (Z.length === 0 && V.length === 1)
                    it = V[0];
                else {
                    it = ee === "JOINT" ? new Xs : new In;
                    for (let Oe = 0; Oe < V.length; Oe++)
                        it.add(V[Oe])
                }
                return it.name = ee === "JOINT" ? z.sid : z.name,
                it.matrix.copy($),
                it.matrix.decompose(it.position, it.quaternion, it.scale),
                it
            }
            let $r = new Yi({
                color: 16711935
            });
            function Pu(z, V) {
                let $ = [];
                for (let Z = 0, ee = z.length; Z < ee; Z++) {
                    let Se = V[z[Z]];
                    Se === void 0 ? (console.warn("THREE.ColladaLoader: Material with key %s not found. Apply fallback material.", z[Z]),
                    $.push($r)) : $.push(de(Se))
                }
                return $
            }
            function Ls(z, V) {
                let $ = [];
                for (let Z in z) {
                    let ee = z[Z]
                      , Se = Pu(ee.materialKeys, V);
                    if (Se.length === 0 && (Z === "lines" || Z === "linestrips" ? Se.push(new pi) : Se.push(new sn)),
                    Z === "lines" || Z === "linestrips")
                        for (let Xe = 0, it = Se.length; Xe < it; Xe++) {
                            let Oe = Se[Xe];
                            if (Oe.isMeshPhongMaterial === !0 || Oe.isMeshLambertMaterial === !0) {
                                let nt = new pi;
                                nt.color.copy(Oe.color),
                                nt.opacity = Oe.opacity,
                                nt.transparent = Oe.transparent,
                                Se[Xe] = nt
                            }
                        }
                    let Re = ee.data.attributes.skinIndex !== void 0, Je = Se.length === 1 ? Se[0] : Se, Ge;
                    switch (Z) {
                    case "lines":
                        Ge = new qs(ee.data,Je);
                        break;
                    case "linestrips":
                        Ge = new gs(ee.data,Je);
                        break;
                    case "triangles":
                    case "polylist":
                        Re ? Ge = new Wa(ee.data,Je) : Ge = new Ht(ee.data,Je);
                        break
                    }
                    $.push(Ge)
                }
                return $
            }
            function na(z) {
                return ft.nodes[z] !== void 0
            }
            function cn(z) {
                return v(ft.nodes[z], gn)
            }
            function Qr(z) {
                let V = {
                    name: z.getAttribute("name"),
                    children: []
                };
                zt(z);
                let $ = n(z, "node");
                for (let Z = 0; Z < $.length; Z++)
                    V.children.push(tr($[Z]));
                ft.visualScenes[z.getAttribute("id")] = V
            }
            function ia(z) {
                let V = new In;
                V.name = z.name;
                let $ = z.children;
                for (let Z = 0; Z < $.length; Z++) {
                    let ee = $[Z];
                    V.add(cn(ee.id))
                }
                return V
            }
            function ei(z) {
                return ft.visualScenes[z] !== void 0
            }
            function ra(z) {
                return v(ft.visualScenes[z], ia)
            }
            function fd(z) {
                let V = n(z, "instance_visual_scene")[0];
                return ra(a(V.getAttribute("url")))
            }
            function Lu() {
                let z = ft.clips;
                if (c(z) === !0) {
                    if (c(ft.animations) === !1) {
                        let V = [];
                        for (let $ in ft.animations) {
                            let Z = _($);
                            for (let ee = 0, Se = Z.length; ee < Se; ee++)
                                V.push(Z[ee])
                        }
                        Du.push(new Bo("default",-1,V))
                    }
                } else
                    for (let V in z)
                        Du.push(U(V))
            }
            function lx(z) {
                let V = ""
                  , $ = [z];
                for (; $.length; ) {
                    let Z = $.shift();
                    Z.nodeType === Node.TEXT_NODE ? V += Z.textContent : (V += `
`,
                    $.push.apply($, Z.childNodes))
                }
                return V.trim()
            }
            if (e.length === 0)
                return {
                    scene: new Or
                };
            let ug = new DOMParser().parseFromString(e, "application/xml")
              , An = n(ug, "COLLADA")[0]
              , dd = ug.getElementsByTagName("parsererror")[0];
            if (dd !== void 0) {
                let z = n(dd, "div")[0], V;
                return z ? V = z.textContent : V = lx(dd),
                console.error(`THREE.ColladaLoader: Failed to parse collada file.
`, V),
                null
            }
            let cx = An.getAttribute("version");
            console.debug("THREE.ColladaLoader: File version", cx);
            let hg = u(n(An, "asset")[0])
              , fg = new Zi(this.manager);
            fg.setPath(this.resourcePath || t).setCrossOrigin(this.crossOrigin);
            let pd;
            oo && (pd = new oo(this.manager),
            pd.setPath(this.resourcePath || t));
            let Nu = new $e
              , Du = []
              , dg = {}
              , ux = 0
              , ft = {
                animations: {},
                clips: {},
                controllers: {},
                images: {},
                effects: {},
                materials: {},
                cameras: {},
                lights: {},
                geometries: {},
                nodes: {},
                visualScenes: {},
                kinematicsModels: {},
                physicsModels: {},
                kinematicsScenes: {}
            };
            m(An, "library_animations", "animation", p),
            m(An, "library_animation_clips", "animation_clip", L),
            m(An, "library_controllers", "controller", W),
            m(An, "library_images", "image", E),
            m(An, "library_effects", "effect", Y),
            m(An, "library_materials", "material", ne),
            m(An, "library_cameras", "camera", ge),
            m(An, "library_lights", "light", Ve),
            m(An, "library_geometries", "geometry", _e),
            m(An, "library_nodes", "node", tr),
            m(An, "library_visual_scenes", "visual_scene", Qr),
            m(An, "library_kinematics_models", "kinematics_model", Ye),
            m(An, "library_physics_models", "physics_model", ye),
            m(An, "scene", "instance_kinematics_scene", ht),
            g(ft.animations, y),
            g(ft.clips, F),
            g(ft.controllers, j),
            g(ft.images, T),
            g(ft.effects, A),
            g(ft.materials, he),
            g(ft.cameras, Ne),
            g(ft.lights, Qe),
            g(ft.geometries, ot),
            g(ft.visualScenes, ia),
            Lu(),
            Et();
            let Ou = fd(n(An, "scene")[0]);
            return Ou.animations = Du,
            hg.upAxis === "Z_UP" && (console.warn("THREE.ColladaLoader: You are loading an asset with a Z-UP coordinate system. The loader just rotates the asset to transform it into Y-UP. The vertex data are not converted, see #24289."),
            Ou.rotation.set(-Math.PI / 2, 0, 0)),
            Ou.scale.multiplyScalar(hg.unit),
            {
                get animations() {
                    return console.warn("THREE.ColladaLoader: Please access animations over scene.animations now."),
                    Du
                },
                kinematics: dg,
                library: ft,
                scene: Ou
            }
        }
    }
    ;
    var _t = (r,e)=>()=>(e || (e = {
        exports: {}
    },
    r(e.exports, e)),
    e.exports)
      , ay = _t(r=>{
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.VERSION = void 0,
        r.VERSION = "9.0.1"
    }
    )
      , Gt = _t((exports,module)=>{
        "use strict";
        var __spreadArray = exports && exports.__spreadArray || function(r, e) {
            for (var t = 0, n = e.length, i = r.length; t < n; t++,
            i++)
                r[i] = e[t];
            return r
        }
        ;
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }),
        exports.toFastProperties = exports.timer = exports.peek = exports.isES2015MapSupported = exports.PRINT_WARNING = exports.PRINT_ERROR = exports.packArray = exports.IDENTITY = exports.NOOP = exports.merge = exports.groupBy = exports.defaults = exports.assignNoOverwrite = exports.assign = exports.zipObject = exports.sortBy = exports.indexOf = exports.some = exports.difference = exports.every = exports.isObject = exports.isRegExp = exports.isArray = exports.partial = exports.uniq = exports.compact = exports.reduce = exports.findAll = exports.find = exports.cloneObj = exports.cloneArr = exports.contains = exports.has = exports.pick = exports.reject = exports.filter = exports.dropRight = exports.drop = exports.isFunction = exports.isUndefined = exports.isString = exports.forEach = exports.last = exports.first = exports.flatten = exports.map = exports.mapValues = exports.values = exports.keys = exports.isEmpty = void 0;
        function isEmpty(r) {
            return r && r.length === 0
        }
        exports.isEmpty = isEmpty;
        function keys(r) {
            return r == null ? [] : Object.keys(r)
        }
        exports.keys = keys;
        function values(r) {
            for (var e = [], t = Object.keys(r), n = 0; n < t.length; n++)
                e.push(r[t[n]]);
            return e
        }
        exports.values = values;
        function mapValues(r, e) {
            for (var t = [], n = keys(r), i = 0; i < n.length; i++) {
                var s = n[i];
                t.push(e.call(null, r[s], s))
            }
            return t
        }
        exports.mapValues = mapValues;
        function map(r, e) {
            for (var t = [], n = 0; n < r.length; n++)
                t.push(e.call(null, r[n], n));
            return t
        }
        exports.map = map;
        function flatten(r) {
            for (var e = [], t = 0; t < r.length; t++) {
                var n = r[t];
                Array.isArray(n) ? e = e.concat(flatten(n)) : e.push(n)
            }
            return e
        }
        exports.flatten = flatten;
        function first(r) {
            return isEmpty(r) ? void 0 : r[0]
        }
        exports.first = first;
        function last(r) {
            var e = r && r.length;
            return e ? r[e - 1] : void 0
        }
        exports.last = last;
        function forEach(r, e) {
            if (Array.isArray(r))
                for (var t = 0; t < r.length; t++)
                    e.call(null, r[t], t);
            else if (isObject(r))
                for (var n = keys(r), t = 0; t < n.length; t++) {
                    var i = n[t]
                      , s = r[i];
                    e.call(null, s, i)
                }
            else
                throw Error("non exhaustive match")
        }
        exports.forEach = forEach;
        function isString(r) {
            return typeof r == "string"
        }
        exports.isString = isString;
        function isUndefined(r) {
            return r === void 0
        }
        exports.isUndefined = isUndefined;
        function isFunction(r) {
            return r instanceof Function
        }
        exports.isFunction = isFunction;
        function drop(r, e) {
            return e === void 0 && (e = 1),
            r.slice(e, r.length)
        }
        exports.drop = drop;
        function dropRight(r, e) {
            return e === void 0 && (e = 1),
            r.slice(0, r.length - e)
        }
        exports.dropRight = dropRight;
        function filter(r, e) {
            var t = [];
            if (Array.isArray(r))
                for (var n = 0; n < r.length; n++) {
                    var i = r[n];
                    e.call(null, i) && t.push(i)
                }
            return t
        }
        exports.filter = filter;
        function reject(r, e) {
            return filter(r, function(t) {
                return !e(t)
            })
        }
        exports.reject = reject;
        function pick(r, e) {
            for (var t = Object.keys(r), n = {}, i = 0; i < t.length; i++) {
                var s = t[i]
                  , o = r[s];
                e(o) && (n[s] = o)
            }
            return n
        }
        exports.pick = pick;
        function has(r, e) {
            return isObject(r) ? r.hasOwnProperty(e) : !1
        }
        exports.has = has;
        function contains(r, e) {
            return find(r, function(t) {
                return t === e
            }) !== void 0
        }
        exports.contains = contains;
        function cloneArr(r) {
            for (var e = [], t = 0; t < r.length; t++)
                e.push(r[t]);
            return e
        }
        exports.cloneArr = cloneArr;
        function cloneObj(r) {
            var e = {};
            for (var t in r)
                Object.prototype.hasOwnProperty.call(r, t) && (e[t] = r[t]);
            return e
        }
        exports.cloneObj = cloneObj;
        function find(r, e) {
            for (var t = 0; t < r.length; t++) {
                var n = r[t];
                if (e.call(null, n))
                    return n
            }
        }
        exports.find = find;
        function findAll(r, e) {
            for (var t = [], n = 0; n < r.length; n++) {
                var i = r[n];
                e.call(null, i) && t.push(i)
            }
            return t
        }
        exports.findAll = findAll;
        function reduce(r, e, t) {
            for (var n = Array.isArray(r), i = n ? r : values(r), s = n ? [] : keys(r), o = t, a = 0; a < i.length; a++)
                o = e.call(null, o, i[a], n ? a : s[a]);
            return o
        }
        exports.reduce = reduce;
        function compact(r) {
            return reject(r, function(e) {
                return e == null
            })
        }
        exports.compact = compact;
        function uniq(r, e) {
            e === void 0 && (e = function(n) {
                return n
            }
            );
            var t = [];
            return reduce(r, function(n, i) {
                var s = e(i);
                return contains(t, s) ? n : (t.push(s),
                n.concat(i))
            }, [])
        }
        exports.uniq = uniq;
        function partial(r) {
            for (var e = [], t = 1; t < arguments.length; t++)
                e[t - 1] = arguments[t];
            var n = [null]
              , i = n.concat(e);
            return Function.bind.apply(r, i)
        }
        exports.partial = partial;
        function isArray(r) {
            return Array.isArray(r)
        }
        exports.isArray = isArray;
        function isRegExp(r) {
            return r instanceof RegExp
        }
        exports.isRegExp = isRegExp;
        function isObject(r) {
            return r instanceof Object
        }
        exports.isObject = isObject;
        function every(r, e) {
            for (var t = 0; t < r.length; t++)
                if (!e(r[t], t))
                    return !1;
            return !0
        }
        exports.every = every;
        function difference(r, e) {
            return reject(r, function(t) {
                return contains(e, t)
            })
        }
        exports.difference = difference;
        function some(r, e) {
            for (var t = 0; t < r.length; t++)
                if (e(r[t]))
                    return !0;
            return !1
        }
        exports.some = some;
        function indexOf(r, e) {
            for (var t = 0; t < r.length; t++)
                if (r[t] === e)
                    return t;
            return -1
        }
        exports.indexOf = indexOf;
        function sortBy(r, e) {
            var t = cloneArr(r);
            return t.sort(function(n, i) {
                return e(n) - e(i)
            }),
            t
        }
        exports.sortBy = sortBy;
        function zipObject(r, e) {
            if (r.length !== e.length)
                throw Error("can't zipObject with different number of keys and values!");
            for (var t = {}, n = 0; n < r.length; n++)
                t[r[n]] = e[n];
            return t
        }
        exports.zipObject = zipObject;
        function assign(r) {
            for (var e = [], t = 1; t < arguments.length; t++)
                e[t - 1] = arguments[t];
            for (var n = 0; n < e.length; n++)
                for (var i = e[n], s = keys(i), o = 0; o < s.length; o++) {
                    var a = s[o];
                    r[a] = i[a]
                }
            return r
        }
        exports.assign = assign;
        function assignNoOverwrite(r) {
            for (var e = [], t = 1; t < arguments.length; t++)
                e[t - 1] = arguments[t];
            for (var n = 0; n < e.length; n++)
                for (var i = e[n], s = keys(i), o = 0; o < s.length; o++) {
                    var a = s[o];
                    has(r, a) || (r[a] = i[a])
                }
            return r
        }
        exports.assignNoOverwrite = assignNoOverwrite;
        function defaults() {
            for (var r = [], e = 0; e < arguments.length; e++)
                r[e] = arguments[e];
            return assignNoOverwrite.apply(void 0, __spreadArray([{}], r))
        }
        exports.defaults = defaults;
        function groupBy(r, e) {
            var t = {};
            return forEach(r, function(n) {
                var i = e(n)
                  , s = t[i];
                s ? s.push(n) : t[i] = [n]
            }),
            t
        }
        exports.groupBy = groupBy;
        function merge(r, e) {
            for (var t = cloneObj(r), n = keys(e), i = 0; i < n.length; i++) {
                var s = n[i]
                  , o = e[s];
                t[s] = o
            }
            return t
        }
        exports.merge = merge;
        function NOOP() {}
        exports.NOOP = NOOP;
        function IDENTITY(r) {
            return r
        }
        exports.IDENTITY = IDENTITY;
        function packArray(r) {
            for (var e = [], t = 0; t < r.length; t++) {
                var n = r[t];
                e.push(n !== void 0 ? n : void 0)
            }
            return e
        }
        exports.packArray = packArray;
        function PRINT_ERROR(r) {
            console && console.error && console.error("Error: " + r)
        }
        exports.PRINT_ERROR = PRINT_ERROR;
        function PRINT_WARNING(r) {
            console && console.warn && console.warn("Warning: " + r)
        }
        exports.PRINT_WARNING = PRINT_WARNING;
        function isES2015MapSupported() {
            return typeof Map == "function"
        }
        exports.isES2015MapSupported = isES2015MapSupported;
        function peek(r) {
            return r[r.length - 1]
        }
        exports.peek = peek;
        function timer(r) {
            var e = new Date().getTime()
              , t = r()
              , n = new Date().getTime()
              , i = n - e;
            return {
                time: i,
                value: t
            }
        }
        exports.timer = timer;
        function toFastProperties(toBecomeFast) {
            function FakeConstructor() {}
            FakeConstructor.prototype = toBecomeFast;
            var fakeInstance = new FakeConstructor;
            function fakeAccess() {
                return typeof fakeInstance.bar
            }
            return fakeAccess(),
            fakeAccess(),
            toBecomeFast
        }
        exports.toFastProperties = toFastProperties
    }
    )
      , fm = _t((r,e)=>{
        (function(t, n) {
            typeof define == "function" && define.amd ? define([], n) : typeof e == "object" && e.exports ? e.exports = n() : t.regexpToAst = n()
        }
        )(typeof self < "u" ? self : r, function() {
            function t() {}
            t.prototype.saveState = function() {
                return {
                    idx: this.idx,
                    input: this.input,
                    groupIdx: this.groupIdx
                }
            }
            ,
            t.prototype.restoreState = function(p) {
                this.idx = p.idx,
                this.input = p.input,
                this.groupIdx = p.groupIdx
            }
            ,
            t.prototype.pattern = function(p) {
                this.idx = 0,
                this.input = p,
                this.groupIdx = 0,
                this.consumeChar("/");
                var d = this.disjunction();
                this.consumeChar("/");
                for (var x = {
                    type: "Flags",
                    loc: {
                        begin: this.idx,
                        end: p.length
                    },
                    global: !1,
                    ignoreCase: !1,
                    multiLine: !1,
                    unicode: !1,
                    sticky: !1
                }; this.isRegExpFlag(); )
                    switch (this.popChar()) {
                    case "g":
                        l(x, "global");
                        break;
                    case "i":
                        l(x, "ignoreCase");
                        break;
                    case "m":
                        l(x, "multiLine");
                        break;
                    case "u":
                        l(x, "unicode");
                        break;
                    case "y":
                        l(x, "sticky");
                        break
                    }
                if (this.idx !== this.input.length)
                    throw Error("Redundant input: " + this.input.substring(this.idx));
                return {
                    type: "Pattern",
                    flags: x,
                    value: d,
                    loc: this.loc(0)
                }
            }
            ,
            t.prototype.disjunction = function() {
                var p = []
                  , d = this.idx;
                for (p.push(this.alternative()); this.peekChar() === "|"; )
                    this.consumeChar("|"),
                    p.push(this.alternative());
                return {
                    type: "Disjunction",
                    value: p,
                    loc: this.loc(d)
                }
            }
            ,
            t.prototype.alternative = function() {
                for (var p = [], d = this.idx; this.isTerm(); )
                    p.push(this.term());
                return {
                    type: "Alternative",
                    value: p,
                    loc: this.loc(d)
                }
            }
            ,
            t.prototype.term = function() {
                return this.isAssertion() ? this.assertion() : this.atom()
            }
            ,
            t.prototype.assertion = function() {
                var p = this.idx;
                switch (this.popChar()) {
                case "^":
                    return {
                        type: "StartAnchor",
                        loc: this.loc(p)
                    };
                case "$":
                    return {
                        type: "EndAnchor",
                        loc: this.loc(p)
                    };
                case "\\":
                    switch (this.popChar()) {
                    case "b":
                        return {
                            type: "WordBoundary",
                            loc: this.loc(p)
                        };
                    case "B":
                        return {
                            type: "NonWordBoundary",
                            loc: this.loc(p)
                        }
                    }
                    throw Error("Invalid Assertion Escape");
                case "(":
                    this.consumeChar("?");
                    var d;
                    switch (this.popChar()) {
                    case "=":
                        d = "Lookahead";
                        break;
                    case "!":
                        d = "NegativeLookahead";
                        break
                    }
                    c(d);
                    var x = this.disjunction();
                    return this.consumeChar(")"),
                    {
                        type: d,
                        value: x,
                        loc: this.loc(p)
                    }
                }
                u()
            }
            ,
            t.prototype.quantifier = function(p) {
                var d, x = this.idx;
                switch (this.popChar()) {
                case "*":
                    d = {
                        atLeast: 0,
                        atMost: 1 / 0
                    };
                    break;
                case "+":
                    d = {
                        atLeast: 1,
                        atMost: 1 / 0
                    };
                    break;
                case "?":
                    d = {
                        atLeast: 0,
                        atMost: 1
                    };
                    break;
                case "{":
                    var y = this.integerIncludingZero();
                    switch (this.popChar()) {
                    case "}":
                        d = {
                            atLeast: y,
                            atMost: y
                        };
                        break;
                    case ",":
                        var _;
                        this.isDigit() ? (_ = this.integerIncludingZero(),
                        d = {
                            atLeast: y,
                            atMost: _
                        }) : d = {
                            atLeast: y,
                            atMost: 1 / 0
                        },
                        this.consumeChar("}");
                        break
                    }
                    if (p === !0 && d === void 0)
                        return;
                    c(d);
                    break
                }
                if (!(p === !0 && d === void 0))
                    return c(d),
                    this.peekChar(0) === "?" ? (this.consumeChar("?"),
                    d.greedy = !1) : d.greedy = !0,
                    d.type = "Quantifier",
                    d.loc = this.loc(x),
                    d
            }
            ,
            t.prototype.atom = function() {
                var p, d = this.idx;
                switch (this.peekChar()) {
                case ".":
                    p = this.dotAll();
                    break;
                case "\\":
                    p = this.atomEscape();
                    break;
                case "[":
                    p = this.characterClass();
                    break;
                case "(":
                    p = this.group();
                    break
                }
                return p === void 0 && this.isPatternCharacter() && (p = this.patternCharacter()),
                c(p),
                p.loc = this.loc(d),
                this.isQuantifier() && (p.quantifier = this.quantifier()),
                p
            }
            ,
            t.prototype.dotAll = function() {
                return this.consumeChar("."),
                {
                    type: "Set",
                    complement: !0,
                    value: [o(`
`), o("\r"), o("\u2028"), o("\u2029")]
                }
            }
            ,
            t.prototype.atomEscape = function() {
                switch (this.consumeChar("\\"),
                this.peekChar()) {
                case "1":
                case "2":
                case "3":
                case "4":
                case "5":
                case "6":
                case "7":
                case "8":
                case "9":
                    return this.decimalEscapeAtom();
                case "d":
                case "D":
                case "s":
                case "S":
                case "w":
                case "W":
                    return this.characterClassEscape();
                case "f":
                case "n":
                case "r":
                case "t":
                case "v":
                    return this.controlEscapeAtom();
                case "c":
                    return this.controlLetterEscapeAtom();
                case "0":
                    return this.nulCharacterAtom();
                case "x":
                    return this.hexEscapeSequenceAtom();
                case "u":
                    return this.regExpUnicodeEscapeSequenceAtom();
                default:
                    return this.identityEscapeAtom()
                }
            }
            ,
            t.prototype.decimalEscapeAtom = function() {
                var p = this.positiveInteger();
                return {
                    type: "GroupBackReference",
                    value: p
                }
            }
            ,
            t.prototype.characterClassEscape = function() {
                var p, d = !1;
                switch (this.popChar()) {
                case "d":
                    p = f;
                    break;
                case "D":
                    p = f,
                    d = !0;
                    break;
                case "s":
                    p = g;
                    break;
                case "S":
                    p = g,
                    d = !0;
                    break;
                case "w":
                    p = m;
                    break;
                case "W":
                    p = m,
                    d = !0;
                    break
                }
                return c(p),
                {
                    type: "Set",
                    value: p,
                    complement: d
                }
            }
            ,
            t.prototype.controlEscapeAtom = function() {
                var p;
                switch (this.popChar()) {
                case "f":
                    p = o("\f");
                    break;
                case "n":
                    p = o(`
`);
                    break;
                case "r":
                    p = o("\r");
                    break;
                case "t":
                    p = o("	");
                    break;
                case "v":
                    p = o("\v");
                    break
                }
                return c(p),
                {
                    type: "Character",
                    value: p
                }
            }
            ,
            t.prototype.controlLetterEscapeAtom = function() {
                this.consumeChar("c");
                var p = this.popChar();
                if (/[a-zA-Z]/.test(p) === !1)
                    throw Error("Invalid ");
                var d = p.toUpperCase().charCodeAt(0) - 64;
                return {
                    type: "Character",
                    value: d
                }
            }
            ,
            t.prototype.nulCharacterAtom = function() {
                return this.consumeChar("0"),
                {
                    type: "Character",
                    value: o("\0")
                }
            }
            ,
            t.prototype.hexEscapeSequenceAtom = function() {
                return this.consumeChar("x"),
                this.parseHexDigits(2)
            }
            ,
            t.prototype.regExpUnicodeEscapeSequenceAtom = function() {
                return this.consumeChar("u"),
                this.parseHexDigits(4)
            }
            ,
            t.prototype.identityEscapeAtom = function() {
                var p = this.popChar();
                return {
                    type: "Character",
                    value: o(p)
                }
            }
            ,
            t.prototype.classPatternCharacterAtom = function() {
                switch (this.peekChar()) {
                case `
`:
                case "\r":
                case "\u2028":
                case "\u2029":
                case "\\":
                case "]":
                    throw Error("TBD");
                default:
                    var p = this.popChar();
                    return {
                        type: "Character",
                        value: o(p)
                    }
                }
            }
            ,
            t.prototype.characterClass = function() {
                var p = []
                  , d = !1;
                for (this.consumeChar("["),
                this.peekChar(0) === "^" && (this.consumeChar("^"),
                d = !0); this.isClassAtom(); ) {
                    var x = this.classAtom()
                      , y = x.type === "Character";
                    if (y && this.isRangeDash()) {
                        this.consumeChar("-");
                        var _ = this.classAtom()
                          , S = _.type === "Character";
                        if (S) {
                            if (_.value < x.value)
                                throw Error("Range out of order in character class");
                            p.push({
                                from: x.value,
                                to: _.value
                            })
                        } else
                            a(x.value, p),
                            p.push(o("-")),
                            a(_.value, p)
                    } else
                        a(x.value, p)
                }
                return this.consumeChar("]"),
                {
                    type: "Set",
                    complement: d,
                    value: p
                }
            }
            ,
            t.prototype.classAtom = function() {
                switch (this.peekChar()) {
                case "]":
                case `
`:
                case "\r":
                case "\u2028":
                case "\u2029":
                    throw Error("TBD");
                case "\\":
                    return this.classEscape();
                default:
                    return this.classPatternCharacterAtom()
                }
            }
            ,
            t.prototype.classEscape = function() {
                switch (this.consumeChar("\\"),
                this.peekChar()) {
                case "b":
                    return this.consumeChar("b"),
                    {
                        type: "Character",
                        value: o("\b")
                    };
                case "d":
                case "D":
                case "s":
                case "S":
                case "w":
                case "W":
                    return this.characterClassEscape();
                case "f":
                case "n":
                case "r":
                case "t":
                case "v":
                    return this.controlEscapeAtom();
                case "c":
                    return this.controlLetterEscapeAtom();
                case "0":
                    return this.nulCharacterAtom();
                case "x":
                    return this.hexEscapeSequenceAtom();
                case "u":
                    return this.regExpUnicodeEscapeSequenceAtom();
                default:
                    return this.identityEscapeAtom()
                }
            }
            ,
            t.prototype.group = function() {
                var p = !0;
                switch (this.consumeChar("("),
                this.peekChar(0)) {
                case "?":
                    this.consumeChar("?"),
                    this.consumeChar(":"),
                    p = !1;
                    break;
                default:
                    this.groupIdx++;
                    break
                }
                var d = this.disjunction();
                this.consumeChar(")");
                var x = {
                    type: "Group",
                    capturing: p,
                    value: d
                };
                return p && (x.idx = this.groupIdx),
                x
            }
            ,
            t.prototype.positiveInteger = function() {
                var p = this.popChar();
                if (s.test(p) === !1)
                    throw Error("Expecting a positive integer");
                for (; i.test(this.peekChar(0)); )
                    p += this.popChar();
                return parseInt(p, 10)
            }
            ,
            t.prototype.integerIncludingZero = function() {
                var p = this.popChar();
                if (i.test(p) === !1)
                    throw Error("Expecting an integer");
                for (; i.test(this.peekChar(0)); )
                    p += this.popChar();
                return parseInt(p, 10)
            }
            ,
            t.prototype.patternCharacter = function() {
                var p = this.popChar();
                switch (p) {
                case `
`:
                case "\r":
                case "\u2028":
                case "\u2029":
                case "^":
                case "$":
                case "\\":
                case ".":
                case "*":
                case "+":
                case "?":
                case "(":
                case ")":
                case "[":
                case "|":
                    throw Error("TBD");
                default:
                    return {
                        type: "Character",
                        value: o(p)
                    }
                }
            }
            ,
            t.prototype.isRegExpFlag = function() {
                switch (this.peekChar(0)) {
                case "g":
                case "i":
                case "m":
                case "u":
                case "y":
                    return !0;
                default:
                    return !1
                }
            }
            ,
            t.prototype.isRangeDash = function() {
                return this.peekChar() === "-" && this.isClassAtom(1)
            }
            ,
            t.prototype.isDigit = function() {
                return i.test(this.peekChar(0))
            }
            ,
            t.prototype.isClassAtom = function(p) {
                switch (p === void 0 && (p = 0),
                this.peekChar(p)) {
                case "]":
                case `
`:
                case "\r":
                case "\u2028":
                case "\u2029":
                    return !1;
                default:
                    return !0
                }
            }
            ,
            t.prototype.isTerm = function() {
                return this.isAtom() || this.isAssertion()
            }
            ,
            t.prototype.isAtom = function() {
                if (this.isPatternCharacter())
                    return !0;
                switch (this.peekChar(0)) {
                case ".":
                case "\\":
                case "[":
                case "(":
                    return !0;
                default:
                    return !1
                }
            }
            ,
            t.prototype.isAssertion = function() {
                switch (this.peekChar(0)) {
                case "^":
                case "$":
                    return !0;
                case "\\":
                    switch (this.peekChar(1)) {
                    case "b":
                    case "B":
                        return !0;
                    default:
                        return !1
                    }
                case "(":
                    return this.peekChar(1) === "?" && (this.peekChar(2) === "=" || this.peekChar(2) === "!");
                default:
                    return !1
                }
            }
            ,
            t.prototype.isQuantifier = function() {
                var p = this.saveState();
                try {
                    return this.quantifier(!0) !== void 0
                } catch {
                    return !1
                } finally {
                    this.restoreState(p)
                }
            }
            ,
            t.prototype.isPatternCharacter = function() {
                switch (this.peekChar()) {
                case "^":
                case "$":
                case "\\":
                case ".":
                case "*":
                case "+":
                case "?":
                case "(":
                case ")":
                case "[":
                case "|":
                case "/":
                case `
`:
                case "\r":
                case "\u2028":
                case "\u2029":
                    return !1;
                default:
                    return !0
                }
            }
            ,
            t.prototype.parseHexDigits = function(p) {
                for (var d = "", x = 0; x < p; x++) {
                    var y = this.popChar();
                    if (n.test(y) === !1)
                        throw Error("Expecting a HexDecimal digits");
                    d += y
                }
                var _ = parseInt(d, 16);
                return {
                    type: "Character",
                    value: _
                }
            }
            ,
            t.prototype.peekChar = function(p) {
                return p === void 0 && (p = 0),
                this.input[this.idx + p]
            }
            ,
            t.prototype.popChar = function() {
                var p = this.peekChar(0);
                return this.consumeChar(),
                p
            }
            ,
            t.prototype.consumeChar = function(p) {
                if (p !== void 0 && this.input[this.idx] !== p)
                    throw Error("Expected: '" + p + "' but found: '" + this.input[this.idx] + "' at offset: " + this.idx);
                if (this.idx >= this.input.length)
                    throw Error("Unexpected end of input");
                this.idx++
            }
            ,
            t.prototype.loc = function(p) {
                return {
                    begin: p,
                    end: this.idx
                }
            }
            ;
            var n = /[0-9a-fA-F]/
              , i = /[0-9]/
              , s = /[1-9]/;
            function o(p) {
                return p.charCodeAt(0)
            }
            function a(p, d) {
                p.length !== void 0 ? p.forEach(function(x) {
                    d.push(x)
                }) : d.push(p)
            }
            function l(p, d) {
                if (p[d] === !0)
                    throw "duplicate flag " + d;
                p[d] = !0
            }
            function c(p) {
                if (p === void 0)
                    throw Error("Internal Error - Should never get here!")
            }
            function u() {
                throw Error("Internal Error - Should never get here!")
            }
            var h, f = [];
            for (h = o("0"); h <= o("9"); h++)
                f.push(h);
            var m = [o("_")].concat(f);
            for (h = o("a"); h <= o("z"); h++)
                m.push(h);
            for (h = o("A"); h <= o("Z"); h++)
                m.push(h);
            var g = [o(" "), o("\f"), o(`
`), o("\r"), o("	"), o("\v"), o("	"), o("\xA0"), o("\u1680"), o("\u2000"), o("\u2001"), o("\u2002"), o("\u2003"), o("\u2004"), o("\u2005"), o("\u2006"), o("\u2007"), o("\u2008"), o("\u2009"), o("\u200A"), o("\u2028"), o("\u2029"), o("\u202F"), o("\u205F"), o("\u3000"), o("\uFEFF")];
            function v() {}
            return v.prototype.visitChildren = function(p) {
                for (var d in p) {
                    var x = p[d];
                    p.hasOwnProperty(d) && (x.type !== void 0 ? this.visit(x) : Array.isArray(x) && x.forEach(function(y) {
                        this.visit(y)
                    }, this))
                }
            }
            ,
            v.prototype.visit = function(p) {
                switch (p.type) {
                case "Pattern":
                    this.visitPattern(p);
                    break;
                case "Flags":
                    this.visitFlags(p);
                    break;
                case "Disjunction":
                    this.visitDisjunction(p);
                    break;
                case "Alternative":
                    this.visitAlternative(p);
                    break;
                case "StartAnchor":
                    this.visitStartAnchor(p);
                    break;
                case "EndAnchor":
                    this.visitEndAnchor(p);
                    break;
                case "WordBoundary":
                    this.visitWordBoundary(p);
                    break;
                case "NonWordBoundary":
                    this.visitNonWordBoundary(p);
                    break;
                case "Lookahead":
                    this.visitLookahead(p);
                    break;
                case "NegativeLookahead":
                    this.visitNegativeLookahead(p);
                    break;
                case "Character":
                    this.visitCharacter(p);
                    break;
                case "Set":
                    this.visitSet(p);
                    break;
                case "Group":
                    this.visitGroup(p);
                    break;
                case "GroupBackReference":
                    this.visitGroupBackReference(p);
                    break;
                case "Quantifier":
                    this.visitQuantifier(p);
                    break
                }
                this.visitChildren(p)
            }
            ,
            v.prototype.visitPattern = function(p) {}
            ,
            v.prototype.visitFlags = function(p) {}
            ,
            v.prototype.visitDisjunction = function(p) {}
            ,
            v.prototype.visitAlternative = function(p) {}
            ,
            v.prototype.visitStartAnchor = function(p) {}
            ,
            v.prototype.visitEndAnchor = function(p) {}
            ,
            v.prototype.visitWordBoundary = function(p) {}
            ,
            v.prototype.visitNonWordBoundary = function(p) {}
            ,
            v.prototype.visitLookahead = function(p) {}
            ,
            v.prototype.visitNegativeLookahead = function(p) {}
            ,
            v.prototype.visitCharacter = function(p) {}
            ,
            v.prototype.visitSet = function(p) {}
            ,
            v.prototype.visitGroup = function(p) {}
            ,
            v.prototype.visitGroupBackReference = function(p) {}
            ,
            v.prototype.visitQuantifier = function(p) {}
            ,
            {
                RegExpParser: t,
                BaseRegExpVisitor: v,
                VERSION: "0.5.0"
            }
        })
    }
    )
      , dm = _t(r=>{
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.clearRegExpParserCache = r.getRegExpAst = void 0;
        var e = fm()
          , t = {}
          , n = new e.RegExpParser;
        function i(o) {
            var a = o.toString();
            if (t.hasOwnProperty(a))
                return t[a];
            var l = n.pattern(a);
            return t[a] = l,
            l
        }
        r.getRegExpAst = i;
        function s() {
            t = {}
        }
        r.clearRegExpParserCache = s
    }
    )
      , Lw = _t(r=>{
        "use strict";
        var e = r && r.__extends || function() {
            var v = function(p, d) {
                return v = Object.setPrototypeOf || {
                    __proto__: []
                }instanceof Array && function(x, y) {
                    x.__proto__ = y
                }
                || function(x, y) {
                    for (var _ in y)
                        Object.prototype.hasOwnProperty.call(y, _) && (x[_] = y[_])
                }
                ,
                v(p, d)
            };
            return function(p, d) {
                if (typeof d != "function" && d !== null)
                    throw new TypeError("Class extends value " + String(d) + " is not a constructor or null");
                v(p, d);
                function x() {
                    this.constructor = p
                }
                p.prototype = d === null ? Object.create(d) : (x.prototype = d.prototype,
                new x)
            }
        }();
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.canMatchCharCode = r.firstCharOptimizedIndices = r.getOptimizedStartCodesIndices = r.failedOptimizationPrefixMsg = void 0;
        var t = fm()
          , n = Gt()
          , i = dm()
          , s = ly()
          , o = "Complement Sets are not supported for first char optimization";
        r.failedOptimizationPrefixMsg = `Unable to use "first char" lexer optimizations:
`;
        function a(v, p) {
            p === void 0 && (p = !1);
            try {
                var d = i.getRegExpAst(v)
                  , x = l(d.value, {}, d.flags.ignoreCase);
                return x
            } catch (_) {
                if (_.message === o)
                    p && n.PRINT_WARNING("" + r.failedOptimizationPrefixMsg + ("	Unable to optimize: < " + v.toString() + ` >
`) + `	Complement Sets cannot be automatically optimized.
	This will disable the lexer's first char optimizations.
	See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.`);
                else {
                    var y = "";
                    p && (y = `
	This will disable the lexer's first char optimizations.
	See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.`),
                    n.PRINT_ERROR(r.failedOptimizationPrefixMsg + `
` + ("	Failed parsing: < " + v.toString() + ` >
`) + ("	Using the regexp-to-ast library version: " + t.VERSION + `
`) + "	Please open an issue at: https://github.com/bd82/regexp-to-ast/issues" + y)
                }
            }
            return []
        }
        r.getOptimizedStartCodesIndices = a;
        function l(v, p, d) {
            switch (v.type) {
            case "Disjunction":
                for (var x = 0; x < v.value.length; x++)
                    l(v.value[x], p, d);
                break;
            case "Alternative":
                for (var y = v.value, x = 0; x < y.length; x++) {
                    var _ = y[x];
                    switch (_.type) {
                    case "EndAnchor":
                    case "GroupBackReference":
                    case "Lookahead":
                    case "NegativeLookahead":
                    case "StartAnchor":
                    case "WordBoundary":
                    case "NonWordBoundary":
                        continue
                    }
                    var S = _;
                    switch (S.type) {
                    case "Character":
                        c(S.value, p, d);
                        break;
                    case "Set":
                        if (S.complement === !0)
                            throw Error(o);
                        n.forEach(S.value, function(O) {
                            if (typeof O == "number")
                                c(O, p, d);
                            else {
                                var M = O;
                                if (d === !0)
                                    for (var R = M.from; R <= M.to; R++)
                                        c(R, p, d);
                                else {
                                    for (var R = M.from; R <= M.to && R < s.minOptimizationVal; R++)
                                        c(R, p, d);
                                    if (M.to >= s.minOptimizationVal)
                                        for (var q = M.from >= s.minOptimizationVal ? M.from : s.minOptimizationVal, k = M.to, B = s.charCodeToOptimizedIndex(q), P = s.charCodeToOptimizedIndex(k), C = B; C <= P; C++)
                                            p[C] = C
                                }
                            }
                        });
                        break;
                    case "Group":
                        l(S.value, p, d);
                        break;
                    default:
                        throw Error("Non Exhaustive Match")
                    }
                    var N = S.quantifier !== void 0 && S.quantifier.atLeast === 0;
                    if (S.type === "Group" && f(S) === !1 || S.type !== "Group" && N === !1)
                        break
                }
                break;
            default:
                throw Error("non exhaustive match!")
            }
            return n.values(p)
        }
        r.firstCharOptimizedIndices = l;
        function c(v, p, d) {
            var x = s.charCodeToOptimizedIndex(v);
            p[x] = x,
            d === !0 && u(v, p)
        }
        function u(v, p) {
            var d = String.fromCharCode(v)
              , x = d.toUpperCase();
            if (x !== d) {
                var y = s.charCodeToOptimizedIndex(x.charCodeAt(0));
                p[y] = y
            } else {
                var _ = d.toLowerCase();
                if (_ !== d) {
                    var y = s.charCodeToOptimizedIndex(_.charCodeAt(0));
                    p[y] = y
                }
            }
        }
        function h(v, p) {
            return n.find(v.value, function(d) {
                if (typeof d == "number")
                    return n.contains(p, d);
                var x = d;
                return n.find(p, function(y) {
                    return x.from <= y && y <= x.to
                }) !== void 0
            })
        }
        function f(v) {
            return v.quantifier && v.quantifier.atLeast === 0 ? !0 : v.value ? n.isArray(v.value) ? n.every(v.value, f) : f(v.value) : !1
        }
        var m = function(v) {
            e(p, v);
            function p(d) {
                var x = v.call(this) || this;
                return x.targetCharCodes = d,
                x.found = !1,
                x
            }
            return p.prototype.visitChildren = function(d) {
                if (this.found !== !0) {
                    switch (d.type) {
                    case "Lookahead":
                        this.visitLookahead(d);
                        return;
                    case "NegativeLookahead":
                        this.visitNegativeLookahead(d);
                        return
                    }
                    v.prototype.visitChildren.call(this, d)
                }
            }
            ,
            p.prototype.visitCharacter = function(d) {
                n.contains(this.targetCharCodes, d.value) && (this.found = !0)
            }
            ,
            p.prototype.visitSet = function(d) {
                d.complement ? h(d, this.targetCharCodes) === void 0 && (this.found = !0) : h(d, this.targetCharCodes) !== void 0 && (this.found = !0)
            }
            ,
            p
        }(t.BaseRegExpVisitor);
        function g(v, p) {
            if (p instanceof RegExp) {
                var d = i.getRegExpAst(p)
                  , x = new m(v);
                return x.visit(d),
                x.found
            } else
                return n.find(p, function(y) {
                    return n.contains(v, y.charCodeAt(0))
                }) !== void 0
        }
        r.canMatchCharCode = g
    }
    )
      , ly = _t(r=>{
        "use strict";
        var e = r && r.__extends || function() {
            var b = function(E, T) {
                return b = Object.setPrototypeOf || {
                    __proto__: []
                }instanceof Array && function(H, Y) {
                    H.__proto__ = Y
                }
                || function(H, Y) {
                    for (var X in Y)
                        Object.prototype.hasOwnProperty.call(Y, X) && (H[X] = Y[X])
                }
                ,
                b(E, T)
            };
            return function(E, T) {
                if (typeof T != "function" && T !== null)
                    throw new TypeError("Class extends value " + String(T) + " is not a constructor or null");
                b(E, T);
                function H() {
                    this.constructor = E
                }
                E.prototype = T === null ? Object.create(T) : (H.prototype = T.prototype,
                new H)
            }
        }();
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.charCodeToOptimizedIndex = r.minOptimizationVal = r.buildLineBreakIssueMessage = r.LineTerminatorOptimizedTester = r.isShortPattern = r.isCustomPattern = r.cloneEmptyGroups = r.performWarningRuntimeChecks = r.performRuntimeChecks = r.addStickyFlag = r.addStartOfInput = r.findUnreachablePatterns = r.findModesThatDoNotExist = r.findInvalidGroupType = r.findDuplicatePatterns = r.findUnsupportedFlags = r.findStartOfInputAnchor = r.findEmptyMatchRegExps = r.findEndOfInputAnchor = r.findInvalidPatterns = r.findMissingPatterns = r.validatePatterns = r.analyzeTokenTypes = r.enableSticky = r.disableSticky = r.SUPPORT_STICKY = r.MODES = r.DEFAULT_MODE = void 0;
        var t = fm()
          , n = gf()
          , i = Gt()
          , s = Lw()
          , o = dm()
          , a = "PATTERN";
        r.DEFAULT_MODE = "defaultMode",
        r.MODES = "modes",
        r.SUPPORT_STICKY = typeof new RegExp("(?:)").sticky == "boolean";
        function l() {
            r.SUPPORT_STICKY = !1
        }
        r.disableSticky = l;
        function c() {
            r.SUPPORT_STICKY = !0
        }
        r.enableSticky = c;
        function u(b, E) {
            E = i.defaults(E, {
                useSticky: r.SUPPORT_STICKY,
                debug: !1,
                safeMode: !1,
                positionTracking: "full",
                lineTerminatorCharacters: ["\r", `
`],
                tracer: function(A, G) {
                    return G()
                }
            });
            var T = E.tracer;
            T("initCharCodeToOptimizedIndexMap", function() {
                w()
            });
            var H;
            T("Reject Lexer.NA", function() {
                H = i.reject(b, function(A) {
                    return A[a] === n.Lexer.NA
                })
            });
            var Y = !1, X;
            T("Transform Patterns", function() {
                Y = !1,
                X = i.map(H, function(A) {
                    var G = A[a];
                    if (i.isRegExp(G)) {
                        var ne = G.source;
                        return ne.length === 1 && ne !== "^" && ne !== "$" && ne !== "." && !G.ignoreCase ? ne : ne.length === 2 && ne[0] === "\\" && !i.contains(["d", "D", "s", "S", "t", "r", "n", "t", "0", "c", "b", "B", "f", "v", "w", "W"], ne[1]) ? ne[1] : E.useSticky ? k(G) : q(G)
                    } else {
                        if (i.isFunction(G))
                            return Y = !0,
                            {
                                exec: G
                            };
                        if (i.has(G, "exec"))
                            return Y = !0,
                            G;
                        if (typeof G == "string") {
                            if (G.length === 1)
                                return G;
                            var Q = G.replace(/[\\^$.*+?()[\]{}|]/g, "\\$&")
                              , he = new RegExp(Q);
                            return E.useSticky ? k(he) : q(he)
                        } else
                            throw Error("non exhaustive match")
                    }
                })
            });
            var ce, J, ae, ie, me;
            T("misc mapping", function() {
                ce = i.map(H, function(A) {
                    return A.tokenTypeIdx
                }),
                J = i.map(H, function(A) {
                    var G = A.GROUP;
                    if (G !== n.Lexer.SKIPPED) {
                        if (i.isString(G))
                            return G;
                        if (i.isUndefined(G))
                            return !1;
                        throw Error("non exhaustive match")
                    }
                }),
                ae = i.map(H, function(A) {
                    var G = A.LONGER_ALT;
                    if (G) {
                        var ne = i.indexOf(H, G);
                        return ne
                    }
                }),
                ie = i.map(H, function(A) {
                    return A.PUSH_MODE
                }),
                me = i.map(H, function(A) {
                    return i.has(A, "POP_MODE")
                })
            });
            var ve;
            T("Line Terminator Handling", function() {
                var A = K(E.lineTerminatorCharacters);
                ve = i.map(H, function(G) {
                    return !1
                }),
                E.positionTracking !== "onlyOffset" && (ve = i.map(H, function(G) {
                    if (i.has(G, "LINE_BREAKS"))
                        return G.LINE_BREAKS;
                    if (U(G, A) === !1)
                        return s.canMatchCharCode(A, G.PATTERN)
                }))
            });
            var be, fe, te, Ee;
            T("Misc Mapping #2", function() {
                be = i.map(H, L),
                fe = i.map(X, F),
                te = i.reduce(H, function(A, G) {
                    var ne = G.GROUP;
                    return i.isString(ne) && ne !== n.Lexer.SKIPPED && (A[ne] = []),
                    A
                }, {}),
                Ee = i.map(X, function(A, G) {
                    return {
                        pattern: X[G],
                        longerAlt: ae[G],
                        canLineTerminator: ve[G],
                        isCustom: be[G],
                        short: fe[G],
                        group: J[G],
                        push: ie[G],
                        pop: me[G],
                        tokenTypeIdx: ce[G],
                        tokenType: H[G]
                    }
                })
            });
            var Le = !0
              , D = [];
            return E.safeMode || T("First Char Optimization", function() {
                D = i.reduce(H, function(A, G, ne) {
                    if (typeof G.PATTERN == "string") {
                        var Q = G.PATTERN.charCodeAt(0)
                          , he = j(Q);
                        re(A, he, Ee[ne])
                    } else if (i.isArray(G.START_CHARS_HINT)) {
                        var de;
                        i.forEach(G.START_CHARS_HINT, function(le) {
                            var xe = typeof le == "string" ? le.charCodeAt(0) : le
                              , Me = j(xe);
                            de !== Me && (de = Me,
                            re(A, Me, Ee[ne]))
                        })
                    } else if (i.isRegExp(G.PATTERN))
                        if (G.PATTERN.unicode)
                            Le = !1,
                            E.ensureOptimizations && i.PRINT_ERROR("" + s.failedOptimizationPrefixMsg + ("	Unable to analyze < " + G.PATTERN.toString() + ` > pattern.
`) + `	The regexp unicode flag is not currently supported by the regexp-to-ast library.
	This will disable the lexer's first char optimizations.
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE`);
                        else {
                            var ge = s.getOptimizedStartCodesIndices(G.PATTERN, E.ensureOptimizations);
                            i.isEmpty(ge) && (Le = !1),
                            i.forEach(ge, function(le) {
                                re(A, le, Ee[ne])
                            })
                        }
                    else
                        E.ensureOptimizations && i.PRINT_ERROR("" + s.failedOptimizationPrefixMsg + ("	TokenType: <" + G.name + `> is using a custom token pattern without providing <start_chars_hint> parameter.
`) + `	This will disable the lexer's first char optimizations.
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE`),
                        Le = !1;
                    return A
                }, [])
            }),
            T("ArrayPacking", function() {
                D = i.packArray(D)
            }),
            {
                emptyGroups: te,
                patternIdxToConfig: Ee,
                charCodeToPatternIdxToConfig: D,
                hasCustom: Y,
                canBeOptimized: Le
            }
        }
        r.analyzeTokenTypes = u;
        function h(b, E) {
            var T = []
              , H = m(b);
            T = T.concat(H.errors);
            var Y = g(H.valid)
              , X = Y.valid;
            return T = T.concat(Y.errors),
            T = T.concat(f(X)),
            T = T.concat(N(X)),
            T = T.concat(I(X, E)),
            T = T.concat(O(X)),
            T
        }
        r.validatePatterns = h;
        function f(b) {
            var E = []
              , T = i.filter(b, function(H) {
                return i.isRegExp(H[a])
            });
            return E = E.concat(p(T)),
            E = E.concat(y(T)),
            E = E.concat(_(T)),
            E = E.concat(S(T)),
            E = E.concat(d(T)),
            E
        }
        function m(b) {
            var E = i.filter(b, function(Y) {
                return !i.has(Y, a)
            })
              , T = i.map(E, function(Y) {
                return {
                    message: "Token Type: ->" + Y.name + "<- missing static 'PATTERN' property",
                    type: n.LexerDefinitionErrorType.MISSING_PATTERN,
                    tokenTypes: [Y]
                }
            })
              , H = i.difference(b, E);
            return {
                errors: T,
                valid: H
            }
        }
        r.findMissingPatterns = m;
        function g(b) {
            var E = i.filter(b, function(Y) {
                var X = Y[a];
                return !i.isRegExp(X) && !i.isFunction(X) && !i.has(X, "exec") && !i.isString(X)
            })
              , T = i.map(E, function(Y) {
                return {
                    message: "Token Type: ->" + Y.name + "<- static 'PATTERN' can only be a RegExp, a Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.",
                    type: n.LexerDefinitionErrorType.INVALID_PATTERN,
                    tokenTypes: [Y]
                }
            })
              , H = i.difference(b, E);
            return {
                errors: T,
                valid: H
            }
        }
        r.findInvalidPatterns = g;
        var v = /[^\\][\$]/;
        function p(b) {
            var E = function(Y) {
                e(X, Y);
                function X() {
                    var ce = Y !== null && Y.apply(this, arguments) || this;
                    return ce.found = !1,
                    ce
                }
                return X.prototype.visitEndAnchor = function(ce) {
                    this.found = !0
                }
                ,
                X
            }(t.BaseRegExpVisitor)
              , T = i.filter(b, function(Y) {
                var X = Y[a];
                try {
                    var ce = o.getRegExpAst(X)
                      , J = new E;
                    return J.visit(ce),
                    J.found
                } catch {
                    return v.test(X.source)
                }
            })
              , H = i.map(T, function(Y) {
                return {
                    message: `Unexpected RegExp Anchor Error:
	Token Type: ->` + Y.name + `<- static 'PATTERN' cannot contain end of input anchor '$'
	See chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS	for details.`,
                    type: n.LexerDefinitionErrorType.EOI_ANCHOR_FOUND,
                    tokenTypes: [Y]
                }
            });
            return H
        }
        r.findEndOfInputAnchor = p;
        function d(b) {
            var E = i.filter(b, function(H) {
                var Y = H[a];
                return Y.test("")
            })
              , T = i.map(E, function(H) {
                return {
                    message: "Token Type: ->" + H.name + "<- static 'PATTERN' must not match an empty string",
                    type: n.LexerDefinitionErrorType.EMPTY_MATCH_PATTERN,
                    tokenTypes: [H]
                }
            });
            return T
        }
        r.findEmptyMatchRegExps = d;
        var x = /[^\\[][\^]|^\^/;
        function y(b) {
            var E = function(Y) {
                e(X, Y);
                function X() {
                    var ce = Y !== null && Y.apply(this, arguments) || this;
                    return ce.found = !1,
                    ce
                }
                return X.prototype.visitStartAnchor = function(ce) {
                    this.found = !0
                }
                ,
                X
            }(t.BaseRegExpVisitor)
              , T = i.filter(b, function(Y) {
                var X = Y[a];
                try {
                    var ce = o.getRegExpAst(X)
                      , J = new E;
                    return J.visit(ce),
                    J.found
                } catch {
                    return x.test(X.source)
                }
            })
              , H = i.map(T, function(Y) {
                return {
                    message: `Unexpected RegExp Anchor Error:
	Token Type: ->` + Y.name + `<- static 'PATTERN' cannot contain start of input anchor '^'
	See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS	for details.`,
                    type: n.LexerDefinitionErrorType.SOI_ANCHOR_FOUND,
                    tokenTypes: [Y]
                }
            });
            return H
        }
        r.findStartOfInputAnchor = y;
        function _(b) {
            var E = i.filter(b, function(H) {
                var Y = H[a];
                return Y instanceof RegExp && (Y.multiline || Y.global)
            })
              , T = i.map(E, function(H) {
                return {
                    message: "Token Type: ->" + H.name + "<- static 'PATTERN' may NOT contain global('g') or multiline('m')",
                    type: n.LexerDefinitionErrorType.UNSUPPORTED_FLAGS_FOUND,
                    tokenTypes: [H]
                }
            });
            return T
        }
        r.findUnsupportedFlags = _;
        function S(b) {
            var E = []
              , T = i.map(b, function(X) {
                return i.reduce(b, function(ce, J) {
                    return X.PATTERN.source === J.PATTERN.source && !i.contains(E, J) && J.PATTERN !== n.Lexer.NA && (E.push(J),
                    ce.push(J)),
                    ce
                }, [])
            });
            T = i.compact(T);
            var H = i.filter(T, function(X) {
                return X.length > 1
            })
              , Y = i.map(H, function(X) {
                var ce = i.map(X, function(ae) {
                    return ae.name
                })
                  , J = i.first(X).PATTERN;
                return {
                    message: "The same RegExp pattern ->" + J + "<-" + ("has been used in all of the following Token Types: " + ce.join(", ") + " <-"),
                    type: n.LexerDefinitionErrorType.DUPLICATE_PATTERNS_FOUND,
                    tokenTypes: X
                }
            });
            return Y
        }
        r.findDuplicatePatterns = S;
        function N(b) {
            var E = i.filter(b, function(H) {
                if (!i.has(H, "GROUP"))
                    return !1;
                var Y = H.GROUP;
                return Y !== n.Lexer.SKIPPED && Y !== n.Lexer.NA && !i.isString(Y)
            })
              , T = i.map(E, function(H) {
                return {
                    message: "Token Type: ->" + H.name + "<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String",
                    type: n.LexerDefinitionErrorType.INVALID_GROUP_TYPE_FOUND,
                    tokenTypes: [H]
                }
            });
            return T
        }
        r.findInvalidGroupType = N;
        function I(b, E) {
            var T = i.filter(b, function(Y) {
                return Y.PUSH_MODE !== void 0 && !i.contains(E, Y.PUSH_MODE)
            })
              , H = i.map(T, function(Y) {
                var X = "Token Type: ->" + Y.name + "<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->" + Y.PUSH_MODE + "<-which does not exist";
                return {
                    message: X,
                    type: n.LexerDefinitionErrorType.PUSH_MODE_DOES_NOT_EXIST,
                    tokenTypes: [Y]
                }
            });
            return H
        }
        r.findModesThatDoNotExist = I;
        function O(b) {
            var E = []
              , T = i.reduce(b, function(H, Y, X) {
                var ce = Y.PATTERN;
                return ce === n.Lexer.NA || (i.isString(ce) ? H.push({
                    str: ce,
                    idx: X,
                    tokenType: Y
                }) : i.isRegExp(ce) && R(ce) && H.push({
                    str: ce.source,
                    idx: X,
                    tokenType: Y
                })),
                H
            }, []);
            return i.forEach(b, function(H, Y) {
                i.forEach(T, function(X) {
                    var ce = X.str
                      , J = X.idx
                      , ae = X.tokenType;
                    if (Y < J && M(ce, H.PATTERN)) {
                        var ie = "Token: ->" + ae.name + `<- can never be matched.
` + ("Because it appears AFTER the Token Type ->" + H.name + "<-") + `in the lexer's definition.
See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNREACHABLE`;
                        E.push({
                            message: ie,
                            type: n.LexerDefinitionErrorType.UNREACHABLE_PATTERN,
                            tokenTypes: [H, ae]
                        })
                    }
                })
            }),
            E
        }
        r.findUnreachablePatterns = O;
        function M(b, E) {
            if (i.isRegExp(E)) {
                var T = E.exec(b);
                return T !== null && T.index === 0
            } else {
                if (i.isFunction(E))
                    return E(b, 0, [], {});
                if (i.has(E, "exec"))
                    return E.exec(b, 0, [], {});
                if (typeof E == "string")
                    return E === b;
                throw Error("non exhaustive match")
            }
        }
        function R(b) {
            var E = [".", "\\", "[", "]", "|", "^", "$", "(", ")", "?", "*", "+", "{"];
            return i.find(E, function(T) {
                return b.source.indexOf(T) !== -1
            }) === void 0
        }
        function q(b) {
            var E = b.ignoreCase ? "i" : "";
            return new RegExp("^(?:" + b.source + ")",E)
        }
        r.addStartOfInput = q;
        function k(b) {
            var E = b.ignoreCase ? "iy" : "y";
            return new RegExp("" + b.source,E)
        }
        r.addStickyFlag = k;
        function B(b, E, T) {
            var H = [];
            return i.has(b, r.DEFAULT_MODE) || H.push({
                message: "A MultiMode Lexer cannot be initialized without a <" + r.DEFAULT_MODE + `> property in its definition
`,
                type: n.LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE
            }),
            i.has(b, r.MODES) || H.push({
                message: "A MultiMode Lexer cannot be initialized without a <" + r.MODES + `> property in its definition
`,
                type: n.LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY
            }),
            i.has(b, r.MODES) && i.has(b, r.DEFAULT_MODE) && !i.has(b.modes, b.defaultMode) && H.push({
                message: "A MultiMode Lexer cannot be initialized with a " + r.DEFAULT_MODE + ": <" + b.defaultMode + `>which does not exist
`,
                type: n.LexerDefinitionErrorType.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST
            }),
            i.has(b, r.MODES) && i.forEach(b.modes, function(Y, X) {
                i.forEach(Y, function(ce, J) {
                    i.isUndefined(ce) && H.push({
                        message: "A Lexer cannot be initialized using an undefined Token Type. Mode:" + ("<" + X + "> at index: <" + J + `>
`),
                        type: n.LexerDefinitionErrorType.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED
                    })
                })
            }),
            H
        }
        r.performRuntimeChecks = B;
        function P(b, E, T) {
            var H = []
              , Y = !1
              , X = i.compact(i.flatten(i.mapValues(b.modes, function(ae) {
                return ae
            })))
              , ce = i.reject(X, function(ae) {
                return ae[a] === n.Lexer.NA
            })
              , J = K(T);
            return E && i.forEach(ce, function(ae) {
                var ie = U(ae, J);
                if (ie !== !1) {
                    var me = W(ae, ie)
                      , ve = {
                        message: me,
                        type: ie.issue,
                        tokenType: ae
                    };
                    H.push(ve)
                } else
                    i.has(ae, "LINE_BREAKS") ? ae.LINE_BREAKS === !0 && (Y = !0) : s.canMatchCharCode(J, ae.PATTERN) && (Y = !0)
            }),
            E && !Y && H.push({
                message: `Warning: No LINE_BREAKS Found.
	This Lexer has been defined to track line and column information,
	But none of the Token Types can be identified as matching a line terminator.
	See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#LINE_BREAKS
	for details.`,
                type: n.LexerDefinitionErrorType.NO_LINE_BREAKS_FLAGS
            }),
            H
        }
        r.performWarningRuntimeChecks = P;
        function C(b) {
            var E = {}
              , T = i.keys(b);
            return i.forEach(T, function(H) {
                var Y = b[H];
                if (i.isArray(Y))
                    E[H] = [];
                else
                    throw Error("non exhaustive match")
            }),
            E
        }
        r.cloneEmptyGroups = C;
        function L(b) {
            var E = b.PATTERN;
            if (i.isRegExp(E))
                return !1;
            if (i.isFunction(E) || i.has(E, "exec"))
                return !0;
            if (i.isString(E))
                return !1;
            throw Error("non exhaustive match")
        }
        r.isCustomPattern = L;
        function F(b) {
            return i.isString(b) && b.length === 1 ? b.charCodeAt(0) : !1
        }
        r.isShortPattern = F,
        r.LineTerminatorOptimizedTester = {
            test: function(b) {
                for (var E = b.length, T = this.lastIndex; T < E; T++) {
                    var H = b.charCodeAt(T);
                    if (H === 10)
                        return this.lastIndex = T + 1,
                        !0;
                    if (H === 13)
                        return b.charCodeAt(T + 1) === 10 ? this.lastIndex = T + 2 : this.lastIndex = T + 1,
                        !0
                }
                return !1
            },
            lastIndex: 0
        };
        function U(b, E) {
            if (i.has(b, "LINE_BREAKS"))
                return !1;
            if (i.isRegExp(b.PATTERN)) {
                try {
                    s.canMatchCharCode(E, b.PATTERN)
                } catch (T) {
                    return {
                        issue: n.LexerDefinitionErrorType.IDENTIFY_TERMINATOR,
                        errMsg: T.message
                    }
                }
                return !1
            } else {
                if (i.isString(b.PATTERN))
                    return !1;
                if (L(b))
                    return {
                        issue: n.LexerDefinitionErrorType.CUSTOM_LINE_BREAK
                    };
                throw Error("non exhaustive match")
            }
        }
        function W(b, E) {
            if (E.issue === n.LexerDefinitionErrorType.IDENTIFY_TERMINATOR)
                return `Warning: unable to identify line terminator usage in pattern.
` + ("	The problem is in the <" + b.name + `> Token Type
`) + ("	 Root cause: " + E.errMsg + `.
`) + "	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR";
            if (E.issue === n.LexerDefinitionErrorType.CUSTOM_LINE_BREAK)
                return `Warning: A Custom Token Pattern should specify the <line_breaks> option.
` + ("	The problem is in the <" + b.name + `> Token Type
`) + "	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK";
            throw Error("non exhaustive match")
        }
        r.buildLineBreakIssueMessage = W;
        function K(b) {
            var E = i.map(b, function(T) {
                return i.isString(T) && T.length > 0 ? T.charCodeAt(0) : T
            });
            return E
        }
        function re(b, E, T) {
            b[E] === void 0 ? b[E] = [T] : b[E].push(T)
        }
        r.minOptimizationVal = 256;
        var oe = [];
        function j(b) {
            return b < r.minOptimizationVal ? b : oe[b]
        }
        r.charCodeToOptimizedIndex = j;
        function w() {
            if (i.isEmpty(oe)) {
                oe = new Array(65536);
                for (var b = 0; b < 65536; b++)
                    oe[b] = b > 255 ? 255 + ~~(b / 255) : b
            }
        }
    }
    )
      , iu = _t(r=>{
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.isTokenType = r.hasExtendingTokensTypesMapProperty = r.hasExtendingTokensTypesProperty = r.hasCategoriesProperty = r.hasShortKeyProperty = r.singleAssignCategoriesToksMap = r.assignCategoriesMapProp = r.assignCategoriesTokensProp = r.assignTokenDefaultProps = r.expandCategories = r.augmentTokenTypes = r.tokenIdxToClass = r.tokenShortNameIdx = r.tokenStructuredMatcherNoCategories = r.tokenStructuredMatcher = void 0;
        var e = Gt();
        function t(v, p) {
            var d = v.tokenTypeIdx;
            return d === p.tokenTypeIdx ? !0 : p.isParent === !0 && p.categoryMatchesMap[d] === !0
        }
        r.tokenStructuredMatcher = t;
        function n(v, p) {
            return v.tokenTypeIdx === p.tokenTypeIdx
        }
        r.tokenStructuredMatcherNoCategories = n,
        r.tokenShortNameIdx = 1,
        r.tokenIdxToClass = {};
        function i(v) {
            var p = s(v);
            o(p),
            l(p),
            a(p),
            e.forEach(p, function(d) {
                d.isParent = d.categoryMatches.length > 0
            })
        }
        r.augmentTokenTypes = i;
        function s(v) {
            for (var p = e.cloneArr(v), d = v, x = !0; x; ) {
                d = e.compact(e.flatten(e.map(d, function(_) {
                    return _.CATEGORIES
                })));
                var y = e.difference(d, p);
                p = p.concat(y),
                e.isEmpty(y) ? x = !1 : d = y
            }
            return p
        }
        r.expandCategories = s;
        function o(v) {
            e.forEach(v, function(p) {
                u(p) || (r.tokenIdxToClass[r.tokenShortNameIdx] = p,
                p.tokenTypeIdx = r.tokenShortNameIdx++),
                h(p) && !e.isArray(p.CATEGORIES) && (p.CATEGORIES = [p.CATEGORIES]),
                h(p) || (p.CATEGORIES = []),
                f(p) || (p.categoryMatches = []),
                m(p) || (p.categoryMatchesMap = {})
            })
        }
        r.assignTokenDefaultProps = o;
        function a(v) {
            e.forEach(v, function(p) {
                p.categoryMatches = [],
                e.forEach(p.categoryMatchesMap, function(d, x) {
                    p.categoryMatches.push(r.tokenIdxToClass[x].tokenTypeIdx)
                })
            })
        }
        r.assignCategoriesTokensProp = a;
        function l(v) {
            e.forEach(v, function(p) {
                c([], p)
            })
        }
        r.assignCategoriesMapProp = l;
        function c(v, p) {
            e.forEach(v, function(d) {
                p.categoryMatchesMap[d.tokenTypeIdx] = !0
            }),
            e.forEach(p.CATEGORIES, function(d) {
                var x = v.concat(p);
                e.contains(x, d) || c(x, d)
            })
        }
        r.singleAssignCategoriesToksMap = c;
        function u(v) {
            return e.has(v, "tokenTypeIdx")
        }
        r.hasShortKeyProperty = u;
        function h(v) {
            return e.has(v, "CATEGORIES")
        }
        r.hasCategoriesProperty = h;
        function f(v) {
            return e.has(v, "categoryMatches")
        }
        r.hasExtendingTokensTypesProperty = f;
        function m(v) {
            return e.has(v, "categoryMatchesMap")
        }
        r.hasExtendingTokensTypesMapProperty = m;
        function g(v) {
            return e.has(v, "tokenTypeIdx")
        }
        r.isTokenType = g
    }
    )
      , cy = _t(r=>{
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.defaultLexerErrorProvider = void 0,
        r.defaultLexerErrorProvider = {
            buildUnableToPopLexerModeMessage: function(e) {
                return "Unable to pop Lexer Mode after encountering Token ->" + e.image + "<- The Mode Stack is empty"
            },
            buildUnexpectedCharactersMessage: function(e, t, n, i, s) {
                return "unexpected character: ->" + e.charAt(t) + "<- at offset: " + t + "," + (" skipped " + n + " characters.")
            }
        }
    }
    )
      , gf = _t(r=>{
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.Lexer = r.LexerDefinitionErrorType = void 0;
        var e = ly(), t = Gt(), n = iu(), i = cy(), s = dm(), o;
        (function(c) {
            c[c.MISSING_PATTERN = 0] = "MISSING_PATTERN",
            c[c.INVALID_PATTERN = 1] = "INVALID_PATTERN",
            c[c.EOI_ANCHOR_FOUND = 2] = "EOI_ANCHOR_FOUND",
            c[c.UNSUPPORTED_FLAGS_FOUND = 3] = "UNSUPPORTED_FLAGS_FOUND",
            c[c.DUPLICATE_PATTERNS_FOUND = 4] = "DUPLICATE_PATTERNS_FOUND",
            c[c.INVALID_GROUP_TYPE_FOUND = 5] = "INVALID_GROUP_TYPE_FOUND",
            c[c.PUSH_MODE_DOES_NOT_EXIST = 6] = "PUSH_MODE_DOES_NOT_EXIST",
            c[c.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE = 7] = "MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE",
            c[c.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY = 8] = "MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY",
            c[c.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST = 9] = "MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST",
            c[c.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED = 10] = "LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED",
            c[c.SOI_ANCHOR_FOUND = 11] = "SOI_ANCHOR_FOUND",
            c[c.EMPTY_MATCH_PATTERN = 12] = "EMPTY_MATCH_PATTERN",
            c[c.NO_LINE_BREAKS_FLAGS = 13] = "NO_LINE_BREAKS_FLAGS",
            c[c.UNREACHABLE_PATTERN = 14] = "UNREACHABLE_PATTERN",
            c[c.IDENTIFY_TERMINATOR = 15] = "IDENTIFY_TERMINATOR",
            c[c.CUSTOM_LINE_BREAK = 16] = "CUSTOM_LINE_BREAK"
        }
        )(o = r.LexerDefinitionErrorType || (r.LexerDefinitionErrorType = {}));
        var a = {
            deferDefinitionErrorsHandling: !1,
            positionTracking: "full",
            lineTerminatorsPattern: /\n|\r\n?/g,
            lineTerminatorCharacters: [`
`, "\r"],
            ensureOptimizations: !1,
            safeMode: !1,
            errorMessageProvider: i.defaultLexerErrorProvider,
            traceInitPerf: !1,
            skipValidations: !1
        };
        Object.freeze(a);
        var l = function() {
            function c(u, h) {
                var f = this;
                if (h === void 0 && (h = a),
                this.lexerDefinition = u,
                this.lexerDefinitionErrors = [],
                this.lexerDefinitionWarning = [],
                this.patternIdxToConfig = {},
                this.charCodeToPatternIdxToConfig = {},
                this.modes = [],
                this.emptyGroups = {},
                this.config = void 0,
                this.trackStartLines = !0,
                this.trackEndLines = !0,
                this.hasCustom = !1,
                this.canModeBeOptimized = {},
                typeof h == "boolean")
                    throw Error(`The second argument to the Lexer constructor is now an ILexerConfig Object.
a boolean 2nd argument is no longer supported`);
                this.config = t.merge(a, h);
                var m = this.config.traceInitPerf;
                m === !0 ? (this.traceInitMaxIdent = 1 / 0,
                this.traceInitPerf = !0) : typeof m == "number" && (this.traceInitMaxIdent = m,
                this.traceInitPerf = !0),
                this.traceInitIndent = -1,
                this.TRACE_INIT("Lexer Constructor", function() {
                    var g, v = !0;
                    f.TRACE_INIT("Lexer Config handling", function() {
                        if (f.config.lineTerminatorsPattern === a.lineTerminatorsPattern)
                            f.config.lineTerminatorsPattern = e.LineTerminatorOptimizedTester;
                        else if (f.config.lineTerminatorCharacters === a.lineTerminatorCharacters)
                            throw Error(`Error: Missing <lineTerminatorCharacters> property on the Lexer config.
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS`);
                        if (h.safeMode && h.ensureOptimizations)
                            throw Error('"safeMode" and "ensureOptimizations" flags are mutually exclusive.');
                        f.trackStartLines = /full|onlyStart/i.test(f.config.positionTracking),
                        f.trackEndLines = /full/i.test(f.config.positionTracking),
                        t.isArray(u) ? (g = {
                            modes: {}
                        },
                        g.modes[e.DEFAULT_MODE] = t.cloneArr(u),
                        g[e.DEFAULT_MODE] = e.DEFAULT_MODE) : (v = !1,
                        g = t.cloneObj(u))
                    }),
                    f.config.skipValidations === !1 && (f.TRACE_INIT("performRuntimeChecks", function() {
                        f.lexerDefinitionErrors = f.lexerDefinitionErrors.concat(e.performRuntimeChecks(g, f.trackStartLines, f.config.lineTerminatorCharacters))
                    }),
                    f.TRACE_INIT("performWarningRuntimeChecks", function() {
                        f.lexerDefinitionWarning = f.lexerDefinitionWarning.concat(e.performWarningRuntimeChecks(g, f.trackStartLines, f.config.lineTerminatorCharacters))
                    })),
                    g.modes = g.modes ? g.modes : {},
                    t.forEach(g.modes, function(y, _) {
                        g.modes[_] = t.reject(y, function(S) {
                            return t.isUndefined(S)
                        })
                    });
                    var p = t.keys(g.modes);
                    if (t.forEach(g.modes, function(y, _) {
                        f.TRACE_INIT("Mode: <" + _ + "> processing", function() {
                            if (f.modes.push(_),
                            f.config.skipValidations === !1 && f.TRACE_INIT("validatePatterns", function() {
                                f.lexerDefinitionErrors = f.lexerDefinitionErrors.concat(e.validatePatterns(y, p))
                            }),
                            t.isEmpty(f.lexerDefinitionErrors)) {
                                n.augmentTokenTypes(y);
                                var S;
                                f.TRACE_INIT("analyzeTokenTypes", function() {
                                    S = e.analyzeTokenTypes(y, {
                                        lineTerminatorCharacters: f.config.lineTerminatorCharacters,
                                        positionTracking: h.positionTracking,
                                        ensureOptimizations: h.ensureOptimizations,
                                        safeMode: h.safeMode,
                                        tracer: f.TRACE_INIT.bind(f)
                                    })
                                }),
                                f.patternIdxToConfig[_] = S.patternIdxToConfig,
                                f.charCodeToPatternIdxToConfig[_] = S.charCodeToPatternIdxToConfig,
                                f.emptyGroups = t.merge(f.emptyGroups, S.emptyGroups),
                                f.hasCustom = S.hasCustom || f.hasCustom,
                                f.canModeBeOptimized[_] = S.canBeOptimized
                            }
                        })
                    }),
                    f.defaultMode = g.defaultMode,
                    !t.isEmpty(f.lexerDefinitionErrors) && !f.config.deferDefinitionErrorsHandling) {
                        var d = t.map(f.lexerDefinitionErrors, function(y) {
                            return y.message
                        })
                          , x = d.join(`-----------------------
`);
                        throw new Error(`Errors detected in definition of Lexer:
` + x)
                    }
                    t.forEach(f.lexerDefinitionWarning, function(y) {
                        t.PRINT_WARNING(y.message)
                    }),
                    f.TRACE_INIT("Choosing sub-methods implementations", function() {
                        if (e.SUPPORT_STICKY ? (f.chopInput = t.IDENTITY,
                        f.match = f.matchWithTest) : (f.updateLastIndex = t.NOOP,
                        f.match = f.matchWithExec),
                        v && (f.handleModes = t.NOOP),
                        f.trackStartLines === !1 && (f.computeNewColumn = t.IDENTITY),
                        f.trackEndLines === !1 && (f.updateTokenEndLineColumnLocation = t.NOOP),
                        /full/i.test(f.config.positionTracking))
                            f.createTokenInstance = f.createFullToken;
                        else if (/onlyStart/i.test(f.config.positionTracking))
                            f.createTokenInstance = f.createStartOnlyToken;
                        else if (/onlyOffset/i.test(f.config.positionTracking))
                            f.createTokenInstance = f.createOffsetOnlyToken;
                        else
                            throw Error('Invalid <positionTracking> config option: "' + f.config.positionTracking + '"');
                        f.hasCustom ? (f.addToken = f.addTokenUsingPush,
                        f.handlePayload = f.handlePayloadWithCustom) : (f.addToken = f.addTokenUsingMemberAccess,
                        f.handlePayload = f.handlePayloadNoCustom)
                    }),
                    f.TRACE_INIT("Failed Optimization Warnings", function() {
                        var y = t.reduce(f.canModeBeOptimized, function(_, S, N) {
                            return S === !1 && _.push(N),
                            _
                        }, []);
                        if (h.ensureOptimizations && !t.isEmpty(y))
                            throw Error("Lexer Modes: < " + y.join(", ") + ` > cannot be optimized.
	 Disable the "ensureOptimizations" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.
	 Or inspect the console log for details on how to resolve these issues.`)
                    }),
                    f.TRACE_INIT("clearRegExpParserCache", function() {
                        s.clearRegExpParserCache()
                    }),
                    f.TRACE_INIT("toFastProperties", function() {
                        t.toFastProperties(f)
                    })
                })
            }
            return c.prototype.tokenize = function(u, h) {
                if (h === void 0 && (h = this.defaultMode),
                !t.isEmpty(this.lexerDefinitionErrors)) {
                    var f = t.map(this.lexerDefinitionErrors, function(v) {
                        return v.message
                    })
                      , m = f.join(`-----------------------
`);
                    throw new Error(`Unable to Tokenize because Errors detected in definition of Lexer:
` + m)
                }
                var g = this.tokenizeInternal(u, h);
                return g
            }
            ,
            c.prototype.tokenizeInternal = function(u, h) {
                var f = this, m, g, v, p, d, x, y, _, S, N, I, O, M, R, q, k = u, B = k.length, P = 0, C = 0, L = this.hasCustom ? 0 : Math.floor(u.length / 10), F = new Array(L), U = [], W = this.trackStartLines ? 1 : void 0, K = this.trackStartLines ? 1 : void 0, re = e.cloneEmptyGroups(this.emptyGroups), oe = this.trackStartLines, j = this.config.lineTerminatorsPattern, w = 0, b = [], E = [], T = [], H = [];
                Object.freeze(H);
                var Y = void 0;
                function X() {
                    return b
                }
                function ce(le) {
                    var xe = e.charCodeToOptimizedIndex(le)
                      , Me = E[xe];
                    return Me === void 0 ? H : Me
                }
                var J = function(le) {
                    if (T.length === 1 && le.tokenType.PUSH_MODE === void 0) {
                        var xe = f.config.errorMessageProvider.buildUnableToPopLexerModeMessage(le);
                        U.push({
                            offset: le.startOffset,
                            line: le.startLine !== void 0 ? le.startLine : void 0,
                            column: le.startColumn !== void 0 ? le.startColumn : void 0,
                            length: le.image.length,
                            message: xe
                        })
                    } else {
                        T.pop();
                        var Me = t.last(T);
                        b = f.patternIdxToConfig[Me],
                        E = f.charCodeToPatternIdxToConfig[Me],
                        w = b.length;
                        var Ne = f.canModeBeOptimized[Me] && f.config.safeMode === !1;
                        E && Ne ? Y = ce : Y = X
                    }
                };
                function ae(le) {
                    T.push(le),
                    E = this.charCodeToPatternIdxToConfig[le],
                    b = this.patternIdxToConfig[le],
                    w = b.length,
                    w = b.length;
                    var xe = this.canModeBeOptimized[le] && this.config.safeMode === !1;
                    E && xe ? Y = ce : Y = X
                }
                ae.call(this, h);
                for (var ie; P < B; ) {
                    d = null;
                    var me = k.charCodeAt(P)
                      , ve = Y(me)
                      , be = ve.length;
                    for (m = 0; m < be; m++) {
                        ie = ve[m];
                        var fe = ie.pattern;
                        x = null;
                        var te = ie.short;
                        if (te !== !1 ? me === te && (d = fe) : ie.isCustom === !0 ? (q = fe.exec(k, P, F, re),
                        q !== null ? (d = q[0],
                        q.payload !== void 0 && (x = q.payload)) : d = null) : (this.updateLastIndex(fe, P),
                        d = this.match(fe, u, P)),
                        d !== null) {
                            if (p = ie.longerAlt,
                            p !== void 0) {
                                var Ee = b[p]
                                  , Le = Ee.pattern;
                                y = null,
                                Ee.isCustom === !0 ? (q = Le.exec(k, P, F, re),
                                q !== null ? (v = q[0],
                                q.payload !== void 0 && (y = q.payload)) : v = null) : (this.updateLastIndex(Le, P),
                                v = this.match(Le, u, P)),
                                v && v.length > d.length && (d = v,
                                x = y,
                                ie = Ee)
                            }
                            break
                        }
                    }
                    if (d !== null) {
                        if (_ = d.length,
                        S = ie.group,
                        S !== void 0 && (N = ie.tokenTypeIdx,
                        I = this.createTokenInstance(d, P, N, ie.tokenType, W, K, _),
                        this.handlePayload(I, x),
                        S === !1 ? C = this.addToken(F, C, I) : re[S].push(I)),
                        u = this.chopInput(u, _),
                        P = P + _,
                        K = this.computeNewColumn(K, _),
                        oe === !0 && ie.canLineTerminator === !0) {
                            var D = 0
                              , A = void 0
                              , G = void 0;
                            j.lastIndex = 0;
                            do
                                A = j.test(d),
                                A === !0 && (G = j.lastIndex - 1,
                                D++);
                            while (A === !0);
                            D !== 0 && (W = W + D,
                            K = _ - G,
                            this.updateTokenEndLineColumnLocation(I, S, G, D, W, K, _))
                        }
                        this.handleModes(ie, J, ae, I)
                    } else {
                        for (var ne = P, Q = W, he = K, de = !1; !de && P < B; )
                            for (M = k.charCodeAt(P),
                            u = this.chopInput(u, 1),
                            P++,
                            g = 0; g < w; g++) {
                                var ge = b[g]
                                  , fe = ge.pattern
                                  , te = ge.short;
                                if (te !== !1 ? k.charCodeAt(P) === te && (de = !0) : ge.isCustom === !0 ? de = fe.exec(k, P, F, re) !== null : (this.updateLastIndex(fe, P),
                                de = fe.exec(u) !== null),
                                de === !0)
                                    break
                            }
                        O = P - ne,
                        R = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(k, ne, O, Q, he),
                        U.push({
                            offset: ne,
                            line: Q,
                            column: he,
                            length: O,
                            message: R
                        })
                    }
                }
                return this.hasCustom || (F.length = C),
                {
                    tokens: F,
                    groups: re,
                    errors: U
                }
            }
            ,
            c.prototype.handleModes = function(u, h, f, m) {
                if (u.pop === !0) {
                    var g = u.push;
                    h(m),
                    g !== void 0 && f.call(this, g)
                } else
                    u.push !== void 0 && f.call(this, u.push)
            }
            ,
            c.prototype.chopInput = function(u, h) {
                return u.substring(h)
            }
            ,
            c.prototype.updateLastIndex = function(u, h) {
                u.lastIndex = h
            }
            ,
            c.prototype.updateTokenEndLineColumnLocation = function(u, h, f, m, g, v, p) {
                var d, x;
                h !== void 0 && (d = f === p - 1,
                x = d ? -1 : 0,
                m === 1 && d === !0 || (u.endLine = g + x,
                u.endColumn = v - 1 + -x))
            }
            ,
            c.prototype.computeNewColumn = function(u, h) {
                return u + h
            }
            ,
            c.prototype.createTokenInstance = function() {
                for (var u = [], h = 0; h < arguments.length; h++)
                    u[h] = arguments[h];
                return null
            }
            ,
            c.prototype.createOffsetOnlyToken = function(u, h, f, m) {
                return {
                    image: u,
                    startOffset: h,
                    tokenTypeIdx: f,
                    tokenType: m
                }
            }
            ,
            c.prototype.createStartOnlyToken = function(u, h, f, m, g, v) {
                return {
                    image: u,
                    startOffset: h,
                    startLine: g,
                    startColumn: v,
                    tokenTypeIdx: f,
                    tokenType: m
                }
            }
            ,
            c.prototype.createFullToken = function(u, h, f, m, g, v, p) {
                return {
                    image: u,
                    startOffset: h,
                    endOffset: h + p - 1,
                    startLine: g,
                    endLine: g,
                    startColumn: v,
                    endColumn: v + p - 1,
                    tokenTypeIdx: f,
                    tokenType: m
                }
            }
            ,
            c.prototype.addToken = function(u, h, f) {
                return 666
            }
            ,
            c.prototype.addTokenUsingPush = function(u, h, f) {
                return u.push(f),
                h
            }
            ,
            c.prototype.addTokenUsingMemberAccess = function(u, h, f) {
                return u[h] = f,
                h++,
                h
            }
            ,
            c.prototype.handlePayload = function(u, h) {}
            ,
            c.prototype.handlePayloadNoCustom = function(u, h) {}
            ,
            c.prototype.handlePayloadWithCustom = function(u, h) {
                h !== null && (u.payload = h)
            }
            ,
            c.prototype.match = function(u, h, f) {
                return null
            }
            ,
            c.prototype.matchWithTest = function(u, h, f) {
                var m = u.test(h);
                return m === !0 ? h.substring(f, u.lastIndex) : null
            }
            ,
            c.prototype.matchWithExec = function(u, h) {
                var f = u.exec(h);
                return f !== null ? f[0] : f
            }
            ,
            c.prototype.TRACE_INIT = function(u, h) {
                if (this.traceInitPerf === !0) {
                    this.traceInitIndent++;
                    var f = new Array(this.traceInitIndent + 1).join("	");
                    this.traceInitIndent < this.traceInitMaxIdent && console.log(f + "--> <" + u + ">");
                    var m = t.timer(h)
                      , g = m.time
                      , v = m.value
                      , p = g > 10 ? console.warn : console.log;
                    return this.traceInitIndent < this.traceInitMaxIdent && p(f + "<-- <" + u + "> time: " + g + "ms"),
                    this.traceInitIndent--,
                    v
                } else
                    return h()
            }
            ,
            c.SKIPPED = "This marks a skipped Token pattern, this means each token identified by it willbe consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.",
            c.NA = /NOT_APPLICABLE/,
            c
        }();
        r.Lexer = l
    }
    )
      , Ko = _t(r=>{
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.tokenMatcher = r.createTokenInstance = r.EOF = r.createToken = r.hasTokenLabel = r.tokenName = r.tokenLabel = void 0;
        var e = Gt()
          , t = gf()
          , n = iu();
        function i(_) {
            return o(_) ? _.LABEL : _.name
        }
        r.tokenLabel = i;
        function s(_) {
            return _.name
        }
        r.tokenName = s;
        function o(_) {
            return e.isString(_.LABEL) && _.LABEL !== ""
        }
        r.hasTokenLabel = o;
        var a = "parent"
          , l = "categories"
          , c = "label"
          , u = "group"
          , h = "push_mode"
          , f = "pop_mode"
          , m = "longer_alt"
          , g = "line_breaks"
          , v = "start_chars_hint";
        function p(_) {
            return d(_)
        }
        r.createToken = p;
        function d(_) {
            var S = _.pattern
              , N = {};
            if (N.name = _.name,
            e.isUndefined(S) || (N.PATTERN = S),
            e.has(_, a))
                throw `The parent property is no longer supported.
See: https://github.com/chevrotain/chevrotain/issues/564#issuecomment-349062346 for details.`;
            return e.has(_, l) && (N.CATEGORIES = _[l]),
            n.augmentTokenTypes([N]),
            e.has(_, c) && (N.LABEL = _[c]),
            e.has(_, u) && (N.GROUP = _[u]),
            e.has(_, f) && (N.POP_MODE = _[f]),
            e.has(_, h) && (N.PUSH_MODE = _[h]),
            e.has(_, m) && (N.LONGER_ALT = _[m]),
            e.has(_, g) && (N.LINE_BREAKS = _[g]),
            e.has(_, v) && (N.START_CHARS_HINT = _[v]),
            N
        }
        r.EOF = p({
            name: "EOF",
            pattern: t.Lexer.NA
        }),
        n.augmentTokenTypes([r.EOF]);
        function x(_, S, N, I, O, M, R, q) {
            return {
                image: S,
                startOffset: N,
                endOffset: I,
                startLine: O,
                endLine: M,
                startColumn: R,
                endColumn: q,
                tokenTypeIdx: _.tokenTypeIdx,
                tokenType: _
            }
        }
        r.createTokenInstance = x;
        function y(_, S) {
            return n.tokenStructuredMatcher(_, S)
        }
        r.tokenMatcher = y
    }
    )
      , Ui = _t(r=>{
        "use strict";
        var e = r && r.__extends || function() {
            var d = function(x, y) {
                return d = Object.setPrototypeOf || {
                    __proto__: []
                }instanceof Array && function(_, S) {
                    _.__proto__ = S
                }
                || function(_, S) {
                    for (var N in S)
                        Object.prototype.hasOwnProperty.call(S, N) && (_[N] = S[N])
                }
                ,
                d(x, y)
            };
            return function(x, y) {
                if (typeof y != "function" && y !== null)
                    throw new TypeError("Class extends value " + String(y) + " is not a constructor or null");
                d(x, y);
                function _() {
                    this.constructor = x
                }
                x.prototype = y === null ? Object.create(y) : (_.prototype = y.prototype,
                new _)
            }
        }();
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.serializeProduction = r.serializeGrammar = r.Terminal = r.Alternation = r.RepetitionWithSeparator = r.Repetition = r.RepetitionMandatoryWithSeparator = r.RepetitionMandatory = r.Option = r.Alternative = r.Rule = r.NonTerminal = r.AbstractProduction = void 0;
        var t = Gt()
          , n = Ko()
          , i = function() {
            function d(x) {
                this._definition = x
            }
            return Object.defineProperty(d.prototype, "definition", {
                get: function() {
                    return this._definition
                },
                set: function(x) {
                    this._definition = x
                },
                enumerable: !1,
                configurable: !0
            }),
            d.prototype.accept = function(x) {
                x.visit(this),
                t.forEach(this.definition, function(y) {
                    y.accept(x)
                })
            }
            ,
            d
        }();
        r.AbstractProduction = i;
        var s = function(d) {
            e(x, d);
            function x(y) {
                var _ = d.call(this, []) || this;
                return _.idx = 1,
                t.assign(_, t.pick(y, function(S) {
                    return S !== void 0
                })),
                _
            }
            return Object.defineProperty(x.prototype, "definition", {
                get: function() {
                    return this.referencedRule !== void 0 ? this.referencedRule.definition : []
                },
                set: function(y) {},
                enumerable: !1,
                configurable: !0
            }),
            x.prototype.accept = function(y) {
                y.visit(this)
            }
            ,
            x
        }(i);
        r.NonTerminal = s;
        var o = function(d) {
            e(x, d);
            function x(y) {
                var _ = d.call(this, y.definition) || this;
                return _.orgText = "",
                t.assign(_, t.pick(y, function(S) {
                    return S !== void 0
                })),
                _
            }
            return x
        }(i);
        r.Rule = o;
        var a = function(d) {
            e(x, d);
            function x(y) {
                var _ = d.call(this, y.definition) || this;
                return _.ignoreAmbiguities = !1,
                t.assign(_, t.pick(y, function(S) {
                    return S !== void 0
                })),
                _
            }
            return x
        }(i);
        r.Alternative = a;
        var l = function(d) {
            e(x, d);
            function x(y) {
                var _ = d.call(this, y.definition) || this;
                return _.idx = 1,
                t.assign(_, t.pick(y, function(S) {
                    return S !== void 0
                })),
                _
            }
            return x
        }(i);
        r.Option = l;
        var c = function(d) {
            e(x, d);
            function x(y) {
                var _ = d.call(this, y.definition) || this;
                return _.idx = 1,
                t.assign(_, t.pick(y, function(S) {
                    return S !== void 0
                })),
                _
            }
            return x
        }(i);
        r.RepetitionMandatory = c;
        var u = function(d) {
            e(x, d);
            function x(y) {
                var _ = d.call(this, y.definition) || this;
                return _.idx = 1,
                t.assign(_, t.pick(y, function(S) {
                    return S !== void 0
                })),
                _
            }
            return x
        }(i);
        r.RepetitionMandatoryWithSeparator = u;
        var h = function(d) {
            e(x, d);
            function x(y) {
                var _ = d.call(this, y.definition) || this;
                return _.idx = 1,
                t.assign(_, t.pick(y, function(S) {
                    return S !== void 0
                })),
                _
            }
            return x
        }(i);
        r.Repetition = h;
        var f = function(d) {
            e(x, d);
            function x(y) {
                var _ = d.call(this, y.definition) || this;
                return _.idx = 1,
                t.assign(_, t.pick(y, function(S) {
                    return S !== void 0
                })),
                _
            }
            return x
        }(i);
        r.RepetitionWithSeparator = f;
        var m = function(d) {
            e(x, d);
            function x(y) {
                var _ = d.call(this, y.definition) || this;
                return _.idx = 1,
                _.ignoreAmbiguities = !1,
                _.hasPredicates = !1,
                t.assign(_, t.pick(y, function(S) {
                    return S !== void 0
                })),
                _
            }
            return Object.defineProperty(x.prototype, "definition", {
                get: function() {
                    return this._definition
                },
                set: function(y) {
                    this._definition = y
                },
                enumerable: !1,
                configurable: !0
            }),
            x
        }(i);
        r.Alternation = m;
        var g = function() {
            function d(x) {
                this.idx = 1,
                t.assign(this, t.pick(x, function(y) {
                    return y !== void 0
                }))
            }
            return d.prototype.accept = function(x) {
                x.visit(this)
            }
            ,
            d
        }();
        r.Terminal = g;
        function v(d) {
            return t.map(d, p)
        }
        r.serializeGrammar = v;
        function p(d) {
            function x(S) {
                return t.map(S, p)
            }
            if (d instanceof s)
                return {
                    type: "NonTerminal",
                    name: d.nonTerminalName,
                    idx: d.idx
                };
            if (d instanceof a)
                return {
                    type: "Alternative",
                    definition: x(d.definition)
                };
            if (d instanceof l)
                return {
                    type: "Option",
                    idx: d.idx,
                    definition: x(d.definition)
                };
            if (d instanceof c)
                return {
                    type: "RepetitionMandatory",
                    idx: d.idx,
                    definition: x(d.definition)
                };
            if (d instanceof u)
                return {
                    type: "RepetitionMandatoryWithSeparator",
                    idx: d.idx,
                    separator: p(new g({
                        terminalType: d.separator
                    })),
                    definition: x(d.definition)
                };
            if (d instanceof f)
                return {
                    type: "RepetitionWithSeparator",
                    idx: d.idx,
                    separator: p(new g({
                        terminalType: d.separator
                    })),
                    definition: x(d.definition)
                };
            if (d instanceof h)
                return {
                    type: "Repetition",
                    idx: d.idx,
                    definition: x(d.definition)
                };
            if (d instanceof m)
                return {
                    type: "Alternation",
                    idx: d.idx,
                    definition: x(d.definition)
                };
            if (d instanceof g) {
                var y = {
                    type: "Terminal",
                    name: d.terminalType.name,
                    label: n.tokenLabel(d.terminalType),
                    idx: d.idx
                }
                  , _ = d.terminalType.PATTERN;
                return d.terminalType.PATTERN && (y.pattern = t.isRegExp(_) ? _.source : _),
                y
            } else {
                if (d instanceof o)
                    return {
                        type: "Rule",
                        name: d.name,
                        orgText: d.orgText,
                        definition: x(d.definition)
                    };
                throw Error("non exhaustive match")
            }
        }
        r.serializeProduction = p
    }
    )
      , pm = _t(r=>{
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.RestWalker = void 0;
        var e = Gt()
          , t = Ui()
          , n = function() {
            function s() {}
            return s.prototype.walk = function(o, a) {
                var l = this;
                a === void 0 && (a = []),
                e.forEach(o.definition, function(c, u) {
                    var h = e.drop(o.definition, u + 1);
                    if (c instanceof t.NonTerminal)
                        l.walkProdRef(c, h, a);
                    else if (c instanceof t.Terminal)
                        l.walkTerminal(c, h, a);
                    else if (c instanceof t.Alternative)
                        l.walkFlat(c, h, a);
                    else if (c instanceof t.Option)
                        l.walkOption(c, h, a);
                    else if (c instanceof t.RepetitionMandatory)
                        l.walkAtLeastOne(c, h, a);
                    else if (c instanceof t.RepetitionMandatoryWithSeparator)
                        l.walkAtLeastOneSep(c, h, a);
                    else if (c instanceof t.RepetitionWithSeparator)
                        l.walkManySep(c, h, a);
                    else if (c instanceof t.Repetition)
                        l.walkMany(c, h, a);
                    else if (c instanceof t.Alternation)
                        l.walkOr(c, h, a);
                    else
                        throw Error("non exhaustive match")
                })
            }
            ,
            s.prototype.walkTerminal = function(o, a, l) {}
            ,
            s.prototype.walkProdRef = function(o, a, l) {}
            ,
            s.prototype.walkFlat = function(o, a, l) {
                var c = a.concat(l);
                this.walk(o, c)
            }
            ,
            s.prototype.walkOption = function(o, a, l) {
                var c = a.concat(l);
                this.walk(o, c)
            }
            ,
            s.prototype.walkAtLeastOne = function(o, a, l) {
                var c = [new t.Option({
                    definition: o.definition
                })].concat(a, l);
                this.walk(o, c)
            }
            ,
            s.prototype.walkAtLeastOneSep = function(o, a, l) {
                var c = i(o, a, l);
                this.walk(o, c)
            }
            ,
            s.prototype.walkMany = function(o, a, l) {
                var c = [new t.Option({
                    definition: o.definition
                })].concat(a, l);
                this.walk(o, c)
            }
            ,
            s.prototype.walkManySep = function(o, a, l) {
                var c = i(o, a, l);
                this.walk(o, c)
            }
            ,
            s.prototype.walkOr = function(o, a, l) {
                var c = this
                  , u = a.concat(l);
                e.forEach(o.definition, function(h) {
                    var f = new t.Alternative({
                        definition: [h]
                    });
                    c.walk(f, u)
                })
            }
            ,
            s
        }();
        r.RestWalker = n;
        function i(s, o, a) {
            var l = [new t.Option({
                definition: [new t.Terminal({
                    terminalType: s.separator
                })].concat(s.definition)
            })]
              , c = l.concat(o, a);
            return c
        }
    }
    )
      , ru = _t(r=>{
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.GAstVisitor = void 0;
        var e = Ui()
          , t = function() {
            function n() {}
            return n.prototype.visit = function(i) {
                var s = i;
                switch (s.constructor) {
                case e.NonTerminal:
                    return this.visitNonTerminal(s);
                case e.Alternative:
                    return this.visitAlternative(s);
                case e.Option:
                    return this.visitOption(s);
                case e.RepetitionMandatory:
                    return this.visitRepetitionMandatory(s);
                case e.RepetitionMandatoryWithSeparator:
                    return this.visitRepetitionMandatoryWithSeparator(s);
                case e.RepetitionWithSeparator:
                    return this.visitRepetitionWithSeparator(s);
                case e.Repetition:
                    return this.visitRepetition(s);
                case e.Alternation:
                    return this.visitAlternation(s);
                case e.Terminal:
                    return this.visitTerminal(s);
                case e.Rule:
                    return this.visitRule(s);
                default:
                    throw Error("non exhaustive match")
                }
            }
            ,
            n.prototype.visitNonTerminal = function(i) {}
            ,
            n.prototype.visitAlternative = function(i) {}
            ,
            n.prototype.visitOption = function(i) {}
            ,
            n.prototype.visitRepetition = function(i) {}
            ,
            n.prototype.visitRepetitionMandatory = function(i) {}
            ,
            n.prototype.visitRepetitionMandatoryWithSeparator = function(i) {}
            ,
            n.prototype.visitRepetitionWithSeparator = function(i) {}
            ,
            n.prototype.visitAlternation = function(i) {}
            ,
            n.prototype.visitTerminal = function(i) {}
            ,
            n.prototype.visitRule = function(i) {}
            ,
            n
        }();
        r.GAstVisitor = t
    }
    )
      , vf = _t(r=>{
        "use strict";
        var e = r && r.__extends || function() {
            var f = function(m, g) {
                return f = Object.setPrototypeOf || {
                    __proto__: []
                }instanceof Array && function(v, p) {
                    v.__proto__ = p
                }
                || function(v, p) {
                    for (var d in p)
                        Object.prototype.hasOwnProperty.call(p, d) && (v[d] = p[d])
                }
                ,
                f(m, g)
            };
            return function(m, g) {
                if (typeof g != "function" && g !== null)
                    throw new TypeError("Class extends value " + String(g) + " is not a constructor or null");
                f(m, g);
                function v() {
                    this.constructor = m
                }
                m.prototype = g === null ? Object.create(g) : (v.prototype = g.prototype,
                new v)
            }
        }();
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.collectMethods = r.DslMethodsCollectorVisitor = r.getProductionDslName = r.isBranchingProd = r.isOptionalProd = r.isSequenceProd = void 0;
        var t = Gt()
          , n = Ui()
          , i = ru();
        function s(f) {
            return f instanceof n.Alternative || f instanceof n.Option || f instanceof n.Repetition || f instanceof n.RepetitionMandatory || f instanceof n.RepetitionMandatoryWithSeparator || f instanceof n.RepetitionWithSeparator || f instanceof n.Terminal || f instanceof n.Rule
        }
        r.isSequenceProd = s;
        function o(f, m) {
            m === void 0 && (m = []);
            var g = f instanceof n.Option || f instanceof n.Repetition || f instanceof n.RepetitionWithSeparator;
            return g ? !0 : f instanceof n.Alternation ? t.some(f.definition, function(v) {
                return o(v, m)
            }) : f instanceof n.NonTerminal && t.contains(m, f) ? !1 : f instanceof n.AbstractProduction ? (f instanceof n.NonTerminal && m.push(f),
            t.every(f.definition, function(v) {
                return o(v, m)
            })) : !1
        }
        r.isOptionalProd = o;
        function a(f) {
            return f instanceof n.Alternation
        }
        r.isBranchingProd = a;
        function l(f) {
            if (f instanceof n.NonTerminal)
                return "SUBRULE";
            if (f instanceof n.Option)
                return "OPTION";
            if (f instanceof n.Alternation)
                return "OR";
            if (f instanceof n.RepetitionMandatory)
                return "AT_LEAST_ONE";
            if (f instanceof n.RepetitionMandatoryWithSeparator)
                return "AT_LEAST_ONE_SEP";
            if (f instanceof n.RepetitionWithSeparator)
                return "MANY_SEP";
            if (f instanceof n.Repetition)
                return "MANY";
            if (f instanceof n.Terminal)
                return "CONSUME";
            throw Error("non exhaustive match")
        }
        r.getProductionDslName = l;
        var c = function(f) {
            e(m, f);
            function m() {
                var g = f !== null && f.apply(this, arguments) || this;
                return g.separator = "-",
                g.dslMethods = {
                    option: [],
                    alternation: [],
                    repetition: [],
                    repetitionWithSeparator: [],
                    repetitionMandatory: [],
                    repetitionMandatoryWithSeparator: []
                },
                g
            }
            return m.prototype.reset = function() {
                this.dslMethods = {
                    option: [],
                    alternation: [],
                    repetition: [],
                    repetitionWithSeparator: [],
                    repetitionMandatory: [],
                    repetitionMandatoryWithSeparator: []
                }
            }
            ,
            m.prototype.visitTerminal = function(g) {
                var v = g.terminalType.name + this.separator + "Terminal";
                t.has(this.dslMethods, v) || (this.dslMethods[v] = []),
                this.dslMethods[v].push(g)
            }
            ,
            m.prototype.visitNonTerminal = function(g) {
                var v = g.nonTerminalName + this.separator + "Terminal";
                t.has(this.dslMethods, v) || (this.dslMethods[v] = []),
                this.dslMethods[v].push(g)
            }
            ,
            m.prototype.visitOption = function(g) {
                this.dslMethods.option.push(g)
            }
            ,
            m.prototype.visitRepetitionWithSeparator = function(g) {
                this.dslMethods.repetitionWithSeparator.push(g)
            }
            ,
            m.prototype.visitRepetitionMandatory = function(g) {
                this.dslMethods.repetitionMandatory.push(g)
            }
            ,
            m.prototype.visitRepetitionMandatoryWithSeparator = function(g) {
                this.dslMethods.repetitionMandatoryWithSeparator.push(g)
            }
            ,
            m.prototype.visitRepetition = function(g) {
                this.dslMethods.repetition.push(g)
            }
            ,
            m.prototype.visitAlternation = function(g) {
                this.dslMethods.alternation.push(g)
            }
            ,
            m
        }(i.GAstVisitor);
        r.DslMethodsCollectorVisitor = c;
        var u = new c;
        function h(f) {
            u.reset(),
            f.accept(u);
            var m = u.dslMethods;
            return u.reset(),
            m
        }
        r.collectMethods = h
    }
    )
      , uy = _t(r=>{
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.firstForTerminal = r.firstForBranching = r.firstForSequence = r.first = void 0;
        var e = Gt()
          , t = Ui()
          , n = vf();
        function i(l) {
            if (l instanceof t.NonTerminal)
                return i(l.referencedRule);
            if (l instanceof t.Terminal)
                return a(l);
            if (n.isSequenceProd(l))
                return s(l);
            if (n.isBranchingProd(l))
                return o(l);
            throw Error("non exhaustive match")
        }
        r.first = i;
        function s(l) {
            for (var c = [], u = l.definition, h = 0, f = u.length > h, m, g = !0; f && g; )
                m = u[h],
                g = n.isOptionalProd(m),
                c = c.concat(i(m)),
                h = h + 1,
                f = u.length > h;
            return e.uniq(c)
        }
        r.firstForSequence = s;
        function o(l) {
            var c = e.map(l.definition, function(u) {
                return i(u)
            });
            return e.uniq(e.flatten(c))
        }
        r.firstForBranching = o;
        function a(l) {
            return [l.terminalType]
        }
        r.firstForTerminal = a
    }
    )
      , hy = _t(r=>{
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.IN = void 0,
        r.IN = "_~IN~_"
    }
    )
      , Nw = _t(r=>{
        "use strict";
        var e = r && r.__extends || function() {
            var h = function(f, m) {
                return h = Object.setPrototypeOf || {
                    __proto__: []
                }instanceof Array && function(g, v) {
                    g.__proto__ = v
                }
                || function(g, v) {
                    for (var p in v)
                        Object.prototype.hasOwnProperty.call(v, p) && (g[p] = v[p])
                }
                ,
                h(f, m)
            };
            return function(f, m) {
                if (typeof m != "function" && m !== null)
                    throw new TypeError("Class extends value " + String(m) + " is not a constructor or null");
                h(f, m);
                function g() {
                    this.constructor = f
                }
                f.prototype = m === null ? Object.create(m) : (g.prototype = m.prototype,
                new g)
            }
        }();
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.buildInProdFollowPrefix = r.buildBetweenProdsFollowPrefix = r.computeAllProdsFollows = r.ResyncFollowsWalker = void 0;
        var t = pm()
          , n = uy()
          , i = Gt()
          , s = hy()
          , o = Ui()
          , a = function(h) {
            e(f, h);
            function f(m) {
                var g = h.call(this) || this;
                return g.topProd = m,
                g.follows = {},
                g
            }
            return f.prototype.startWalking = function() {
                return this.walk(this.topProd),
                this.follows
            }
            ,
            f.prototype.walkTerminal = function(m, g, v) {}
            ,
            f.prototype.walkProdRef = function(m, g, v) {
                var p = c(m.referencedRule, m.idx) + this.topProd.name
                  , d = g.concat(v)
                  , x = new o.Alternative({
                    definition: d
                })
                  , y = n.first(x);
                this.follows[p] = y
            }
            ,
            f
        }(t.RestWalker);
        r.ResyncFollowsWalker = a;
        function l(h) {
            var f = {};
            return i.forEach(h, function(m) {
                var g = new a(m).startWalking();
                i.assign(f, g)
            }),
            f
        }
        r.computeAllProdsFollows = l;
        function c(h, f) {
            return h.name + f + s.IN
        }
        r.buildBetweenProdsFollowPrefix = c;
        function u(h) {
            var f = h.terminalType.name;
            return f + h.idx + s.IN
        }
        r.buildInProdFollowPrefix = u
    }
    )
      , yf = _t(r=>{
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.defaultGrammarValidatorErrorProvider = r.defaultGrammarResolverErrorProvider = r.defaultParserErrorProvider = void 0;
        var e = Ko()
          , t = Gt()
          , n = Gt()
          , i = Ui()
          , s = vf();
        r.defaultParserErrorProvider = {
            buildMismatchTokenMessage: function(o) {
                var a = o.expected
                  , l = o.actual
                  , c = o.previous
                  , u = o.ruleName
                  , h = e.hasTokenLabel(a)
                  , f = h ? "--> " + e.tokenLabel(a) + " <--" : "token of type --> " + a.name + " <--"
                  , m = "Expecting " + f + " but found --> '" + l.image + "' <--";
                return m
            },
            buildNotAllInputParsedMessage: function(o) {
                var a = o.firstRedundant
                  , l = o.ruleName;
                return "Redundant input, expecting EOF but found: " + a.image
            },
            buildNoViableAltMessage: function(o) {
                var a = o.expectedPathsPerAlt
                  , l = o.actual
                  , c = o.previous
                  , u = o.customUserDescription
                  , h = o.ruleName
                  , f = "Expecting: "
                  , m = n.first(l).image
                  , g = `
but found: '` + m + "'";
                if (u)
                    return f + u + g;
                var v = n.reduce(a, function(y, _) {
                    return y.concat(_)
                }, [])
                  , p = n.map(v, function(y) {
                    return "[" + n.map(y, function(_) {
                        return e.tokenLabel(_)
                    }).join(", ") + "]"
                })
                  , d = n.map(p, function(y, _) {
                    return "  " + (_ + 1) + ". " + y
                })
                  , x = `one of these possible Token sequences:
` + d.join(`
`);
                return f + x + g
            },
            buildEarlyExitMessage: function(o) {
                var a = o.expectedIterationPaths
                  , l = o.actual
                  , c = o.customUserDescription
                  , u = o.ruleName
                  , h = "Expecting: "
                  , f = n.first(l).image
                  , m = `
but found: '` + f + "'";
                if (c)
                    return h + c + m;
                var g = n.map(a, function(p) {
                    return "[" + n.map(p, function(d) {
                        return e.tokenLabel(d)
                    }).join(",") + "]"
                })
                  , v = `expecting at least one iteration which starts with one of these possible Token sequences::
  ` + ("<" + g.join(" ,") + ">");
                return h + v + m
            }
        },
        Object.freeze(r.defaultParserErrorProvider),
        r.defaultGrammarResolverErrorProvider = {
            buildRuleNotFoundError: function(o, a) {
                var l = "Invalid grammar, reference to a rule which is not defined: ->" + a.nonTerminalName + `<-
inside top level rule: ->` + o.name + "<-";
                return l
            }
        },
        r.defaultGrammarValidatorErrorProvider = {
            buildDuplicateFoundError: function(o, a) {
                function l(p) {
                    return p instanceof i.Terminal ? p.terminalType.name : p instanceof i.NonTerminal ? p.nonTerminalName : ""
                }
                var c = o.name
                  , u = n.first(a)
                  , h = u.idx
                  , f = s.getProductionDslName(u)
                  , m = l(u)
                  , g = h > 0
                  , v = "->" + f + (g ? h : "") + "<- " + (m ? "with argument: ->" + m + "<-" : "") + `
                  appears more than once (` + a.length + " times) in the top level rule: ->" + c + `<-.
                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES
                  `;
                return v = v.replace(/[ \t]+/g, " "),
                v = v.replace(/\s\s+/g, `
`),
                v
            },
            buildNamespaceConflictError: function(o) {
                var a = `Namespace conflict found in grammar.
` + ("The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <" + o.name + `>.
`) + `To resolve this make sure each Terminal and Non-Terminal names are unique
This is easy to accomplish by using the convention that Terminal names start with an uppercase letter
and Non-Terminal names start with a lower case letter.`;
                return a
            },
            buildAlternationPrefixAmbiguityError: function(o) {
                var a = n.map(o.prefixPath, function(u) {
                    return e.tokenLabel(u)
                }).join(", ")
                  , l = o.alternation.idx === 0 ? "" : o.alternation.idx
                  , c = "Ambiguous alternatives: <" + o.ambiguityIndices.join(" ,") + `> due to common lookahead prefix
` + ("in <OR" + l + "> inside <" + o.topLevelRule.name + `> Rule,
`) + ("<" + a + `> may appears as a prefix path in all these alternatives.
`) + `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX
For Further details.`;
                return c
            },
            buildAlternationAmbiguityError: function(o) {
                var a = n.map(o.prefixPath, function(u) {
                    return e.tokenLabel(u)
                }).join(", ")
                  , l = o.alternation.idx === 0 ? "" : o.alternation.idx
                  , c = "Ambiguous Alternatives Detected: <" + o.ambiguityIndices.join(" ,") + "> in <OR" + l + ">" + (" inside <" + o.topLevelRule.name + `> Rule,
`) + ("<" + a + `> may appears as a prefix path in all these alternatives.
`);
                return c = c + `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES
For Further details.`,
                c
            },
            buildEmptyRepetitionError: function(o) {
                var a = s.getProductionDslName(o.repetition);
                o.repetition.idx !== 0 && (a += o.repetition.idx);
                var l = "The repetition <" + a + "> within Rule <" + o.topLevelRule.name + `> can never consume any tokens.
This could lead to an infinite loop.`;
                return l
            },
            buildTokenNameError: function(o) {
                return "deprecated"
            },
            buildEmptyAlternationError: function(o) {
                var a = "Ambiguous empty alternative: <" + (o.emptyChoiceIdx + 1) + ">" + (" in <OR" + o.alternation.idx + "> inside <" + o.topLevelRule.name + `> Rule.
`) + "Only the last alternative may be an empty alternative.";
                return a
            },
            buildTooManyAlternativesError: function(o) {
                var a = `An Alternation cannot have more than 256 alternatives:
` + ("<OR" + o.alternation.idx + "> inside <" + o.topLevelRule.name + `> Rule.
 has ` + (o.alternation.definition.length + 1) + " alternatives.");
                return a
            },
            buildLeftRecursionError: function(o) {
                var a = o.topLevelRule.name
                  , l = t.map(o.leftRecursionPath, function(h) {
                    return h.name
                })
                  , c = a + " --> " + l.concat([a]).join(" --> ")
                  , u = `Left Recursion found in grammar.
` + ("rule: <" + a + `> can be invoked from itself (directly or indirectly)
`) + (`without consuming any Tokens. The grammar path that causes this is:
 ` + c + `
`) + ` To fix this refactor your grammar to remove the left recursion.
see: https://en.wikipedia.org/wiki/LL_parser#Left_Factoring.`;
                return u
            },
            buildInvalidRuleNameError: function(o) {
                return "deprecated"
            },
            buildDuplicateRuleNameError: function(o) {
                var a;
                o.topLevelRule instanceof i.Rule ? a = o.topLevelRule.name : a = o.topLevelRule;
                var l = "Duplicate definition, rule: ->" + a + "<- is already defined in the grammar: ->" + o.grammarName + "<-";
                return l
            }
        }
    }
    )
      , Dw = _t(r=>{
        "use strict";
        var e = r && r.__extends || function() {
            var a = function(l, c) {
                return a = Object.setPrototypeOf || {
                    __proto__: []
                }instanceof Array && function(u, h) {
                    u.__proto__ = h
                }
                || function(u, h) {
                    for (var f in h)
                        Object.prototype.hasOwnProperty.call(h, f) && (u[f] = h[f])
                }
                ,
                a(l, c)
            };
            return function(l, c) {
                if (typeof c != "function" && c !== null)
                    throw new TypeError("Class extends value " + String(c) + " is not a constructor or null");
                a(l, c);
                function u() {
                    this.constructor = l
                }
                l.prototype = c === null ? Object.create(c) : (u.prototype = c.prototype,
                new u)
            }
        }();
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.GastRefResolverVisitor = r.resolveGrammar = void 0;
        var t = Ji()
          , n = Gt()
          , i = ru();
        function s(a, l) {
            var c = new o(a,l);
            return c.resolveRefs(),
            c.errors
        }
        r.resolveGrammar = s;
        var o = function(a) {
            e(l, a);
            function l(c, u) {
                var h = a.call(this) || this;
                return h.nameToTopRule = c,
                h.errMsgProvider = u,
                h.errors = [],
                h
            }
            return l.prototype.resolveRefs = function() {
                var c = this;
                n.forEach(n.values(this.nameToTopRule), function(u) {
                    c.currTopLevel = u,
                    u.accept(c)
                })
            }
            ,
            l.prototype.visitNonTerminal = function(c) {
                var u = this.nameToTopRule[c.nonTerminalName];
                if (u)
                    c.referencedRule = u;
                else {
                    var h = this.errMsgProvider.buildRuleNotFoundError(this.currTopLevel, c);
                    this.errors.push({
                        message: h,
                        type: t.ParserDefinitionErrorType.UNRESOLVED_SUBRULE_REF,
                        ruleName: this.currTopLevel.name,
                        unresolvedRefName: c.nonTerminalName
                    })
                }
            }
            ,
            l
        }(i.GAstVisitor);
        r.GastRefResolverVisitor = o
    }
    )
      , xf = _t(r=>{
        "use strict";
        var e = r && r.__extends || function() {
            var p = function(d, x) {
                return p = Object.setPrototypeOf || {
                    __proto__: []
                }instanceof Array && function(y, _) {
                    y.__proto__ = _
                }
                || function(y, _) {
                    for (var S in _)
                        Object.prototype.hasOwnProperty.call(_, S) && (y[S] = _[S])
                }
                ,
                p(d, x)
            };
            return function(d, x) {
                if (typeof x != "function" && x !== null)
                    throw new TypeError("Class extends value " + String(x) + " is not a constructor or null");
                p(d, x);
                function y() {
                    this.constructor = d
                }
                d.prototype = x === null ? Object.create(x) : (y.prototype = x.prototype,
                new y)
            }
        }();
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.nextPossibleTokensAfter = r.possiblePathsFrom = r.NextTerminalAfterAtLeastOneSepWalker = r.NextTerminalAfterAtLeastOneWalker = r.NextTerminalAfterManySepWalker = r.NextTerminalAfterManyWalker = r.AbstractNextTerminalAfterProductionWalker = r.NextAfterTokenWalker = r.AbstractNextPossibleTokensWalker = void 0;
        var t = pm()
          , n = Gt()
          , i = uy()
          , s = Ui()
          , o = function(p) {
            e(d, p);
            function d(x, y) {
                var _ = p.call(this) || this;
                return _.topProd = x,
                _.path = y,
                _.possibleTokTypes = [],
                _.nextProductionName = "",
                _.nextProductionOccurrence = 0,
                _.found = !1,
                _.isAtEndOfPath = !1,
                _
            }
            return d.prototype.startWalking = function() {
                if (this.found = !1,
                this.path.ruleStack[0] !== this.topProd.name)
                    throw Error("The path does not start with the walker's top Rule!");
                return this.ruleStack = n.cloneArr(this.path.ruleStack).reverse(),
                this.occurrenceStack = n.cloneArr(this.path.occurrenceStack).reverse(),
                this.ruleStack.pop(),
                this.occurrenceStack.pop(),
                this.updateExpectedNext(),
                this.walk(this.topProd),
                this.possibleTokTypes
            }
            ,
            d.prototype.walk = function(x, y) {
                y === void 0 && (y = []),
                this.found || p.prototype.walk.call(this, x, y)
            }
            ,
            d.prototype.walkProdRef = function(x, y, _) {
                if (x.referencedRule.name === this.nextProductionName && x.idx === this.nextProductionOccurrence) {
                    var S = y.concat(_);
                    this.updateExpectedNext(),
                    this.walk(x.referencedRule, S)
                }
            }
            ,
            d.prototype.updateExpectedNext = function() {
                n.isEmpty(this.ruleStack) ? (this.nextProductionName = "",
                this.nextProductionOccurrence = 0,
                this.isAtEndOfPath = !0) : (this.nextProductionName = this.ruleStack.pop(),
                this.nextProductionOccurrence = this.occurrenceStack.pop())
            }
            ,
            d
        }(t.RestWalker);
        r.AbstractNextPossibleTokensWalker = o;
        var a = function(p) {
            e(d, p);
            function d(x, y) {
                var _ = p.call(this, x, y) || this;
                return _.path = y,
                _.nextTerminalName = "",
                _.nextTerminalOccurrence = 0,
                _.nextTerminalName = _.path.lastTok.name,
                _.nextTerminalOccurrence = _.path.lastTokOccurrence,
                _
            }
            return d.prototype.walkTerminal = function(x, y, _) {
                if (this.isAtEndOfPath && x.terminalType.name === this.nextTerminalName && x.idx === this.nextTerminalOccurrence && !this.found) {
                    var S = y.concat(_)
                      , N = new s.Alternative({
                        definition: S
                    });
                    this.possibleTokTypes = i.first(N),
                    this.found = !0
                }
            }
            ,
            d
        }(o);
        r.NextAfterTokenWalker = a;
        var l = function(p) {
            e(d, p);
            function d(x, y) {
                var _ = p.call(this) || this;
                return _.topRule = x,
                _.occurrence = y,
                _.result = {
                    token: void 0,
                    occurrence: void 0,
                    isEndOfRule: void 0
                },
                _
            }
            return d.prototype.startWalking = function() {
                return this.walk(this.topRule),
                this.result
            }
            ,
            d
        }(t.RestWalker);
        r.AbstractNextTerminalAfterProductionWalker = l;
        var c = function(p) {
            e(d, p);
            function d() {
                return p !== null && p.apply(this, arguments) || this
            }
            return d.prototype.walkMany = function(x, y, _) {
                if (x.idx === this.occurrence) {
                    var S = n.first(y.concat(_));
                    this.result.isEndOfRule = S === void 0,
                    S instanceof s.Terminal && (this.result.token = S.terminalType,
                    this.result.occurrence = S.idx)
                } else
                    p.prototype.walkMany.call(this, x, y, _)
            }
            ,
            d
        }(l);
        r.NextTerminalAfterManyWalker = c;
        var u = function(p) {
            e(d, p);
            function d() {
                return p !== null && p.apply(this, arguments) || this
            }
            return d.prototype.walkManySep = function(x, y, _) {
                if (x.idx === this.occurrence) {
                    var S = n.first(y.concat(_));
                    this.result.isEndOfRule = S === void 0,
                    S instanceof s.Terminal && (this.result.token = S.terminalType,
                    this.result.occurrence = S.idx)
                } else
                    p.prototype.walkManySep.call(this, x, y, _)
            }
            ,
            d
        }(l);
        r.NextTerminalAfterManySepWalker = u;
        var h = function(p) {
            e(d, p);
            function d() {
                return p !== null && p.apply(this, arguments) || this
            }
            return d.prototype.walkAtLeastOne = function(x, y, _) {
                if (x.idx === this.occurrence) {
                    var S = n.first(y.concat(_));
                    this.result.isEndOfRule = S === void 0,
                    S instanceof s.Terminal && (this.result.token = S.terminalType,
                    this.result.occurrence = S.idx)
                } else
                    p.prototype.walkAtLeastOne.call(this, x, y, _)
            }
            ,
            d
        }(l);
        r.NextTerminalAfterAtLeastOneWalker = h;
        var f = function(p) {
            e(d, p);
            function d() {
                return p !== null && p.apply(this, arguments) || this
            }
            return d.prototype.walkAtLeastOneSep = function(x, y, _) {
                if (x.idx === this.occurrence) {
                    var S = n.first(y.concat(_));
                    this.result.isEndOfRule = S === void 0,
                    S instanceof s.Terminal && (this.result.token = S.terminalType,
                    this.result.occurrence = S.idx)
                } else
                    p.prototype.walkAtLeastOneSep.call(this, x, y, _)
            }
            ,
            d
        }(l);
        r.NextTerminalAfterAtLeastOneSepWalker = f;
        function m(p, d, x) {
            x === void 0 && (x = []),
            x = n.cloneArr(x);
            var y = []
              , _ = 0;
            function S(M) {
                return M.concat(n.drop(p, _ + 1))
            }
            function N(M) {
                var R = m(S(M), d, x);
                return y.concat(R)
            }
            for (; x.length < d && _ < p.length; ) {
                var I = p[_];
                if (I instanceof s.Alternative || I instanceof s.NonTerminal)
                    return N(I.definition);
                if (I instanceof s.Option)
                    y = N(I.definition);
                else if (I instanceof s.RepetitionMandatory) {
                    var O = I.definition.concat([new s.Repetition({
                        definition: I.definition
                    })]);
                    return N(O)
                } else if (I instanceof s.RepetitionMandatoryWithSeparator) {
                    var O = [new s.Alternative({
                        definition: I.definition
                    }), new s.Repetition({
                        definition: [new s.Terminal({
                            terminalType: I.separator
                        })].concat(I.definition)
                    })];
                    return N(O)
                } else if (I instanceof s.RepetitionWithSeparator) {
                    var O = I.definition.concat([new s.Repetition({
                        definition: [new s.Terminal({
                            terminalType: I.separator
                        })].concat(I.definition)
                    })]);
                    y = N(O)
                } else if (I instanceof s.Repetition) {
                    var O = I.definition.concat([new s.Repetition({
                        definition: I.definition
                    })]);
                    y = N(O)
                } else {
                    if (I instanceof s.Alternation)
                        return n.forEach(I.definition, function(M) {
                            n.isEmpty(M.definition) === !1 && (y = N(M.definition))
                        }),
                        y;
                    if (I instanceof s.Terminal)
                        x.push(I.terminalType);
                    else
                        throw Error("non exhaustive match")
                }
                _++
            }
            return y.push({
                partialPath: x,
                suffixDef: n.drop(p, _)
            }),
            y
        }
        r.possiblePathsFrom = m;
        function g(p, d, x, y) {
            var _ = "EXIT_NONE_TERMINAL"
              , S = [_]
              , N = "EXIT_ALTERNATIVE"
              , I = !1
              , O = d.length
              , M = O - y - 1
              , R = []
              , q = [];
            for (q.push({
                idx: -1,
                def: p,
                ruleStack: [],
                occurrenceStack: []
            }); !n.isEmpty(q); ) {
                var k = q.pop();
                if (k === N) {
                    I && n.last(q).idx <= M && q.pop();
                    continue
                }
                var B = k.def
                  , P = k.idx
                  , C = k.ruleStack
                  , L = k.occurrenceStack;
                if (!n.isEmpty(B)) {
                    var F = B[0];
                    if (F === _) {
                        var U = {
                            idx: P,
                            def: n.drop(B),
                            ruleStack: n.dropRight(C),
                            occurrenceStack: n.dropRight(L)
                        };
                        q.push(U)
                    } else if (F instanceof s.Terminal)
                        if (P < O - 1) {
                            var W = P + 1
                              , K = d[W];
                            if (x(K, F.terminalType)) {
                                var U = {
                                    idx: W,
                                    def: n.drop(B),
                                    ruleStack: C,
                                    occurrenceStack: L
                                };
                                q.push(U)
                            }
                        } else if (P === O - 1)
                            R.push({
                                nextTokenType: F.terminalType,
                                nextTokenOccurrence: F.idx,
                                ruleStack: C,
                                occurrenceStack: L
                            }),
                            I = !0;
                        else
                            throw Error("non exhaustive match");
                    else if (F instanceof s.NonTerminal) {
                        var re = n.cloneArr(C);
                        re.push(F.nonTerminalName);
                        var oe = n.cloneArr(L);
                        oe.push(F.idx);
                        var U = {
                            idx: P,
                            def: F.definition.concat(S, n.drop(B)),
                            ruleStack: re,
                            occurrenceStack: oe
                        };
                        q.push(U)
                    } else if (F instanceof s.Option) {
                        var j = {
                            idx: P,
                            def: n.drop(B),
                            ruleStack: C,
                            occurrenceStack: L
                        };
                        q.push(j),
                        q.push(N);
                        var w = {
                            idx: P,
                            def: F.definition.concat(n.drop(B)),
                            ruleStack: C,
                            occurrenceStack: L
                        };
                        q.push(w)
                    } else if (F instanceof s.RepetitionMandatory) {
                        var b = new s.Repetition({
                            definition: F.definition,
                            idx: F.idx
                        })
                          , E = F.definition.concat([b], n.drop(B))
                          , U = {
                            idx: P,
                            def: E,
                            ruleStack: C,
                            occurrenceStack: L
                        };
                        q.push(U)
                    } else if (F instanceof s.RepetitionMandatoryWithSeparator) {
                        var T = new s.Terminal({
                            terminalType: F.separator
                        })
                          , b = new s.Repetition({
                            definition: [T].concat(F.definition),
                            idx: F.idx
                        })
                          , E = F.definition.concat([b], n.drop(B))
                          , U = {
                            idx: P,
                            def: E,
                            ruleStack: C,
                            occurrenceStack: L
                        };
                        q.push(U)
                    } else if (F instanceof s.RepetitionWithSeparator) {
                        var j = {
                            idx: P,
                            def: n.drop(B),
                            ruleStack: C,
                            occurrenceStack: L
                        };
                        q.push(j),
                        q.push(N);
                        var T = new s.Terminal({
                            terminalType: F.separator
                        })
                          , H = new s.Repetition({
                            definition: [T].concat(F.definition),
                            idx: F.idx
                        })
                          , E = F.definition.concat([H], n.drop(B))
                          , w = {
                            idx: P,
                            def: E,
                            ruleStack: C,
                            occurrenceStack: L
                        };
                        q.push(w)
                    } else if (F instanceof s.Repetition) {
                        var j = {
                            idx: P,
                            def: n.drop(B),
                            ruleStack: C,
                            occurrenceStack: L
                        };
                        q.push(j),
                        q.push(N);
                        var H = new s.Repetition({
                            definition: F.definition,
                            idx: F.idx
                        })
                          , E = F.definition.concat([H], n.drop(B))
                          , w = {
                            idx: P,
                            def: E,
                            ruleStack: C,
                            occurrenceStack: L
                        };
                        q.push(w)
                    } else if (F instanceof s.Alternation)
                        for (var Y = F.definition.length - 1; Y >= 0; Y--) {
                            var X = F.definition[Y]
                              , ce = {
                                idx: P,
                                def: X.definition.concat(n.drop(B)),
                                ruleStack: C,
                                occurrenceStack: L
                            };
                            q.push(ce),
                            q.push(N)
                        }
                    else if (F instanceof s.Alternative)
                        q.push({
                            idx: P,
                            def: F.definition.concat(n.drop(B)),
                            ruleStack: C,
                            occurrenceStack: L
                        });
                    else if (F instanceof s.Rule)
                        q.push(v(F, P, C, L));
                    else
                        throw Error("non exhaustive match")
                }
            }
            return R
        }
        r.nextPossibleTokensAfter = g;
        function v(p, d, x, y) {
            var _ = n.cloneArr(x);
            _.push(p.name);
            var S = n.cloneArr(y);
            return S.push(1),
            {
                idx: d,
                def: p.definition,
                ruleStack: _,
                occurrenceStack: S
            }
        }
    }
    )
      , _f = _t(r=>{
        "use strict";
        var e = r && r.__extends || function() {
            var M = function(R, q) {
                return M = Object.setPrototypeOf || {
                    __proto__: []
                }instanceof Array && function(k, B) {
                    k.__proto__ = B
                }
                || function(k, B) {
                    for (var P in B)
                        Object.prototype.hasOwnProperty.call(B, P) && (k[P] = B[P])
                }
                ,
                M(R, q)
            };
            return function(R, q) {
                if (typeof q != "function" && q !== null)
                    throw new TypeError("Class extends value " + String(q) + " is not a constructor or null");
                M(R, q);
                function k() {
                    this.constructor = R
                }
                R.prototype = q === null ? Object.create(q) : (k.prototype = q.prototype,
                new k)
            }
        }();
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.areTokenCategoriesNotUsed = r.isStrictPrefixOfPath = r.containsPath = r.getLookaheadPathsForOptionalProd = r.getLookaheadPathsForOr = r.lookAheadSequenceFromAlternatives = r.buildSingleAlternativeLookaheadFunction = r.buildAlternativesLookAheadFunc = r.buildLookaheadFuncForOptionalProd = r.buildLookaheadFuncForOr = r.getProdType = r.PROD_TYPE = void 0;
        var t = Gt(), n = xf(), i = pm(), s = iu(), o = Ui(), a = ru(), l;
        (function(M) {
            M[M.OPTION = 0] = "OPTION",
            M[M.REPETITION = 1] = "REPETITION",
            M[M.REPETITION_MANDATORY = 2] = "REPETITION_MANDATORY",
            M[M.REPETITION_MANDATORY_WITH_SEPARATOR = 3] = "REPETITION_MANDATORY_WITH_SEPARATOR",
            M[M.REPETITION_WITH_SEPARATOR = 4] = "REPETITION_WITH_SEPARATOR",
            M[M.ALTERNATION = 5] = "ALTERNATION"
        }
        )(l = r.PROD_TYPE || (r.PROD_TYPE = {}));
        function c(M) {
            if (M instanceof o.Option)
                return l.OPTION;
            if (M instanceof o.Repetition)
                return l.REPETITION;
            if (M instanceof o.RepetitionMandatory)
                return l.REPETITION_MANDATORY;
            if (M instanceof o.RepetitionMandatoryWithSeparator)
                return l.REPETITION_MANDATORY_WITH_SEPARATOR;
            if (M instanceof o.RepetitionWithSeparator)
                return l.REPETITION_WITH_SEPARATOR;
            if (M instanceof o.Alternation)
                return l.ALTERNATION;
            throw Error("non exhaustive match")
        }
        r.getProdType = c;
        function u(M, R, q, k, B, P) {
            var C = _(M, R, q)
              , L = O(C) ? s.tokenStructuredMatcherNoCategories : s.tokenStructuredMatcher;
            return P(C, k, L, B)
        }
        r.buildLookaheadFuncForOr = u;
        function h(M, R, q, k, B, P) {
            var C = S(M, R, B, q)
              , L = O(C) ? s.tokenStructuredMatcherNoCategories : s.tokenStructuredMatcher;
            return P(C[0], L, k)
        }
        r.buildLookaheadFuncForOptionalProd = h;
        function f(M, R, q, k) {
            var B = M.length
              , P = t.every(M, function(F) {
                return t.every(F, function(U) {
                    return U.length === 1
                })
            });
            if (R)
                return function(F) {
                    for (var U = t.map(F, function(H) {
                        return H.GATE
                    }), W = 0; W < B; W++) {
                        var K = M[W]
                          , re = K.length
                          , oe = U[W];
                        if (!(oe !== void 0 && oe.call(this) === !1))
                            e: for (var j = 0; j < re; j++) {
                                for (var w = K[j], b = w.length, E = 0; E < b; E++) {
                                    var T = this.LA(E + 1);
                                    if (q(T, w[E]) === !1)
                                        continue e
                                }
                                return W
                            }
                    }
                }
                ;
            if (P && !k) {
                var C = t.map(M, function(F) {
                    return t.flatten(F)
                })
                  , L = t.reduce(C, function(F, U, W) {
                    return t.forEach(U, function(K) {
                        t.has(F, K.tokenTypeIdx) || (F[K.tokenTypeIdx] = W),
                        t.forEach(K.categoryMatches, function(re) {
                            t.has(F, re) || (F[re] = W)
                        })
                    }),
                    F
                }, []);
                return function() {
                    var F = this.LA(1);
                    return L[F.tokenTypeIdx]
                }
            } else
                return function() {
                    for (var F = 0; F < B; F++) {
                        var U = M[F]
                          , W = U.length;
                        e: for (var K = 0; K < W; K++) {
                            for (var re = U[K], oe = re.length, j = 0; j < oe; j++) {
                                var w = this.LA(j + 1);
                                if (q(w, re[j]) === !1)
                                    continue e
                            }
                            return F
                        }
                    }
                }
        }
        r.buildAlternativesLookAheadFunc = f;
        function m(M, R, q) {
            var k = t.every(M, function(U) {
                return U.length === 1
            })
              , B = M.length;
            if (k && !q) {
                var P = t.flatten(M);
                if (P.length === 1 && t.isEmpty(P[0].categoryMatches)) {
                    var C = P[0]
                      , L = C.tokenTypeIdx;
                    return function() {
                        return this.LA(1).tokenTypeIdx === L
                    }
                } else {
                    var F = t.reduce(P, function(U, W, K) {
                        return U[W.tokenTypeIdx] = !0,
                        t.forEach(W.categoryMatches, function(re) {
                            U[re] = !0
                        }),
                        U
                    }, []);
                    return function() {
                        var U = this.LA(1);
                        return F[U.tokenTypeIdx] === !0
                    }
                }
            } else
                return function() {
                    e: for (var U = 0; U < B; U++) {
                        for (var W = M[U], K = W.length, re = 0; re < K; re++) {
                            var oe = this.LA(re + 1);
                            if (R(oe, W[re]) === !1)
                                continue e
                        }
                        return !0
                    }
                    return !1
                }
        }
        r.buildSingleAlternativeLookaheadFunction = m;
        var g = function(M) {
            e(R, M);
            function R(q, k, B) {
                var P = M.call(this) || this;
                return P.topProd = q,
                P.targetOccurrence = k,
                P.targetProdType = B,
                P
            }
            return R.prototype.startWalking = function() {
                return this.walk(this.topProd),
                this.restDef
            }
            ,
            R.prototype.checkIsTarget = function(q, k, B, P) {
                return q.idx === this.targetOccurrence && this.targetProdType === k ? (this.restDef = B.concat(P),
                !0) : !1
            }
            ,
            R.prototype.walkOption = function(q, k, B) {
                this.checkIsTarget(q, l.OPTION, k, B) || M.prototype.walkOption.call(this, q, k, B)
            }
            ,
            R.prototype.walkAtLeastOne = function(q, k, B) {
                this.checkIsTarget(q, l.REPETITION_MANDATORY, k, B) || M.prototype.walkOption.call(this, q, k, B)
            }
            ,
            R.prototype.walkAtLeastOneSep = function(q, k, B) {
                this.checkIsTarget(q, l.REPETITION_MANDATORY_WITH_SEPARATOR, k, B) || M.prototype.walkOption.call(this, q, k, B)
            }
            ,
            R.prototype.walkMany = function(q, k, B) {
                this.checkIsTarget(q, l.REPETITION, k, B) || M.prototype.walkOption.call(this, q, k, B)
            }
            ,
            R.prototype.walkManySep = function(q, k, B) {
                this.checkIsTarget(q, l.REPETITION_WITH_SEPARATOR, k, B) || M.prototype.walkOption.call(this, q, k, B)
            }
            ,
            R
        }(i.RestWalker)
          , v = function(M) {
            e(R, M);
            function R(q, k, B) {
                var P = M.call(this) || this;
                return P.targetOccurrence = q,
                P.targetProdType = k,
                P.targetRef = B,
                P.result = [],
                P
            }
            return R.prototype.checkIsTarget = function(q, k) {
                q.idx === this.targetOccurrence && this.targetProdType === k && (this.targetRef === void 0 || q === this.targetRef) && (this.result = q.definition)
            }
            ,
            R.prototype.visitOption = function(q) {
                this.checkIsTarget(q, l.OPTION)
            }
            ,
            R.prototype.visitRepetition = function(q) {
                this.checkIsTarget(q, l.REPETITION)
            }
            ,
            R.prototype.visitRepetitionMandatory = function(q) {
                this.checkIsTarget(q, l.REPETITION_MANDATORY)
            }
            ,
            R.prototype.visitRepetitionMandatoryWithSeparator = function(q) {
                this.checkIsTarget(q, l.REPETITION_MANDATORY_WITH_SEPARATOR)
            }
            ,
            R.prototype.visitRepetitionWithSeparator = function(q) {
                this.checkIsTarget(q, l.REPETITION_WITH_SEPARATOR)
            }
            ,
            R.prototype.visitAlternation = function(q) {
                this.checkIsTarget(q, l.ALTERNATION)
            }
            ,
            R
        }(a.GAstVisitor);
        function p(M) {
            for (var R = new Array(M), q = 0; q < M; q++)
                R[q] = [];
            return R
        }
        function d(M) {
            for (var R = [""], q = 0; q < M.length; q++) {
                for (var k = M[q], B = [], P = 0; P < R.length; P++) {
                    var C = R[P];
                    B.push(C + "_" + k.tokenTypeIdx);
                    for (var L = 0; L < k.categoryMatches.length; L++) {
                        var F = "_" + k.categoryMatches[L];
                        B.push(C + F)
                    }
                }
                R = B
            }
            return R
        }
        function x(M, R, q) {
            for (var k = 0; k < M.length; k++)
                if (k !== q)
                    for (var B = M[k], P = 0; P < R.length; P++) {
                        var C = R[P];
                        if (B[C] === !0)
                            return !1
                    }
            return !0
        }
        function y(M, R) {
            for (var q = t.map(M, function(W) {
                return n.possiblePathsFrom([W], 1)
            }), k = p(q.length), B = t.map(q, function(W) {
                var K = {};
                return t.forEach(W, function(re) {
                    var oe = d(re.partialPath);
                    t.forEach(oe, function(j) {
                        K[j] = !0
                    })
                }),
                K
            }), P = q, C = 1; C <= R; C++) {
                var L = P;
                P = p(L.length);
                for (var F = function(W) {
                    for (var K = L[W], re = 0; re < K.length; re++) {
                        var oe = K[re].partialPath
                          , j = K[re].suffixDef
                          , w = d(oe)
                          , b = x(B, w, W);
                        if (b || t.isEmpty(j) || oe.length === R) {
                            var E = k[W];
                            if (N(E, oe) === !1) {
                                E.push(oe);
                                for (var T = 0; T < w.length; T++) {
                                    var H = w[T];
                                    B[W][H] = !0
                                }
                            }
                        } else {
                            var Y = n.possiblePathsFrom(j, C + 1, oe);
                            P[W] = P[W].concat(Y),
                            t.forEach(Y, function(X) {
                                var ce = d(X.partialPath);
                                t.forEach(ce, function(J) {
                                    B[W][J] = !0
                                })
                            })
                        }
                    }
                }, U = 0; U < L.length; U++)
                    F(U)
            }
            return k
        }
        r.lookAheadSequenceFromAlternatives = y;
        function _(M, R, q, k) {
            var B = new v(M,l.ALTERNATION,k);
            return R.accept(B),
            y(B.result, q)
        }
        r.getLookaheadPathsForOr = _;
        function S(M, R, q, k) {
            var B = new v(M,q);
            R.accept(B);
            var P = B.result
              , C = new g(R,M,q)
              , L = C.startWalking()
              , F = new o.Alternative({
                definition: P
            })
              , U = new o.Alternative({
                definition: L
            });
            return y([F, U], k)
        }
        r.getLookaheadPathsForOptionalProd = S;
        function N(M, R) {
            e: for (var q = 0; q < M.length; q++) {
                var k = M[q];
                if (k.length === R.length) {
                    for (var B = 0; B < k.length; B++) {
                        var P = R[B]
                          , C = k[B]
                          , L = P === C || C.categoryMatchesMap[P.tokenTypeIdx] !== void 0;
                        if (L === !1)
                            continue e
                    }
                    return !0
                }
            }
            return !1
        }
        r.containsPath = N;
        function I(M, R) {
            return M.length < R.length && t.every(M, function(q, k) {
                var B = R[k];
                return q === B || B.categoryMatchesMap[q.tokenTypeIdx]
            })
        }
        r.isStrictPrefixOfPath = I;
        function O(M) {
            return t.every(M, function(R) {
                return t.every(R, function(q) {
                    return t.every(q, function(k) {
                        return t.isEmpty(k.categoryMatches)
                    })
                })
            })
        }
        r.areTokenCategoriesNotUsed = O
    }
    )
      , fy = _t(r=>{
        "use strict";
        var e = r && r.__extends || function() {
            var k = function(B, P) {
                return k = Object.setPrototypeOf || {
                    __proto__: []
                }instanceof Array && function(C, L) {
                    C.__proto__ = L
                }
                || function(C, L) {
                    for (var F in L)
                        Object.prototype.hasOwnProperty.call(L, F) && (C[F] = L[F])
                }
                ,
                k(B, P)
            };
            return function(B, P) {
                if (typeof P != "function" && P !== null)
                    throw new TypeError("Class extends value " + String(P) + " is not a constructor or null");
                k(B, P);
                function C() {
                    this.constructor = B
                }
                B.prototype = P === null ? Object.create(P) : (C.prototype = P.prototype,
                new C)
            }
        }();
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.checkPrefixAlternativesAmbiguities = r.validateSomeNonEmptyLookaheadPath = r.validateTooManyAlts = r.RepetionCollector = r.validateAmbiguousAlternationAlternatives = r.validateEmptyOrAlternative = r.getFirstNoneTerminal = r.validateNoLeftRecursion = r.validateRuleIsOverridden = r.validateRuleDoesNotAlreadyExist = r.OccurrenceValidationCollector = r.identifyProductionForDuplicates = r.validateGrammar = void 0;
        var t = Gt()
          , n = Gt()
          , i = Ji()
          , s = vf()
          , o = _f()
          , a = xf()
          , l = Ui()
          , c = ru();
        function u(k, B, P, C, L) {
            var F = t.map(k, function(b) {
                return h(b, C)
            })
              , U = t.map(k, function(b) {
                return d(b, b, C)
            })
              , W = []
              , K = []
              , re = [];
            n.every(U, n.isEmpty) && (W = n.map(k, function(b) {
                return _(b, C)
            }),
            K = n.map(k, function(b) {
                return S(b, B, C)
            }),
            re = O(k, B, C));
            var oe = q(k, P, C)
              , j = n.map(k, function(b) {
                return I(b, C)
            })
              , w = n.map(k, function(b) {
                return v(b, k, L, C)
            });
            return t.flatten(F.concat(re, U, W, K, oe, j, w))
        }
        r.validateGrammar = u;
        function h(k, B) {
            var P = new g;
            k.accept(P);
            var C = P.allProductions
              , L = t.groupBy(C, f)
              , F = t.pick(L, function(W) {
                return W.length > 1
            })
              , U = t.map(t.values(F), function(W) {
                var K = t.first(W)
                  , re = B.buildDuplicateFoundError(k, W)
                  , oe = s.getProductionDslName(K)
                  , j = {
                    message: re,
                    type: i.ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,
                    ruleName: k.name,
                    dslName: oe,
                    occurrence: K.idx
                }
                  , w = m(K);
                return w && (j.parameter = w),
                j
            });
            return U
        }
        function f(k) {
            return s.getProductionDslName(k) + "_#_" + k.idx + "_#_" + m(k)
        }
        r.identifyProductionForDuplicates = f;
        function m(k) {
            return k instanceof l.Terminal ? k.terminalType.name : k instanceof l.NonTerminal ? k.nonTerminalName : ""
        }
        var g = function(k) {
            e(B, k);
            function B() {
                var P = k !== null && k.apply(this, arguments) || this;
                return P.allProductions = [],
                P
            }
            return B.prototype.visitNonTerminal = function(P) {
                this.allProductions.push(P)
            }
            ,
            B.prototype.visitOption = function(P) {
                this.allProductions.push(P)
            }
            ,
            B.prototype.visitRepetitionWithSeparator = function(P) {
                this.allProductions.push(P)
            }
            ,
            B.prototype.visitRepetitionMandatory = function(P) {
                this.allProductions.push(P)
            }
            ,
            B.prototype.visitRepetitionMandatoryWithSeparator = function(P) {
                this.allProductions.push(P)
            }
            ,
            B.prototype.visitRepetition = function(P) {
                this.allProductions.push(P)
            }
            ,
            B.prototype.visitAlternation = function(P) {
                this.allProductions.push(P)
            }
            ,
            B.prototype.visitTerminal = function(P) {
                this.allProductions.push(P)
            }
            ,
            B
        }(c.GAstVisitor);
        r.OccurrenceValidationCollector = g;
        function v(k, B, P, C) {
            var L = []
              , F = n.reduce(B, function(W, K) {
                return K.name === k.name ? W + 1 : W
            }, 0);
            if (F > 1) {
                var U = C.buildDuplicateRuleNameError({
                    topLevelRule: k,
                    grammarName: P
                });
                L.push({
                    message: U,
                    type: i.ParserDefinitionErrorType.DUPLICATE_RULE_NAME,
                    ruleName: k.name
                })
            }
            return L
        }
        r.validateRuleDoesNotAlreadyExist = v;
        function p(k, B, P) {
            var C = [], L;
            return t.contains(B, k) || (L = "Invalid rule override, rule: ->" + k + "<- cannot be overridden in the grammar: ->" + P + "<-as it is not defined in any of the super grammars ",
            C.push({
                message: L,
                type: i.ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,
                ruleName: k
            })),
            C
        }
        r.validateRuleIsOverridden = p;
        function d(k, B, P, C) {
            C === void 0 && (C = []);
            var L = []
              , F = x(B.definition);
            if (t.isEmpty(F))
                return [];
            var U = k.name
              , W = t.contains(F, k);
            W && L.push({
                message: P.buildLeftRecursionError({
                    topLevelRule: k,
                    leftRecursionPath: C
                }),
                type: i.ParserDefinitionErrorType.LEFT_RECURSION,
                ruleName: U
            });
            var K = t.difference(F, C.concat([k]))
              , re = t.map(K, function(oe) {
                var j = t.cloneArr(C);
                return j.push(oe),
                d(k, oe, P, j)
            });
            return L.concat(t.flatten(re))
        }
        r.validateNoLeftRecursion = d;
        function x(k) {
            var B = [];
            if (t.isEmpty(k))
                return B;
            var P = t.first(k);
            if (P instanceof l.NonTerminal)
                B.push(P.referencedRule);
            else if (P instanceof l.Alternative || P instanceof l.Option || P instanceof l.RepetitionMandatory || P instanceof l.RepetitionMandatoryWithSeparator || P instanceof l.RepetitionWithSeparator || P instanceof l.Repetition)
                B = B.concat(x(P.definition));
            else if (P instanceof l.Alternation)
                B = t.flatten(t.map(P.definition, function(U) {
                    return x(U.definition)
                }));
            else if (!(P instanceof l.Terminal))
                throw Error("non exhaustive match");
            var C = s.isOptionalProd(P)
              , L = k.length > 1;
            if (C && L) {
                var F = t.drop(k);
                return B.concat(x(F))
            } else
                return B
        }
        r.getFirstNoneTerminal = x;
        var y = function(k) {
            e(B, k);
            function B() {
                var P = k !== null && k.apply(this, arguments) || this;
                return P.alternations = [],
                P
            }
            return B.prototype.visitAlternation = function(P) {
                this.alternations.push(P)
            }
            ,
            B
        }(c.GAstVisitor);
        function _(k, B) {
            var P = new y;
            k.accept(P);
            var C = P.alternations
              , L = t.reduce(C, function(F, U) {
                var W = t.dropRight(U.definition)
                  , K = t.map(W, function(re, oe) {
                    var j = a.nextPossibleTokensAfter([re], [], null, 1);
                    return t.isEmpty(j) ? {
                        message: B.buildEmptyAlternationError({
                            topLevelRule: k,
                            alternation: U,
                            emptyChoiceIdx: oe
                        }),
                        type: i.ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,
                        ruleName: k.name,
                        occurrence: U.idx,
                        alternative: oe + 1
                    } : null
                });
                return F.concat(t.compact(K))
            }, []);
            return L
        }
        r.validateEmptyOrAlternative = _;
        function S(k, B, P) {
            var C = new y;
            k.accept(C);
            var L = C.alternations;
            L = n.reject(L, function(U) {
                return U.ignoreAmbiguities === !0
            });
            var F = t.reduce(L, function(U, W) {
                var K = W.idx
                  , re = W.maxLookahead || B
                  , oe = o.getLookaheadPathsForOr(K, k, re, W)
                  , j = M(oe, W, k, P)
                  , w = R(oe, W, k, P);
                return U.concat(j, w)
            }, []);
            return F
        }
        r.validateAmbiguousAlternationAlternatives = S;
        var N = function(k) {
            e(B, k);
            function B() {
                var P = k !== null && k.apply(this, arguments) || this;
                return P.allProductions = [],
                P
            }
            return B.prototype.visitRepetitionWithSeparator = function(P) {
                this.allProductions.push(P)
            }
            ,
            B.prototype.visitRepetitionMandatory = function(P) {
                this.allProductions.push(P)
            }
            ,
            B.prototype.visitRepetitionMandatoryWithSeparator = function(P) {
                this.allProductions.push(P)
            }
            ,
            B.prototype.visitRepetition = function(P) {
                this.allProductions.push(P)
            }
            ,
            B
        }(c.GAstVisitor);
        r.RepetionCollector = N;
        function I(k, B) {
            var P = new y;
            k.accept(P);
            var C = P.alternations
              , L = t.reduce(C, function(F, U) {
                return U.definition.length > 255 && F.push({
                    message: B.buildTooManyAlternativesError({
                        topLevelRule: k,
                        alternation: U
                    }),
                    type: i.ParserDefinitionErrorType.TOO_MANY_ALTS,
                    ruleName: k.name,
                    occurrence: U.idx
                }),
                F
            }, []);
            return L
        }
        r.validateTooManyAlts = I;
        function O(k, B, P) {
            var C = [];
            return n.forEach(k, function(L) {
                var F = new N;
                L.accept(F);
                var U = F.allProductions;
                n.forEach(U, function(W) {
                    var K = o.getProdType(W)
                      , re = W.maxLookahead || B
                      , oe = W.idx
                      , j = o.getLookaheadPathsForOptionalProd(oe, L, K, re)
                      , w = j[0];
                    if (n.isEmpty(n.flatten(w))) {
                        var b = P.buildEmptyRepetitionError({
                            topLevelRule: L,
                            repetition: W
                        });
                        C.push({
                            message: b,
                            type: i.ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,
                            ruleName: L.name
                        })
                    }
                })
            }),
            C
        }
        r.validateSomeNonEmptyLookaheadPath = O;
        function M(k, B, P, C) {
            var L = []
              , F = n.reduce(k, function(W, K, re) {
                return B.definition[re].ignoreAmbiguities === !0 || n.forEach(K, function(oe) {
                    var j = [re];
                    n.forEach(k, function(w, b) {
                        re !== b && o.containsPath(w, oe) && B.definition[b].ignoreAmbiguities !== !0 && j.push(b)
                    }),
                    j.length > 1 && !o.containsPath(L, oe) && (L.push(oe),
                    W.push({
                        alts: j,
                        path: oe
                    }))
                }),
                W
            }, [])
              , U = t.map(F, function(W) {
                var K = n.map(W.alts, function(oe) {
                    return oe + 1
                })
                  , re = C.buildAlternationAmbiguityError({
                    topLevelRule: P,
                    alternation: B,
                    ambiguityIndices: K,
                    prefixPath: W.path
                });
                return {
                    message: re,
                    type: i.ParserDefinitionErrorType.AMBIGUOUS_ALTS,
                    ruleName: P.name,
                    occurrence: B.idx,
                    alternatives: [W.alts]
                }
            });
            return U
        }
        function R(k, B, P, C) {
            var L = []
              , F = n.reduce(k, function(U, W, K) {
                var re = n.map(W, function(oe) {
                    return {
                        idx: K,
                        path: oe
                    }
                });
                return U.concat(re)
            }, []);
            return n.forEach(F, function(U) {
                var W = B.definition[U.idx];
                if (W.ignoreAmbiguities !== !0) {
                    var K = U.idx
                      , re = U.path
                      , oe = n.findAll(F, function(w) {
                        return B.definition[w.idx].ignoreAmbiguities !== !0 && w.idx < K && o.isStrictPrefixOfPath(w.path, re)
                    })
                      , j = n.map(oe, function(w) {
                        var b = [w.idx + 1, K + 1]
                          , E = B.idx === 0 ? "" : B.idx
                          , T = C.buildAlternationPrefixAmbiguityError({
                            topLevelRule: P,
                            alternation: B,
                            ambiguityIndices: b,
                            prefixPath: w.path
                        });
                        return {
                            message: T,
                            type: i.ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,
                            ruleName: P.name,
                            occurrence: E,
                            alternatives: b
                        }
                    });
                    L = L.concat(j)
                }
            }),
            L
        }
        r.checkPrefixAlternativesAmbiguities = R;
        function q(k, B, P) {
            var C = []
              , L = n.map(B, function(F) {
                return F.name
            });
            return n.forEach(k, function(F) {
                var U = F.name;
                if (n.contains(L, U)) {
                    var W = P.buildNamespaceConflictError(F);
                    C.push({
                        message: W,
                        type: i.ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,
                        ruleName: U
                    })
                }
            }),
            C
        }
    }
    )
      , Ow = _t(r=>{
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.validateGrammar = r.resolveGrammar = void 0;
        var e = Gt()
          , t = Dw()
          , n = fy()
          , i = yf();
        function s(a) {
            a = e.defaults(a, {
                errMsgProvider: i.defaultGrammarResolverErrorProvider
            });
            var l = {};
            return e.forEach(a.rules, function(c) {
                l[c.name] = c
            }),
            t.resolveGrammar(l, a.errMsgProvider)
        }
        r.resolveGrammar = s;
        function o(a) {
            return a = e.defaults(a, {
                errMsgProvider: i.defaultGrammarValidatorErrorProvider
            }),
            n.validateGrammar(a.rules, a.maxLookahead, a.tokenTypes, a.errMsgProvider, a.grammarName)
        }
        r.validateGrammar = o
    }
    )
      , su = _t(r=>{
        "use strict";
        var e = r && r.__extends || function() {
            var g = function(v, p) {
                return g = Object.setPrototypeOf || {
                    __proto__: []
                }instanceof Array && function(d, x) {
                    d.__proto__ = x
                }
                || function(d, x) {
                    for (var y in x)
                        Object.prototype.hasOwnProperty.call(x, y) && (d[y] = x[y])
                }
                ,
                g(v, p)
            };
            return function(v, p) {
                if (typeof p != "function" && p !== null)
                    throw new TypeError("Class extends value " + String(p) + " is not a constructor or null");
                g(v, p);
                function d() {
                    this.constructor = v
                }
                v.prototype = p === null ? Object.create(p) : (d.prototype = p.prototype,
                new d)
            }
        }();
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.EarlyExitException = r.NotAllInputParsedException = r.NoViableAltException = r.MismatchedTokenException = r.isRecognitionException = void 0;
        var t = Gt()
          , n = "MismatchedTokenException"
          , i = "NoViableAltException"
          , s = "EarlyExitException"
          , o = "NotAllInputParsedException"
          , a = [n, i, s, o];
        Object.freeze(a);
        function l(g) {
            return t.contains(a, g.name)
        }
        r.isRecognitionException = l;
        var c = function(g) {
            e(v, g);
            function v(p, d) {
                var x = this.constructor
                  , y = g.call(this, p) || this;
                return y.token = d,
                y.resyncedTokens = [],
                Object.setPrototypeOf(y, x.prototype),
                Error.captureStackTrace && Error.captureStackTrace(y, y.constructor),
                y
            }
            return v
        }(Error)
          , u = function(g) {
            e(v, g);
            function v(p, d, x) {
                var y = g.call(this, p, d) || this;
                return y.previousToken = x,
                y.name = n,
                y
            }
            return v
        }(c);
        r.MismatchedTokenException = u;
        var h = function(g) {
            e(v, g);
            function v(p, d, x) {
                var y = g.call(this, p, d) || this;
                return y.previousToken = x,
                y.name = i,
                y
            }
            return v
        }(c);
        r.NoViableAltException = h;
        var f = function(g) {
            e(v, g);
            function v(p, d) {
                var x = g.call(this, p, d) || this;
                return x.name = o,
                x
            }
            return v
        }(c);
        r.NotAllInputParsedException = f;
        var m = function(g) {
            e(v, g);
            function v(p, d, x) {
                var y = g.call(this, p, d) || this;
                return y.previousToken = x,
                y.name = s,
                y
            }
            return v
        }(c);
        r.EarlyExitException = m
    }
    )
      , dy = _t(r=>{
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.attemptInRepetitionRecovery = r.Recoverable = r.InRuleRecoveryException = r.IN_RULE_RECOVERY_EXCEPTION = r.EOF_FOLLOW_KEY = void 0;
        var e = Ko()
          , t = Gt()
          , n = su()
          , i = hy()
          , s = Ji();
        r.EOF_FOLLOW_KEY = {},
        r.IN_RULE_RECOVERY_EXCEPTION = "InRuleRecoveryException";
        function o(c) {
            this.name = r.IN_RULE_RECOVERY_EXCEPTION,
            this.message = c
        }
        r.InRuleRecoveryException = o,
        o.prototype = Error.prototype;
        var a = function() {
            function c() {}
            return c.prototype.initRecoverable = function(u) {
                this.firstAfterRepMap = {},
                this.resyncFollows = {},
                this.recoveryEnabled = t.has(u, "recoveryEnabled") ? u.recoveryEnabled : s.DEFAULT_PARSER_CONFIG.recoveryEnabled,
                this.recoveryEnabled && (this.attemptInRepetitionRecovery = l)
            }
            ,
            c.prototype.getTokenToInsert = function(u) {
                var h = e.createTokenInstance(u, "", NaN, NaN, NaN, NaN, NaN, NaN);
                return h.isInsertedInRecovery = !0,
                h
            }
            ,
            c.prototype.canTokenTypeBeInsertedInRecovery = function(u) {
                return !0
            }
            ,
            c.prototype.tryInRepetitionRecovery = function(u, h, f, m) {
                for (var g = this, v = this.findReSyncTokenType(), p = this.exportLexerState(), d = [], x = !1, y = this.LA(1), _ = this.LA(1), S = function() {
                    var N = g.LA(0)
                      , I = g.errorMessageProvider.buildMismatchTokenMessage({
                        expected: m,
                        actual: y,
                        previous: N,
                        ruleName: g.getCurrRuleFullName()
                    })
                      , O = new n.MismatchedTokenException(I,y,g.LA(0));
                    O.resyncedTokens = t.dropRight(d),
                    g.SAVE_ERROR(O)
                }; !x; )
                    if (this.tokenMatcher(_, m)) {
                        S();
                        return
                    } else if (f.call(this)) {
                        S(),
                        u.apply(this, h);
                        return
                    } else
                        this.tokenMatcher(_, v) ? x = !0 : (_ = this.SKIP_TOKEN(),
                        this.addToResyncTokens(_, d));
                this.importLexerState(p)
            }
            ,
            c.prototype.shouldInRepetitionRecoveryBeTried = function(u, h, f) {
                return !(f === !1 || u === void 0 || h === void 0 || this.tokenMatcher(this.LA(1), u) || this.isBackTracking() || this.canPerformInRuleRecovery(u, this.getFollowsForInRuleRecovery(u, h)))
            }
            ,
            c.prototype.getFollowsForInRuleRecovery = function(u, h) {
                var f = this.getCurrentGrammarPath(u, h)
                  , m = this.getNextPossibleTokenTypes(f);
                return m
            }
            ,
            c.prototype.tryInRuleRecovery = function(u, h) {
                if (this.canRecoverWithSingleTokenInsertion(u, h)) {
                    var f = this.getTokenToInsert(u);
                    return f
                }
                if (this.canRecoverWithSingleTokenDeletion(u)) {
                    var m = this.SKIP_TOKEN();
                    return this.consumeToken(),
                    m
                }
                throw new o("sad sad panda")
            }
            ,
            c.prototype.canPerformInRuleRecovery = function(u, h) {
                return this.canRecoverWithSingleTokenInsertion(u, h) || this.canRecoverWithSingleTokenDeletion(u)
            }
            ,
            c.prototype.canRecoverWithSingleTokenInsertion = function(u, h) {
                var f = this;
                if (!this.canTokenTypeBeInsertedInRecovery(u) || t.isEmpty(h))
                    return !1;
                var m = this.LA(1)
                  , g = t.find(h, function(v) {
                    return f.tokenMatcher(m, v)
                }) !== void 0;
                return g
            }
            ,
            c.prototype.canRecoverWithSingleTokenDeletion = function(u) {
                var h = this.tokenMatcher(this.LA(2), u);
                return h
            }
            ,
            c.prototype.isInCurrentRuleReSyncSet = function(u) {
                var h = this.getCurrFollowKey()
                  , f = this.getFollowSetFromFollowKey(h);
                return t.contains(f, u)
            }
            ,
            c.prototype.findReSyncTokenType = function() {
                for (var u = this.flattenFollowSet(), h = this.LA(1), f = 2; ; ) {
                    var m = h.tokenType;
                    if (t.contains(u, m))
                        return m;
                    h = this.LA(f),
                    f++
                }
            }
            ,
            c.prototype.getCurrFollowKey = function() {
                if (this.RULE_STACK.length === 1)
                    return r.EOF_FOLLOW_KEY;
                var u = this.getLastExplicitRuleShortName()
                  , h = this.getLastExplicitRuleOccurrenceIndex()
                  , f = this.getPreviousExplicitRuleShortName();
                return {
                    ruleName: this.shortRuleNameToFullName(u),
                    idxInCallingRule: h,
                    inRule: this.shortRuleNameToFullName(f)
                }
            }
            ,
            c.prototype.buildFullFollowKeyStack = function() {
                var u = this
                  , h = this.RULE_STACK
                  , f = this.RULE_OCCURRENCE_STACK;
                return t.map(h, function(m, g) {
                    return g === 0 ? r.EOF_FOLLOW_KEY : {
                        ruleName: u.shortRuleNameToFullName(m),
                        idxInCallingRule: f[g],
                        inRule: u.shortRuleNameToFullName(h[g - 1])
                    }
                })
            }
            ,
            c.prototype.flattenFollowSet = function() {
                var u = this
                  , h = t.map(this.buildFullFollowKeyStack(), function(f) {
                    return u.getFollowSetFromFollowKey(f)
                });
                return t.flatten(h)
            }
            ,
            c.prototype.getFollowSetFromFollowKey = function(u) {
                if (u === r.EOF_FOLLOW_KEY)
                    return [e.EOF];
                var h = u.ruleName + u.idxInCallingRule + i.IN + u.inRule;
                return this.resyncFollows[h]
            }
            ,
            c.prototype.addToResyncTokens = function(u, h) {
                return this.tokenMatcher(u, e.EOF) || h.push(u),
                h
            }
            ,
            c.prototype.reSyncTo = function(u) {
                for (var h = [], f = this.LA(1); this.tokenMatcher(f, u) === !1; )
                    f = this.SKIP_TOKEN(),
                    this.addToResyncTokens(f, h);
                return t.dropRight(h)
            }
            ,
            c.prototype.attemptInRepetitionRecovery = function(u, h, f, m, g, v, p) {}
            ,
            c.prototype.getCurrentGrammarPath = function(u, h) {
                var f = this.getHumanReadableRuleStack()
                  , m = t.cloneArr(this.RULE_OCCURRENCE_STACK)
                  , g = {
                    ruleStack: f,
                    occurrenceStack: m,
                    lastTok: u,
                    lastTokOccurrence: h
                };
                return g
            }
            ,
            c.prototype.getHumanReadableRuleStack = function() {
                var u = this;
                return t.map(this.RULE_STACK, function(h) {
                    return u.shortRuleNameToFullName(h)
                })
            }
            ,
            c
        }();
        r.Recoverable = a;
        function l(c, u, h, f, m, g, v) {
            var p = this.getKeyForAutomaticLookahead(f, m)
              , d = this.firstAfterRepMap[p];
            if (d === void 0) {
                var x = this.getCurrRuleFullName()
                  , y = this.getGAstProductions()[x]
                  , _ = new g(y,m);
                d = _.startWalking(),
                this.firstAfterRepMap[p] = d
            }
            var S = d.token
              , N = d.occurrence
              , I = d.isEndOfRule;
            this.RULE_STACK.length === 1 && I && S === void 0 && (S = e.EOF,
            N = 1),
            this.shouldInRepetitionRecoveryBeTried(S, N, v) && this.tryInRepetitionRecovery(c, u, h, S)
        }
        r.attemptInRepetitionRecovery = l
    }
    )
      , mm = _t(r=>{
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.getKeyForAutomaticLookahead = r.AT_LEAST_ONE_SEP_IDX = r.MANY_SEP_IDX = r.AT_LEAST_ONE_IDX = r.MANY_IDX = r.OPTION_IDX = r.OR_IDX = r.BITS_FOR_ALT_IDX = r.BITS_FOR_RULE_IDX = r.BITS_FOR_OCCURRENCE_IDX = r.BITS_FOR_METHOD_TYPE = void 0,
        r.BITS_FOR_METHOD_TYPE = 4,
        r.BITS_FOR_OCCURRENCE_IDX = 8,
        r.BITS_FOR_RULE_IDX = 12,
        r.BITS_FOR_ALT_IDX = 8,
        r.OR_IDX = 1 << r.BITS_FOR_OCCURRENCE_IDX,
        r.OPTION_IDX = 2 << r.BITS_FOR_OCCURRENCE_IDX,
        r.MANY_IDX = 3 << r.BITS_FOR_OCCURRENCE_IDX,
        r.AT_LEAST_ONE_IDX = 4 << r.BITS_FOR_OCCURRENCE_IDX,
        r.MANY_SEP_IDX = 5 << r.BITS_FOR_OCCURRENCE_IDX,
        r.AT_LEAST_ONE_SEP_IDX = 6 << r.BITS_FOR_OCCURRENCE_IDX;
        function e(n, i, s) {
            return s | i | n
        }
        r.getKeyForAutomaticLookahead = e;
        var t = 32 - r.BITS_FOR_ALT_IDX
    }
    )
      , Fw = _t(r=>{
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.LooksAhead = void 0;
        var e = _f()
          , t = Gt()
          , n = Ji()
          , i = mm()
          , s = vf()
          , o = function() {
            function a() {}
            return a.prototype.initLooksAhead = function(l) {
                this.dynamicTokensEnabled = t.has(l, "dynamicTokensEnabled") ? l.dynamicTokensEnabled : n.DEFAULT_PARSER_CONFIG.dynamicTokensEnabled,
                this.maxLookahead = t.has(l, "maxLookahead") ? l.maxLookahead : n.DEFAULT_PARSER_CONFIG.maxLookahead,
                this.lookAheadFuncsCache = t.isES2015MapSupported() ? new Map : [],
                t.isES2015MapSupported() ? (this.getLaFuncFromCache = this.getLaFuncFromMap,
                this.setLaFuncCache = this.setLaFuncCacheUsingMap) : (this.getLaFuncFromCache = this.getLaFuncFromObj,
                this.setLaFuncCache = this.setLaFuncUsingObj)
            }
            ,
            a.prototype.preComputeLookaheadFunctions = function(l) {
                var c = this;
                t.forEach(l, function(u) {
                    c.TRACE_INIT(u.name + " Rule Lookahead", function() {
                        var h = s.collectMethods(u)
                          , f = h.alternation
                          , m = h.repetition
                          , g = h.option
                          , v = h.repetitionMandatory
                          , p = h.repetitionMandatoryWithSeparator
                          , d = h.repetitionWithSeparator;
                        t.forEach(f, function(x) {
                            var y = x.idx === 0 ? "" : x.idx;
                            c.TRACE_INIT("" + s.getProductionDslName(x) + y, function() {
                                var _ = e.buildLookaheadFuncForOr(x.idx, u, x.maxLookahead || c.maxLookahead, x.hasPredicates, c.dynamicTokensEnabled, c.lookAheadBuilderForAlternatives)
                                  , S = i.getKeyForAutomaticLookahead(c.fullRuleNameToShort[u.name], i.OR_IDX, x.idx);
                                c.setLaFuncCache(S, _)
                            })
                        }),
                        t.forEach(m, function(x) {
                            c.computeLookaheadFunc(u, x.idx, i.MANY_IDX, e.PROD_TYPE.REPETITION, x.maxLookahead, s.getProductionDslName(x))
                        }),
                        t.forEach(g, function(x) {
                            c.computeLookaheadFunc(u, x.idx, i.OPTION_IDX, e.PROD_TYPE.OPTION, x.maxLookahead, s.getProductionDslName(x))
                        }),
                        t.forEach(v, function(x) {
                            c.computeLookaheadFunc(u, x.idx, i.AT_LEAST_ONE_IDX, e.PROD_TYPE.REPETITION_MANDATORY, x.maxLookahead, s.getProductionDslName(x))
                        }),
                        t.forEach(p, function(x) {
                            c.computeLookaheadFunc(u, x.idx, i.AT_LEAST_ONE_SEP_IDX, e.PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, x.maxLookahead, s.getProductionDslName(x))
                        }),
                        t.forEach(d, function(x) {
                            c.computeLookaheadFunc(u, x.idx, i.MANY_SEP_IDX, e.PROD_TYPE.REPETITION_WITH_SEPARATOR, x.maxLookahead, s.getProductionDslName(x))
                        })
                    })
                })
            }
            ,
            a.prototype.computeLookaheadFunc = function(l, c, u, h, f, m) {
                var g = this;
                this.TRACE_INIT("" + m + (c === 0 ? "" : c), function() {
                    var v = e.buildLookaheadFuncForOptionalProd(c, l, f || g.maxLookahead, g.dynamicTokensEnabled, h, g.lookAheadBuilderForOptional)
                      , p = i.getKeyForAutomaticLookahead(g.fullRuleNameToShort[l.name], u, c);
                    g.setLaFuncCache(p, v)
                })
            }
            ,
            a.prototype.lookAheadBuilderForOptional = function(l, c, u) {
                return e.buildSingleAlternativeLookaheadFunction(l, c, u)
            }
            ,
            a.prototype.lookAheadBuilderForAlternatives = function(l, c, u, h) {
                return e.buildAlternativesLookAheadFunc(l, c, u, h)
            }
            ,
            a.prototype.getKeyForAutomaticLookahead = function(l, c) {
                var u = this.getLastExplicitRuleShortName();
                return i.getKeyForAutomaticLookahead(u, l, c)
            }
            ,
            a.prototype.getLaFuncFromCache = function(l) {}
            ,
            a.prototype.getLaFuncFromMap = function(l) {
                return this.lookAheadFuncsCache.get(l)
            }
            ,
            a.prototype.getLaFuncFromObj = function(l) {
                return this.lookAheadFuncsCache[l]
            }
            ,
            a.prototype.setLaFuncCache = function(l, c) {}
            ,
            a.prototype.setLaFuncCacheUsingMap = function(l, c) {
                this.lookAheadFuncsCache.set(l, c)
            }
            ,
            a.prototype.setLaFuncUsingObj = function(l, c) {
                this.lookAheadFuncsCache[l] = c
            }
            ,
            a
        }();
        r.LooksAhead = o
    }
    )
      , kw = _t(r=>{
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.addNoneTerminalToCst = r.addTerminalToCst = r.setNodeLocationFull = r.setNodeLocationOnlyOffset = void 0;
        function e(s, o) {
            isNaN(s.startOffset) === !0 ? (s.startOffset = o.startOffset,
            s.endOffset = o.endOffset) : s.endOffset < o.endOffset && (s.endOffset = o.endOffset)
        }
        r.setNodeLocationOnlyOffset = e;
        function t(s, o) {
            isNaN(s.startOffset) === !0 ? (s.startOffset = o.startOffset,
            s.startColumn = o.startColumn,
            s.startLine = o.startLine,
            s.endOffset = o.endOffset,
            s.endColumn = o.endColumn,
            s.endLine = o.endLine) : s.endOffset < o.endOffset && (s.endOffset = o.endOffset,
            s.endColumn = o.endColumn,
            s.endLine = o.endLine)
        }
        r.setNodeLocationFull = t;
        function n(s, o, a) {
            s.children[a] === void 0 ? s.children[a] = [o] : s.children[a].push(o)
        }
        r.addTerminalToCst = n;
        function i(s, o, a) {
            s.children[o] === void 0 ? s.children[o] = [a] : s.children[o].push(a)
        }
        r.addNoneTerminalToCst = i
    }
    )
      , py = _t(r=>{
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.defineNameProp = r.functionName = r.classNameFromInstance = void 0;
        var e = Gt();
        function t(o) {
            return i(o.constructor)
        }
        r.classNameFromInstance = t;
        var n = "name";
        function i(o) {
            var a = o.name;
            return a || "anonymous"
        }
        r.functionName = i;
        function s(o, a) {
            var l = Object.getOwnPropertyDescriptor(o, n);
            return e.isUndefined(l) || l.configurable ? (Object.defineProperty(o, n, {
                enumerable: !1,
                configurable: !0,
                writable: !1,
                value: a
            }),
            !0) : !1
        }
        r.defineNameProp = s
    }
    )
      , Uw = _t(r=>{
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.validateRedundantMethods = r.validateMissingCstMethods = r.validateVisitor = r.CstVisitorDefinitionError = r.createBaseVisitorConstructorWithDefaults = r.createBaseSemanticVisitorConstructor = r.defaultVisit = void 0;
        var e = Gt()
          , t = py();
        function n(h, f) {
            for (var m = e.keys(h), g = m.length, v = 0; v < g; v++)
                for (var p = m[v], d = h[p], x = d.length, y = 0; y < x; y++) {
                    var _ = d[y];
                    _.tokenTypeIdx === void 0 && this[_.name](_.children, f)
                }
        }
        r.defaultVisit = n;
        function i(h, f) {
            var m = function() {};
            t.defineNameProp(m, h + "BaseSemantics");
            var g = {
                visit: function(v, p) {
                    if (e.isArray(v) && (v = v[0]),
                    !e.isUndefined(v))
                        return this[v.name](v.children, p)
                },
                validateVisitor: function() {
                    var v = a(this, f);
                    if (!e.isEmpty(v)) {
                        var p = e.map(v, function(d) {
                            return d.msg
                        });
                        throw Error("Errors Detected in CST Visitor <" + t.functionName(this.constructor) + `>:
	` + ("" + p.join(`

`).replace(/\n/g, `
	`)))
                    }
                }
            };
            return m.prototype = g,
            m.prototype.constructor = m,
            m._RULE_NAMES = f,
            m
        }
        r.createBaseSemanticVisitorConstructor = i;
        function s(h, f, m) {
            var g = function() {};
            t.defineNameProp(g, h + "BaseSemanticsWithDefaults");
            var v = Object.create(m.prototype);
            return e.forEach(f, function(p) {
                v[p] = n
            }),
            g.prototype = v,
            g.prototype.constructor = g,
            g
        }
        r.createBaseVisitorConstructorWithDefaults = s;
        var o;
        (function(h) {
            h[h.REDUNDANT_METHOD = 0] = "REDUNDANT_METHOD",
            h[h.MISSING_METHOD = 1] = "MISSING_METHOD"
        }
        )(o = r.CstVisitorDefinitionError || (r.CstVisitorDefinitionError = {}));
        function a(h, f) {
            var m = l(h, f)
              , g = u(h, f);
            return m.concat(g)
        }
        r.validateVisitor = a;
        function l(h, f) {
            var m = e.map(f, function(g) {
                if (!e.isFunction(h[g]))
                    return {
                        msg: "Missing visitor method: <" + g + "> on " + t.functionName(h.constructor) + " CST Visitor.",
                        type: o.MISSING_METHOD,
                        methodName: g
                    }
            });
            return e.compact(m)
        }
        r.validateMissingCstMethods = l;
        var c = ["constructor", "visit", "validateVisitor"];
        function u(h, f) {
            var m = [];
            for (var g in h)
                e.isFunction(h[g]) && !e.contains(c, g) && !e.contains(f, g) && m.push({
                    msg: "Redundant visitor method: <" + g + "> on " + t.functionName(h.constructor) + ` CST Visitor
There is no Grammar Rule corresponding to this method's name.
`,
                    type: o.REDUNDANT_METHOD,
                    methodName: g
                });
            return m
        }
        r.validateRedundantMethods = u
    }
    )
      , Bw = _t(r=>{
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.TreeBuilder = void 0;
        var e = kw()
          , t = Gt()
          , n = Uw()
          , i = Ji()
          , s = function() {
            function o() {}
            return o.prototype.initTreeBuilder = function(a) {
                if (this.CST_STACK = [],
                this.outputCst = a.outputCst,
                this.nodeLocationTracking = t.has(a, "nodeLocationTracking") ? a.nodeLocationTracking : i.DEFAULT_PARSER_CONFIG.nodeLocationTracking,
                !this.outputCst)
                    this.cstInvocationStateUpdate = t.NOOP,
                    this.cstFinallyStateUpdate = t.NOOP,
                    this.cstPostTerminal = t.NOOP,
                    this.cstPostNonTerminal = t.NOOP,
                    this.cstPostRule = t.NOOP;
                else if (/full/i.test(this.nodeLocationTracking))
                    this.recoveryEnabled ? (this.setNodeLocationFromToken = e.setNodeLocationFull,
                    this.setNodeLocationFromNode = e.setNodeLocationFull,
                    this.cstPostRule = t.NOOP,
                    this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery) : (this.setNodeLocationFromToken = t.NOOP,
                    this.setNodeLocationFromNode = t.NOOP,
                    this.cstPostRule = this.cstPostRuleFull,
                    this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular);
                else if (/onlyOffset/i.test(this.nodeLocationTracking))
                    this.recoveryEnabled ? (this.setNodeLocationFromToken = e.setNodeLocationOnlyOffset,
                    this.setNodeLocationFromNode = e.setNodeLocationOnlyOffset,
                    this.cstPostRule = t.NOOP,
                    this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRecovery) : (this.setNodeLocationFromToken = t.NOOP,
                    this.setNodeLocationFromNode = t.NOOP,
                    this.cstPostRule = this.cstPostRuleOnlyOffset,
                    this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRegular);
                else if (/none/i.test(this.nodeLocationTracking))
                    this.setNodeLocationFromToken = t.NOOP,
                    this.setNodeLocationFromNode = t.NOOP,
                    this.cstPostRule = t.NOOP,
                    this.setInitialNodeLocation = t.NOOP;
                else
                    throw Error('Invalid <nodeLocationTracking> config option: "' + a.nodeLocationTracking + '"')
            }
            ,
            o.prototype.setInitialNodeLocationOnlyOffsetRecovery = function(a) {
                a.location = {
                    startOffset: NaN,
                    endOffset: NaN
                }
            }
            ,
            o.prototype.setInitialNodeLocationOnlyOffsetRegular = function(a) {
                a.location = {
                    startOffset: this.LA(1).startOffset,
                    endOffset: NaN
                }
            }
            ,
            o.prototype.setInitialNodeLocationFullRecovery = function(a) {
                a.location = {
                    startOffset: NaN,
                    startLine: NaN,
                    startColumn: NaN,
                    endOffset: NaN,
                    endLine: NaN,
                    endColumn: NaN
                }
            }
            ,
            o.prototype.setInitialNodeLocationFullRegular = function(a) {
                var l = this.LA(1);
                a.location = {
                    startOffset: l.startOffset,
                    startLine: l.startLine,
                    startColumn: l.startColumn,
                    endOffset: NaN,
                    endLine: NaN,
                    endColumn: NaN
                }
            }
            ,
            o.prototype.cstInvocationStateUpdate = function(a, l) {
                var c = {
                    name: a,
                    children: {}
                };
                this.setInitialNodeLocation(c),
                this.CST_STACK.push(c)
            }
            ,
            o.prototype.cstFinallyStateUpdate = function() {
                this.CST_STACK.pop()
            }
            ,
            o.prototype.cstPostRuleFull = function(a) {
                var l = this.LA(0)
                  , c = a.location;
                c.startOffset <= l.startOffset ? (c.endOffset = l.endOffset,
                c.endLine = l.endLine,
                c.endColumn = l.endColumn) : (c.startOffset = NaN,
                c.startLine = NaN,
                c.startColumn = NaN)
            }
            ,
            o.prototype.cstPostRuleOnlyOffset = function(a) {
                var l = this.LA(0)
                  , c = a.location;
                c.startOffset <= l.startOffset ? c.endOffset = l.endOffset : c.startOffset = NaN
            }
            ,
            o.prototype.cstPostTerminal = function(a, l) {
                var c = this.CST_STACK[this.CST_STACK.length - 1];
                e.addTerminalToCst(c, l, a),
                this.setNodeLocationFromToken(c.location, l)
            }
            ,
            o.prototype.cstPostNonTerminal = function(a, l) {
                var c = this.CST_STACK[this.CST_STACK.length - 1];
                e.addNoneTerminalToCst(c, l, a),
                this.setNodeLocationFromNode(c.location, a.location)
            }
            ,
            o.prototype.getBaseCstVisitorConstructor = function() {
                if (t.isUndefined(this.baseCstVisitorConstructor)) {
                    var a = n.createBaseSemanticVisitorConstructor(this.className, t.keys(this.gastProductionsCache));
                    return this.baseCstVisitorConstructor = a,
                    a
                }
                return this.baseCstVisitorConstructor
            }
            ,
            o.prototype.getBaseCstVisitorConstructorWithDefaults = function() {
                if (t.isUndefined(this.baseCstVisitorWithDefaultsConstructor)) {
                    var a = n.createBaseVisitorConstructorWithDefaults(this.className, t.keys(this.gastProductionsCache), this.getBaseCstVisitorConstructor());
                    return this.baseCstVisitorWithDefaultsConstructor = a,
                    a
                }
                return this.baseCstVisitorWithDefaultsConstructor
            }
            ,
            o.prototype.getLastExplicitRuleShortName = function() {
                var a = this.RULE_STACK;
                return a[a.length - 1]
            }
            ,
            o.prototype.getPreviousExplicitRuleShortName = function() {
                var a = this.RULE_STACK;
                return a[a.length - 2]
            }
            ,
            o.prototype.getLastExplicitRuleOccurrenceIndex = function() {
                var a = this.RULE_OCCURRENCE_STACK;
                return a[a.length - 1]
            }
            ,
            o
        }();
        r.TreeBuilder = s
    }
    )
      , Gw = _t(r=>{
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.LexerAdapter = void 0;
        var e = Ji()
          , t = function() {
            function n() {}
            return n.prototype.initLexerAdapter = function() {
                this.tokVector = [],
                this.tokVectorLength = 0,
                this.currIdx = -1
            }
            ,
            Object.defineProperty(n.prototype, "input", {
                get: function() {
                    return this.tokVector
                },
                set: function(i) {
                    if (this.selfAnalysisDone !== !0)
                        throw Error("Missing <performSelfAnalysis> invocation at the end of the Parser's constructor.");
                    this.reset(),
                    this.tokVector = i,
                    this.tokVectorLength = i.length
                },
                enumerable: !1,
                configurable: !0
            }),
            n.prototype.SKIP_TOKEN = function() {
                return this.currIdx <= this.tokVector.length - 2 ? (this.consumeToken(),
                this.LA(1)) : e.END_OF_FILE
            }
            ,
            n.prototype.LA = function(i) {
                var s = this.currIdx + i;
                return s < 0 || this.tokVectorLength <= s ? e.END_OF_FILE : this.tokVector[s]
            }
            ,
            n.prototype.consumeToken = function() {
                this.currIdx++
            }
            ,
            n.prototype.exportLexerState = function() {
                return this.currIdx
            }
            ,
            n.prototype.importLexerState = function(i) {
                this.currIdx = i
            }
            ,
            n.prototype.resetLexerState = function() {
                this.currIdx = -1
            }
            ,
            n.prototype.moveToTerminatedState = function() {
                this.currIdx = this.tokVector.length - 1
            }
            ,
            n.prototype.getLexerPosition = function() {
                return this.exportLexerState()
            }
            ,
            n
        }();
        r.LexerAdapter = t
    }
    )
      , Vw = _t(r=>{
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.RecognizerApi = void 0;
        var e = Gt()
          , t = su()
          , n = Ji()
          , i = yf()
          , s = fy()
          , o = Ui()
          , a = function() {
            function l() {}
            return l.prototype.ACTION = function(c) {
                return c.call(this)
            }
            ,
            l.prototype.consume = function(c, u, h) {
                return this.consumeInternal(u, c, h)
            }
            ,
            l.prototype.subrule = function(c, u, h) {
                return this.subruleInternal(u, c, h)
            }
            ,
            l.prototype.option = function(c, u) {
                return this.optionInternal(u, c)
            }
            ,
            l.prototype.or = function(c, u) {
                return this.orInternal(u, c)
            }
            ,
            l.prototype.many = function(c, u) {
                return this.manyInternal(c, u)
            }
            ,
            l.prototype.atLeastOne = function(c, u) {
                return this.atLeastOneInternal(c, u)
            }
            ,
            l.prototype.CONSUME = function(c, u) {
                return this.consumeInternal(c, 0, u)
            }
            ,
            l.prototype.CONSUME1 = function(c, u) {
                return this.consumeInternal(c, 1, u)
            }
            ,
            l.prototype.CONSUME2 = function(c, u) {
                return this.consumeInternal(c, 2, u)
            }
            ,
            l.prototype.CONSUME3 = function(c, u) {
                return this.consumeInternal(c, 3, u)
            }
            ,
            l.prototype.CONSUME4 = function(c, u) {
                return this.consumeInternal(c, 4, u)
            }
            ,
            l.prototype.CONSUME5 = function(c, u) {
                return this.consumeInternal(c, 5, u)
            }
            ,
            l.prototype.CONSUME6 = function(c, u) {
                return this.consumeInternal(c, 6, u)
            }
            ,
            l.prototype.CONSUME7 = function(c, u) {
                return this.consumeInternal(c, 7, u)
            }
            ,
            l.prototype.CONSUME8 = function(c, u) {
                return this.consumeInternal(c, 8, u)
            }
            ,
            l.prototype.CONSUME9 = function(c, u) {
                return this.consumeInternal(c, 9, u)
            }
            ,
            l.prototype.SUBRULE = function(c, u) {
                return this.subruleInternal(c, 0, u)
            }
            ,
            l.prototype.SUBRULE1 = function(c, u) {
                return this.subruleInternal(c, 1, u)
            }
            ,
            l.prototype.SUBRULE2 = function(c, u) {
                return this.subruleInternal(c, 2, u)
            }
            ,
            l.prototype.SUBRULE3 = function(c, u) {
                return this.subruleInternal(c, 3, u)
            }
            ,
            l.prototype.SUBRULE4 = function(c, u) {
                return this.subruleInternal(c, 4, u)
            }
            ,
            l.prototype.SUBRULE5 = function(c, u) {
                return this.subruleInternal(c, 5, u)
            }
            ,
            l.prototype.SUBRULE6 = function(c, u) {
                return this.subruleInternal(c, 6, u)
            }
            ,
            l.prototype.SUBRULE7 = function(c, u) {
                return this.subruleInternal(c, 7, u)
            }
            ,
            l.prototype.SUBRULE8 = function(c, u) {
                return this.subruleInternal(c, 8, u)
            }
            ,
            l.prototype.SUBRULE9 = function(c, u) {
                return this.subruleInternal(c, 9, u)
            }
            ,
            l.prototype.OPTION = function(c) {
                return this.optionInternal(c, 0)
            }
            ,
            l.prototype.OPTION1 = function(c) {
                return this.optionInternal(c, 1)
            }
            ,
            l.prototype.OPTION2 = function(c) {
                return this.optionInternal(c, 2)
            }
            ,
            l.prototype.OPTION3 = function(c) {
                return this.optionInternal(c, 3)
            }
            ,
            l.prototype.OPTION4 = function(c) {
                return this.optionInternal(c, 4)
            }
            ,
            l.prototype.OPTION5 = function(c) {
                return this.optionInternal(c, 5)
            }
            ,
            l.prototype.OPTION6 = function(c) {
                return this.optionInternal(c, 6)
            }
            ,
            l.prototype.OPTION7 = function(c) {
                return this.optionInternal(c, 7)
            }
            ,
            l.prototype.OPTION8 = function(c) {
                return this.optionInternal(c, 8)
            }
            ,
            l.prototype.OPTION9 = function(c) {
                return this.optionInternal(c, 9)
            }
            ,
            l.prototype.OR = function(c) {
                return this.orInternal(c, 0)
            }
            ,
            l.prototype.OR1 = function(c) {
                return this.orInternal(c, 1)
            }
            ,
            l.prototype.OR2 = function(c) {
                return this.orInternal(c, 2)
            }
            ,
            l.prototype.OR3 = function(c) {
                return this.orInternal(c, 3)
            }
            ,
            l.prototype.OR4 = function(c) {
                return this.orInternal(c, 4)
            }
            ,
            l.prototype.OR5 = function(c) {
                return this.orInternal(c, 5)
            }
            ,
            l.prototype.OR6 = function(c) {
                return this.orInternal(c, 6)
            }
            ,
            l.prototype.OR7 = function(c) {
                return this.orInternal(c, 7)
            }
            ,
            l.prototype.OR8 = function(c) {
                return this.orInternal(c, 8)
            }
            ,
            l.prototype.OR9 = function(c) {
                return this.orInternal(c, 9)
            }
            ,
            l.prototype.MANY = function(c) {
                this.manyInternal(0, c)
            }
            ,
            l.prototype.MANY1 = function(c) {
                this.manyInternal(1, c)
            }
            ,
            l.prototype.MANY2 = function(c) {
                this.manyInternal(2, c)
            }
            ,
            l.prototype.MANY3 = function(c) {
                this.manyInternal(3, c)
            }
            ,
            l.prototype.MANY4 = function(c) {
                this.manyInternal(4, c)
            }
            ,
            l.prototype.MANY5 = function(c) {
                this.manyInternal(5, c)
            }
            ,
            l.prototype.MANY6 = function(c) {
                this.manyInternal(6, c)
            }
            ,
            l.prototype.MANY7 = function(c) {
                this.manyInternal(7, c)
            }
            ,
            l.prototype.MANY8 = function(c) {
                this.manyInternal(8, c)
            }
            ,
            l.prototype.MANY9 = function(c) {
                this.manyInternal(9, c)
            }
            ,
            l.prototype.MANY_SEP = function(c) {
                this.manySepFirstInternal(0, c)
            }
            ,
            l.prototype.MANY_SEP1 = function(c) {
                this.manySepFirstInternal(1, c)
            }
            ,
            l.prototype.MANY_SEP2 = function(c) {
                this.manySepFirstInternal(2, c)
            }
            ,
            l.prototype.MANY_SEP3 = function(c) {
                this.manySepFirstInternal(3, c)
            }
            ,
            l.prototype.MANY_SEP4 = function(c) {
                this.manySepFirstInternal(4, c)
            }
            ,
            l.prototype.MANY_SEP5 = function(c) {
                this.manySepFirstInternal(5, c)
            }
            ,
            l.prototype.MANY_SEP6 = function(c) {
                this.manySepFirstInternal(6, c)
            }
            ,
            l.prototype.MANY_SEP7 = function(c) {
                this.manySepFirstInternal(7, c)
            }
            ,
            l.prototype.MANY_SEP8 = function(c) {
                this.manySepFirstInternal(8, c)
            }
            ,
            l.prototype.MANY_SEP9 = function(c) {
                this.manySepFirstInternal(9, c)
            }
            ,
            l.prototype.AT_LEAST_ONE = function(c) {
                this.atLeastOneInternal(0, c)
            }
            ,
            l.prototype.AT_LEAST_ONE1 = function(c) {
                return this.atLeastOneInternal(1, c)
            }
            ,
            l.prototype.AT_LEAST_ONE2 = function(c) {
                this.atLeastOneInternal(2, c)
            }
            ,
            l.prototype.AT_LEAST_ONE3 = function(c) {
                this.atLeastOneInternal(3, c)
            }
            ,
            l.prototype.AT_LEAST_ONE4 = function(c) {
                this.atLeastOneInternal(4, c)
            }
            ,
            l.prototype.AT_LEAST_ONE5 = function(c) {
                this.atLeastOneInternal(5, c)
            }
            ,
            l.prototype.AT_LEAST_ONE6 = function(c) {
                this.atLeastOneInternal(6, c)
            }
            ,
            l.prototype.AT_LEAST_ONE7 = function(c) {
                this.atLeastOneInternal(7, c)
            }
            ,
            l.prototype.AT_LEAST_ONE8 = function(c) {
                this.atLeastOneInternal(8, c)
            }
            ,
            l.prototype.AT_LEAST_ONE9 = function(c) {
                this.atLeastOneInternal(9, c)
            }
            ,
            l.prototype.AT_LEAST_ONE_SEP = function(c) {
                this.atLeastOneSepFirstInternal(0, c)
            }
            ,
            l.prototype.AT_LEAST_ONE_SEP1 = function(c) {
                this.atLeastOneSepFirstInternal(1, c)
            }
            ,
            l.prototype.AT_LEAST_ONE_SEP2 = function(c) {
                this.atLeastOneSepFirstInternal(2, c)
            }
            ,
            l.prototype.AT_LEAST_ONE_SEP3 = function(c) {
                this.atLeastOneSepFirstInternal(3, c)
            }
            ,
            l.prototype.AT_LEAST_ONE_SEP4 = function(c) {
                this.atLeastOneSepFirstInternal(4, c)
            }
            ,
            l.prototype.AT_LEAST_ONE_SEP5 = function(c) {
                this.atLeastOneSepFirstInternal(5, c)
            }
            ,
            l.prototype.AT_LEAST_ONE_SEP6 = function(c) {
                this.atLeastOneSepFirstInternal(6, c)
            }
            ,
            l.prototype.AT_LEAST_ONE_SEP7 = function(c) {
                this.atLeastOneSepFirstInternal(7, c)
            }
            ,
            l.prototype.AT_LEAST_ONE_SEP8 = function(c) {
                this.atLeastOneSepFirstInternal(8, c)
            }
            ,
            l.prototype.AT_LEAST_ONE_SEP9 = function(c) {
                this.atLeastOneSepFirstInternal(9, c)
            }
            ,
            l.prototype.RULE = function(c, u, h) {
                if (h === void 0 && (h = n.DEFAULT_RULE_CONFIG),
                e.contains(this.definedRulesNames, c)) {
                    var f = i.defaultGrammarValidatorErrorProvider.buildDuplicateRuleNameError({
                        topLevelRule: c,
                        grammarName: this.className
                    })
                      , m = {
                        message: f,
                        type: n.ParserDefinitionErrorType.DUPLICATE_RULE_NAME,
                        ruleName: c
                    };
                    this.definitionErrors.push(m)
                }
                this.definedRulesNames.push(c);
                var g = this.defineRule(c, u, h);
                return this[c] = g,
                g
            }
            ,
            l.prototype.OVERRIDE_RULE = function(c, u, h) {
                h === void 0 && (h = n.DEFAULT_RULE_CONFIG);
                var f = [];
                f = f.concat(s.validateRuleIsOverridden(c, this.definedRulesNames, this.className)),
                this.definitionErrors = this.definitionErrors.concat(f);
                var m = this.defineRule(c, u, h);
                return this[c] = m,
                m
            }
            ,
            l.prototype.BACKTRACK = function(c, u) {
                return function() {
                    this.isBackTrackingStack.push(1);
                    var h = this.saveRecogState();
                    try {
                        return c.apply(this, u),
                        !0
                    } catch (f) {
                        if (t.isRecognitionException(f))
                            return !1;
                        throw f
                    } finally {
                        this.reloadRecogState(h),
                        this.isBackTrackingStack.pop()
                    }
                }
            }
            ,
            l.prototype.getGAstProductions = function() {
                return this.gastProductionsCache
            }
            ,
            l.prototype.getSerializedGastProductions = function() {
                return o.serializeGrammar(e.values(this.gastProductionsCache))
            }
            ,
            l
        }();
        r.RecognizerApi = a
    }
    )
      , zw = _t(r=>{
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.RecognizerEngine = void 0;
        var e = Gt()
          , t = mm()
          , n = su()
          , i = _f()
          , s = xf()
          , o = Ji()
          , a = dy()
          , l = Ko()
          , c = iu()
          , u = py()
          , h = function() {
            function f() {}
            return f.prototype.initRecognizerEngine = function(m, g) {
                if (this.className = u.classNameFromInstance(this),
                this.shortRuleNameToFull = {},
                this.fullRuleNameToShort = {},
                this.ruleShortNameIdx = 256,
                this.tokenMatcher = c.tokenStructuredMatcherNoCategories,
                this.definedRulesNames = [],
                this.tokensMap = {},
                this.isBackTrackingStack = [],
                this.RULE_STACK = [],
                this.RULE_OCCURRENCE_STACK = [],
                this.gastProductionsCache = {},
                e.has(g, "serializedGrammar"))
                    throw Error(`The Parser's configuration can no longer contain a <serializedGrammar> property.
	See: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_6-0-0
	For Further details.`);
                if (e.isArray(m)) {
                    if (e.isEmpty(m))
                        throw Error(`A Token Vocabulary cannot be empty.
	Note that the first argument for the parser constructor
	is no longer a Token vector (since v4.0).`);
                    if (typeof m[0].startOffset == "number")
                        throw Error(`The Parser constructor no longer accepts a token vector as the first argument.
	See: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_4-0-0
	For Further details.`)
                }
                if (e.isArray(m))
                    this.tokensMap = e.reduce(m, function(x, y) {
                        return x[y.name] = y,
                        x
                    }, {});
                else if (e.has(m, "modes") && e.every(e.flatten(e.values(m.modes)), c.isTokenType)) {
                    var v = e.flatten(e.values(m.modes))
                      , p = e.uniq(v);
                    this.tokensMap = e.reduce(p, function(x, y) {
                        return x[y.name] = y,
                        x
                    }, {})
                } else if (e.isObject(m))
                    this.tokensMap = e.cloneObj(m);
                else
                    throw new Error("<tokensDictionary> argument must be An Array of Token constructors, A dictionary of Token constructors or an IMultiModeLexerDefinition");
                this.tokensMap.EOF = l.EOF;
                var d = e.every(e.values(m), function(x) {
                    return e.isEmpty(x.categoryMatches)
                });
                this.tokenMatcher = d ? c.tokenStructuredMatcherNoCategories : c.tokenStructuredMatcher,
                c.augmentTokenTypes(e.values(this.tokensMap))
            }
            ,
            f.prototype.defineRule = function(m, g, v) {
                if (this.selfAnalysisDone)
                    throw Error("Grammar rule <" + m + `> may not be defined after the 'performSelfAnalysis' method has been called'
Make sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.`);
                var p = e.has(v, "resyncEnabled") ? v.resyncEnabled : o.DEFAULT_RULE_CONFIG.resyncEnabled
                  , d = e.has(v, "recoveryValueFunc") ? v.recoveryValueFunc : o.DEFAULT_RULE_CONFIG.recoveryValueFunc
                  , x = this.ruleShortNameIdx << t.BITS_FOR_METHOD_TYPE + t.BITS_FOR_OCCURRENCE_IDX;
                this.ruleShortNameIdx++,
                this.shortRuleNameToFull[x] = m,
                this.fullRuleNameToShort[m] = x;
                function y(N) {
                    try {
                        if (this.outputCst === !0) {
                            g.apply(this, N);
                            var I = this.CST_STACK[this.CST_STACK.length - 1];
                            return this.cstPostRule(I),
                            I
                        } else
                            return g.apply(this, N)
                    } catch (O) {
                        return this.invokeRuleCatch(O, p, d)
                    } finally {
                        this.ruleFinallyStateUpdate()
                    }
                }
                var _ = function(N, I) {
                    return N === void 0 && (N = 0),
                    this.ruleInvocationStateUpdate(x, m, N),
                    y.call(this, I)
                }
                  , S = "ruleName";
                return _[S] = m,
                _.originalGrammarAction = g,
                _
            }
            ,
            f.prototype.invokeRuleCatch = function(m, g, v) {
                var p = this.RULE_STACK.length === 1
                  , d = g && !this.isBackTracking() && this.recoveryEnabled;
                if (n.isRecognitionException(m)) {
                    var x = m;
                    if (d) {
                        var y = this.findReSyncTokenType();
                        if (this.isInCurrentRuleReSyncSet(y))
                            if (x.resyncedTokens = this.reSyncTo(y),
                            this.outputCst) {
                                var _ = this.CST_STACK[this.CST_STACK.length - 1];
                                return _.recoveredNode = !0,
                                _
                            } else
                                return v();
                        else {
                            if (this.outputCst) {
                                var _ = this.CST_STACK[this.CST_STACK.length - 1];
                                _.recoveredNode = !0,
                                x.partialCstResult = _
                            }
                            throw x
                        }
                    } else {
                        if (p)
                            return this.moveToTerminatedState(),
                            v();
                        throw x
                    }
                } else
                    throw m
            }
            ,
            f.prototype.optionInternal = function(m, g) {
                var v = this.getKeyForAutomaticLookahead(t.OPTION_IDX, g);
                return this.optionInternalLogic(m, g, v)
            }
            ,
            f.prototype.optionInternalLogic = function(m, g, v) {
                var p = this, d = this.getLaFuncFromCache(v), x, y;
                if (m.DEF !== void 0) {
                    if (x = m.DEF,
                    y = m.GATE,
                    y !== void 0) {
                        var _ = d;
                        d = function() {
                            return y.call(p) && _.call(p)
                        }
                    }
                } else
                    x = m;
                if (d.call(this) === !0)
                    return x.call(this)
            }
            ,
            f.prototype.atLeastOneInternal = function(m, g) {
                var v = this.getKeyForAutomaticLookahead(t.AT_LEAST_ONE_IDX, m);
                return this.atLeastOneInternalLogic(m, g, v)
            }
            ,
            f.prototype.atLeastOneInternalLogic = function(m, g, v) {
                var p = this, d = this.getLaFuncFromCache(v), x, y;
                if (g.DEF !== void 0) {
                    if (x = g.DEF,
                    y = g.GATE,
                    y !== void 0) {
                        var _ = d;
                        d = function() {
                            return y.call(p) && _.call(p)
                        }
                    }
                } else
                    x = g;
                if (d.call(this) === !0)
                    for (var S = this.doSingleRepetition(x); d.call(this) === !0 && S === !0; )
                        S = this.doSingleRepetition(x);
                else
                    throw this.raiseEarlyExitException(m, i.PROD_TYPE.REPETITION_MANDATORY, g.ERR_MSG);
                this.attemptInRepetitionRecovery(this.atLeastOneInternal, [m, g], d, t.AT_LEAST_ONE_IDX, m, s.NextTerminalAfterAtLeastOneWalker)
            }
            ,
            f.prototype.atLeastOneSepFirstInternal = function(m, g) {
                var v = this.getKeyForAutomaticLookahead(t.AT_LEAST_ONE_SEP_IDX, m);
                this.atLeastOneSepFirstInternalLogic(m, g, v)
            }
            ,
            f.prototype.atLeastOneSepFirstInternalLogic = function(m, g, v) {
                var p = this
                  , d = g.DEF
                  , x = g.SEP
                  , y = this.getLaFuncFromCache(v);
                if (y.call(this) === !0) {
                    d.call(this);
                    for (var _ = function() {
                        return p.tokenMatcher(p.LA(1), x)
                    }; this.tokenMatcher(this.LA(1), x) === !0; )
                        this.CONSUME(x),
                        d.call(this);
                    this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [m, x, _, d, s.NextTerminalAfterAtLeastOneSepWalker], _, t.AT_LEAST_ONE_SEP_IDX, m, s.NextTerminalAfterAtLeastOneSepWalker)
                } else
                    throw this.raiseEarlyExitException(m, i.PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, g.ERR_MSG)
            }
            ,
            f.prototype.manyInternal = function(m, g) {
                var v = this.getKeyForAutomaticLookahead(t.MANY_IDX, m);
                return this.manyInternalLogic(m, g, v)
            }
            ,
            f.prototype.manyInternalLogic = function(m, g, v) {
                var p = this, d = this.getLaFuncFromCache(v), x, y;
                if (g.DEF !== void 0) {
                    if (x = g.DEF,
                    y = g.GATE,
                    y !== void 0) {
                        var _ = d;
                        d = function() {
                            return y.call(p) && _.call(p)
                        }
                    }
                } else
                    x = g;
                for (var S = !0; d.call(this) === !0 && S === !0; )
                    S = this.doSingleRepetition(x);
                this.attemptInRepetitionRecovery(this.manyInternal, [m, g], d, t.MANY_IDX, m, s.NextTerminalAfterManyWalker, S)
            }
            ,
            f.prototype.manySepFirstInternal = function(m, g) {
                var v = this.getKeyForAutomaticLookahead(t.MANY_SEP_IDX, m);
                this.manySepFirstInternalLogic(m, g, v)
            }
            ,
            f.prototype.manySepFirstInternalLogic = function(m, g, v) {
                var p = this
                  , d = g.DEF
                  , x = g.SEP
                  , y = this.getLaFuncFromCache(v);
                if (y.call(this) === !0) {
                    d.call(this);
                    for (var _ = function() {
                        return p.tokenMatcher(p.LA(1), x)
                    }; this.tokenMatcher(this.LA(1), x) === !0; )
                        this.CONSUME(x),
                        d.call(this);
                    this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [m, x, _, d, s.NextTerminalAfterManySepWalker], _, t.MANY_SEP_IDX, m, s.NextTerminalAfterManySepWalker)
                }
            }
            ,
            f.prototype.repetitionSepSecondInternal = function(m, g, v, p, d) {
                for (; v(); )
                    this.CONSUME(g),
                    p.call(this);
                this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [m, g, v, p, d], v, t.AT_LEAST_ONE_SEP_IDX, m, d)
            }
            ,
            f.prototype.doSingleRepetition = function(m) {
                var g = this.getLexerPosition();
                m.call(this);
                var v = this.getLexerPosition();
                return v > g
            }
            ,
            f.prototype.orInternal = function(m, g) {
                var v = this.getKeyForAutomaticLookahead(t.OR_IDX, g)
                  , p = e.isArray(m) ? m : m.DEF
                  , d = this.getLaFuncFromCache(v)
                  , x = d.call(this, p);
                if (x !== void 0) {
                    var y = p[x];
                    return y.ALT.call(this)
                }
                this.raiseNoAltException(g, m.ERR_MSG)
            }
            ,
            f.prototype.ruleFinallyStateUpdate = function() {
                if (this.RULE_STACK.pop(),
                this.RULE_OCCURRENCE_STACK.pop(),
                this.cstFinallyStateUpdate(),
                this.RULE_STACK.length === 0 && this.isAtEndOfInput() === !1) {
                    var m = this.LA(1)
                      , g = this.errorMessageProvider.buildNotAllInputParsedMessage({
                        firstRedundant: m,
                        ruleName: this.getCurrRuleFullName()
                    });
                    this.SAVE_ERROR(new n.NotAllInputParsedException(g,m))
                }
            }
            ,
            f.prototype.subruleInternal = function(m, g, v) {
                var p;
                try {
                    var d = v !== void 0 ? v.ARGS : void 0;
                    return p = m.call(this, g, d),
                    this.cstPostNonTerminal(p, v !== void 0 && v.LABEL !== void 0 ? v.LABEL : m.ruleName),
                    p
                } catch (x) {
                    this.subruleInternalError(x, v, m.ruleName)
                }
            }
            ,
            f.prototype.subruleInternalError = function(m, g, v) {
                throw n.isRecognitionException(m) && m.partialCstResult !== void 0 && (this.cstPostNonTerminal(m.partialCstResult, g !== void 0 && g.LABEL !== void 0 ? g.LABEL : v),
                delete m.partialCstResult),
                m
            }
            ,
            f.prototype.consumeInternal = function(m, g, v) {
                var p;
                try {
                    var d = this.LA(1);
                    this.tokenMatcher(d, m) === !0 ? (this.consumeToken(),
                    p = d) : this.consumeInternalError(m, d, v)
                } catch (x) {
                    p = this.consumeInternalRecovery(m, g, x)
                }
                return this.cstPostTerminal(v !== void 0 && v.LABEL !== void 0 ? v.LABEL : m.name, p),
                p
            }
            ,
            f.prototype.consumeInternalError = function(m, g, v) {
                var p, d = this.LA(0);
                throw v !== void 0 && v.ERR_MSG ? p = v.ERR_MSG : p = this.errorMessageProvider.buildMismatchTokenMessage({
                    expected: m,
                    actual: g,
                    previous: d,
                    ruleName: this.getCurrRuleFullName()
                }),
                this.SAVE_ERROR(new n.MismatchedTokenException(p,g,d))
            }
            ,
            f.prototype.consumeInternalRecovery = function(m, g, v) {
                if (this.recoveryEnabled && v.name === "MismatchedTokenException" && !this.isBackTracking()) {
                    var p = this.getFollowsForInRuleRecovery(m, g);
                    try {
                        return this.tryInRuleRecovery(m, p)
                    } catch (d) {
                        throw d.name === a.IN_RULE_RECOVERY_EXCEPTION ? v : d
                    }
                } else
                    throw v
            }
            ,
            f.prototype.saveRecogState = function() {
                var m = this.errors
                  , g = e.cloneArr(this.RULE_STACK);
                return {
                    errors: m,
                    lexerState: this.exportLexerState(),
                    RULE_STACK: g,
                    CST_STACK: this.CST_STACK
                }
            }
            ,
            f.prototype.reloadRecogState = function(m) {
                this.errors = m.errors,
                this.importLexerState(m.lexerState),
                this.RULE_STACK = m.RULE_STACK
            }
            ,
            f.prototype.ruleInvocationStateUpdate = function(m, g, v) {
                this.RULE_OCCURRENCE_STACK.push(v),
                this.RULE_STACK.push(m),
                this.cstInvocationStateUpdate(g, m)
            }
            ,
            f.prototype.isBackTracking = function() {
                return this.isBackTrackingStack.length !== 0
            }
            ,
            f.prototype.getCurrRuleFullName = function() {
                var m = this.getLastExplicitRuleShortName();
                return this.shortRuleNameToFull[m]
            }
            ,
            f.prototype.shortRuleNameToFullName = function(m) {
                return this.shortRuleNameToFull[m]
            }
            ,
            f.prototype.isAtEndOfInput = function() {
                return this.tokenMatcher(this.LA(1), l.EOF)
            }
            ,
            f.prototype.reset = function() {
                this.resetLexerState(),
                this.isBackTrackingStack = [],
                this.errors = [],
                this.RULE_STACK = [],
                this.CST_STACK = [],
                this.RULE_OCCURRENCE_STACK = []
            }
            ,
            f
        }();
        r.RecognizerEngine = h
    }
    )
      , Hw = _t(r=>{
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.ErrorHandler = void 0;
        var e = su()
          , t = Gt()
          , n = _f()
          , i = Ji()
          , s = function() {
            function o() {}
            return o.prototype.initErrorHandler = function(a) {
                this._errors = [],
                this.errorMessageProvider = t.has(a, "errorMessageProvider") ? a.errorMessageProvider : i.DEFAULT_PARSER_CONFIG.errorMessageProvider
            }
            ,
            o.prototype.SAVE_ERROR = function(a) {
                if (e.isRecognitionException(a))
                    return a.context = {
                        ruleStack: this.getHumanReadableRuleStack(),
                        ruleOccurrenceStack: t.cloneArr(this.RULE_OCCURRENCE_STACK)
                    },
                    this._errors.push(a),
                    a;
                throw Error("Trying to save an Error which is not a RecognitionException")
            }
            ,
            Object.defineProperty(o.prototype, "errors", {
                get: function() {
                    return t.cloneArr(this._errors)
                },
                set: function(a) {
                    this._errors = a
                },
                enumerable: !1,
                configurable: !0
            }),
            o.prototype.raiseEarlyExitException = function(a, l, c) {
                for (var u = this.getCurrRuleFullName(), h = this.getGAstProductions()[u], f = n.getLookaheadPathsForOptionalProd(a, h, l, this.maxLookahead), m = f[0], g = [], v = 1; v <= this.maxLookahead; v++)
                    g.push(this.LA(v));
                var p = this.errorMessageProvider.buildEarlyExitMessage({
                    expectedIterationPaths: m,
                    actual: g,
                    previous: this.LA(0),
                    customUserDescription: c,
                    ruleName: u
                });
                throw this.SAVE_ERROR(new e.EarlyExitException(p,this.LA(1),this.LA(0)))
            }
            ,
            o.prototype.raiseNoAltException = function(a, l) {
                for (var c = this.getCurrRuleFullName(), u = this.getGAstProductions()[c], h = n.getLookaheadPathsForOr(a, u, this.maxLookahead), f = [], m = 1; m <= this.maxLookahead; m++)
                    f.push(this.LA(m));
                var g = this.LA(0)
                  , v = this.errorMessageProvider.buildNoViableAltMessage({
                    expectedPathsPerAlt: h,
                    actual: f,
                    previous: g,
                    customUserDescription: l,
                    ruleName: this.getCurrRuleFullName()
                });
                throw this.SAVE_ERROR(new e.NoViableAltException(v,this.LA(1),g))
            }
            ,
            o
        }();
        r.ErrorHandler = s
    }
    )
      , Ww = _t(r=>{
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.ContentAssist = void 0;
        var e = xf()
          , t = Gt()
          , n = function() {
            function i() {}
            return i.prototype.initContentAssist = function() {}
            ,
            i.prototype.computeContentAssist = function(s, o) {
                var a = this.gastProductionsCache[s];
                if (t.isUndefined(a))
                    throw Error("Rule ->" + s + "<- does not exist in this grammar.");
                return e.nextPossibleTokensAfter([a], o, this.tokenMatcher, this.maxLookahead)
            }
            ,
            i.prototype.getNextPossibleTokenTypes = function(s) {
                var o = t.first(s.ruleStack)
                  , a = this.getGAstProductions()
                  , l = a[o]
                  , c = new e.NextAfterTokenWalker(l,s).startWalking();
                return c
            }
            ,
            i
        }();
        r.ContentAssist = n
    }
    )
      , Xw = _t(r=>{
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.GastRecorder = void 0;
        var e = Gt()
          , t = Ui()
          , n = gf()
          , i = iu()
          , s = Ko()
          , o = Ji()
          , a = mm()
          , l = {
            description: "This Object indicates the Parser is during Recording Phase"
        };
        Object.freeze(l);
        var c = !0
          , u = Math.pow(2, a.BITS_FOR_OCCURRENCE_IDX) - 1
          , h = s.createToken({
            name: "RECORDING_PHASE_TOKEN",
            pattern: n.Lexer.NA
        });
        i.augmentTokenTypes([h]);
        var f = s.createTokenInstance(h, `This IToken indicates the Parser is in Recording Phase
	See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details`, -1, -1, -1, -1, -1, -1);
        Object.freeze(f);
        var m = {
            name: `This CSTNode indicates the Parser is in Recording Phase
	See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details`,
            children: {}
        }
          , g = function() {
            function y() {}
            return y.prototype.initGastRecorder = function(_) {
                this.recordingProdStack = [],
                this.RECORDING_PHASE = !1
            }
            ,
            y.prototype.enableRecording = function() {
                var _ = this;
                this.RECORDING_PHASE = !0,
                this.TRACE_INIT("Enable Recording", function() {
                    for (var S = function(I) {
                        var O = I > 0 ? I : "";
                        _["CONSUME" + O] = function(M, R) {
                            return this.consumeInternalRecord(M, I, R)
                        }
                        ,
                        _["SUBRULE" + O] = function(M, R) {
                            return this.subruleInternalRecord(M, I, R)
                        }
                        ,
                        _["OPTION" + O] = function(M) {
                            return this.optionInternalRecord(M, I)
                        }
                        ,
                        _["OR" + O] = function(M) {
                            return this.orInternalRecord(M, I)
                        }
                        ,
                        _["MANY" + O] = function(M) {
                            this.manyInternalRecord(I, M)
                        }
                        ,
                        _["MANY_SEP" + O] = function(M) {
                            this.manySepFirstInternalRecord(I, M)
                        }
                        ,
                        _["AT_LEAST_ONE" + O] = function(M) {
                            this.atLeastOneInternalRecord(I, M)
                        }
                        ,
                        _["AT_LEAST_ONE_SEP" + O] = function(M) {
                            this.atLeastOneSepFirstInternalRecord(I, M)
                        }
                    }, N = 0; N < 10; N++)
                        S(N);
                    _.consume = function(I, O, M) {
                        return this.consumeInternalRecord(O, I, M)
                    }
                    ,
                    _.subrule = function(I, O, M) {
                        return this.subruleInternalRecord(O, I, M)
                    }
                    ,
                    _.option = function(I, O) {
                        return this.optionInternalRecord(O, I)
                    }
                    ,
                    _.or = function(I, O) {
                        return this.orInternalRecord(O, I)
                    }
                    ,
                    _.many = function(I, O) {
                        this.manyInternalRecord(I, O)
                    }
                    ,
                    _.atLeastOne = function(I, O) {
                        this.atLeastOneInternalRecord(I, O)
                    }
                    ,
                    _.ACTION = _.ACTION_RECORD,
                    _.BACKTRACK = _.BACKTRACK_RECORD,
                    _.LA = _.LA_RECORD
                })
            }
            ,
            y.prototype.disableRecording = function() {
                var _ = this;
                this.RECORDING_PHASE = !1,
                this.TRACE_INIT("Deleting Recording methods", function() {
                    for (var S = 0; S < 10; S++) {
                        var N = S > 0 ? S : "";
                        delete _["CONSUME" + N],
                        delete _["SUBRULE" + N],
                        delete _["OPTION" + N],
                        delete _["OR" + N],
                        delete _["MANY" + N],
                        delete _["MANY_SEP" + N],
                        delete _["AT_LEAST_ONE" + N],
                        delete _["AT_LEAST_ONE_SEP" + N]
                    }
                    delete _.consume,
                    delete _.subrule,
                    delete _.option,
                    delete _.or,
                    delete _.many,
                    delete _.atLeastOne,
                    delete _.ACTION,
                    delete _.BACKTRACK,
                    delete _.LA
                })
            }
            ,
            y.prototype.ACTION_RECORD = function(_) {}
            ,
            y.prototype.BACKTRACK_RECORD = function(_, S) {
                return function() {
                    return !0
                }
            }
            ,
            y.prototype.LA_RECORD = function(_) {
                return o.END_OF_FILE
            }
            ,
            y.prototype.topLevelRuleRecord = function(_, S) {
                try {
                    var N = new t.Rule({
                        definition: [],
                        name: _
                    });
                    return N.name = _,
                    this.recordingProdStack.push(N),
                    S.call(this),
                    this.recordingProdStack.pop(),
                    N
                } catch (I) {
                    if (I.KNOWN_RECORDER_ERROR !== !0)
                        try {
                            I.message = I.message + `
	 This error was thrown during the "grammar recording phase" For more info see:
	https://chevrotain.io/docs/guide/internals.html#grammar-recording`
                        } catch {
                            throw I
                        }
                    throw I
                }
            }
            ,
            y.prototype.optionInternalRecord = function(_, S) {
                return v.call(this, t.Option, _, S)
            }
            ,
            y.prototype.atLeastOneInternalRecord = function(_, S) {
                v.call(this, t.RepetitionMandatory, S, _)
            }
            ,
            y.prototype.atLeastOneSepFirstInternalRecord = function(_, S) {
                v.call(this, t.RepetitionMandatoryWithSeparator, S, _, c)
            }
            ,
            y.prototype.manyInternalRecord = function(_, S) {
                v.call(this, t.Repetition, S, _)
            }
            ,
            y.prototype.manySepFirstInternalRecord = function(_, S) {
                v.call(this, t.RepetitionWithSeparator, S, _, c)
            }
            ,
            y.prototype.orInternalRecord = function(_, S) {
                return p.call(this, _, S)
            }
            ,
            y.prototype.subruleInternalRecord = function(_, S, N) {
                if (x(S),
                !_ || e.has(_, "ruleName") === !1) {
                    var I = new Error("<SUBRULE" + d(S) + "> argument is invalid" + (" expecting a Parser method reference but got: <" + JSON.stringify(_) + ">") + (`
 inside top level rule: <` + this.recordingProdStack[0].name + ">"));
                    throw I.KNOWN_RECORDER_ERROR = !0,
                    I
                }
                var O = e.peek(this.recordingProdStack)
                  , M = _.ruleName
                  , R = new t.NonTerminal({
                    idx: S,
                    nonTerminalName: M,
                    referencedRule: void 0
                });
                return O.definition.push(R),
                this.outputCst ? m : l
            }
            ,
            y.prototype.consumeInternalRecord = function(_, S, N) {
                if (x(S),
                !i.hasShortKeyProperty(_)) {
                    var I = new Error("<CONSUME" + d(S) + "> argument is invalid" + (" expecting a TokenType reference but got: <" + JSON.stringify(_) + ">") + (`
 inside top level rule: <` + this.recordingProdStack[0].name + ">"));
                    throw I.KNOWN_RECORDER_ERROR = !0,
                    I
                }
                var O = e.peek(this.recordingProdStack)
                  , M = new t.Terminal({
                    idx: S,
                    terminalType: _
                });
                return O.definition.push(M),
                f
            }
            ,
            y
        }();
        r.GastRecorder = g;
        function v(y, _, S, N) {
            N === void 0 && (N = !1),
            x(S);
            var I = e.peek(this.recordingProdStack)
              , O = e.isFunction(_) ? _ : _.DEF
              , M = new y({
                definition: [],
                idx: S
            });
            return N && (M.separator = _.SEP),
            e.has(_, "MAX_LOOKAHEAD") && (M.maxLookahead = _.MAX_LOOKAHEAD),
            this.recordingProdStack.push(M),
            O.call(this),
            I.definition.push(M),
            this.recordingProdStack.pop(),
            l
        }
        function p(y, _) {
            var S = this;
            x(_);
            var N = e.peek(this.recordingProdStack)
              , I = e.isArray(y) === !1
              , O = I === !1 ? y : y.DEF
              , M = new t.Alternation({
                definition: [],
                idx: _,
                ignoreAmbiguities: I && y.IGNORE_AMBIGUITIES === !0
            });
            e.has(y, "MAX_LOOKAHEAD") && (M.maxLookahead = y.MAX_LOOKAHEAD);
            var R = e.some(O, function(q) {
                return e.isFunction(q.GATE)
            });
            return M.hasPredicates = R,
            N.definition.push(M),
            e.forEach(O, function(q) {
                var k = new t.Alternative({
                    definition: []
                });
                M.definition.push(k),
                e.has(q, "IGNORE_AMBIGUITIES") ? k.ignoreAmbiguities = q.IGNORE_AMBIGUITIES : e.has(q, "GATE") && (k.ignoreAmbiguities = !0),
                S.recordingProdStack.push(k),
                q.ALT.call(S),
                S.recordingProdStack.pop()
            }),
            l
        }
        function d(y) {
            return y === 0 ? "" : "" + y
        }
        function x(y) {
            if (y < 0 || y > u) {
                var _ = new Error("Invalid DSL Method idx value: <" + y + `>
	` + ("Idx value must be a none negative value smaller than " + (u + 1)));
                throw _.KNOWN_RECORDER_ERROR = !0,
                _
            }
        }
    }
    )
      , jw = _t(r=>{
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.PerformanceTracer = void 0;
        var e = Gt()
          , t = Ji()
          , n = function() {
            function i() {}
            return i.prototype.initPerformanceTracer = function(s) {
                if (e.has(s, "traceInitPerf")) {
                    var o = s.traceInitPerf
                      , a = typeof o == "number";
                    this.traceInitMaxIdent = a ? o : 1 / 0,
                    this.traceInitPerf = a ? o > 0 : o
                } else
                    this.traceInitMaxIdent = 0,
                    this.traceInitPerf = t.DEFAULT_PARSER_CONFIG.traceInitPerf;
                this.traceInitIndent = -1
            }
            ,
            i.prototype.TRACE_INIT = function(s, o) {
                if (this.traceInitPerf === !0) {
                    this.traceInitIndent++;
                    var a = new Array(this.traceInitIndent + 1).join("	");
                    this.traceInitIndent < this.traceInitMaxIdent && console.log(a + "--> <" + s + ">");
                    var l = e.timer(o)
                      , c = l.time
                      , u = l.value
                      , h = c > 10 ? console.warn : console.log;
                    return this.traceInitIndent < this.traceInitMaxIdent && h(a + "<-- <" + s + "> time: " + c + "ms"),
                    this.traceInitIndent--,
                    u
                } else
                    return o()
            }
            ,
            i
        }();
        r.PerformanceTracer = n
    }
    )
      , qw = _t(r=>{
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.applyMixins = void 0;
        function e(t, n) {
            n.forEach(function(i) {
                var s = i.prototype;
                Object.getOwnPropertyNames(s).forEach(function(o) {
                    if (o !== "constructor") {
                        var a = Object.getOwnPropertyDescriptor(s, o);
                        a && (a.get || a.set) ? Object.defineProperty(t.prototype, o, a) : t.prototype[o] = i.prototype[o]
                    }
                })
            })
        }
        r.applyMixins = e
    }
    )
      , Ji = _t(r=>{
        "use strict";
        var e = r && r.__extends || function() {
            var I = function(O, M) {
                return I = Object.setPrototypeOf || {
                    __proto__: []
                }instanceof Array && function(R, q) {
                    R.__proto__ = q
                }
                || function(R, q) {
                    for (var k in q)
                        Object.prototype.hasOwnProperty.call(q, k) && (R[k] = q[k])
                }
                ,
                I(O, M)
            };
            return function(O, M) {
                if (typeof M != "function" && M !== null)
                    throw new TypeError("Class extends value " + String(M) + " is not a constructor or null");
                I(O, M);
                function R() {
                    this.constructor = O
                }
                O.prototype = M === null ? Object.create(M) : (R.prototype = M.prototype,
                new R)
            }
        }();
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.EmbeddedActionsParser = r.CstParser = r.Parser = r.EMPTY_ALT = r.ParserDefinitionErrorType = r.DEFAULT_RULE_CONFIG = r.DEFAULT_PARSER_CONFIG = r.END_OF_FILE = void 0;
        var t = Gt()
          , n = Nw()
          , i = Ko()
          , s = yf()
          , o = Ow()
          , a = dy()
          , l = Fw()
          , c = Bw()
          , u = Gw()
          , h = Vw()
          , f = zw()
          , m = Hw()
          , g = Ww()
          , v = Xw()
          , p = jw()
          , d = qw();
        r.END_OF_FILE = i.createTokenInstance(i.EOF, "", NaN, NaN, NaN, NaN, NaN, NaN),
        Object.freeze(r.END_OF_FILE),
        r.DEFAULT_PARSER_CONFIG = Object.freeze({
            recoveryEnabled: !1,
            maxLookahead: 3,
            dynamicTokensEnabled: !1,
            outputCst: !0,
            errorMessageProvider: s.defaultParserErrorProvider,
            nodeLocationTracking: "none",
            traceInitPerf: !1,
            skipValidations: !1
        }),
        r.DEFAULT_RULE_CONFIG = Object.freeze({
            recoveryValueFunc: function() {},
            resyncEnabled: !0
        });
        var x;
        (function(I) {
            I[I.INVALID_RULE_NAME = 0] = "INVALID_RULE_NAME",
            I[I.DUPLICATE_RULE_NAME = 1] = "DUPLICATE_RULE_NAME",
            I[I.INVALID_RULE_OVERRIDE = 2] = "INVALID_RULE_OVERRIDE",
            I[I.DUPLICATE_PRODUCTIONS = 3] = "DUPLICATE_PRODUCTIONS",
            I[I.UNRESOLVED_SUBRULE_REF = 4] = "UNRESOLVED_SUBRULE_REF",
            I[I.LEFT_RECURSION = 5] = "LEFT_RECURSION",
            I[I.NONE_LAST_EMPTY_ALT = 6] = "NONE_LAST_EMPTY_ALT",
            I[I.AMBIGUOUS_ALTS = 7] = "AMBIGUOUS_ALTS",
            I[I.CONFLICT_TOKENS_RULES_NAMESPACE = 8] = "CONFLICT_TOKENS_RULES_NAMESPACE",
            I[I.INVALID_TOKEN_NAME = 9] = "INVALID_TOKEN_NAME",
            I[I.NO_NON_EMPTY_LOOKAHEAD = 10] = "NO_NON_EMPTY_LOOKAHEAD",
            I[I.AMBIGUOUS_PREFIX_ALTS = 11] = "AMBIGUOUS_PREFIX_ALTS",
            I[I.TOO_MANY_ALTS = 12] = "TOO_MANY_ALTS"
        }
        )(x = r.ParserDefinitionErrorType || (r.ParserDefinitionErrorType = {}));
        function y(I) {
            return I === void 0 && (I = void 0),
            function() {
                return I
            }
        }
        r.EMPTY_ALT = y;
        var _ = function() {
            function I(O, M) {
                this.definitionErrors = [],
                this.selfAnalysisDone = !1;
                var R = this;
                if (R.initErrorHandler(M),
                R.initLexerAdapter(),
                R.initLooksAhead(M),
                R.initRecognizerEngine(O, M),
                R.initRecoverable(M),
                R.initTreeBuilder(M),
                R.initContentAssist(),
                R.initGastRecorder(M),
                R.initPerformanceTracer(M),
                t.has(M, "ignoredIssues"))
                    throw new Error(`The <ignoredIssues> IParserConfig property has been deprecated.
	Please use the <IGNORE_AMBIGUITIES> flag on the relevant DSL method instead.
	See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#IGNORING_AMBIGUITIES
	For further details.`);
                this.skipValidations = t.has(M, "skipValidations") ? M.skipValidations : r.DEFAULT_PARSER_CONFIG.skipValidations
            }
            return I.performSelfAnalysis = function(O) {
                throw Error("The **static** `performSelfAnalysis` method has been deprecated.	\nUse the **instance** method with the same name instead.")
            }
            ,
            I.prototype.performSelfAnalysis = function() {
                var O = this;
                this.TRACE_INIT("performSelfAnalysis", function() {
                    var M;
                    O.selfAnalysisDone = !0;
                    var R = O.className;
                    O.TRACE_INIT("toFastProps", function() {
                        t.toFastProperties(O)
                    }),
                    O.TRACE_INIT("Grammar Recording", function() {
                        try {
                            O.enableRecording(),
                            t.forEach(O.definedRulesNames, function(k) {
                                var B = O[k]
                                  , P = B.originalGrammarAction
                                  , C = void 0;
                                O.TRACE_INIT(k + " Rule", function() {
                                    C = O.topLevelRuleRecord(k, P)
                                }),
                                O.gastProductionsCache[k] = C
                            })
                        } finally {
                            O.disableRecording()
                        }
                    });
                    var q = [];
                    if (O.TRACE_INIT("Grammar Resolving", function() {
                        q = o.resolveGrammar({
                            rules: t.values(O.gastProductionsCache)
                        }),
                        O.definitionErrors = O.definitionErrors.concat(q)
                    }),
                    O.TRACE_INIT("Grammar Validations", function() {
                        if (t.isEmpty(q) && O.skipValidations === !1) {
                            var k = o.validateGrammar({
                                rules: t.values(O.gastProductionsCache),
                                maxLookahead: O.maxLookahead,
                                tokenTypes: t.values(O.tokensMap),
                                errMsgProvider: s.defaultGrammarValidatorErrorProvider,
                                grammarName: R
                            });
                            O.definitionErrors = O.definitionErrors.concat(k)
                        }
                    }),
                    t.isEmpty(O.definitionErrors) && (O.recoveryEnabled && O.TRACE_INIT("computeAllProdsFollows", function() {
                        var k = n.computeAllProdsFollows(t.values(O.gastProductionsCache));
                        O.resyncFollows = k
                    }),
                    O.TRACE_INIT("ComputeLookaheadFunctions", function() {
                        O.preComputeLookaheadFunctions(t.values(O.gastProductionsCache))
                    })),
                    !I.DEFER_DEFINITION_ERRORS_HANDLING && !t.isEmpty(O.definitionErrors))
                        throw M = t.map(O.definitionErrors, function(k) {
                            return k.message
                        }),
                        new Error(`Parser Definition Errors detected:
 ` + M.join(`
-------------------------------
`))
                })
            }
            ,
            I.DEFER_DEFINITION_ERRORS_HANDLING = !1,
            I
        }();
        r.Parser = _,
        d.applyMixins(_, [a.Recoverable, l.LooksAhead, c.TreeBuilder, u.LexerAdapter, f.RecognizerEngine, h.RecognizerApi, m.ErrorHandler, g.ContentAssist, v.GastRecorder, p.PerformanceTracer]);
        var S = function(I) {
            e(O, I);
            function O(M, R) {
                R === void 0 && (R = r.DEFAULT_PARSER_CONFIG);
                var q = this
                  , k = t.cloneObj(R);
                return k.outputCst = !0,
                q = I.call(this, M, k) || this,
                q
            }
            return O
        }(_);
        r.CstParser = S;
        var N = function(I) {
            e(O, I);
            function O(M, R) {
                R === void 0 && (R = r.DEFAULT_PARSER_CONFIG);
                var q = this
                  , k = t.cloneObj(R);
                return k.outputCst = !1,
                q = I.call(this, M, k) || this,
                q
            }
            return O
        }(_);
        r.EmbeddedActionsParser = N
    }
    )
      , Yw = _t(r=>{
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.createSyntaxDiagramsCode = void 0;
        var e = ay();
        function t(n, i) {
            var s = i === void 0 ? {} : i
              , o = s.resourceBase
              , a = o === void 0 ? "https://unpkg.com/chevrotain@" + e.VERSION + "/diagrams/" : o
              , l = s.css
              , c = l === void 0 ? "https://unpkg.com/chevrotain@" + e.VERSION + "/diagrams/diagrams.css" : l
              , u = `
<!-- This is a generated file -->
<!DOCTYPE html>
<meta charset="utf-8">
<style>
  body {
    background-color: hsl(30, 20%, 95%)
  }
</style>

`
              , h = `
<link rel='stylesheet' href='` + c + `'>
`
              , f = `
<script src='` + a + `vendor/railroad-diagrams.js'><\/script>
<script src='` + a + `src/diagrams_builder.js'><\/script>
<script src='` + a + `src/diagrams_behavior.js'><\/script>
<script src='` + a + `src/main.js'><\/script>
`
              , m = `
<div id="diagrams" align="center"></div>
`
              , g = `
<script>
    window.serializedGrammar = ` + JSON.stringify(n, null, "  ") + `;
<\/script>
`
              , v = `
<script>
    var diagramsDiv = document.getElementById("diagrams");
    main.drawDiagramsFromSerializedGrammar(serializedGrammar, diagramsDiv);
<\/script>
`;
            return u + h + f + m + g + v
        }
        r.createSyntaxDiagramsCode = t
    }
    )
      , Kw = _t(r=>{
        "use strict";
        Object.defineProperty(r, "__esModule", {
            value: !0
        }),
        r.Parser = r.createSyntaxDiagramsCode = r.clearCache = r.GAstVisitor = r.serializeProduction = r.serializeGrammar = r.Terminal = r.Rule = r.RepetitionWithSeparator = r.RepetitionMandatoryWithSeparator = r.RepetitionMandatory = r.Repetition = r.Option = r.NonTerminal = r.Alternative = r.Alternation = r.defaultLexerErrorProvider = r.NoViableAltException = r.NotAllInputParsedException = r.MismatchedTokenException = r.isRecognitionException = r.EarlyExitException = r.defaultParserErrorProvider = r.tokenName = r.tokenMatcher = r.tokenLabel = r.EOF = r.createTokenInstance = r.createToken = r.LexerDefinitionErrorType = r.Lexer = r.EMPTY_ALT = r.ParserDefinitionErrorType = r.EmbeddedActionsParser = r.CstParser = r.VERSION = void 0;
        var e = ay();
        Object.defineProperty(r, "VERSION", {
            enumerable: !0,
            get: function() {
                return e.VERSION
            }
        });
        var t = Ji();
        Object.defineProperty(r, "CstParser", {
            enumerable: !0,
            get: function() {
                return t.CstParser
            }
        }),
        Object.defineProperty(r, "EmbeddedActionsParser", {
            enumerable: !0,
            get: function() {
                return t.EmbeddedActionsParser
            }
        }),
        Object.defineProperty(r, "ParserDefinitionErrorType", {
            enumerable: !0,
            get: function() {
                return t.ParserDefinitionErrorType
            }
        }),
        Object.defineProperty(r, "EMPTY_ALT", {
            enumerable: !0,
            get: function() {
                return t.EMPTY_ALT
            }
        });
        var n = gf();
        Object.defineProperty(r, "Lexer", {
            enumerable: !0,
            get: function() {
                return n.Lexer
            }
        }),
        Object.defineProperty(r, "LexerDefinitionErrorType", {
            enumerable: !0,
            get: function() {
                return n.LexerDefinitionErrorType
            }
        });
        var i = Ko();
        Object.defineProperty(r, "createToken", {
            enumerable: !0,
            get: function() {
                return i.createToken
            }
        }),
        Object.defineProperty(r, "createTokenInstance", {
            enumerable: !0,
            get: function() {
                return i.createTokenInstance
            }
        }),
        Object.defineProperty(r, "EOF", {
            enumerable: !0,
            get: function() {
                return i.EOF
            }
        }),
        Object.defineProperty(r, "tokenLabel", {
            enumerable: !0,
            get: function() {
                return i.tokenLabel
            }
        }),
        Object.defineProperty(r, "tokenMatcher", {
            enumerable: !0,
            get: function() {
                return i.tokenMatcher
            }
        }),
        Object.defineProperty(r, "tokenName", {
            enumerable: !0,
            get: function() {
                return i.tokenName
            }
        });
        var s = yf();
        Object.defineProperty(r, "defaultParserErrorProvider", {
            enumerable: !0,
            get: function() {
                return s.defaultParserErrorProvider
            }
        });
        var o = su();
        Object.defineProperty(r, "EarlyExitException", {
            enumerable: !0,
            get: function() {
                return o.EarlyExitException
            }
        }),
        Object.defineProperty(r, "isRecognitionException", {
            enumerable: !0,
            get: function() {
                return o.isRecognitionException
            }
        }),
        Object.defineProperty(r, "MismatchedTokenException", {
            enumerable: !0,
            get: function() {
                return o.MismatchedTokenException
            }
        }),
        Object.defineProperty(r, "NotAllInputParsedException", {
            enumerable: !0,
            get: function() {
                return o.NotAllInputParsedException
            }
        }),
        Object.defineProperty(r, "NoViableAltException", {
            enumerable: !0,
            get: function() {
                return o.NoViableAltException
            }
        });
        var a = cy();
        Object.defineProperty(r, "defaultLexerErrorProvider", {
            enumerable: !0,
            get: function() {
                return a.defaultLexerErrorProvider
            }
        });
        var l = Ui();
        Object.defineProperty(r, "Alternation", {
            enumerable: !0,
            get: function() {
                return l.Alternation
            }
        }),
        Object.defineProperty(r, "Alternative", {
            enumerable: !0,
            get: function() {
                return l.Alternative
            }
        }),
        Object.defineProperty(r, "NonTerminal", {
            enumerable: !0,
            get: function() {
                return l.NonTerminal
            }
        }),
        Object.defineProperty(r, "Option", {
            enumerable: !0,
            get: function() {
                return l.Option
            }
        }),
        Object.defineProperty(r, "Repetition", {
            enumerable: !0,
            get: function() {
                return l.Repetition
            }
        }),
        Object.defineProperty(r, "RepetitionMandatory", {
            enumerable: !0,
            get: function() {
                return l.RepetitionMandatory
            }
        }),
        Object.defineProperty(r, "RepetitionMandatoryWithSeparator", {
            enumerable: !0,
            get: function() {
                return l.RepetitionMandatoryWithSeparator
            }
        }),
        Object.defineProperty(r, "RepetitionWithSeparator", {
            enumerable: !0,
            get: function() {
                return l.RepetitionWithSeparator
            }
        }),
        Object.defineProperty(r, "Rule", {
            enumerable: !0,
            get: function() {
                return l.Rule
            }
        }),
        Object.defineProperty(r, "Terminal", {
            enumerable: !0,
            get: function() {
                return l.Terminal
            }
        });
        var c = Ui();
        Object.defineProperty(r, "serializeGrammar", {
            enumerable: !0,
            get: function() {
                return c.serializeGrammar
            }
        }),
        Object.defineProperty(r, "serializeProduction", {
            enumerable: !0,
            get: function() {
                return c.serializeProduction
            }
        });
        var u = ru();
        Object.defineProperty(r, "GAstVisitor", {
            enumerable: !0,
            get: function() {
                return u.GAstVisitor
            }
        });
        function h() {
            console.warn(`The clearCache function was 'soft' removed from the Chevrotain API.
	 It performs no action other than printing this message.
	 Please avoid using it as it will be completely removed in the future`)
        }
        r.clearCache = h;
        var f = Yw();
        Object.defineProperty(r, "createSyntaxDiagramsCode", {
            enumerable: !0,
            get: function() {
                return f.createSyntaxDiagramsCode
            }
        });
        var m = function() {
            function g() {
                throw new Error(`The Parser class has been deprecated, use CstParser or EmbeddedActionsParser instead.
See: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_7-0-0`)
            }
            return g
        }();
        r.Parser = m
    }
    )
      , wl = Kw();
    var Tf = class extends Hn {
        constructor(e) {
            super(e)
        }
        load(e, t, n, i) {
            let s = this
              , o = s.path === "" ? Qs.extractUrlBase(e) : s.path
              , a = new Ni(s.manager);
            a.setPath(s.path),
            a.setRequestHeader(s.requestHeader),
            a.setWithCredentials(s.withCredentials),
            a.load(e, function(l) {
                try {
                    t(s.parse(l, o))
                } catch (c) {
                    i ? i(c) : console.error(c),
                    s.manager.itemError(e)
                }
            }, n, i)
        }
        parse(e, t) {
            let n = {};
            function i(D) {
                let A = s()
                  , G = new gm(A.tokens)
                  , ne = new vm(A.tokenVocabulary)
                  , Q = o(ne.getBaseCstVisitorConstructor())
                  , he = G.lex(D);
                ne.input = he.tokens;
                let de = ne.vrml();
                if (ne.errors.length > 0)
                    throw console.error(ne.errors),
                    Error("THREE.VRMLLoader: Parsing errors detected.");
                return Q.visit(de)
            }
            function s() {
                let D = wl.createToken
                  , A = D({
                    name: "RouteIdentifier",
                    pattern: /[^\x30-\x39\0-\x20\x22\x27\x23\x2b\x2c\x2d\x2e\x5b\x5d\x5c\x7b\x7d][^\0-\x20\x22\x27\x23\x2b\x2c\x2d\x2e\x5b\x5d\x5c\x7b\x7d]*[\.][^\x30-\x39\0-\x20\x22\x27\x23\x2b\x2c\x2d\x2e\x5b\x5d\x5c\x7b\x7d][^\0-\x20\x22\x27\x23\x2b\x2c\x2d\x2e\x5b\x5d\x5c\x7b\x7d]*/
                })
                  , G = D({
                    name: "Identifier",
                    pattern: /[^\x30-\x39\0-\x20\x22\x27\x23\x2b\x2c\x2d\x2e\x5b\x5d\x5c\x7b\x7d][^\0-\x20\x22\x27\x23\x2b\x2c\x2d\x2e\x5b\x5d\x5c\x7b\x7d]*/,
                    longer_alt: A
                })
                  , ne = ["Anchor", "Billboard", "Collision", "Group", "Transform", "Inline", "LOD", "Switch", "AudioClip", "DirectionalLight", "PointLight", "Script", "Shape", "Sound", "SpotLight", "WorldInfo", "CylinderSensor", "PlaneSensor", "ProximitySensor", "SphereSensor", "TimeSensor", "TouchSensor", "VisibilitySensor", "Box", "Cone", "Cylinder", "ElevationGrid", "Extrusion", "IndexedFaceSet", "IndexedLineSet", "PointSet", "Sphere", "Color", "Coordinate", "Normal", "TextureCoordinate", "Appearance", "FontStyle", "ImageTexture", "Material", "MovieTexture", "PixelTexture", "TextureTransform", "ColorInterpolator", "CoordinateInterpolator", "NormalInterpolator", "OrientationInterpolator", "PositionInterpolator", "ScalarInterpolator", "Background", "Fog", "NavigationInfo", "Viewpoint", "Text"]
                  , Q = D({
                    name: "Version",
                    pattern: /#VRML.*/,
                    longer_alt: G
                })
                  , he = D({
                    name: "NodeName",
                    pattern: new RegExp(ne.join("|")),
                    longer_alt: G
                })
                  , de = D({
                    name: "DEF",
                    pattern: /DEF/,
                    longer_alt: G
                })
                  , ge = D({
                    name: "USE",
                    pattern: /USE/,
                    longer_alt: G
                })
                  , le = D({
                    name: "ROUTE",
                    pattern: /ROUTE/,
                    longer_alt: G
                })
                  , xe = D({
                    name: "TO",
                    pattern: /TO/,
                    longer_alt: G
                })
                  , Me = D({
                    name: "StringLiteral",
                    pattern: /"(?:[^\\"\n\r]|\\[bfnrtv"\\/]|\\u[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F])*"/
                })
                  , Ne = D({
                    name: "HexLiteral",
                    pattern: /0[xX][0-9a-fA-F]+/
                })
                  , De = D({
                    name: "NumberLiteral",
                    pattern: /[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?/
                })
                  , Ve = D({
                    name: "TrueLiteral",
                    pattern: /TRUE/
                })
                  , Ze = D({
                    name: "FalseLiteral",
                    pattern: /FALSE/
                })
                  , We = D({
                    name: "NullLiteral",
                    pattern: /NULL/
                })
                  , Qe = D({
                    name: "LSquare",
                    pattern: /\[/
                })
                  , pe = D({
                    name: "RSquare",
                    pattern: /]/
                })
                  , _e = D({
                    name: "LCurly",
                    pattern: /{/
                })
                  , we = D({
                    name: "RCurly",
                    pattern: /}/
                })
                  , Fe = D({
                    name: "Comment",
                    pattern: /#.*/,
                    group: wl.Lexer.SKIPPED
                })
                  , pt = [D({
                    name: "WhiteSpace",
                    pattern: /[ ,\s]/,
                    group: wl.Lexer.SKIPPED
                }), he, de, ge, le, xe, Ve, Ze, We, Q, G, A, Me, Ne, De, Qe, pe, _e, we, Fe]
                  , mt = {};
                for (let ot = 0, Ke = pt.length; ot < Ke; ot++) {
                    let ke = pt[ot];
                    mt[ke.name] = ke
                }
                return {
                    tokens: pt,
                    tokenVocabulary: mt
                }
            }
            function o(D) {
                class A extends D {
                    constructor() {
                        super(),
                        this.validateVisitor()
                    }
                    vrml(Q) {
                        let he = {
                            version: this.visit(Q.version),
                            nodes: [],
                            routes: []
                        };
                        for (let de = 0, ge = Q.node.length; de < ge; de++) {
                            let le = Q.node[de];
                            he.nodes.push(this.visit(le))
                        }
                        if (Q.route)
                            for (let de = 0, ge = Q.route.length; de < ge; de++) {
                                let le = Q.route[de];
                                he.routes.push(this.visit(le))
                            }
                        return he
                    }
                    version(Q) {
                        return Q.Version[0].image
                    }
                    node(Q) {
                        let he = {
                            name: Q.NodeName[0].image,
                            fields: []
                        };
                        if (Q.field)
                            for (let de = 0, ge = Q.field.length; de < ge; de++) {
                                let le = Q.field[de];
                                he.fields.push(this.visit(le))
                            }
                        return Q.def && (he.DEF = this.visit(Q.def[0])),
                        he
                    }
                    field(Q) {
                        let he = {
                            name: Q.Identifier[0].image,
                            type: null,
                            values: null
                        }, de;
                        return Q.singleFieldValue && (de = this.visit(Q.singleFieldValue[0])),
                        Q.multiFieldValue && (de = this.visit(Q.multiFieldValue[0])),
                        he.type = de.type,
                        he.values = de.values,
                        he
                    }
                    def(Q) {
                        return (Q.Identifier || Q.NodeName)[0].image
                    }
                    use(Q) {
                        return {
                            USE: (Q.Identifier || Q.NodeName)[0].image
                        }
                    }
                    singleFieldValue(Q) {
                        return G(this, Q)
                    }
                    multiFieldValue(Q) {
                        return G(this, Q)
                    }
                    route(Q) {
                        return {
                            FROM: Q.RouteIdentifier[0].image,
                            TO: Q.RouteIdentifier[1].image
                        }
                    }
                }
                function G(ne, Q) {
                    let he = {
                        type: null,
                        values: []
                    };
                    if (Q.node) {
                        he.type = "node";
                        for (let de = 0, ge = Q.node.length; de < ge; de++) {
                            let le = Q.node[de];
                            he.values.push(ne.visit(le))
                        }
                    }
                    if (Q.use) {
                        he.type = "use";
                        for (let de = 0, ge = Q.use.length; de < ge; de++) {
                            let le = Q.use[de];
                            he.values.push(ne.visit(le))
                        }
                    }
                    if (Q.StringLiteral) {
                        he.type = "string";
                        for (let de = 0, ge = Q.StringLiteral.length; de < ge; de++) {
                            let le = Q.StringLiteral[de];
                            he.values.push(le.image.replace(/'|"/g, ""))
                        }
                    }
                    if (Q.NumberLiteral) {
                        he.type = "number";
                        for (let de = 0, ge = Q.NumberLiteral.length; de < ge; de++) {
                            let le = Q.NumberLiteral[de];
                            he.values.push(parseFloat(le.image))
                        }
                    }
                    if (Q.HexLiteral) {
                        he.type = "hex";
                        for (let de = 0, ge = Q.HexLiteral.length; de < ge; de++) {
                            let le = Q.HexLiteral[de];
                            he.values.push(le.image)
                        }
                    }
                    if (Q.TrueLiteral) {
                        he.type = "boolean";
                        for (let de = 0, ge = Q.TrueLiteral.length; de < ge; de++)
                            Q.TrueLiteral[de].image === "TRUE" && he.values.push(!0)
                    }
                    if (Q.FalseLiteral) {
                        he.type = "boolean";
                        for (let de = 0, ge = Q.FalseLiteral.length; de < ge; de++)
                            Q.FalseLiteral[de].image === "FALSE" && he.values.push(!1)
                    }
                    return Q.NullLiteral && (he.type = "null",
                    Q.NullLiteral.forEach(function() {
                        he.values.push(null)
                    })),
                    he
                }
                return new A
            }
            function a(D) {
                let A = D.nodes
                  , G = new Or;
                for (let ne = 0, Q = A.length; ne < Q; ne++) {
                    let he = A[ne];
                    l(he)
                }
                for (let ne = 0, Q = A.length; ne < Q; ne++) {
                    let he = A[ne]
                      , de = c(he);
                    de instanceof bt && G.add(de),
                    he.name === "WorldInfo" && (G.userData.worldInfo = de)
                }
                return G
            }
            function l(D) {
                D.DEF && (n[D.DEF] = D);
                let A = D.fields;
                for (let G = 0, ne = A.length; G < ne; G++) {
                    let Q = A[G];
                    if (Q.type === "node") {
                        let he = Q.values;
                        for (let de = 0, ge = he.length; de < ge; de++)
                            l(he[de])
                    }
                }
            }
            function c(D) {
                return D.USE ? L(D.USE) : (D.build !== void 0 || (D.build = u(D)),
                D.build)
            }
            function u(D) {
                let A = D.name, G;
                switch (A) {
                case "Anchor":
                case "Group":
                case "Transform":
                case "Collision":
                    G = h(D);
                    break;
                case "Background":
                    G = f(D);
                    break;
                case "Shape":
                    G = m(D);
                    break;
                case "Appearance":
                    G = g(D);
                    break;
                case "Material":
                    G = v(D);
                    break;
                case "ImageTexture":
                    G = y(D);
                    break;
                case "PixelTexture":
                    G = x(D);
                    break;
                case "TextureTransform":
                    G = _(D);
                    break;
                case "IndexedFaceSet":
                    G = I(D);
                    break;
                case "IndexedLineSet":
                    G = O(D);
                    break;
                case "PointSet":
                    G = M(D);
                    break;
                case "Box":
                    G = R(D);
                    break;
                case "Cone":
                    G = q(D);
                    break;
                case "Cylinder":
                    G = k(D);
                    break;
                case "Sphere":
                    G = B(D);
                    break;
                case "ElevationGrid":
                    G = P(D);
                    break;
                case "Extrusion":
                    G = C(D);
                    break;
                case "Color":
                case "Coordinate":
                case "Normal":
                case "TextureCoordinate":
                    G = S(D);
                    break;
                case "WorldInfo":
                    G = N(D);
                    break;
                case "Billboard":
                case "Inline":
                case "LOD":
                case "Switch":
                case "AudioClip":
                case "DirectionalLight":
                case "PointLight":
                case "Script":
                case "Sound":
                case "SpotLight":
                case "CylinderSensor":
                case "PlaneSensor":
                case "ProximitySensor":
                case "SphereSensor":
                case "TimeSensor":
                case "TouchSensor":
                case "VisibilitySensor":
                case "Text":
                case "FontStyle":
                case "MovieTexture":
                case "ColorInterpolator":
                case "CoordinateInterpolator":
                case "NormalInterpolator":
                case "OrientationInterpolator":
                case "PositionInterpolator":
                case "ScalarInterpolator":
                case "Fog":
                case "NavigationInfo":
                case "Viewpoint":
                    break;
                default:
                    console.warn("THREE.VRMLLoader: Unknown node:", A);
                    break
                }
                return G !== void 0 && D.DEF !== void 0 && G.hasOwnProperty("name") === !0 && (G.name = D.DEF),
                G
            }
            function h(D) {
                let A = new In
                  , G = D.fields;
                for (let ne = 0, Q = G.length; ne < Q; ne++) {
                    let he = G[ne]
                      , de = he.name
                      , ge = he.values;
                    switch (de) {
                    case "bboxCenter":
                        break;
                    case "bboxSize":
                        break;
                    case "center":
                        break;
                    case "children":
                        F(ge, A);
                        break;
                    case "description":
                        break;
                    case "collide":
                        break;
                    case "parameter":
                        break;
                    case "rotation":
                        let le = new ue(ge[0],ge[1],ge[2])
                          , xe = ge[3];
                        A.quaternion.setFromAxisAngle(le, xe);
                        break;
                    case "scale":
                        A.scale.set(ge[0], ge[1], ge[2]);
                        break;
                    case "scaleOrientation":
                        break;
                    case "translation":
                        A.position.set(ge[0], ge[1], ge[2]);
                        break;
                    case "proxy":
                        break;
                    case "url":
                        break;
                    default:
                        console.warn("THREE.VRMLLoader: Unknown field:", de);
                        break
                    }
                }
                return A
            }
            function f(D) {
                let A = new In, G, ne, Q, he, de = D.fields;
                for (let le = 0, xe = de.length; le < xe; le++) {
                    let Me = de[le]
                      , Ne = Me.name
                      , De = Me.values;
                    switch (Ne) {
                    case "groundAngle":
                        G = De;
                        break;
                    case "groundColor":
                        ne = De;
                        break;
                    case "backUrl":
                        break;
                    case "bottomUrl":
                        break;
                    case "frontUrl":
                        break;
                    case "leftUrl":
                        break;
                    case "rightUrl":
                        break;
                    case "topUrl":
                        break;
                    case "skyAngle":
                        Q = De;
                        break;
                    case "skyColor":
                        he = De;
                        break;
                    default:
                        console.warn("THREE.VRMLLoader: Unknown field:", Ne);
                        break
                    }
                }
                let ge = 1e4;
                if (he) {
                    let le = new Ys(ge,32,16)
                      , xe = new Yi({
                        fog: !1,
                        side: Mn,
                        depthWrite: !1,
                        depthTest: !1
                    });
                    he.length > 3 ? (fe(le, ge, Q, be(he), !0),
                    xe.vertexColors = !0) : xe.color.setRGB(he[0], he[1], he[2]);
                    let Me = new Ht(le,xe);
                    A.add(Me)
                }
                if (ne && ne.length > 0) {
                    let le = new Ys(ge,32,16,0,2 * Math.PI,.5 * Math.PI,1.5 * Math.PI)
                      , xe = new Yi({
                        fog: !1,
                        side: Mn,
                        vertexColors: !0,
                        depthWrite: !1,
                        depthTest: !1
                    });
                    fe(le, ge, G, be(ne), !1);
                    let Me = new Ht(le,xe);
                    A.add(Me)
                }
                return A.renderOrder = -1 / 0,
                A
            }
            function m(D) {
                let A = D.fields, G = new Yi({
                    color: 0
                }), ne;
                for (let he = 0, de = A.length; he < de; he++) {
                    let ge = A[he]
                      , le = ge.name
                      , xe = ge.values;
                    switch (le) {
                    case "appearance":
                        xe[0] !== null && (G = c(xe[0]));
                        break;
                    case "geometry":
                        xe[0] !== null && (ne = c(xe[0]));
                        break;
                    default:
                        console.warn("THREE.VRMLLoader: Unknown field:", le);
                        break
                    }
                }
                let Q;
                if (ne && ne.attributes.position) {
                    let he = ne._type;
                    if (he === "points") {
                        let de = new kc({
                            color: 16777215
                        });
                        ne.attributes.color !== void 0 ? de.vertexColors = !0 : G.isMeshPhongMaterial && de.color.copy(G.emissive),
                        Q = new wh(ne,de)
                    } else if (he === "line") {
                        let de = new pi({
                            color: 16777215
                        });
                        ne.attributes.color !== void 0 ? de.vertexColors = !0 : G.isMeshPhongMaterial && de.color.copy(G.emissive),
                        Q = new qs(ne,de)
                    } else
                        ne._solid !== void 0 && (G.side = ne._solid ? qi : On),
                        ne.attributes.color !== void 0 && (G.vertexColors = !0),
                        Q = new Ht(ne,G)
                } else
                    Q = new bt,
                    Q.visible = !1;
                return Q
            }
            function g(D) {
                let A = new sn, G, ne = D.fields;
                for (let Q = 0, he = ne.length; Q < he; Q++) {
                    let de = ne[Q]
                      , ge = de.name
                      , le = de.values;
                    switch (ge) {
                    case "material":
                        if (le[0] !== null) {
                            let Me = c(le[0]);
                            Me.diffuseColor && A.color.copy(Me.diffuseColor),
                            Me.emissiveColor && A.emissive.copy(Me.emissiveColor),
                            Me.shininess && (A.shininess = Me.shininess),
                            Me.specularColor && A.specular.copy(Me.specularColor),
                            Me.transparency && (A.opacity = 1 - Me.transparency),
                            Me.transparency > 0 && (A.transparent = !0)
                        } else
                            A = new Yi({
                                color: 0
                            });
                        break;
                    case "texture":
                        let xe = le[0];
                        xe !== null && (xe.name === "ImageTexture" || xe.name === "PixelTexture") && (A.map = c(xe));
                        break;
                    case "textureTransform":
                        le[0] !== null && (G = c(le[0]));
                        break;
                    default:
                        console.warn("THREE.VRMLLoader: Unknown field:", ge);
                        break
                    }
                }
                if (A.map) {
                    if (A.map.__type) {
                        switch (A.map.__type) {
                        case xr.INTENSITY_ALPHA:
                            A.opacity = 1;
                            break;
                        case xr.RGB:
                            A.color.set(16777215);
                            break;
                        case xr.RGBA:
                            A.color.set(16777215),
                            A.opacity = 1;
                            break;
                        default:
                        }
                        delete A.map.__type
                    }
                    G && (A.map.center.copy(G.center),
                    A.map.rotation = G.rotation,
                    A.map.repeat.copy(G.scale),
                    A.map.offset.copy(G.translation))
                }
                return A
            }
            function v(D) {
                let A = {}
                  , G = D.fields;
                for (let ne = 0, Q = G.length; ne < Q; ne++) {
                    let he = G[ne]
                      , de = he.name
                      , ge = he.values;
                    switch (de) {
                    case "ambientIntensity":
                        break;
                    case "diffuseColor":
                        A.diffuseColor = new $e(ge[0],ge[1],ge[2]);
                        break;
                    case "emissiveColor":
                        A.emissiveColor = new $e(ge[0],ge[1],ge[2]);
                        break;
                    case "shininess":
                        A.shininess = ge[0];
                        break;
                    case "specularColor":
                        A.emissiveColor = new $e(ge[0],ge[1],ge[2]);
                        break;
                    case "transparency":
                        A.transparency = ge[0];
                        break;
                    default:
                        console.warn("THREE.VRMLLoader: Unknown field:", de);
                        break
                    }
                }
                return A
            }
            function p(D, A, G) {
                let ne;
                switch (A) {
                case xr.INTENSITY:
                    ne = parseInt(D),
                    G.r = ne,
                    G.g = ne,
                    G.b = ne,
                    G.a = 1;
                    break;
                case xr.INTENSITY_ALPHA:
                    ne = parseInt("0x" + D.substring(2, 4)),
                    G.r = ne,
                    G.g = ne,
                    G.b = ne,
                    G.a = parseInt("0x" + D.substring(4, 6));
                    break;
                case xr.RGB:
                    G.r = parseInt("0x" + D.substring(2, 4)),
                    G.g = parseInt("0x" + D.substring(4, 6)),
                    G.b = parseInt("0x" + D.substring(6, 8)),
                    G.a = 1;
                    break;
                case xr.RGBA:
                    G.r = parseInt("0x" + D.substring(2, 4)),
                    G.g = parseInt("0x" + D.substring(4, 6)),
                    G.b = parseInt("0x" + D.substring(6, 8)),
                    G.a = parseInt("0x" + D.substring(8, 10));
                    break;
                default:
                }
            }
            function d(D) {
                let A;
                switch (D) {
                case 1:
                    A = xr.INTENSITY;
                    break;
                case 2:
                    A = xr.INTENSITY_ALPHA;
                    break;
                case 3:
                    A = xr.RGB;
                    break;
                case 4:
                    A = xr.RGBA;
                    break;
                default:
                }
                return A
            }
            function x(D) {
                let A, G = rn, ne = rn, Q = D.fields;
                for (let he = 0, de = Q.length; he < de; he++) {
                    let ge = Q[he]
                      , le = ge.name
                      , xe = ge.values;
                    switch (le) {
                    case "image":
                        let Me = xe[0]
                          , Ne = xe[1]
                          , De = xe[2]
                          , Ve = d(De)
                          , Ze = new Uint8Array(4 * Me * Ne)
                          , We = {
                            r: 0,
                            g: 0,
                            b: 0,
                            a: 0
                        };
                        for (let Qe = 3, pe = 0, _e = xe.length; Qe < _e; Qe++,
                        pe++) {
                            p(xe[Qe], Ve, We);
                            let we = pe * 4;
                            Ze[we + 0] = We.r,
                            Ze[we + 1] = We.g,
                            Ze[we + 2] = We.b,
                            Ze[we + 3] = We.a
                        }
                        A = new Xa(Ze,Me,Ne),
                        A.needsUpdate = !0,
                        A.__type = Ve;
                        break;
                    case "repeatS":
                        xe[0] === !1 && (G = Zt);
                        break;
                    case "repeatT":
                        xe[0] === !1 && (ne = Zt);
                        break;
                    default:
                        console.warn("THREE.VRMLLoader: Unknown field:", le);
                        break
                    }
                }
                return A && (A.wrapS = G,
                A.wrapT = ne),
                A
            }
            function y(D) {
                let A, G = rn, ne = rn, Q = D.fields;
                for (let he = 0, de = Q.length; he < de; he++) {
                    let ge = Q[he]
                      , le = ge.name
                      , xe = ge.values;
                    switch (le) {
                    case "url":
                        let Me = xe[0];
                        Me && (A = te.load(Me));
                        break;
                    case "repeatS":
                        xe[0] === !1 && (G = Zt);
                        break;
                    case "repeatT":
                        xe[0] === !1 && (ne = Zt);
                        break;
                    default:
                        console.warn("THREE.VRMLLoader: Unknown field:", le);
                        break
                    }
                }
                return A && (A.wrapS = G,
                A.wrapT = ne),
                A
            }
            function _(D) {
                let A = {
                    center: new Ie,
                    rotation: new Ie,
                    scale: new Ie,
                    translation: new Ie
                }
                  , G = D.fields;
                for (let ne = 0, Q = G.length; ne < Q; ne++) {
                    let he = G[ne]
                      , de = he.name
                      , ge = he.values;
                    switch (de) {
                    case "center":
                        A.center.set(ge[0], ge[1]);
                        break;
                    case "rotation":
                        A.rotation = ge[0];
                        break;
                    case "scale":
                        A.scale.set(ge[0], ge[1]);
                        break;
                    case "translation":
                        A.translation.set(ge[0], ge[1]);
                        break;
                    default:
                        console.warn("THREE.VRMLLoader: Unknown field:", de);
                        break
                    }
                }
                return A
            }
            function S(D) {
                return D.fields[0].values
            }
            function N(D) {
                let A = {}
                  , G = D.fields;
                for (let ne = 0, Q = G.length; ne < Q; ne++) {
                    let he = G[ne]
                      , de = he.name
                      , ge = he.values;
                    switch (de) {
                    case "title":
                        A.title = ge[0];
                        break;
                    case "info":
                        A.info = ge;
                        break;
                    default:
                        console.warn("THREE.VRMLLoader: Unknown field:", de);
                        break
                    }
                }
                return A
            }
            function I(D) {
                let A, G, ne, Q, he = !0, de = !0, ge = 0, le, xe, Me, Ne, De = !0, Ve = !0, Ze = D.fields;
                for (let Ue = 0, pt = Ze.length; Ue < pt; Ue++) {
                    let mt = Ze[Ue]
                      , ot = mt.name
                      , Ke = mt.values;
                    switch (ot) {
                    case "color":
                        let ke = Ke[0];
                        ke !== null && (A = c(ke));
                        break;
                    case "coord":
                        let Be = Ke[0];
                        Be !== null && (G = c(Be));
                        break;
                    case "normal":
                        let Ye = Ke[0];
                        Ye !== null && (ne = c(Ye));
                        break;
                    case "texCoord":
                        let tt = Ke[0];
                        tt !== null && (Q = c(tt));
                        break;
                    case "ccw":
                        he = Ke[0];
                        break;
                    case "colorIndex":
                        le = Ke;
                        break;
                    case "colorPerVertex":
                        De = Ke[0];
                        break;
                    case "convex":
                        break;
                    case "coordIndex":
                        xe = Ke;
                        break;
                    case "creaseAngle":
                        ge = Ke[0];
                        break;
                    case "normalIndex":
                        Me = Ke;
                        break;
                    case "normalPerVertex":
                        Ve = Ke[0];
                        break;
                    case "solid":
                        de = Ke[0];
                        break;
                    case "texCoordIndex":
                        Ne = Ke;
                        break;
                    default:
                        console.warn("THREE.VRMLLoader: Unknown field:", ot);
                        break
                    }
                }
                if (xe === void 0)
                    return console.warn("THREE.VRMLLoader: Missing coordIndex."),
                    new wt;
                let We = U(xe, he), Qe, pe, _e;
                if (A)
                    if (De === !0)
                        if (le && le.length > 0) {
                            let Ue = U(le, he);
                            Qe = Y(We, Ue, A, 3)
                        } else
                            Qe = J(We, new qe(A,3));
                    else if (le && le.length > 0) {
                        let Ue = K(A, le)
                          , pt = W(Ue, xe);
                        Qe = X(We, pt)
                    } else {
                        let Ue = W(A, xe);
                        Qe = X(We, Ue)
                    }
                if (ne)
                    if (Ve === !0)
                        if (Me && Me.length > 0) {
                            let Ue = U(Me, he);
                            pe = Y(We, Ue, ne, 3)
                        } else
                            pe = J(We, new qe(ne,3));
                    else if (Me && Me.length > 0) {
                        let Ue = K(ne, Me)
                          , pt = W(Ue, xe);
                        pe = X(We, pt)
                    } else {
                        let Ue = W(ne, xe);
                        pe = X(We, Ue)
                    }
                else
                    pe = me(We, G, ge);
                if (Q)
                    if (Ne && Ne.length > 0) {
                        let Ue = U(Ne, he);
                        _e = Y(We, Ue, Q, 2)
                    } else
                        _e = J(We, new qe(Q,2));
                let we = new wt
                  , Fe = J(We, new qe(G,3));
                return we.setAttribute("position", Fe),
                we.setAttribute("normal", pe),
                Qe && we.setAttribute("color", Qe),
                _e && we.setAttribute("uv", _e),
                we._solid = de,
                we._type = "mesh",
                we
            }
            function O(D) {
                let A, G, ne, Q, he = !0, de = D.fields;
                for (let Ne = 0, De = de.length; Ne < De; Ne++) {
                    let Ve = de[Ne]
                      , Ze = Ve.name
                      , We = Ve.values;
                    switch (Ze) {
                    case "color":
                        let Qe = We[0];
                        Qe !== null && (A = c(Qe));
                        break;
                    case "coord":
                        let pe = We[0];
                        pe !== null && (G = c(pe));
                        break;
                    case "colorIndex":
                        ne = We;
                        break;
                    case "colorPerVertex":
                        he = We[0];
                        break;
                    case "coordIndex":
                        Q = We;
                        break;
                    default:
                        console.warn("THREE.VRMLLoader: Unknown field:", Ze);
                        break
                    }
                }
                let ge, le = re(Q);
                if (A)
                    if (he === !0)
                        if (ne.length > 0) {
                            let Ne = re(ne);
                            ge = Y(le, Ne, A, 3)
                        } else
                            ge = J(le, new qe(A,3));
                    else if (ne.length > 0) {
                        let Ne = K(A, ne)
                          , De = oe(Ne, Q);
                        ge = ce(le, De)
                    } else {
                        let Ne = oe(A, Q);
                        ge = ce(le, Ne)
                    }
                let xe = new wt
                  , Me = J(le, new qe(G,3));
                return xe.setAttribute("position", Me),
                ge && xe.setAttribute("color", ge),
                xe._type = "line",
                xe
            }
            function M(D) {
                let A, G, ne = D.fields;
                for (let he = 0, de = ne.length; he < de; he++) {
                    let ge = ne[he]
                      , le = ge.name
                      , xe = ge.values;
                    switch (le) {
                    case "color":
                        let Me = xe[0];
                        Me !== null && (A = c(Me));
                        break;
                    case "coord":
                        let Ne = xe[0];
                        Ne !== null && (G = c(Ne));
                        break;
                    default:
                        console.warn("THREE.VRMLLoader: Unknown field:", le);
                        break
                    }
                }
                let Q = new wt;
                return Q.setAttribute("position", new qe(G,3)),
                A && Q.setAttribute("color", new qe(A,3)),
                Q._type = "points",
                Q
            }
            function R(D) {
                let A = new ue(2,2,2)
                  , G = D.fields;
                for (let Q = 0, he = G.length; Q < he; Q++) {
                    let de = G[Q]
                      , ge = de.name
                      , le = de.values;
                    switch (ge) {
                    case "size":
                        A.x = le[0],
                        A.y = le[1],
                        A.z = le[2];
                        break;
                    default:
                        console.warn("THREE.VRMLLoader: Unknown field:", ge);
                        break
                    }
                }
                return new ps(A.x,A.y,A.z)
            }
            function q(D) {
                let A = 1
                  , G = 2
                  , ne = !1
                  , Q = D.fields;
                for (let de = 0, ge = Q.length; de < ge; de++) {
                    let le = Q[de]
                      , xe = le.name
                      , Me = le.values;
                    switch (xe) {
                    case "bottom":
                        ne = !Me[0];
                        break;
                    case "bottomRadius":
                        A = Me[0];
                        break;
                    case "height":
                        G = Me[0];
                        break;
                    case "side":
                        break;
                    default:
                        console.warn("THREE.VRMLLoader: Unknown field:", xe);
                        break
                    }
                }
                return new ja(A,G,16,1,ne)
            }
            function k(D) {
                let A = 1
                  , G = 2
                  , ne = D.fields;
                for (let he = 0, de = ne.length; he < de; he++) {
                    let ge = ne[he]
                      , le = ge.name
                      , xe = ge.values;
                    switch (le) {
                    case "bottom":
                        break;
                    case "radius":
                        A = xe[0];
                        break;
                    case "height":
                        G = xe[0];
                        break;
                    case "side":
                        break;
                    case "top":
                        break;
                    default:
                        console.warn("THREE.VRMLLoader: Unknown field:", le);
                        break
                    }
                }
                return new ko(A,A,G,16,1)
            }
            function B(D) {
                let A = 1
                  , G = D.fields;
                for (let Q = 0, he = G.length; Q < he; Q++) {
                    let de = G[Q]
                      , ge = de.name
                      , le = de.values;
                    switch (ge) {
                    case "radius":
                        A = le[0];
                        break;
                    default:
                        console.warn("THREE.VRMLLoader: Unknown field:", ge);
                        break
                    }
                }
                return new Ys(A,16,16)
            }
            function P(D) {
                let A, G, ne, Q, he = !0, de = !0, ge = !0, le = !0, xe = 0, Me = 2, Ne = 2, De = 1, Ve = 1, Ze = D.fields;
                for (let Ke = 0, ke = Ze.length; Ke < ke; Ke++) {
                    let Be = Ze[Ke]
                      , Ye = Be.name
                      , tt = Be.values;
                    switch (Ye) {
                    case "color":
                        let qt = tt[0];
                        qt !== null && (A = c(qt));
                        break;
                    case "normal":
                        let Gi = tt[0];
                        Gi !== null && (G = c(Gi));
                        break;
                    case "texCoord":
                        let Vi = tt[0];
                        Vi !== null && (ne = c(Vi));
                        break;
                    case "height":
                        Q = tt;
                        break;
                    case "ccw":
                        le = tt[0];
                        break;
                    case "colorPerVertex":
                        he = tt[0];
                        break;
                    case "creaseAngle":
                        xe = tt[0];
                        break;
                    case "normalPerVertex":
                        de = tt[0];
                        break;
                    case "solid":
                        ge = tt[0];
                        break;
                    case "xDimension":
                        Me = tt[0];
                        break;
                    case "xSpacing":
                        De = tt[0];
                        break;
                    case "zDimension":
                        Ne = tt[0];
                        break;
                    case "zSpacing":
                        Ve = tt[0];
                        break;
                    default:
                        console.warn("THREE.VRMLLoader: Unknown field:", Ye);
                        break
                    }
                }
                let We = []
                  , Qe = []
                  , pe = []
                  , _e = [];
                for (let Ke = 0; Ke < Ne; Ke++)
                    for (let ke = 0; ke < Me; ke++) {
                        let Be = Ke * Me + ke
                          , Ye = De * Ke
                          , tt = Q[Be]
                          , qt = Ve * ke;
                        if (We.push(Ye, tt, qt),
                        A && he === !0) {
                            let Gi = A[Be * 3 + 0]
                              , Vi = A[Be * 3 + 1]
                              , xo = A[Be * 3 + 2];
                            pe.push(Gi, Vi, xo)
                        }
                        if (G && de === !0) {
                            let Gi = G[Be * 3 + 0]
                              , Vi = G[Be * 3 + 1]
                              , xo = G[Be * 3 + 2];
                            Qe.push(Gi, Vi, xo)
                        }
                        if (ne) {
                            let Gi = ne[Be * 2 + 0]
                              , Vi = ne[Be * 2 + 1];
                            _e.push(Gi, Vi)
                        } else
                            _e.push(Ke / (Me - 1), ke / (Ne - 1))
                    }
                let we = [];
                for (let Ke = 0; Ke < Me - 1; Ke++)
                    for (let ke = 0; ke < Ne - 1; ke++) {
                        let Be = Ke + ke * Me
                          , Ye = Ke + (ke + 1) * Me
                          , tt = Ke + 1 + (ke + 1) * Me
                          , qt = Ke + 1 + ke * Me;
                        le === !0 ? (we.push(Be, tt, Ye),
                        we.push(tt, Be, qt)) : (we.push(Be, Ye, tt),
                        we.push(tt, qt, Be))
                    }
                let Fe = J(we, new qe(We,3)), Ue = J(we, new qe(_e,2)), pt, mt;
                if (A)
                    if (he === !1) {
                        for (let Ke = 0; Ke < Me - 1; Ke++)
                            for (let ke = 0; ke < Ne - 1; ke++) {
                                let Be = Ke + ke * (Me - 1)
                                  , Ye = A[Be * 3 + 0]
                                  , tt = A[Be * 3 + 1]
                                  , qt = A[Be * 3 + 2];
                                pe.push(Ye, tt, qt),
                                pe.push(Ye, tt, qt),
                                pe.push(Ye, tt, qt),
                                pe.push(Ye, tt, qt),
                                pe.push(Ye, tt, qt),
                                pe.push(Ye, tt, qt)
                            }
                        pt = new qe(pe,3)
                    } else
                        pt = J(we, new qe(pe,3));
                if (G)
                    if (de === !1) {
                        for (let Ke = 0; Ke < Me - 1; Ke++)
                            for (let ke = 0; ke < Ne - 1; ke++) {
                                let Be = Ke + ke * (Me - 1)
                                  , Ye = G[Be * 3 + 0]
                                  , tt = G[Be * 3 + 1]
                                  , qt = G[Be * 3 + 2];
                                Qe.push(Ye, tt, qt),
                                Qe.push(Ye, tt, qt),
                                Qe.push(Ye, tt, qt),
                                Qe.push(Ye, tt, qt),
                                Qe.push(Ye, tt, qt),
                                Qe.push(Ye, tt, qt)
                            }
                        mt = new qe(Qe,3)
                    } else
                        mt = J(we, new qe(Qe,3));
                else
                    mt = me(we, We, xe);
                let ot = new wt;
                return ot.setAttribute("position", Fe),
                ot.setAttribute("normal", mt),
                ot.setAttribute("uv", Ue),
                pt && ot.setAttribute("color", pt),
                ot._solid = ge,
                ot._type = "mesh",
                ot
            }
            function C(D) {
                let A = [1, 1, 1, -1, -1, -1, -1, 1, 1, 1], G = [0, 0, 0, 0, 1, 0], ne, Q, he = !0, de = !0, ge = 0, le = !0, xe = !0, Me = D.fields;
                for (let ot = 0, Ke = Me.length; ot < Ke; ot++) {
                    let ke = Me[ot]
                      , Be = ke.name
                      , Ye = ke.values;
                    switch (Be) {
                    case "beginCap":
                        he = Ye[0];
                        break;
                    case "ccw":
                        de = Ye[0];
                        break;
                    case "convex":
                        break;
                    case "creaseAngle":
                        ge = Ye[0];
                        break;
                    case "crossSection":
                        A = Ye;
                        break;
                    case "endCap":
                        le = Ye[0];
                        break;
                    case "orientation":
                        Q = Ye;
                        break;
                    case "scale":
                        ne = Ye;
                        break;
                    case "solid":
                        xe = Ye[0];
                        break;
                    case "spine":
                        G = Ye;
                        break;
                    default:
                        console.warn("THREE.VRMLLoader: Unknown field:", Be);
                        break
                    }
                }
                let Ne = A[0] === A[A.length - 2] && A[1] === A[A.length - 1]
                  , De = []
                  , Ve = new ue
                  , Ze = new ue
                  , We = new ue
                  , Qe = new ue
                  , pe = new Sn;
                for (let ot = 0, Ke = 0, ke = 0, Be = G.length; ot < Be; ot += 3,
                Ke += 2,
                ke += 4) {
                    Ve.fromArray(G, ot),
                    Ze.x = ne ? ne[Ke + 0] : 1,
                    Ze.y = 1,
                    Ze.z = ne ? ne[Ke + 1] : 1,
                    We.x = Q ? Q[ke + 0] : 0,
                    We.y = Q ? Q[ke + 1] : 0,
                    We.z = Q ? Q[ke + 2] : 1;
                    let Ye = Q ? Q[ke + 3] : 0;
                    for (let tt = 0, qt = A.length; tt < qt; tt += 2)
                        Qe.x = A[tt + 0],
                        Qe.y = 0,
                        Qe.z = A[tt + 1],
                        Qe.multiply(Ze),
                        pe.setFromAxisAngle(We, Ye),
                        Qe.applyQuaternion(pe),
                        Qe.add(Ve),
                        De.push(Qe.x, Qe.y, Qe.z)
                }
                let _e = []
                  , we = G.length / 3
                  , Fe = A.length / 2;
                for (let ot = 0; ot < we - 1; ot++)
                    for (let Ke = 0; Ke < Fe - 1; Ke++) {
                        let ke = Ke + ot * Fe
                          , Be = Ke + 1 + ot * Fe
                          , Ye = Ke + (ot + 1) * Fe
                          , tt = Ke + 1 + (ot + 1) * Fe;
                        Ke === Fe - 2 && Ne === !0 && (Be = ot * Fe,
                        tt = (ot + 1) * Fe),
                        de === !0 ? (_e.push(ke, Be, Ye),
                        _e.push(Ye, Be, tt)) : (_e.push(ke, Ye, Be),
                        _e.push(Ye, tt, Be))
                    }
                if (he === !0 || le === !0) {
                    let ot = [];
                    for (let Be = 0, Ye = A.length; Be < Ye; Be += 2)
                        ot.push(new Ie(A[Be],A[Be + 1]));
                    let Ke = ji.triangulateShape(ot, [])
                      , ke = [];
                    for (let Be = 0, Ye = Ke.length; Be < Ye; Be++) {
                        let tt = Ke[Be];
                        ke.push(tt[0], tt[1], tt[2])
                    }
                    if (he === !0)
                        for (let Be = 0, Ye = ke.length; Be < Ye; Be += 3)
                            de === !0 ? _e.push(ke[Be + 0], ke[Be + 1], ke[Be + 2]) : _e.push(ke[Be + 0], ke[Be + 2], ke[Be + 1]);
                    if (le === !0) {
                        let Be = Fe * (we - 1);
                        for (let Ye = 0, tt = ke.length; Ye < tt; Ye += 3)
                            de === !0 ? _e.push(Be + ke[Ye + 0], Be + ke[Ye + 2], Be + ke[Ye + 1]) : _e.push(Be + ke[Ye + 0], Be + ke[Ye + 1], Be + ke[Ye + 2])
                    }
                }
                let Ue = J(_e, new qe(De,3))
                  , pt = me(_e, De, ge)
                  , mt = new wt;
                return mt.setAttribute("position", Ue),
                mt.setAttribute("normal", pt),
                mt._solid = xe,
                mt._type = "mesh",
                mt
            }
            function L(D) {
                let A = n[D]
                  , G = c(A);
                return G.isObject3D || G.isMaterial ? G.clone() : G
            }
            function F(D, A) {
                for (let G = 0, ne = D.length; G < ne; G++) {
                    let Q = c(D[G]);
                    Q instanceof bt && A.add(Q)
                }
            }
            function U(D, A) {
                let G = []
                  , ne = 0;
                for (let Q = 0, he = D.length; Q < he; Q++) {
                    let de = D[ne]
                      , ge = D[Q + (A ? 1 : 2)]
                      , le = D[Q + (A ? 2 : 1)];
                    G.push(de, ge, le),
                    (D[Q + 3] === -1 || Q + 3 >= he) && (Q += 3,
                    ne = Q + 1)
                }
                return G
            }
            function W(D, A) {
                let G = []
                  , ne = 0;
                for (let Q = 0, he = A.length; Q < he; Q++) {
                    let de = ne * 3
                      , ge = D[de]
                      , le = D[de + 1]
                      , xe = D[de + 2];
                    G.push(ge, le, xe),
                    (A[Q + 3] === -1 || Q + 3 >= he) && (Q += 3,
                    ne++)
                }
                return G
            }
            function K(D, A) {
                let G = [];
                for (let ne = 0, Q = A.length; ne < Q; ne++) {
                    let de = A[ne] * 3
                      , ge = D[de]
                      , le = D[de + 1]
                      , xe = D[de + 2];
                    G.push(ge, le, xe)
                }
                return G
            }
            function re(D) {
                let A = [];
                for (let G = 0, ne = D.length; G < ne; G++) {
                    let Q = D[G]
                      , he = D[G + 1];
                    A.push(Q, he),
                    (D[G + 2] === -1 || G + 2 >= ne) && (G += 2)
                }
                return A
            }
            function oe(D, A) {
                let G = []
                  , ne = 0;
                for (let Q = 0, he = A.length; Q < he; Q++) {
                    let de = ne * 3
                      , ge = D[de]
                      , le = D[de + 1]
                      , xe = D[de + 2];
                    G.push(ge, le, xe),
                    (A[Q + 2] === -1 || Q + 2 >= he) && (Q += 2,
                    ne++)
                }
                return G
            }
            let j = new ue
              , w = new ue
              , b = new ue
              , E = new Ie
              , T = new Ie
              , H = new Ie;
            function Y(D, A, G, ne) {
                let Q = [];
                for (let he = 0, de = D.length; he < de; he += 3) {
                    let ge = A[he]
                      , le = A[he + 1]
                      , xe = A[he + 2];
                    ne === 2 ? (E.fromArray(G, ge * ne),
                    T.fromArray(G, le * ne),
                    H.fromArray(G, xe * ne),
                    Q.push(E.x, E.y),
                    Q.push(T.x, T.y),
                    Q.push(H.x, H.y)) : (j.fromArray(G, ge * ne),
                    w.fromArray(G, le * ne),
                    b.fromArray(G, xe * ne),
                    Q.push(j.x, j.y, j.z),
                    Q.push(w.x, w.y, w.z),
                    Q.push(b.x, b.y, b.z))
                }
                return new qe(Q,ne)
            }
            function X(D, A) {
                let G = [];
                for (let ne = 0, Q = 0, he = D.length; ne < he; ne += 3,
                Q++)
                    j.fromArray(A, Q * 3),
                    G.push(j.x, j.y, j.z),
                    G.push(j.x, j.y, j.z),
                    G.push(j.x, j.y, j.z);
                return new qe(G,3)
            }
            function ce(D, A) {
                let G = [];
                for (let ne = 0, Q = 0, he = D.length; ne < he; ne += 2,
                Q++)
                    j.fromArray(A, Q * 3),
                    G.push(j.x, j.y, j.z),
                    G.push(j.x, j.y, j.z);
                return new qe(G,3)
            }
            function J(D, A) {
                let G = A.array
                  , ne = A.itemSize
                  , Q = new G.constructor(D.length * ne)
                  , he = 0
                  , de = 0;
                for (let ge = 0, le = D.length; ge < le; ge++) {
                    he = D[ge] * ne;
                    for (let xe = 0; xe < ne; xe++)
                        Q[de++] = G[he++]
                }
                return new qe(Q,ne)
            }
            let ae = new ue
              , ie = new ue;
            function me(D, A, G) {
                let ne = []
                  , Q = {};
                for (let de = 0, ge = D.length; de < ge; de += 3) {
                    let le = D[de]
                      , xe = D[de + 1]
                      , Me = D[de + 2]
                      , Ne = new ym(le,xe,Me);
                    j.fromArray(A, le * 3),
                    w.fromArray(A, xe * 3),
                    b.fromArray(A, Me * 3),
                    ie.subVectors(b, w),
                    ae.subVectors(j, w),
                    ie.cross(ae),
                    ie.normalize(),
                    Ne.normal.copy(ie),
                    Q[le] === void 0 && (Q[le] = []),
                    Q[xe] === void 0 && (Q[xe] = []),
                    Q[Me] === void 0 && (Q[Me] = []),
                    Q[le].push(Ne.normal),
                    Q[xe].push(Ne.normal),
                    Q[Me].push(Ne.normal),
                    ne.push(Ne)
                }
                let he = [];
                for (let de = 0, ge = ne.length; de < ge; de++) {
                    let le = ne[de]
                      , xe = ve(Q[le.a], le.normal, G)
                      , Me = ve(Q[le.b], le.normal, G)
                      , Ne = ve(Q[le.c], le.normal, G);
                    j.fromArray(A, le.a * 3),
                    w.fromArray(A, le.b * 3),
                    b.fromArray(A, le.c * 3),
                    he.push(xe.x, xe.y, xe.z),
                    he.push(Me.x, Me.y, Me.z),
                    he.push(Ne.x, Ne.y, Ne.z)
                }
                return new qe(he,3)
            }
            function ve(D, A, G) {
                let ne = new ue;
                if (G === 0)
                    ne.copy(A);
                else
                    for (let Q = 0, he = D.length; Q < he; Q++)
                        D[Q].angleTo(A) < G && ne.add(D[Q]);
                return ne.normalize()
            }
            function be(D) {
                let A = [];
                for (let G = 0, ne = D.length; G < ne; G += 3)
                    A.push(new $e(D[G],D[G + 1],D[G + 2]));
                return A
            }
            function fe(D, A, G, ne, Q) {
                let he = []
                  , de = Q === !0 ? 0 : Math.PI;
                for (let De = 0, Ve = ne.length; De < Ve; De++) {
                    let Ze = De === 0 ? 0 : G[De - 1];
                    Ze = Q === !0 ? Ze : de - Ze;
                    let We = new ue;
                    We.setFromSphericalCoords(A, Ze, 0),
                    he.push(We)
                }
                let ge = D.index
                  , le = D.attributes.position
                  , xe = new zn(new Float32Array(D.attributes.position.count * 3),3)
                  , Me = new ue
                  , Ne = new $e;
                for (let De = 0; De < ge.count; De++) {
                    let Ve = ge.getX(De);
                    Me.fromBufferAttribute(le, Ve);
                    let Ze, We, Qe = 1;
                    for (let we = 1; we < he.length; we++) {
                        Ze = we - 1,
                        We = we;
                        let Fe = he[Ze]
                          , Ue = he[We];
                        if (Q === !0) {
                            if (Me.y <= Fe.y && Me.y > Ue.y) {
                                Qe = Math.abs(Fe.y - Me.y) / Math.abs(Fe.y - Ue.y);
                                break
                            }
                        } else if (Me.y >= Fe.y && Me.y < Ue.y) {
                            Qe = Math.abs(Fe.y - Me.y) / Math.abs(Fe.y - Ue.y);
                            break
                        }
                    }
                    let pe = ne[Ze]
                      , _e = ne[We];
                    Ne.copy(pe).lerp(_e, Qe),
                    xe.setXYZ(Ve, Ne.r, Ne.g, Ne.b)
                }
                D.setAttribute("color", xe)
            }
            let te = new Zi(this.manager);
            if (te.setPath(this.resourcePath || t).setCrossOrigin(this.crossOrigin),
            e.indexOf("#VRML V2.0") === -1)
                throw Error("THREE.VRMLLexer: Version of VRML asset not supported.");
            let Ee = i(e);
            return a(Ee)
        }
    }
      , gm = class {
        constructor(e) {
            this.lexer = new wl.Lexer(e)
        }
        lex(e) {
            let t = this.lexer.tokenize(e);
            if (t.errors.length > 0)
                throw console.error(t.errors),
                Error("THREE.VRMLLexer: Lexing errors detected.");
            return t
        }
    }
      , Zw = wl.CstParser
      , vm = class extends Zw {
        constructor(e) {
            super(e);
            let t = this
              , n = e.Version
              , i = e.LCurly
              , s = e.RCurly
              , o = e.LSquare
              , a = e.RSquare
              , l = e.Identifier
              , c = e.RouteIdentifier
              , u = e.StringLiteral
              , h = e.HexLiteral
              , f = e.NumberLiteral
              , m = e.TrueLiteral
              , g = e.FalseLiteral
              , v = e.NullLiteral
              , p = e.DEF
              , d = e.USE
              , x = e.ROUTE
              , y = e.TO
              , _ = e.NodeName;
            t.RULE("vrml", function() {
                t.SUBRULE(t.version),
                t.AT_LEAST_ONE(function() {
                    t.SUBRULE(t.node)
                }),
                t.MANY(function() {
                    t.SUBRULE(t.route)
                })
            }),
            t.RULE("version", function() {
                t.CONSUME(n)
            }),
            t.RULE("node", function() {
                t.OPTION(function() {
                    t.SUBRULE(t.def)
                }),
                t.CONSUME(_),
                t.CONSUME(i),
                t.MANY(function() {
                    t.SUBRULE(t.field)
                }),
                t.CONSUME(s)
            }),
            t.RULE("field", function() {
                t.CONSUME(l),
                t.OR2([{
                    ALT: function() {
                        t.SUBRULE(t.singleFieldValue)
                    }
                }, {
                    ALT: function() {
                        t.SUBRULE(t.multiFieldValue)
                    }
                }])
            }),
            t.RULE("def", function() {
                t.CONSUME(p),
                t.OR([{
                    ALT: function() {
                        t.CONSUME(l)
                    }
                }, {
                    ALT: function() {
                        t.CONSUME(_)
                    }
                }])
            }),
            t.RULE("use", function() {
                t.CONSUME(d),
                t.OR([{
                    ALT: function() {
                        t.CONSUME(l)
                    }
                }, {
                    ALT: function() {
                        t.CONSUME(_)
                    }
                }])
            }),
            t.RULE("singleFieldValue", function() {
                t.AT_LEAST_ONE(function() {
                    t.OR([{
                        ALT: function() {
                            t.SUBRULE(t.node)
                        }
                    }, {
                        ALT: function() {
                            t.SUBRULE(t.use)
                        }
                    }, {
                        ALT: function() {
                            t.CONSUME(u)
                        }
                    }, {
                        ALT: function() {
                            t.CONSUME(h)
                        }
                    }, {
                        ALT: function() {
                            t.CONSUME(f)
                        }
                    }, {
                        ALT: function() {
                            t.CONSUME(m)
                        }
                    }, {
                        ALT: function() {
                            t.CONSUME(g)
                        }
                    }, {
                        ALT: function() {
                            t.CONSUME(v)
                        }
                    }])
                })
            }),
            t.RULE("multiFieldValue", function() {
                t.CONSUME(o),
                t.MANY(function() {
                    t.OR([{
                        ALT: function() {
                            t.SUBRULE(t.node)
                        }
                    }, {
                        ALT: function() {
                            t.SUBRULE(t.use)
                        }
                    }, {
                        ALT: function() {
                            t.CONSUME(u)
                        }
                    }, {
                        ALT: function() {
                            t.CONSUME(h)
                        }
                    }, {
                        ALT: function() {
                            t.CONSUME(f)
                        }
                    }, {
                        ALT: function() {
                            t.CONSUME(v)
                        }
                    }])
                }),
                t.CONSUME(a)
            }),
            t.RULE("route", function() {
                t.CONSUME(x),
                t.CONSUME(c),
                t.CONSUME(y),
                t.CONSUME2(c)
            }),
            this.performSelfAnalysis()
        }
    }
      , ym = class {
        constructor(e, t, n) {
            this.a = e,
            this.b = t,
            this.c = n,
            this.normal = new ue
        }
    }
      , xr = {
        INTENSITY: 1,
        INTENSITY_ALPHA: 2,
        RGB: 3,
        RGBA: 4
    };
    var xm = ct
      , bf = class extends Hn {
        constructor(e) {
            super(e),
            this.availableExtensions = []
        }
        load(e, t, n, i) {
            let s = this
              , o = new Ni(s.manager);
            o.setPath(s.path),
            o.setResponseType("arraybuffer"),
            o.setRequestHeader(s.requestHeader),
            o.setWithCredentials(s.withCredentials),
            o.load(e, function(a) {
                try {
                    t(s.parse(a))
                } catch (l) {
                    i ? i(l) : console.error(l),
                    s.manager.itemError(e)
                }
            }, n, i)
        }
        parse(e) {
            let t = this
              , n = new Zi(this.manager);
            function i(w) {
                let b = null, E = null, T, H, Y = [], X = [], ce, J = {}, ae = {}, ie = {}, me = new TextDecoder;
                try {
                    b = Jv(new Uint8Array(w))
                } catch (te) {
                    if (te instanceof ReferenceError)
                        return console.error("THREE.3MFLoader: fflate missing and file is compressed."),
                        null
                }
                for (E in b)
                    E.match(/\_rels\/.rels$/) ? T = E : E.match(/3D\/_rels\/.*\.model\.rels$/) ? H = E : E.match(/^3D\/.*\.model$/) ? Y.push(E) : E.match(/^3D\/Textures?\/.*/) && X.push(E);
                let ve = b[T]
                  , be = me.decode(ve)
                  , fe = s(be);
                if (H) {
                    let te = b[H]
                      , Ee = me.decode(te);
                    ce = s(Ee)
                }
                for (let te = 0; te < Y.length; te++) {
                    let Ee = Y[te]
                      , Le = b[Ee]
                      , D = me.decode(Le)
                      , A = new DOMParser().parseFromString(D, "application/xml");
                    A.documentElement.nodeName.toLowerCase() !== "model" && console.error("THREE.3MFLoader: Error loading 3MF - no 3MF document found: ", Ee);
                    let G = A.querySelector("model")
                      , ne = {};
                    for (let he = 0; he < G.attributes.length; he++) {
                        let de = G.attributes[he];
                        de.name.match(/^xmlns:(.+)$/) && (ne[de.value] = RegExp.$1)
                    }
                    let Q = _(G);
                    Q.xml = G,
                    0 < Object.keys(ne).length && (Q.extensions = ne),
                    J[Ee] = Q
                }
                for (let te = 0; te < X.length; te++) {
                    let Ee = X[te];
                    ie[Ee] = b[Ee].buffer
                }
                return {
                    rels: fe,
                    modelRels: ce,
                    model: J,
                    printTicket: ae,
                    texture: ie
                }
            }
            function s(w) {
                let b = []
                  , T = new DOMParser().parseFromString(w, "application/xml").querySelectorAll("Relationship");
                for (let H = 0; H < T.length; H++) {
                    let Y = T[H]
                      , X = {
                        target: Y.getAttribute("Target"),
                        id: Y.getAttribute("Id"),
                        type: Y.getAttribute("Type")
                    };
                    b.push(X)
                }
                return b
            }
            function o(w) {
                let b = {};
                for (let E = 0; E < w.length; E++) {
                    let T = w[E]
                      , H = T.getAttribute("name");
                    0 <= ["Title", "Designer", "Description", "Copyright", "LicenseTerms", "Rating", "CreationDate", "ModificationDate"].indexOf(H) && (b[H] = T.textContent)
                }
                return b
            }
            function a(w) {
                let b = {
                    id: w.getAttribute("id"),
                    basematerials: []
                }
                  , E = w.querySelectorAll("base");
                for (let T = 0; T < E.length; T++) {
                    let H = E[T]
                      , Y = f(H);
                    Y.index = T,
                    b.basematerials.push(Y)
                }
                return b
            }
            function l(w) {
                return {
                    id: w.getAttribute("id"),
                    path: w.getAttribute("path"),
                    contenttype: w.getAttribute("contenttype"),
                    tilestyleu: w.getAttribute("tilestyleu"),
                    tilestylev: w.getAttribute("tilestylev"),
                    filter: w.getAttribute("filter")
                }
            }
            function c(w) {
                let b = {
                    id: w.getAttribute("id"),
                    texid: w.getAttribute("texid"),
                    displaypropertiesid: w.getAttribute("displaypropertiesid")
                }
                  , E = w.querySelectorAll("tex2coord")
                  , T = [];
                for (let H = 0; H < E.length; H++) {
                    let Y = E[H]
                      , X = Y.getAttribute("u")
                      , ce = Y.getAttribute("v");
                    T.push(parseFloat(X), parseFloat(ce))
                }
                return b.uvs = new Float32Array(T),
                b
            }
            function u(w) {
                let b = {
                    id: w.getAttribute("id"),
                    displaypropertiesid: w.getAttribute("displaypropertiesid")
                }
                  , E = w.querySelectorAll("color")
                  , T = []
                  , H = new $e;
                for (let Y = 0; Y < E.length; Y++) {
                    let ce = E[Y].getAttribute("color");
                    H.setStyle(ce.substring(0, 7), xm),
                    T.push(H.r, H.g, H.b)
                }
                return b.colors = new Float32Array(T),
                b
            }
            function h(w) {
                let b = {
                    id: w.getAttribute("id")
                }
                  , E = w.querySelectorAll("pbmetallic")
                  , T = [];
                for (let H = 0; H < E.length; H++) {
                    let Y = E[H];
                    T.push({
                        name: Y.getAttribute("name"),
                        metallicness: parseFloat(Y.getAttribute("metallicness")),
                        roughness: parseFloat(Y.getAttribute("roughness"))
                    })
                }
                return b.data = T,
                b
            }
            function f(w) {
                let b = {};
                return b.name = w.getAttribute("name"),
                b.displaycolor = w.getAttribute("displaycolor"),
                b.displaypropertiesid = w.getAttribute("displaypropertiesid"),
                b
            }
            function m(w) {
                let b = {}
                  , E = []
                  , T = w.querySelectorAll("vertices vertex");
                for (let ce = 0; ce < T.length; ce++) {
                    let J = T[ce]
                      , ae = J.getAttribute("x")
                      , ie = J.getAttribute("y")
                      , me = J.getAttribute("z");
                    E.push(parseFloat(ae), parseFloat(ie), parseFloat(me))
                }
                b.vertices = new Float32Array(E);
                let H = []
                  , Y = []
                  , X = w.querySelectorAll("triangles triangle");
                for (let ce = 0; ce < X.length; ce++) {
                    let J = X[ce]
                      , ae = J.getAttribute("v1")
                      , ie = J.getAttribute("v2")
                      , me = J.getAttribute("v3")
                      , ve = J.getAttribute("p1")
                      , be = J.getAttribute("p2")
                      , fe = J.getAttribute("p3")
                      , te = J.getAttribute("pid")
                      , Ee = {};
                    Ee.v1 = parseInt(ae, 10),
                    Ee.v2 = parseInt(ie, 10),
                    Ee.v3 = parseInt(me, 10),
                    Y.push(Ee.v1, Ee.v2, Ee.v3),
                    ve && (Ee.p1 = parseInt(ve, 10)),
                    be && (Ee.p2 = parseInt(be, 10)),
                    fe && (Ee.p3 = parseInt(fe, 10)),
                    te && (Ee.pid = te),
                    0 < Object.keys(Ee).length && H.push(Ee)
                }
                return b.triangleProperties = H,
                b.triangles = new Uint32Array(Y),
                b
            }
            function g(w) {
                let b = []
                  , E = w.querySelectorAll("component");
                for (let T = 0; T < E.length; T++) {
                    let H = E[T]
                      , Y = v(H);
                    b.push(Y)
                }
                return b
            }
            function v(w) {
                let b = {};
                b.objectId = w.getAttribute("objectid");
                let E = w.getAttribute("transform");
                return E && (b.transform = p(E)),
                b
            }
            function p(w) {
                let b = [];
                w.split(" ").forEach(function(T) {
                    b.push(parseFloat(T))
                });
                let E = new je;
                return E.set(b[0], b[3], b[6], b[9], b[1], b[4], b[7], b[10], b[2], b[5], b[8], b[11], 0, 0, 0, 1),
                E
            }
            function d(w) {
                let b = {
                    type: w.getAttribute("type")
                }
                  , E = w.getAttribute("id");
                E && (b.id = E);
                let T = w.getAttribute("pid");
                T && (b.pid = T);
                let H = w.getAttribute("pindex");
                H && (b.pindex = H);
                let Y = w.getAttribute("thumbnail");
                Y && (b.thumbnail = Y);
                let X = w.getAttribute("partnumber");
                X && (b.partnumber = X);
                let ce = w.getAttribute("name");
                ce && (b.name = ce);
                let J = w.querySelector("mesh");
                J && (b.mesh = m(J));
                let ae = w.querySelector("components");
                return ae && (b.components = g(ae)),
                b
            }
            function x(w) {
                let b = {};
                b.basematerials = {};
                let E = w.querySelectorAll("basematerials");
                for (let J = 0; J < E.length; J++) {
                    let ae = E[J]
                      , ie = a(ae);
                    b.basematerials[ie.id] = ie
                }
                b.texture2d = {};
                let T = w.querySelectorAll("texture2d");
                for (let J = 0; J < T.length; J++) {
                    let ae = T[J]
                      , ie = l(ae);
                    b.texture2d[ie.id] = ie
                }
                b.colorgroup = {};
                let H = w.querySelectorAll("colorgroup");
                for (let J = 0; J < H.length; J++) {
                    let ae = H[J]
                      , ie = u(ae);
                    b.colorgroup[ie.id] = ie
                }
                b.pbmetallicdisplayproperties = {};
                let Y = w.querySelectorAll("pbmetallicdisplayproperties");
                for (let J = 0; J < Y.length; J++) {
                    let ae = Y[J]
                      , ie = h(ae);
                    b.pbmetallicdisplayproperties[ie.id] = ie
                }
                b.texture2dgroup = {};
                let X = w.querySelectorAll("texture2dgroup");
                for (let J = 0; J < X.length; J++) {
                    let ae = X[J]
                      , ie = c(ae);
                    b.texture2dgroup[ie.id] = ie
                }
                b.object = {};
                let ce = w.querySelectorAll("object");
                for (let J = 0; J < ce.length; J++) {
                    let ae = ce[J]
                      , ie = d(ae);
                    b.object[ie.id] = ie
                }
                return b
            }
            function y(w) {
                let b = []
                  , E = w.querySelectorAll("item");
                for (let T = 0; T < E.length; T++) {
                    let H = E[T]
                      , Y = {
                        objectId: H.getAttribute("objectid")
                    }
                      , X = H.getAttribute("transform");
                    X && (Y.transform = p(X)),
                    b.push(Y)
                }
                return b
            }
            function _(w) {
                let b = {
                    unit: w.getAttribute("unit") || "millimeter"
                }
                  , E = w.querySelectorAll("metadata");
                E && (b.metadata = o(E));
                let T = w.querySelector("resources");
                T && (b.resources = x(T));
                let H = w.querySelector("build");
                return H && (b.build = y(H)),
                b
            }
            function S(w, b, E, T) {
                let H = w.texid
                  , X = E.resources.texture2d[H];
                if (X) {
                    let ce = T[X.path]
                      , J = X.contenttype
                      , ae = new Blob([ce],{
                        type: J
                    })
                      , ie = URL.createObjectURL(ae)
                      , me = n.load(ie, function() {
                        URL.revokeObjectURL(ie)
                    });
                    switch (me.colorSpace = xm,
                    X.tilestyleu) {
                    case "wrap":
                        me.wrapS = rn;
                        break;
                    case "mirror":
                        me.wrapS = Ua;
                        break;
                    case "none":
                    case "clamp":
                        me.wrapS = Zt;
                        break;
                    default:
                        me.wrapS = rn
                    }
                    switch (X.tilestylev) {
                    case "wrap":
                        me.wrapT = rn;
                        break;
                    case "mirror":
                        me.wrapT = Ua;
                        break;
                    case "none":
                    case "clamp":
                        me.wrapT = Zt;
                        break;
                    default:
                        me.wrapT = rn
                    }
                    switch (X.filter) {
                    case "auto":
                        me.magFilter = bn,
                        me.minFilter = lr;
                        break;
                    case "linear":
                        me.magFilter = bn,
                        me.minFilter = bn;
                        break;
                    case "nearest":
                        me.magFilter = Tn,
                        me.minFilter = Tn;
                        break;
                    default:
                        me.magFilter = bn,
                        me.minFilter = lr
                    }
                    return me
                } else
                    return null
            }
            function N(w, b, E, T, H, Y, X) {
                let ce = X.pindex
                  , J = {};
                for (let me = 0, ve = b.length; me < ve; me++) {
                    let be = b[me]
                      , fe = be.p1 !== void 0 ? be.p1 : ce;
                    J[fe] === void 0 && (J[fe] = []),
                    J[fe].push(be)
                }
                let ae = Object.keys(J)
                  , ie = [];
                for (let me = 0, ve = ae.length; me < ve; me++) {
                    let be = ae[me]
                      , fe = J[be]
                      , te = w.basematerials[be]
                      , Ee = C(te, T, H, Y, X, L)
                      , Le = new wt
                      , D = []
                      , A = E.vertices;
                    for (let ne = 0, Q = fe.length; ne < Q; ne++) {
                        let he = fe[ne];
                        D.push(A[he.v1 * 3 + 0]),
                        D.push(A[he.v1 * 3 + 1]),
                        D.push(A[he.v1 * 3 + 2]),
                        D.push(A[he.v2 * 3 + 0]),
                        D.push(A[he.v2 * 3 + 1]),
                        D.push(A[he.v2 * 3 + 2]),
                        D.push(A[he.v3 * 3 + 0]),
                        D.push(A[he.v3 * 3 + 1]),
                        D.push(A[he.v3 * 3 + 2])
                    }
                    Le.setAttribute("position", new qe(D,3));
                    let G = new Ht(Le,Ee);
                    ie.push(G)
                }
                return ie
            }
            function I(w, b, E, T, H, Y, X) {
                let ce = new wt
                  , J = []
                  , ae = []
                  , ie = E.vertices
                  , me = w.uvs;
                for (let te = 0, Ee = b.length; te < Ee; te++) {
                    let Le = b[te];
                    J.push(ie[Le.v1 * 3 + 0]),
                    J.push(ie[Le.v1 * 3 + 1]),
                    J.push(ie[Le.v1 * 3 + 2]),
                    J.push(ie[Le.v2 * 3 + 0]),
                    J.push(ie[Le.v2 * 3 + 1]),
                    J.push(ie[Le.v2 * 3 + 2]),
                    J.push(ie[Le.v3 * 3 + 0]),
                    J.push(ie[Le.v3 * 3 + 1]),
                    J.push(ie[Le.v3 * 3 + 2]),
                    ae.push(me[Le.p1 * 2 + 0]),
                    ae.push(me[Le.p1 * 2 + 1]),
                    ae.push(me[Le.p2 * 2 + 0]),
                    ae.push(me[Le.p2 * 2 + 1]),
                    ae.push(me[Le.p3 * 2 + 0]),
                    ae.push(me[Le.p3 * 2 + 1])
                }
                ce.setAttribute("position", new qe(J,3)),
                ce.setAttribute("uv", new qe(ae,2));
                let ve = C(w, T, H, Y, X, S)
                  , be = new sn({
                    map: ve,
                    flatShading: !0
                });
                return new Ht(ce,be)
            }
            function O(w, b, E, T) {
                let H = new wt
                  , Y = []
                  , X = []
                  , ce = E.vertices
                  , J = w.colors;
                for (let me = 0, ve = b.length; me < ve; me++) {
                    let be = b[me]
                      , fe = be.v1
                      , te = be.v2
                      , Ee = be.v3;
                    Y.push(ce[fe * 3 + 0]),
                    Y.push(ce[fe * 3 + 1]),
                    Y.push(ce[fe * 3 + 2]),
                    Y.push(ce[te * 3 + 0]),
                    Y.push(ce[te * 3 + 1]),
                    Y.push(ce[te * 3 + 2]),
                    Y.push(ce[Ee * 3 + 0]),
                    Y.push(ce[Ee * 3 + 1]),
                    Y.push(ce[Ee * 3 + 2]);
                    let Le = be.p1 !== void 0 ? be.p1 : T.pindex
                      , D = be.p2 !== void 0 ? be.p2 : Le
                      , A = be.p3 !== void 0 ? be.p3 : Le;
                    X.push(J[Le * 3 + 0]),
                    X.push(J[Le * 3 + 1]),
                    X.push(J[Le * 3 + 2]),
                    X.push(J[D * 3 + 0]),
                    X.push(J[D * 3 + 1]),
                    X.push(J[D * 3 + 2]),
                    X.push(J[A * 3 + 0]),
                    X.push(J[A * 3 + 1]),
                    X.push(J[A * 3 + 2])
                }
                H.setAttribute("position", new qe(Y,3)),
                H.setAttribute("color", new qe(X,3));
                let ae = new sn({
                    vertexColors: !0,
                    flatShading: !0
                });
                return new Ht(H,ae)
            }
            function M(w) {
                let b = new wt;
                b.setIndex(new zn(w.triangles,1)),
                b.setAttribute("position", new zn(w.vertices,3));
                let E = new sn({
                    color: 16777215,
                    flatShading: !0
                });
                return new Ht(b,E)
            }
            function R(w, b, E, T, H, Y) {
                let X = Object.keys(w)
                  , ce = [];
                for (let J = 0, ae = X.length; J < ae; J++) {
                    let ie = X[J]
                      , me = w[ie];
                    switch (q(ie, T)) {
                    case "material":
                        let be = T.resources.basematerials[ie]
                          , fe = N(be, me, b, E, T, H, Y);
                        for (let Le = 0, D = fe.length; Le < D; Le++)
                            ce.push(fe[Le]);
                        break;
                    case "texture":
                        let te = T.resources.texture2dgroup[ie];
                        ce.push(I(te, me, b, E, T, H, Y));
                        break;
                    case "vertexColors":
                        let Ee = T.resources.colorgroup[ie];
                        ce.push(O(Ee, me, b, Y));
                        break;
                    case "default":
                        ce.push(M(b));
                        break;
                    default:
                        console.error("THREE.3MFLoader: Unsupported resource type.")
                    }
                }
                if (Y.name)
                    for (let J = 0; J < ce.length; J++)
                        ce[J].name = Y.name;
                return ce
            }
            function q(w, b) {
                return b.resources.texture2dgroup[w] !== void 0 ? "texture" : b.resources.basematerials[w] !== void 0 ? "material" : b.resources.colorgroup[w] !== void 0 ? "vertexColors" : w === "default" ? "default" : void 0
            }
            function k(w, b) {
                let E = {}
                  , T = w.triangleProperties
                  , H = b.pid;
                for (let Y = 0, X = T.length; Y < X; Y++) {
                    let ce = T[Y]
                      , J = ce.pid !== void 0 ? ce.pid : H;
                    J === void 0 && (J = "default"),
                    E[J] === void 0 && (E[J] = []),
                    E[J].push(ce)
                }
                return E
            }
            function B(w, b, E, T, H) {
                let Y = new In
                  , X = k(w, H)
                  , ce = R(X, w, b, E, T, H);
                for (let J = 0, ae = ce.length; J < ae; J++)
                    Y.add(ce[J]);
                return Y
            }
            function P(w, b, E) {
                if (!w)
                    return;
                let T = []
                  , H = Object.keys(w);
                for (let Y = 0; Y < H.length; Y++) {
                    let X = H[Y];
                    for (let ce = 0; ce < t.availableExtensions.length; ce++) {
                        let J = t.availableExtensions[ce];
                        J.ns === X && T.push(J)
                    }
                }
                for (let Y = 0; Y < T.length; Y++) {
                    let X = T[Y];
                    X.apply(E, w[X.ns], b)
                }
            }
            function C(w, b, E, T, H, Y) {
                return w.build !== void 0 || (w.build = Y(w, b, E, T, H)),
                w.build
            }
            function L(w, b, E) {
                let T, H = w.displaypropertiesid, Y = E.resources.pbmetallicdisplayproperties;
                if (H !== null && Y[H] !== void 0) {
                    let ae = Y[H].data[w.index];
                    T = new Ks({
                        flatShading: !0,
                        roughness: ae.roughness,
                        metalness: ae.metallicness
                    })
                } else
                    T = new sn({
                        flatShading: !0
                    });
                T.name = w.name;
                let X = w.displaycolor
                  , ce = X.substring(0, 7);
                return T.color.setStyle(ce, xm),
                X.length === 9 && (T.opacity = parseInt(X.charAt(7) + X.charAt(8), 16) / 255),
                T
            }
            function F(w, b, E, T) {
                let H = new In;
                for (let Y = 0; Y < w.length; Y++) {
                    let X = w[Y]
                      , ce = b[X.objectId];
                    ce === void 0 && (U(X.objectId, b, E, T),
                    ce = b[X.objectId]);
                    let J = ce.clone()
                      , ae = X.transform;
                    ae && J.applyMatrix4(ae),
                    H.add(J)
                }
                return H
            }
            function U(w, b, E, T) {
                let H = E.resources.object[w];
                if (H.mesh) {
                    let Y = H.mesh
                      , X = E.extensions
                      , ce = E.xml;
                    P(X, Y, ce),
                    b[H.id] = C(Y, b, E, T, H, B)
                } else {
                    let Y = H.components;
                    b[H.id] = C(Y, b, E, T, H, F)
                }
                H.name && (b[H.id].name = H.name)
            }
            function W(w) {
                let b = w.model
                  , E = w.modelRels
                  , T = {}
                  , H = Object.keys(b)
                  , Y = {};
                if (E)
                    for (let X = 0, ce = E.length; X < ce; X++) {
                        let J = E[X]
                          , ae = J.target.substring(1);
                        w.texture[ae] && (Y[J.target] = w.texture[ae])
                    }
                for (let X = 0; X < H.length; X++) {
                    let ce = H[X]
                      , J = b[ce]
                      , ae = Object.keys(J.resources.object);
                    for (let ie = 0; ie < ae.length; ie++) {
                        let me = ae[ie];
                        U(me, T, J, Y)
                    }
                }
                return T
            }
            function K(w) {
                for (let b = 0; b < w.length; b++) {
                    let E = w[b];
                    if (E.target.split(".").pop().toLowerCase() === "model")
                        return E
                }
            }
            function re(w, b) {
                let E = new In
                  , T = K(b.rels)
                  , H = b.model[T.target.substring(1)].build;
                for (let Y = 0; Y < H.length; Y++) {
                    let X = H[Y]
                      , ce = w[X.objectId].clone()
                      , J = X.transform;
                    J && ce.applyMatrix4(J),
                    E.add(ce)
                }
                return E
            }
            let oe = i(e)
              , j = W(oe);
            return re(j, oe)
        }
        addExtension(e) {
            this.availableExtensions.push(e)
        }
    }
    ;
    var Xr = class extends Kt {
        constructor() {
            super(),
            this.colorConverter = null
        }
        CreateLoader(e) {
            return null
        }
        GetMainObject(e) {
            return e
        }
        IsMeshVisible(e) {
            return !0
        }
        ClearContent() {
            this.loader = null,
            this.materialIdToIndex = null,
            this.objectUrlToFileName = null
        }
        ResetContent() {
            this.loader = null,
            this.materialIdToIndex = new Map,
            this.objectUrlToFileName = new Map
        }
        ImportContent(e, t) {
            this.LoadModel(e, t)
        }
        LoadModel(e, t) {
            let n = !1
              , i = new zc(()=>{
                n = !0
            }
            )
              , s = Ms(e);
            i.setURLModifier(a=>{
                if (a === s)
                    return a;
                let l = pn(a);
                if (Oi(a).length > 0) {
                    let u = this.callbacks.getFileBuffer(a);
                    if (u !== null) {
                        let h = Ms(u);
                        return this.objectUrlToFileName.set(h, l),
                        h
                    }
                }
                return a
            }
            );
            let o = this.CreateLoader(i);
            if (o === null) {
                t();
                return
            }
            o.load(s, a=>{
                $h(()=>n ? (this.OnThreeObjectsLoaded(a, t),
                !1) : !0)
            }
            , ()=>{}
            , a=>{
                this.SetError(a),
                t()
            }
            )
        }
        OnThreeObjectsLoaded(e, t) {
            function n(a) {
                let l = new Ut().CreateIdentity();
                return a.updateMatrix(),
                a.matrix !== void 0 && a.matrix !== null && l.Set(a.matrix.elements),
                new en(l)
            }
            function i(a, l, c, u) {
                let h = new Fn;
                c.name !== void 0 && h.SetName(c.name),
                h.SetTransformation(n(c)),
                u.AddChildNode(h);
                for (let f of c.children)
                    i(a, l, f, h);
                if (c.isMesh && a.IsMeshVisible(c)) {
                    let f = a.ConvertThreeMesh(c)
                      , m = l.AddMesh(f);
                    h.AddMeshIndex(m)
                }
            }
            let s = this.GetMainObject(e)
              , o = this.model.GetRootNode();
            o.SetTransformation(n(s));
            for (let a of s.children)
                i(this, this.model, a, o);
            t()
        }
        ConvertThreeMesh(e) {
            let t = null;
            if (Array.isArray(e.material)) {
                if (t = dr(e.geometry, null, this.colorConverter),
                e.geometry.attributes.color === void 0 || e.geometry.attributes.color === null) {
                    let n = [];
                    for (let i = 0; i < e.material.length; i++) {
                        let s = e.material[i]
                          , o = this.FindOrCreateMaterial(s);
                        n.push(o)
                    }
                    for (let i = 0; i < e.geometry.groups.length; i++) {
                        let s = e.geometry.groups[i]
                          , o = null;
                        s.count === 1 / 0 ? o = t.TriangleCount() : o = s.start / 3 + s.count / 3;
                        for (let a = s.start / 3; a < o; a++)
                            t.GetTriangle(a).SetMaterial(n[s.materialIndex])
                    }
                }
            } else {
                let n = this.FindOrCreateMaterial(e.material);
                t = dr(e.geometry, n, this.colorConverter)
            }
            return e.name !== void 0 && e.name !== null && t.SetName(e.name),
            t
        }
        FindOrCreateMaterial(e) {
            if (this.materialIdToIndex.has(e.id))
                return this.materialIdToIndex.get(e.id);
            let t = this.ConvertThreeMaterial(e)
              , n = this.model.AddMaterial(t);
            return this.materialIdToIndex.set(e.id, n),
            n
        }
        ConvertThreeMaterial(e) {
            function t(i, s) {
                function o(a) {
                    if (a.data !== void 0 && a.data !== null) {
                        let l = new ImageData(a.width,a.height)
                          , c = a.width * a.height * 4;
                        for (let u = 0; u < c; u++)
                            l.data[u] = a.data[u];
                        return No.getDataURL(l)
                    } else
                        return No.getDataURL(a)
                }
                if (i == null || i.image === void 0 || i.image === null)
                    return null;
                try {
                    let a = o(i.image)
                      , l = qo(a)
                      , c = new ui
                      , u = null;
                    return s.has(i.image.src) ? u = s.get(i.image.src) : i.name !== void 0 && i.name !== null ? u = i.name + "." + ro(l.mimeType) : u = "Embedded_" + i.id.toString() + "." + ro(l.mimeType),
                    c.name = u,
                    c.mimeType = l.mimeType,
                    c.buffer = l.buffer,
                    c.rotation = i.rotation,
                    c.offset.x = i.offset.x,
                    c.offset.y = i.offset.y,
                    c.scale.x = i.repeat.x,
                    c.scale.y = i.repeat.y,
                    c
                } catch {
                    return null
                }
            }
            let n = new xn;
            return n.name = e.name,
            n.color = this.ConvertThreeColor(e.color),
            n.opacity = e.opacity,
            n.transparent = e.transparent,
            n.alphaTest = e.alphaTest,
            e.type === "MeshPhongMaterial" && (n.specular = this.ConvertThreeColor(e.specular),
            n.shininess = e.shininess / 100),
            n.diffuseMap = t(e.map, this.objectUrlToFileName),
            n.normalMap = t(e.normalMap, this.objectUrlToFileName),
            n.bumpMap = t(e.bumpMap, this.objectUrlToFileName),
            n
        }
        ConvertThreeColor(e) {
            return this.colorConverter !== null && (e = this.colorConverter.Convert(e)),
            Wc(e)
        }
    }
      , Al = class extends Xr {
        constructor() {
            super(),
            this.colorConverter = new el
        }
        CanImportExtension(e) {
            return e === "fbx"
        }
        GetUpDirection() {
            return lt.Y
        }
        CreateLoader(e) {
            return e.addHandler(/\.tga$/i, new oo(e)),
            new ff(e)
        }
        GetMainObject(e) {
            return e
        }
    }
      , Cl = class extends Xr {
        constructor() {
            super()
        }
        CanImportExtension(e) {
            return e === "dae"
        }
        GetUpDirection() {
            return lt.Y
        }
        CreateLoader(e) {
            return e.addHandler(/\.tga$/i, new oo(e)),
            new mf(e)
        }
        GetMainObject(e) {
            return e.scene
        }
    }
      , Il = class extends Xr {
        constructor() {
            super()
        }
        CanImportExtension(e) {
            return e === "wrl"
        }
        GetUpDirection() {
            return lt.Y
        }
        CreateLoader(e) {
            return new Tf(e)
        }
        GetMainObject(e) {
            return e
        }
        IsMeshVisible(e) {
            let t = !0;
            if (Array.isArray(e.material)) {
                for (let n = 0; n < e.material.length; n++)
                    if (e.material[n].side === Mn) {
                        t = !1;
                        break
                    }
            } else
                t = e.material.side !== Mn;
            return t
        }
    }
      , Rl = class extends Xr {
        constructor() {
            super(),
            this.colorConverter = new tl
        }
        CanImportExtension(e) {
            return e === "3mf"
        }
        GetUpDirection() {
            return lt.Z
        }
        CreateLoader(e) {
            return new bf(e)
        }
        GetMainObject(e) {
            return e
        }
    }
    ;
    var fn = Uint8Array
      , Mi = Uint16Array
      , Mf = Uint32Array
      , Ef = new fn([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0])
      , Sf = new fn([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0])
      , Em = new fn([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
      , Ty = function(r, e) {
        for (var t = new Mi(31), n = 0; n < 31; ++n)
            t[n] = e += 1 << r[n - 1];
        for (var i = new Mf(t[30]), n = 1; n < 30; ++n)
            for (var s = t[n]; s < t[n + 1]; ++s)
                i[s] = s - t[n] << 5 | n;
        return [t, i]
    }
      , by = Ty(Ef, 2)
      , My = by[0]
      , Sm = by[1];
    My[28] = 258,
    Sm[258] = 28;
    var Ey = Ty(Sf, 0)
      , Jw = Ey[0]
      , my = Ey[1]
      , wm = new Mi(32768);
    for (Vt = 0; Vt < 32768; ++Vt)
        Ss = (Vt & 43690) >>> 1 | (Vt & 21845) << 1,
        Ss = (Ss & 52428) >>> 2 | (Ss & 13107) << 2,
        Ss = (Ss & 61680) >>> 4 | (Ss & 3855) << 4,
        wm[Vt] = ((Ss & 65280) >>> 8 | (Ss & 255) << 8) >>> 1;
    var Ss, Vt, qr = function(r, e, t) {
        for (var n = r.length, i = 0, s = new Mi(e); i < n; ++i)
            r[i] && ++s[r[i] - 1];
        var o = new Mi(e);
        for (i = 0; i < e; ++i)
            o[i] = o[i - 1] + s[i - 1] << 1;
        var a;
        if (t) {
            a = new Mi(1 << e);
            var l = 15 - e;
            for (i = 0; i < n; ++i)
                if (r[i])
                    for (var c = i << 4 | r[i], u = e - r[i], h = o[r[i] - 1]++ << u, f = h | (1 << u) - 1; h <= f; ++h)
                        a[wm[h] >>> l] = c
        } else
            for (a = new Mi(n),
            i = 0; i < n; ++i)
                r[i] && (a[i] = wm[o[r[i] - 1]++] >>> 15 - r[i]);
        return a
    }, lo = new fn(288);
    for (Vt = 0; Vt < 144; ++Vt)
        lo[Vt] = 8;
    var Vt;
    for (Vt = 144; Vt < 256; ++Vt)
        lo[Vt] = 9;
    var Vt;
    for (Vt = 256; Vt < 280; ++Vt)
        lo[Vt] = 7;
    var Vt;
    for (Vt = 280; Vt < 288; ++Vt)
        lo[Vt] = 8;
    var Vt, lu = new fn(32);
    for (Vt = 0; Vt < 32; ++Vt)
        lu[Vt] = 5;
    var Vt, $w = qr(lo, 9, 0), Qw = qr(lo, 9, 1), eA = qr(lu, 5, 0), tA = qr(lu, 5, 1), _m = function(r) {
        for (var e = r[0], t = 1; t < r.length; ++t)
            r[t] > e && (e = r[t]);
        return e
    }, _r = function(r, e, t) {
        var n = e / 8 | 0;
        return (r[n] | r[n + 1] << 8) >> (e & 7) & t
    }, Tm = function(r, e) {
        var t = e / 8 | 0;
        return (r[t] | r[t + 1] << 8 | r[t + 2] << 16) >> (e & 7)
    }, Pm = function(r) {
        return (r + 7) / 8 | 0
    }, cu = function(r, e, t) {
        (e == null || e < 0) && (e = 0),
        (t == null || t > r.length) && (t = r.length);
        var n = new (r.BYTES_PER_ELEMENT == 2 ? Mi : r.BYTES_PER_ELEMENT == 4 ? Mf : fn)(t - e);
        return n.set(r.subarray(e, t)),
        n
    };
    var nA = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"]
      , bi = function(r, e, t) {
        var n = new Error(e || nA[r]);
        if (n.code = r,
        Error.captureStackTrace && Error.captureStackTrace(n, bi),
        !t)
            throw n;
        return n
    }
      , iA = function(r, e, t) {
        var n = r.length;
        if (!n || t && t.f && !t.l)
            return e || new fn(0);
        var i = !e || t
          , s = !t || t.i;
        t || (t = {}),
        e || (e = new fn(n * 3));
        var o = function(E) {
            var T = e.length;
            if (E > T) {
                var H = new fn(Math.max(T * 2, E));
                H.set(e),
                e = H
            }
        }
          , a = t.f || 0
          , l = t.p || 0
          , c = t.b || 0
          , u = t.l
          , h = t.d
          , f = t.m
          , m = t.n
          , g = n * 8;
        do {
            if (!u) {
                a = _r(r, l, 1);
                var v = _r(r, l + 1, 3);
                if (l += 3,
                v)
                    if (v == 1)
                        u = Qw,
                        h = tA,
                        f = 9,
                        m = 5;
                    else if (v == 2) {
                        var y = _r(r, l, 31) + 257
                          , _ = _r(r, l + 10, 15) + 4
                          , S = y + _r(r, l + 5, 31) + 1;
                        l += 14;
                        for (var N = new fn(S), I = new fn(19), O = 0; O < _; ++O)
                            I[Em[O]] = _r(r, l + O * 3, 7);
                        l += _ * 3;
                        for (var M = _m(I), R = (1 << M) - 1, q = qr(I, M, 1), O = 0; O < S; ) {
                            var k = q[_r(r, l, R)];
                            l += k & 15;
                            var p = k >>> 4;
                            if (p < 16)
                                N[O++] = p;
                            else {
                                var B = 0
                                  , P = 0;
                                for (p == 16 ? (P = 3 + _r(r, l, 3),
                                l += 2,
                                B = N[O - 1]) : p == 17 ? (P = 3 + _r(r, l, 7),
                                l += 3) : p == 18 && (P = 11 + _r(r, l, 127),
                                l += 7); P--; )
                                    N[O++] = B
                            }
                        }
                        var C = N.subarray(0, y)
                          , L = N.subarray(y);
                        f = _m(C),
                        m = _m(L),
                        u = qr(C, f, 1),
                        h = qr(L, m, 1)
                    } else
                        bi(1);
                else {
                    var p = Pm(l) + 4
                      , d = r[p - 4] | r[p - 3] << 8
                      , x = p + d;
                    if (x > n) {
                        s && bi(0);
                        break
                    }
                    i && o(c + d),
                    e.set(r.subarray(p, x), c),
                    t.b = c += d,
                    t.p = l = x * 8,
                    t.f = a;
                    continue
                }
                if (l > g) {
                    s && bi(0);
                    break
                }
            }
            i && o(c + 131072);
            for (var F = (1 << f) - 1, U = (1 << m) - 1, W = l; ; W = l) {
                var B = u[Tm(r, l) & F]
                  , K = B >>> 4;
                if (l += B & 15,
                l > g) {
                    s && bi(0);
                    break
                }
                if (B || bi(2),
                K < 256)
                    e[c++] = K;
                else if (K == 256) {
                    W = l,
                    u = null;
                    break
                } else {
                    var re = K - 254;
                    if (K > 264) {
                        var O = K - 257
                          , oe = Ef[O];
                        re = _r(r, l, (1 << oe) - 1) + My[O],
                        l += oe
                    }
                    var j = h[Tm(r, l) & U]
                      , w = j >>> 4;
                    j || bi(3),
                    l += j & 15;
                    var L = Jw[w];
                    if (w > 3) {
                        var oe = Sf[w];
                        L += Tm(r, l) & (1 << oe) - 1,
                        l += oe
                    }
                    if (l > g) {
                        s && bi(0);
                        break
                    }
                    i && o(c + 131072);
                    for (var b = c + re; c < b; c += 4)
                        e[c] = e[c - L],
                        e[c + 1] = e[c + 1 - L],
                        e[c + 2] = e[c + 2 - L],
                        e[c + 3] = e[c + 3 - L];
                    c = b
                }
            }
            t.l = u,
            t.p = W,
            t.b = c,
            t.f = a,
            u && (a = 1,
            t.m = f,
            t.d = h,
            t.n = m)
        } while (!a);
        return c == e.length ? e : cu(e, 0, c)
    }
      , ws = function(r, e, t) {
        t <<= e & 7;
        var n = e / 8 | 0;
        r[n] |= t,
        r[n + 1] |= t >>> 8
    }
      , ou = function(r, e, t) {
        t <<= e & 7;
        var n = e / 8 | 0;
        r[n] |= t,
        r[n + 1] |= t >>> 8,
        r[n + 2] |= t >>> 16
    }
      , bm = function(r, e) {
        for (var t = [], n = 0; n < r.length; ++n)
            r[n] && t.push({
                s: n,
                f: r[n]
            });
        var i = t.length
          , s = t.slice();
        if (!i)
            return [Lm, 0];
        if (i == 1) {
            var o = new fn(t[0].s + 1);
            return o[t[0].s] = 1,
            [o, 1]
        }
        t.sort(function(S, N) {
            return S.f - N.f
        }),
        t.push({
            s: -1,
            f: 25001
        });
        var a = t[0]
          , l = t[1]
          , c = 0
          , u = 1
          , h = 2;
        for (t[0] = {
            s: -1,
            f: a.f + l.f,
            l: a,
            r: l
        }; u != i - 1; )
            a = t[t[c].f < t[h].f ? c++ : h++],
            l = t[c != u && t[c].f < t[h].f ? c++ : h++],
            t[u++] = {
                s: -1,
                f: a.f + l.f,
                l: a,
                r: l
            };
        for (var f = s[0].s, n = 1; n < i; ++n)
            s[n].s > f && (f = s[n].s);
        var m = new Mi(f + 1)
          , g = Am(t[u - 1], m, 0);
        if (g > e) {
            var n = 0
              , v = 0
              , p = g - e
              , d = 1 << p;
            for (s.sort(function(N, I) {
                return m[I.s] - m[N.s] || N.f - I.f
            }); n < i; ++n) {
                var x = s[n].s;
                if (m[x] > e)
                    v += d - (1 << g - m[x]),
                    m[x] = e;
                else
                    break
            }
            for (v >>>= p; v > 0; ) {
                var y = s[n].s;
                m[y] < e ? v -= 1 << e - m[y]++ - 1 : ++n
            }
            for (; n >= 0 && v; --n) {
                var _ = s[n].s;
                m[_] == e && (--m[_],
                ++v)
            }
            g = e
        }
        return [new fn(m), g]
    }
      , Am = function(r, e, t) {
        return r.s == -1 ? Math.max(Am(r.l, e, t + 1), Am(r.r, e, t + 1)) : e[r.s] = t
    }
      , gy = function(r) {
        for (var e = r.length; e && !r[--e]; )
            ;
        for (var t = new Mi(++e), n = 0, i = r[0], s = 1, o = function(l) {
            t[n++] = l
        }, a = 1; a <= e; ++a)
            if (r[a] == i && a != e)
                ++s;
            else {
                if (!i && s > 2) {
                    for (; s > 138; s -= 138)
                        o(32754);
                    s > 2 && (o(s > 10 ? s - 11 << 5 | 28690 : s - 3 << 5 | 12305),
                    s = 0)
                } else if (s > 3) {
                    for (o(i),
                    --s; s > 6; s -= 6)
                        o(8304);
                    s > 2 && (o(s - 3 << 5 | 8208),
                    s = 0)
                }
                for (; s--; )
                    o(i);
                s = 1,
                i = r[a]
            }
        return [t.subarray(0, n), e]
    }
      , au = function(r, e) {
        for (var t = 0, n = 0; n < e.length; ++n)
            t += r[n] * e[n];
        return t
    }
      , Cm = function(r, e, t) {
        var n = t.length
          , i = Pm(e + 2);
        r[i] = n & 255,
        r[i + 1] = n >>> 8,
        r[i + 2] = r[i] ^ 255,
        r[i + 3] = r[i + 1] ^ 255;
        for (var s = 0; s < n; ++s)
            r[i + s + 4] = t[s];
        return (i + 4 + n) * 8
    }
      , vy = function(r, e, t, n, i, s, o, a, l, c, u) {
        ws(e, u++, t),
        ++i[256];
        for (var h = bm(i, 15), f = h[0], m = h[1], g = bm(s, 15), v = g[0], p = g[1], d = gy(f), x = d[0], y = d[1], _ = gy(v), S = _[0], N = _[1], I = new Mi(19), O = 0; O < x.length; ++O)
            I[x[O] & 31]++;
        for (var O = 0; O < S.length; ++O)
            I[S[O] & 31]++;
        for (var M = bm(I, 7), R = M[0], q = M[1], k = 19; k > 4 && !R[Em[k - 1]]; --k)
            ;
        var B = c + 5 << 3
          , P = au(i, lo) + au(s, lu) + o
          , C = au(i, f) + au(s, v) + o + 14 + 3 * k + au(I, R) + (2 * I[16] + 3 * I[17] + 7 * I[18]);
        if (B <= P && B <= C)
            return Cm(e, u, r.subarray(l, l + c));
        var L, F, U, W;
        if (ws(e, u, 1 + (C < P)),
        u += 2,
        C < P) {
            L = qr(f, m, 0),
            F = f,
            U = qr(v, p, 0),
            W = v;
            var K = qr(R, q, 0);
            ws(e, u, y - 257),
            ws(e, u + 5, N - 1),
            ws(e, u + 10, k - 4),
            u += 14;
            for (var O = 0; O < k; ++O)
                ws(e, u + 3 * O, R[Em[O]]);
            u += 3 * k;
            for (var re = [x, S], oe = 0; oe < 2; ++oe)
                for (var j = re[oe], O = 0; O < j.length; ++O) {
                    var w = j[O] & 31;
                    ws(e, u, K[w]),
                    u += R[w],
                    w > 15 && (ws(e, u, j[O] >>> 5 & 127),
                    u += j[O] >>> 12)
                }
        } else
            L = $w,
            F = lo,
            U = eA,
            W = lu;
        for (var O = 0; O < a; ++O)
            if (n[O] > 255) {
                var w = n[O] >>> 18 & 31;
                ou(e, u, L[w + 257]),
                u += F[w + 257],
                w > 7 && (ws(e, u, n[O] >>> 23 & 31),
                u += Ef[w]);
                var b = n[O] & 31;
                ou(e, u, U[b]),
                u += W[b],
                b > 3 && (ou(e, u, n[O] >>> 5 & 8191),
                u += Sf[b])
            } else
                ou(e, u, L[n[O]]),
                u += F[n[O]];
        return ou(e, u, L[256]),
        u + F[256]
    }
      , rA = new Mf([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632])
      , Lm = new fn(0)
      , sA = function(r, e, t, n, i, s) {
        var o = r.length
          , a = new fn(n + o + 5 * (1 + Math.ceil(o / 7e3)) + i)
          , l = a.subarray(n, a.length - i)
          , c = 0;
        if (!e || o < 8)
            for (var u = 0; u <= o; u += 65535) {
                var h = u + 65535;
                h >= o && (l[c >> 3] = s),
                c = Cm(l, c + 1, r.subarray(u, h))
            }
        else {
            for (var f = rA[e - 1], m = f >>> 13, g = f & 8191, v = (1 << t) - 1, p = new Mi(32768), d = new Mi(v + 1), x = Math.ceil(t / 3), y = 2 * x, _ = function(ie) {
                return (r[ie] ^ r[ie + 1] << x ^ r[ie + 2] << y) & v
            }, S = new Mf(25e3), N = new Mi(288), I = new Mi(32), O = 0, M = 0, u = 0, R = 0, q = 0, k = 0; u < o; ++u) {
                var B = _(u)
                  , P = u & 32767
                  , C = d[B];
                if (p[P] = C,
                d[B] = P,
                q <= u) {
                    var L = o - u;
                    if ((O > 7e3 || R > 24576) && L > 423) {
                        c = vy(r, l, 0, S, N, I, M, R, k, u - k, c),
                        R = O = M = 0,
                        k = u;
                        for (var F = 0; F < 286; ++F)
                            N[F] = 0;
                        for (var F = 0; F < 30; ++F)
                            I[F] = 0
                    }
                    var U = 2
                      , W = 0
                      , K = g
                      , re = P - C & 32767;
                    if (L > 2 && B == _(u - re))
                        for (var oe = Math.min(m, L) - 1, j = Math.min(32767, u), w = Math.min(258, L); re <= j && --K && P != C; ) {
                            if (r[u + U] == r[u + U - re]) {
                                for (var b = 0; b < w && r[u + b] == r[u + b - re]; ++b)
                                    ;
                                if (b > U) {
                                    if (U = b,
                                    W = re,
                                    b > oe)
                                        break;
                                    for (var E = Math.min(re, b - 2), T = 0, F = 0; F < E; ++F) {
                                        var H = u - re + F + 32768 & 32767
                                          , Y = p[H]
                                          , X = H - Y + 32768 & 32767;
                                        X > T && (T = X,
                                        C = H)
                                    }
                                }
                            }
                            P = C,
                            C = p[P],
                            re += P - C + 32768 & 32767
                        }
                    if (W) {
                        S[R++] = 268435456 | Sm[U] << 18 | my[W];
                        var ce = Sm[U] & 31
                          , J = my[W] & 31;
                        M += Ef[ce] + Sf[J],
                        ++N[257 + ce],
                        ++I[J],
                        q = u + U,
                        ++O
                    } else
                        S[R++] = r[u],
                        ++N[r[u]]
                }
            }
            c = vy(r, l, s, S, N, I, M, R, k, u - k, c),
            !s && c & 7 && (c = Cm(l, c + 1, Lm))
        }
        return cu(a, 0, n + Pm(c) + i)
    }
      , oA = function() {
        for (var r = new Int32Array(256), e = 0; e < 256; ++e) {
            for (var t = e, n = 9; --n; )
                t = (t & 1 && -306674912) ^ t >>> 1;
            r[e] = t
        }
        return r
    }()
      , aA = function() {
        var r = -1;
        return {
            p: function(e) {
                for (var t = r, n = 0; n < e.length; ++n)
                    t = oA[t & 255 ^ e[n]] ^ t >>> 8;
                r = t
            },
            d: function() {
                return ~r
            }
        }
    };
    var lA = function(r, e, t, n, i) {
        return sA(r, e.level == null ? 6 : e.level, e.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(r.length))) * 1.5) : 12 + e.mem, t, n, !i)
    }
      , Sy = function(r, e) {
        var t = {};
        for (var n in r)
            t[n] = r[n];
        for (var n in e)
            t[n] = e[n];
        return t
    };
    var jr = function(r, e) {
        return r[e] | r[e + 1] << 8
    }
      , Tr = function(r, e) {
        return (r[e] | r[e + 1] << 8 | r[e + 2] << 16 | r[e + 3] << 24) >>> 0
    }
      , Mm = function(r, e) {
        return Tr(r, e) + Tr(r, e + 4) * 4294967296
    }
      , jn = function(r, e, t) {
        for (; t; ++e)
            r[e] = t,
            t >>>= 8
    };
    function cA(r, e) {
        return lA(r, e || {}, 0, 0)
    }
    function uA(r, e) {
        return iA(r, e)
    }
    var wy = function(r, e, t, n) {
        for (var i in r) {
            var s = r[i]
              , o = e + i
              , a = n;
            Array.isArray(s) && (a = Sy(n, s[1]),
            s = s[0]),
            s instanceof fn ? t[o] = [s, a] : (t[o += "/"] = [new fn(0), a],
            wy(s, o, t, n))
        }
    }
      , yy = typeof TextEncoder < "u" && new TextEncoder
      , Im = typeof TextDecoder < "u" && new TextDecoder
      , hA = 0;
    try {
        Im.decode(Lm, {
            stream: !0
        }),
        hA = 1
    } catch {}
    var fA = function(r) {
        for (var e = "", t = 0; ; ) {
            var n = r[t++]
              , i = (n > 127) + (n > 223) + (n > 239);
            if (t + i > r.length)
                return [e, cu(r, t - 1)];
            i ? i == 3 ? (n = ((n & 15) << 18 | (r[t++] & 63) << 12 | (r[t++] & 63) << 6 | r[t++] & 63) - 65536,
            e += String.fromCharCode(55296 | n >> 10, 56320 | n & 1023)) : i & 1 ? e += String.fromCharCode((n & 31) << 6 | r[t++] & 63) : e += String.fromCharCode((n & 15) << 12 | (r[t++] & 63) << 6 | r[t++] & 63) : e += String.fromCharCode(n)
        }
    };
    function xy(r, e) {
        if (e) {
            for (var t = new fn(r.length), n = 0; n < r.length; ++n)
                t[n] = r.charCodeAt(n);
            return t
        }
        if (yy)
            return yy.encode(r);
        for (var i = r.length, s = new fn(r.length + (r.length >> 1)), o = 0, a = function(u) {
            s[o++] = u
        }, n = 0; n < i; ++n) {
            if (o + 5 > s.length) {
                var l = new fn(o + 8 + (i - n << 1));
                l.set(s),
                s = l
            }
            var c = r.charCodeAt(n);
            c < 128 || e ? a(c) : c < 2048 ? (a(192 | c >> 6),
            a(128 | c & 63)) : c > 55295 && c < 57344 ? (c = 65536 + (c & 1023 << 10) | r.charCodeAt(++n) & 1023,
            a(240 | c >> 18),
            a(128 | c >> 12 & 63),
            a(128 | c >> 6 & 63),
            a(128 | c & 63)) : (a(224 | c >> 12),
            a(128 | c >> 6 & 63),
            a(128 | c & 63))
        }
        return cu(s, 0, o)
    }
    function dA(r, e) {
        if (e) {
            for (var t = "", n = 0; n < r.length; n += 16384)
                t += String.fromCharCode.apply(null, r.subarray(n, n + 16384));
            return t
        } else {
            if (Im)
                return Im.decode(r);
            var i = fA(r)
              , s = i[0]
              , o = i[1];
            return o.length && bi(8),
            s
        }
    }
    var pA = function(r, e) {
        return e + 30 + jr(r, e + 26) + jr(r, e + 28)
    }
      , mA = function(r, e, t) {
        var n = jr(r, e + 28)
          , i = dA(r.subarray(e + 46, e + 46 + n), !(jr(r, e + 8) & 2048))
          , s = e + 46 + n
          , o = Tr(r, e + 20)
          , a = t && o == 4294967295 ? gA(r, s) : [o, Tr(r, e + 24), Tr(r, e + 42)]
          , l = a[0]
          , c = a[1]
          , u = a[2];
        return [jr(r, e + 10), l, c, i, s + jr(r, e + 30) + jr(r, e + 32), u]
    }
      , gA = function(r, e) {
        for (; jr(r, e) != 1; e += 4 + jr(r, e + 2))
            ;
        return [Mm(r, e + 12), Mm(r, e + 4), Mm(r, e + 20)]
    }
      , Rm = function(r) {
        var e = 0;
        if (r)
            for (var t in r) {
                var n = r[t].length;
                n > 65535 && bi(9),
                e += n + 4
            }
        return e
    }
      , _y = function(r, e, t, n, i, s, o, a) {
        var l = n.length
          , c = t.extra
          , u = a && a.length
          , h = Rm(c);
        jn(r, e, o != null ? 33639248 : 67324752),
        e += 4,
        o != null && (r[e++] = 20,
        r[e++] = t.os),
        r[e] = 20,
        e += 2,
        r[e++] = t.flag << 1 | (s < 0 && 8),
        r[e++] = i && 8,
        r[e++] = t.compression & 255,
        r[e++] = t.compression >> 8;
        var f = new Date(t.mtime == null ? Date.now() : t.mtime)
          , m = f.getFullYear() - 1980;
        if ((m < 0 || m > 119) && bi(10),
        jn(r, e, m << 25 | f.getMonth() + 1 << 21 | f.getDate() << 16 | f.getHours() << 11 | f.getMinutes() << 5 | f.getSeconds() >>> 1),
        e += 4,
        s != -1 && (jn(r, e, t.crc),
        jn(r, e + 4, s < 0 ? -s - 2 : s),
        jn(r, e + 8, t.size)),
        jn(r, e + 12, l),
        jn(r, e + 14, h),
        e += 16,
        o != null && (jn(r, e, u),
        jn(r, e + 6, t.attrs),
        jn(r, e + 10, o),
        e += 14),
        r.set(n, e),
        e += l,
        h)
            for (var g in c) {
                var v = c[g]
                  , p = v.length;
                jn(r, e, +g),
                jn(r, e + 2, p),
                r.set(v, e + 4),
                e += 4 + p
            }
        return u && (r.set(a, e),
        e += u),
        e
    }
      , vA = function(r, e, t, n, i) {
        jn(r, e, 101010256),
        jn(r, e + 8, t),
        jn(r, e + 10, t),
        jn(r, e + 12, n),
        jn(r, e + 16, i)
    };
    function Nm(r, e) {
        e || (e = {});
        var t = {}
          , n = [];
        wy(r, "", t, e);
        var i = 0
          , s = 0;
        for (var o in t) {
            var a = t[o]
              , l = a[0]
              , c = a[1]
              , u = c.level == 0 ? 0 : 8
              , h = xy(o)
              , f = h.length
              , m = c.comment
              , g = m && xy(m)
              , v = g && g.length
              , p = Rm(c.extra);
            f > 65535 && bi(11);
            var d = u ? cA(l, c) : l
              , x = d.length
              , y = aA();
            y.p(l),
            n.push(Sy(c, {
                size: l.length,
                crc: y.d(),
                c: d,
                f: h,
                m: g,
                u: f != o.length || g && m.length != v,
                o: i,
                compression: u
            })),
            i += 30 + f + p + x,
            s += 76 + 2 * (f + p) + (v || 0) + x
        }
        for (var _ = new fn(s + 22), S = i, N = s - i, I = 0; I < n.length; ++I) {
            var h = n[I];
            _y(_, h.o, h, h.f, h.u, h.c.length);
            var O = 30 + h.f.length + Rm(h.extra);
            _.set(h.c, h.o + O),
            _y(_, i, h, h.f, h.u, h.c.length, h.o, h.m),
            i += 16 + O + (h.m ? h.m.length : 0)
        }
        return vA(_, i, n.length, N, S),
        _
    }
    function wf(r, e) {
        for (var t = {}, n = r.length - 22; Tr(r, n) != 101010256; --n)
            (!n || r.length - n > 65558) && bi(13);
        var i = jr(r, n + 8);
        if (!i)
            return {};
        var s = Tr(r, n + 16)
          , o = s == 4294967295 || i == 65535;
        if (o) {
            var a = Tr(r, n - 12);
            o = Tr(r, a) == 101075792,
            o && (i = Tr(r, a + 32),
            s = Tr(r, a + 48))
        }
        for (var l = e && e.filter, c = 0; c < i; ++c) {
            var u = mA(r, s, o)
              , h = u[0]
              , f = u[1]
              , m = u[2]
              , g = u[3]
              , v = u[4]
              , p = u[5]
              , d = pA(r, p);
            s = v,
            (!l || l({
                name: g,
                size: f,
                originalSize: m,
                compression: h
            })) && (h ? h == 8 ? t[g] = uA(r.subarray(d, d + f), new fn(m)) : bi(14, "unknown compression type " + h) : t[g] = cu(r, d, d + f))
        }
        return t
    }
    var Om = {
        Success: 0,
        NoDocumentXml: 1
    }
      , Fm = class {
        constructor(e, t) {
            this.name = e,
            this.type = t,
            this.shapeName = null,
            this.isVisible = !1,
            this.color = null,
            this.fileName = null,
            this.fileContent = null,
            this.inLinkCount = 0,
            this.properties = null
        }
        IsConvertible() {
            return !(this.fileName === null || this.fileContent === null || !this.isVisible || this.inLinkCount > 0)
        }
    }
      , km = class {
        constructor() {
            this.files = null,
            this.properties = null,
            this.objectNames = [],
            this.objectData = new Map
        }
        Init(e) {
            let t = new Uint8Array(e);
            return this.files = wf(t),
            this.LoadDocumentXml() ? (this.LoadGuiDocumentXml(),
            Om.Success) : Om.NoDocumentXml
        }
        GetObjectListToConvert() {
            let e = [];
            for (let t of this.objectNames) {
                let n = this.objectData.get(t);
                n.IsConvertible() && e.push(n)
            }
            return e
        }
        IsSupportedType(e) {
            return !(!e.startsWith("Part::") && !e.startsWith("PartDesign::") || e.indexOf("Part2D") !== -1)
        }
        HasFile(e) {
            return e in this.files
        }
        LoadDocumentXml() {
            let e = this.GetXMLContent("Document.xml");
            if (e === null)
                return !1;
            this.properties = new kn("Properties");
            let t = e.getElementsByTagName("Document");
            for (let s of t)
                for (let o of s.childNodes)
                    o.tagName === "Properties" && this.GetPropertiesFromElement(o, this.properties);
            let n = e.getElementsByTagName("Objects");
            for (let s of n) {
                let o = s.getElementsByTagName("Object");
                for (let a of o) {
                    let l = a.getAttribute("name")
                      , c = a.getAttribute("type");
                    if (!this.IsSupportedType(c))
                        continue;
                    let u = new Fm(l,c);
                    this.objectNames.push(l),
                    this.objectData.set(l, u)
                }
            }
            let i = e.getElementsByTagName("ObjectData");
            for (let s of i) {
                let o = s.getElementsByTagName("Object");
                for (let a of o) {
                    let l = a.getAttribute("name");
                    if (!this.objectData.has(l))
                        continue;
                    let c = this.objectData.get(l);
                    c.properties = new kn("Properties");
                    for (let f of a.childNodes)
                        f.tagName === "Properties" && this.GetPropertiesFromElement(f, c.properties);
                    let u = a.getElementsByTagName("Property");
                    for (let f of u) {
                        let m = f.getAttribute("name");
                        if (m === "Label")
                            c.shapeName = this.GetFirstChildValue(f, "String", "value");
                        else if (m === "Visibility") {
                            let g = this.GetFirstChildValue(f, "Bool", "value");
                            c.isVisible = g === "true"
                        } else if (m === "Visible") {
                            let g = this.GetFirstChildValue(f, "Bool", "value");
                            c.isVisible = g === "true"
                        } else if (m === "Shape") {
                            let g = this.GetFirstChildValue(f, "Part", "file");
                            if (!this.HasFile(g))
                                continue;
                            let v = Oi(g);
                            if (v !== "brp" && v !== "brep")
                                continue;
                            c.fileName = g,
                            c.fileContent = this.files[g]
                        }
                    }
                    let h = a.getElementsByTagName("Link");
                    for (let f of h) {
                        let m = f.getAttribute("value");
                        if (this.objectData.has(m)) {
                            let g = this.objectData.get(m);
                            g.inLinkCount += 1
                        }
                    }
                }
            }
            return !0
        }
        LoadGuiDocumentXml() {
            let e = this.GetXMLContent("GuiDocument.xml");
            if (e === null)
                return !1;
            let t = e.getElementsByTagName("ViewProvider");
            for (let n of t) {
                let i = n.getAttribute("name");
                if (!this.objectData.has(i))
                    continue;
                let s = this.objectData.get(i)
                  , o = n.getElementsByTagName("Property");
                for (let a of o) {
                    let l = a.getAttribute("name");
                    if (l === "Visibility") {
                        let c = this.GetFirstChildValue(a, "Bool", "value");
                        s.isVisible = c === "true"
                    } else if (l === "ShapeColor") {
                        let c = this.GetFirstChildValue(a, "PropertyColor", "value")
                          , u = parseInt(c, 10);
                        s.color = new Nn(u >> 24 & 255,u >> 16 & 255,u >> 8 & 255,255)
                    }
                }
            }
            return !0
        }
        GetPropertiesFromElement(e, t) {
            let n = e.getElementsByTagName("Property");
            for (let i of n) {
                let s = i.getAttribute("name")
                  , o = i.getAttribute("type")
                  , a = null;
                if (o === "App::PropertyBool") {
                    let l = this.GetFirstChildValue(i, "String", "bool");
                    l !== null && l.length > 0 && (a = new yt(dt.Boolean,s,l === "true"))
                } else if (o === "App::PropertyInteger") {
                    let l = this.GetFirstChildValue(i, "Integer", "value");
                    l !== null && l.length > 0 && (a = new yt(dt.Integer,s,parseInt(l)))
                } else if (o === "App::PropertyString") {
                    let l = this.GetFirstChildValue(i, "String", "value");
                    l !== null && l.length > 0 && (a = new yt(dt.Text,s,l))
                } else if (o === "App::PropertyUUID") {
                    let l = this.GetFirstChildValue(i, "Uuid", "value");
                    l !== null && l.length > 0 && (a = new yt(dt.Text,s,l))
                } else if (o === "App::PropertyFloat" || o === "App::PropertyLength" || o === "App::PropertyDistance" || o === "App::PropertyArea" || o === "App::PropertyVolume") {
                    let l = this.GetFirstChildValue(i, "Float", "value");
                    l !== null && l.length > 0 && (a = new yt(dt.Number,s,parseFloat(l)))
                }
                a !== null && t.AddProperty(a)
            }
        }
        GetXMLContent(e) {
            if (!this.HasFile(e))
                return null;
            let t = new DOMParser
              , n = wn(this.files[e]);
            return t.parseFromString(n, "text/xml")
        }
        GetFirstChildValue(e, t, n) {
            let i = e.getElementsByTagName(t);
            return i.length === 0 ? null : i[0].getAttribute(n)
        }
    }
      , Pl = class extends Kt {
        constructor() {
            super(),
            this.worker = null,
            this.document = null
        }
        CanImportExtension(e) {
            return e === "fcstd"
        }
        GetUpDirection() {
            return lt.Z
        }
        ClearContent() {
            this.worker !== null && (this.worker.terminate(),
            this.worker = null),
            this.document = null
        }
        ResetContent() {
            this.worker = null,
            this.document = new km
        }
        ImportContent(e, t) {
            if (this.document.Init(e) === Om.NoDocumentXml) {
                this.SetError("No Document.xml found."),
                t();
                return
            }
            this.document.properties !== null && this.document.properties.PropertyCount() > 0 && this.model.AddPropertyGroup(this.document.properties);
            let i = this.document.GetObjectListToConvert();
            if (i.length === 0) {
                this.SetError("No importable object found."),
                t();
                return
            }
            this.ConvertObjects(i, t)
        }
        ConvertObjects(e, t) {
            let n = _o("loaders/occt-import-js-worker.js");
            this.worker = new Worker(n);
            let i = 0
              , s = new vi(this.model)
              , o = l=>{
                if (l !== null) {
                    let c = e[i];
                    this.OnFileConverted(c, l, s)
                }
                if (i += 1,
                i === e.length)
                    t();
                else {
                    let c = e[i];
                    this.worker.postMessage({
                        format: "brep",
                        buffer: c.fileContent
                    })
                }
            }
            ;
            this.worker.addEventListener("message", l=>{
                o(l.data)
            }
            ),
            this.worker.addEventListener("error", l=>{
                o(null)
            }
            );
            let a = e[i];
            this.worker.postMessage({
                format: "brep",
                buffer: a.fileContent
            })
        }
        OnFileConverted(e, t, n) {
            if (!t.success || t.meshes.length === 0)
                return;
            let i = new Fn;
            e.shapeName !== null && i.SetName(e.shapeName);
            let s = 1;
            for (let a of t.meshes) {
                let l = null;
                e.color !== null && (l = n.GetMaterialIndex(e.color.r, e.color.g, e.color.b, e.color.a));
                let c = dr(a, l, null);
                if (e.shapeName !== null) {
                    let h = s.toString().padStart(3, "0");
                    c.SetName(e.shapeName + " " + h)
                }
                e.properties !== null && e.properties.PropertyCount() > 0 && c.AddPropertyGroup(e.properties);
                let u = this.model.AddMesh(c);
                i.AddMeshIndex(u),
                s += 1
            }
            this.model.GetRootNode().AddChildNode(i)
        }
    }
    ;
    var br = class {
        constructor() {
            this.defaultColor = new rt(200,200,200)
        }
    }
      , Un = {
        NoImportableFile: 1,
        FailedToLoadFile: 2,
        ImportFailed: 3,
        UnknownError: 4
    }
      , co = class {
        constructor(e) {
            this.code = e,
            this.mainFile = null,
            this.message = null
        }
    }
      , uu = class {
        constructor() {
            this.model = null,
            this.mainFile = null,
            this.upVector = null,
            this.usedFiles = null,
            this.missingFiles = null
        }
    }
      , hu = class {
        constructor(e) {
            this.getBufferCallback = e,
            this.fileBuffers = new Map
        }
        GetFileBuffer(e) {
            let t = pn(e);
            if (this.fileBuffers.has(t))
                return this.fileBuffers.get(t);
            let n = this.getBufferCallback(t);
            return this.fileBuffers.set(t, n),
            n
        }
    }
      , Ll = class {
        constructor() {
            this.importers = [new xl, new Ml, new _l, new Tl, new ml, new vl, new El, new pl, new yl, new bl, new Pl, new Al, new Cl, new Il, new Rl],
            this.fileList = new zo,
            this.model = null,
            this.usedFiles = [],
            this.missingFiles = []
        }
        AddImporter(e) {
            this.importers.push(e)
        }
        ImportFiles(e, t, n) {
            n.onLoadStart(),
            this.LoadFiles(e, {
                onReady: ()=>{
                    n.onImportStart(),
                    _s(()=>{
                        this.DecompressArchives(this.fileList, ()=>{
                            this.ImportLoadedFiles(t, n)
                        }
                        )
                    }
                    )
                }
                ,
                onFileListProgress: n.onFileListProgress,
                onFileLoadProgress: n.onFileLoadProgress
            })
        }
        LoadFiles(e, t) {
            let n = new zo;
            n.FillFromInputFiles(e);
            let i = !1;
            if (this.HasImportableFile(n))
                i = !0;
            else {
                let s = !1;
                for (let o = 0; o < this.missingFiles.length; o++) {
                    let a = this.missingFiles[o];
                    n.ContainsFileByPath(a) && (s = !0)
                }
                s ? (this.fileList.ExtendFromFileList(n),
                i = !1) : i = !0
            }
            i && (this.fileList = n),
            this.fileList.GetContent({
                onReady: t.onReady,
                onFileListProgress: t.onFileListProgress,
                onFileLoadProgress: t.onFileLoadProgress
            })
        }
        ImportLoadedFiles(e, t) {
            let n = this.GetImportableFiles(this.fileList);
            if (n.length === 0) {
                t.onImportError(new co(Un.NoImportableFile));
                return
            }
            if (n.length === 1 || !t.onSelectMainFile) {
                let i = n[0];
                this.ImportLoadedMainFile(i, e, t)
            } else {
                let i = n.map(s=>s.file.name);
                t.onSelectMainFile(i, s=>{
                    if (s === null) {
                        t.onImportError(new co(Un.NoImportableFile));
                        return
                    }
                    _s(()=>{
                        let o = n[s];
                        this.ImportLoadedMainFile(o, e, t)
                    }
                    )
                }
                )
            }
        }
        ImportLoadedMainFile(e, t, n) {
            if (e === null || e.file === null || e.file.content === null) {
                let o = new co(Un.FailedToLoadFile);
                e !== null && e.file !== null && (o.mainFile = e.file.name),
                n.onImportError(o);
                return
            }
            this.model = null,
            this.usedFiles = [],
            this.missingFiles = [],
            this.usedFiles.push(e.file.name);
            let i = e.importer
              , s = new hu(o=>{
                let a = null
                  , l = this.fileList.FindFileByPath(o);
                return l === null || l.content === null ? (this.missingFiles.push(o),
                a = null) : (this.usedFiles.push(o),
                a = l.content),
                a
            }
            );
            i.Import(e.file.name, e.file.extension, e.file.content, {
                getDefaultMaterialColor: ()=>t.defaultColor,
                getFileBuffer: o=>s.GetFileBuffer(o),
                onSuccess: ()=>{
                    this.model = i.GetModel();
                    let o = new uu;
                    o.mainFile = e.file.name,
                    o.model = this.model,
                    o.usedFiles = this.usedFiles,
                    o.missingFiles = this.missingFiles,
                    o.upVector = i.GetUpDirection(),
                    n.onImportSuccess(o)
                }
                ,
                onError: ()=>{
                    let o = new co(Un.ImportFailed);
                    o.mainFile = e.file.name,
                    o.message = i.GetErrorMessage(),
                    n.onImportError(o)
                }
                ,
                onComplete: ()=>{
                    i.Clear()
                }
            })
        }
        DecompressArchives(e, t) {
            let n = e.GetFiles()
              , i = [];
            for (let s of n)
                s.extension === "zip" && i.push(s);
            if (i.length === 0) {
                t();
                return
            }
            for (let s = 0; s < i.length; s++) {
                let o = i[s]
                  , a = new Uint8Array(o.content)
                  , l = wf(a);
                for (let c in l)
                    if (Object.prototype.hasOwnProperty.call(l, c)) {
                        let u = new Vo(c,Di.Decompressed,null);
                        u.SetContent(l[c].buffer),
                        e.AddFile(u)
                    }
            }
            t()
        }
        GetFileList() {
            return this.fileList
        }
        HasImportableFile(e) {
            return this.GetImportableFiles(e).length > 0
        }
        GetImportableFiles(e) {
            function t(s, o) {
                for (let a = 0; a < o.length; a++) {
                    let l = o[a];
                    if (l.CanImportExtension(s.extension))
                        return l
                }
                return null
            }
            let n = []
              , i = e.GetFiles();
            for (let s = 0; s < i.length; s++) {
                let o = i[s]
                  , a = t(o, this.importers);
                a !== null && n.push({
                    file: o,
                    importer: a
                })
            }
            return n
        }
    }
    ;
    function Bn(r) {
        return Math.round(parseFloat(r))
    }
    function Af(r) {
        let e = Bn(r.paddingLeft) + Bn(r.paddingRight)
          , t = Bn(r.borderLeftWidth) + Bn(r.borderRightWidth)
          , n = Bn(r.marginLeft) + Bn(r.marginRight);
        return e + t + n
    }
    function Cf(r) {
        let e = Bn(r.paddingTop) + Bn(r.paddingBottom)
          , t = Bn(r.borderTopWidth) + Bn(r.borderBottomWidth)
          , n = Bn(r.marginTop) + Bn(r.marginBottom);
        return e + t + n
    }
    function If(r, e, t) {
        let n = getComputedStyle(r)
          , i = e - Af(n)
          , s = t - Cf(n);
        return {
            width: i,
            height: s
        }
    }
    function As(r, e, t) {
        if (r.getBoundingClientRect) {
            let n = r.getBoundingClientRect();
            e -= n.left,
            t -= n.top
        }
        return window.pageXOffset && window.pageYOffset && (e += window.pageXOffset,
        t += window.pageYOffset),
        new Pt(e,t)
    }
    function Yr(r, e, t) {
        let n = document.createElement(r);
        return e && (n.className = e),
        t && (n.innerHTML = t),
        n
    }
    function Jt(r, e, t, n) {
        let i = Yr(e, t, n);
        return r.appendChild(i),
        i
    }
    function Ce(r, e, t) {
        return Jt(r, "div", e, t)
    }
    function Zn(r) {
        for (; r.firstChild; )
            r.removeChild(r.firstChild)
    }
    function Cs(r, e) {
        e.parentNode.insertBefore(r, e)
    }
    function Rf(r, e) {
        e.parentNode.insertBefore(r, e.nextSibling)
    }
    function It(r, e) {
        e ? r.style.display = "block" : r.style.display = "none"
    }
    function Nl(r) {
        return r.offsetParent !== null
    }
    function Dl(r, e) {
        r.style.width = e.toString() + "px"
    }
    function $i(r, e) {
        r.style.height = e.toString() + "px"
    }
    function Ei(r) {
        let e = getComputedStyle(r);
        return r.offsetWidth + Bn(e.marginLeft) + Bn(e.marginRight)
    }
    function Mr(r) {
        let e = getComputedStyle(r);
        return r.offsetHeight + Bn(e.marginTop) + Bn(e.marginBottom)
    }
    function Ol(r, e) {
        let t = getComputedStyle(r);
        Dl(r, e - Af(t))
    }
    function Qi(r, e) {
        let t = getComputedStyle(r);
        $i(r, e - Cf(t))
    }
    function Jn(r, e) {
        return Yr("div", r, e)
    }
    function Ay(r, e, t) {
        let n = e / t;
        return r * (n * n * (3 - 2 * n))
    }
    function Cy(r, e, t) {
        return e * r / t
    }
    function Pf(r, e, t) {
        let n = e / t
          , i = n * n;
        return r * (i / (2 * (i - n) + 1))
    }
    function Fl(r, e, t, n) {
        let i = vn(e, r).Normalize()
          , s = ti(r, e)
          , o = [];
        for (let a = 0; a < t; a++) {
            let l = n(s, a, t - 1);
            o.push(r.Clone().Offset(i, l))
        }
        return o
    }
    var fu = class {
        constructor() {
            this.prev = new Pt(0,0),
            this.curr = new Pt(0,0),
            this.diff = new Pt(0,0),
            this.buttons = []
        }
        Down(e, t) {
            this.buttons.push(t.which),
            this.curr = this.GetPositionFromEvent(e, t),
            this.prev = this.curr.Clone()
        }
        Move(e, t) {
            this.curr = this.GetPositionFromEvent(e, t),
            this.diff = mc(this.curr, this.prev),
            this.prev = this.curr.Clone()
        }
        Up(e, t) {
            let n = this.buttons.indexOf(t.which);
            n !== -1 && this.buttons.splice(n, 1),
            this.curr = this.GetPositionFromEvent(e, t)
        }
        Leave(e, t) {
            this.buttons = [],
            this.curr = this.GetPositionFromEvent(e, t)
        }
        IsButtonDown() {
            return this.buttons.length > 0
        }
        GetButton() {
            let e = this.buttons.length;
            return e === 0 ? 0 : this.buttons[e - 1]
        }
        GetPosition() {
            return this.curr
        }
        GetMoveDiff() {
            return this.diff
        }
        GetPositionFromEvent(e, t) {
            return As(e, t.clientX, t.clientY)
        }
    }
      , du = class {
        constructor() {
            this.prevPos = new Pt(0,0),
            this.currPos = new Pt(0,0),
            this.diffPos = new Pt(0,0),
            this.prevDist = 0,
            this.currDist = 0,
            this.diffDist = 0,
            this.fingers = 0
        }
        Start(e, t) {
            t.touches.length !== 0 && (this.fingers = t.touches.length,
            this.currPos = this.GetPositionFromEvent(e, t),
            this.prevPos = this.currPos.Clone(),
            this.currDist = this.GetTouchDistanceFromEvent(e, t),
            this.prevDist = this.currDist)
        }
        Move(e, t) {
            t.touches.length !== 0 && (this.currPos = this.GetPositionFromEvent(e, t),
            this.diffPos = mc(this.currPos, this.prevPos),
            this.prevPos = this.currPos.Clone(),
            this.currDist = this.GetTouchDistanceFromEvent(e, t),
            this.diffDist = this.currDist - this.prevDist,
            this.prevDist = this.currDist)
        }
        End(e, t) {
            t.touches.length !== 0 && (this.fingers = 0,
            this.currPos = this.GetPositionFromEvent(e, t),
            this.currDist = this.GetTouchDistanceFromEvent(e, t))
        }
        IsFingerDown() {
            return this.fingers !== 0
        }
        GetFingerCount() {
            return this.fingers
        }
        GetPosition() {
            return this.currPos
        }
        GetMoveDiff() {
            return this.diffPos
        }
        GetDistanceDiff() {
            return this.diffDist
        }
        GetPositionFromEvent(e, t) {
            let n = null;
            if (t.touches.length !== 0) {
                let i = t.touches[0];
                n = As(e, i.pageX, i.pageY)
            }
            return n
        }
        GetTouchDistanceFromEvent(e, t) {
            if (t.touches.length !== 2)
                return 0;
            let n = t.touches[0]
              , i = t.touches[1];
            return gc(As(e, n.pageX, n.pageY), As(e, i.pageX, i.pageY))
        }
    }
      , pu = class {
        constructor() {
            this.isClick = !1,
            this.startPosition = null
        }
        Start(e) {
            this.isClick = !0,
            this.startPosition = e
        }
        Move(e) {
            this.isClick && (this.startPosition !== null ? gc(this.startPosition, e) > 3 && this.Cancel() : this.Cancel())
        }
        End() {
            this.startPosition = null
        }
        Cancel() {
            this.isClick = !1,
            this.startPosition = null
        }
        IsClick() {
            return this.isClick
        }
    }
      , oi = {
        None: 0,
        Orbit: 1,
        Pan: 2,
        Zoom: 3
    }
      , kl = class {
        constructor(e, t, n) {
            this.canvas = e,
            this.camera = t,
            this.callbacks = n,
            this.fixUpVector = !0,
            this.mouse = new fu,
            this.touch = new du,
            this.clickDetector = new pu,
            this.onMouseClick = null,
            this.onMouseMove = null,
            this.onContext = null,
            this.canvas.addEventListener && (this.canvas.addEventListener("mousedown", this.OnMouseDown.bind(this)),
            this.canvas.addEventListener("wheel", this.OnMouseWheel.bind(this)),
            this.canvas.addEventListener("touchstart", this.OnTouchStart.bind(this)),
            this.canvas.addEventListener("touchmove", this.OnTouchMove.bind(this)),
            this.canvas.addEventListener("touchcancel", this.OnTouchEnd.bind(this)),
            this.canvas.addEventListener("touchend", this.OnTouchEnd.bind(this)),
            this.canvas.addEventListener("contextmenu", this.OnContextMenu.bind(this))),
            document.addEventListener && (document.addEventListener("mousemove", this.OnMouseMove.bind(this)),
            document.addEventListener("mouseup", this.OnMouseUp.bind(this)),
            document.addEventListener("mouseleave", this.OnMouseLeave.bind(this)))
        }
        SetMouseClickHandler(e) {
            this.onMouseClick = e
        }
        SetMouseMoveHandler(e) {
            this.onMouseMove = e
        }
        SetContextMenuHandler(e) {
            this.onContext = e
        }
        IsFixUpVector() {
            return this.fixUpVector
        }
        SetFixUpVector(e) {
            this.fixUpVector = e
        }
        GetCamera() {
            return this.camera
        }
        SetCamera(e) {
            this.camera = e
        }
        MoveCamera(e, t) {
            function n(i, s, o, a) {
                i.camera.eye = s.eye[a],
                i.camera.center = s.center[a],
                i.camera.up = s.up[a],
                i.Update(),
                a < o - 1 && requestAnimationFrame(()=>{
                    n(i, s, o, a + 1)
                }
                )
            }
            if (e !== null) {
                if (t === 0 || zu(this.camera, e))
                    this.camera = e;
                else {
                    let i = Pf
                      , s = {
                        eye: Fl(this.camera.eye, e.eye, t, i),
                        center: Fl(this.camera.center, e.center, t, i),
                        up: Fl(this.camera.up, e.up, t, i)
                    };
                    requestAnimationFrame(()=>{
                        n(this, s, t, 0)
                    }
                    )
                }
                this.Update()
            }
        }
        GetFitToSphereCamera(e, t) {
            if (To(t))
                return null;
            let n = this.camera.Clone()
              , i = vn(n.center, e);
            n.eye = vn(n.eye, i),
            n.center = e.Clone();
            let s = vn(n.eye, n.center).Normalize()
              , o = this.camera.fov / 2;
            this.canvas.width < this.canvas.height && (o = o * this.canvas.width / this.canvas.height);
            let a = t / Math.sin(o * Cr);
            return n.eye = n.center.Clone().Offset(s, a),
            n
        }
        OnMouseDown(e) {
            e.preventDefault(),
            this.mouse.Down(this.canvas, e),
            this.clickDetector.Start(this.mouse.GetPosition())
        }
        OnMouseMove(e) {
            if (this.mouse.Move(this.canvas, e),
            this.clickDetector.Move(this.mouse.GetPosition()),
            this.onMouseMove) {
                let s = As(this.canvas, e.clientX, e.clientY);
                this.onMouseMove(s)
            }
            if (!this.mouse.IsButtonDown())
                return;
            let t = this.mouse.GetMoveDiff()
              , n = this.mouse.GetButton()
              , i = oi.None;
            if (n === 1 ? e.ctrlKey ? i = oi.Zoom : e.shiftKey ? i = oi.Pan : i = oi.Orbit : (n === 2 || n === 3) && (i = oi.Pan),
            i === oi.Orbit) {
                let s = .5;
                this.Orbit(t.x * s, t.y * s)
            } else if (i === oi.Pan) {
                let o = .001 * ti(this.camera.eye, this.camera.center);
                this.Pan(t.x * o, t.y * o)
            } else if (i === oi.Zoom) {
                let s = .005;
                this.Zoom(-t.y * s)
            }
            this.Update()
        }
        OnMouseUp(e) {
            if (this.mouse.Up(this.canvas, e),
            this.clickDetector.End(),
            this.clickDetector.IsClick()) {
                let t = this.mouse.GetPosition();
                this.Click(e.which, t)
            }
        }
        OnMouseLeave(e) {
            this.mouse.Leave(this.canvas, e),
            this.clickDetector.Cancel()
        }
        OnTouchStart(e) {
            e.preventDefault(),
            this.touch.Start(this.canvas, e),
            this.clickDetector.Start(this.touch.GetPosition())
        }
        OnTouchMove(e) {
            if (e.preventDefault(),
            this.touch.Move(this.canvas, e),
            this.clickDetector.Move(this.touch.GetPosition()),
            !this.touch.IsFingerDown())
                return;
            let t = this.touch.GetMoveDiff()
              , n = this.touch.GetDistanceDiff()
              , i = this.touch.GetFingerCount()
              , s = oi.None;
            if (i === 1 ? s = oi.Orbit : i === 2 && (s = oi.Pan),
            s === oi.Orbit) {
                let o = .5;
                this.Orbit(t.x * o, t.y * o)
            } else if (s === oi.Pan) {
                let o = .005;
                this.Zoom(n * o);
                let a = .001 * ti(this.camera.eye, this.camera.center);
                this.Pan(t.x * a, t.y * a)
            }
            this.Update()
        }
        OnTouchEnd(e) {
            if (e.preventDefault(),
            this.touch.End(this.canvas, e),
            this.clickDetector.End(),
            this.clickDetector.IsClick()) {
                let t = this.touch.GetPosition();
                this.touch.GetFingerCount() === 1 && this.Click(1, t)
            }
        }
        OnMouseWheel(e) {
            let t = e || window.event;
            t.preventDefault();
            let n = -t.deltaY / 40
              , i = .1;
            n < 0 && (i = i * -1),
            this.Zoom(i),
            this.Update()
        }
        OnContextMenu(e) {
            e.preventDefault(),
            this.clickDetector.IsClick() && (this.Context(e.clientX, e.clientY),
            this.clickDetector.Cancel())
        }
        Orbit(e, t) {
            let n = e * Cr
              , i = t * Cr
              , s = vn(this.camera.center, this.camera.eye).Normalize()
              , o = nr(s, this.camera.up).Normalize();
            if (this.fixUpVector) {
                let l = Vu(s, this.camera.up) + i;
                Bu(l, 0) && oa(l, Math.PI) && this.camera.eye.Rotate(o, -i, this.camera.center),
                this.camera.eye.Rotate(this.camera.up, -n, this.camera.center)
            } else {
                let a = nr(o, s).Normalize();
                this.camera.eye.Rotate(o, -i, this.camera.center),
                this.camera.eye.Rotate(a, -n, this.camera.center),
                this.camera.up = a
            }
        }
        Pan(e, t) {
            let n = vn(this.camera.center, this.camera.eye).Normalize()
              , i = nr(n, this.camera.up).Normalize()
              , s = nr(i, n).Normalize();
            this.camera.eye.Offset(i, -e),
            this.camera.center.Offset(i, -e),
            this.camera.eye.Offset(s, t),
            this.camera.center.Offset(s, t)
        }
        Zoom(e) {
            let t = vn(this.camera.center, this.camera.eye)
              , i = t.Length() * e;
            this.camera.eye.Offset(t, i)
        }
        Update() {
            this.callbacks.onUpdate()
        }
        Click(e, t) {
            this.onMouseClick && this.onMouseClick(e, t)
        }
        Context(e, t) {
            if (this.onContext) {
                let n = {
                    x: e,
                    y: t
                }
                  , i = As(this.canvas, e, t);
                this.onContext(n, i)
            }
        }
    }
    ;
    var Bi = class {
        constructor(e, t) {
            this.textureNames = e,
            this.backgroundIsEnvMap = t
        }
        Clone() {
            let e = null;
            if (this.textureNames !== null) {
                e = [];
                for (let t of this.textureNames)
                    e.push(t)
            }
            return new Bi(e,this.backgroundIsEnvMap)
        }
    }
      , Ul = class {
        constructor(e) {
            this.scene = e,
            this.type = hn.Phong,
            this.cameraMode = un.Perspective,
            this.ambientLight = new kr(8947848),
            this.directionalLight = new Fr(8947848),
            this.environmentSettings = new Bi(null,!1),
            this.environment = null,
            this.scene.add(this.ambientLight),
            this.scene.add(this.directionalLight)
        }
        SetShadingType(e) {
            this.type = e,
            this.UpdateShading()
        }
        SetCameraMode(e) {
            this.cameraMode = e,
            this.UpdateShading()
        }
        UpdateShading() {
            this.type === hn.Phong ? (this.ambientLight.color.set(8947848),
            this.directionalLight.color.set(8947848),
            this.scene.environment = null) : this.type === hn.Physical && (this.ambientLight.color.set(0),
            this.directionalLight.color.set(5592405),
            this.scene.environment = this.environment),
            this.environmentSettings.backgroundIsEnvMap && this.cameraMode === un.Perspective ? this.scene.background = this.environment : this.scene.background = null
        }
        SetEnvironmentMapSettings(e, t) {
            let n = new Dh;
            this.environment = n.load(e.textureNames, ()=>{
                t()
            }
            ),
            this.environmentSettings = e
        }
        UpdateByCamera(e) {
            let t = vn(e.eye, e.center);
            this.directionalLight.position.set(t.x, t.y, t.z)
        }
        CreateHighlightMaterial(e, t) {
            let n = null;
            return this.type === hn.Phong ? n = new sn({
                color: Xn(e),
                side: On
            }) : this.type === hn.Physical && (n = new Ks({
                color: Xn(e),
                side: On
            })),
            n !== null && t && (n.polygonOffset = !0,
            n.polygonOffsetUnit = 1,
            n.polygonOffsetFactor = 1),
            n
        }
    }
    ;
    function Lf(r) {
        let e = 45;
        return r === lt.X ? new Hi(new ze(2,-3,1.5),new ze(0,0,0),new ze(1,0,0),e) : r === lt.Y ? new Hi(new ze(-1.5,2,3),new ze(0,0,0),new ze(0,1,0),e) : r === lt.Z ? new Hi(new ze(-1.5,-3,2),new ze(0,0,0),new ze(0,0,1),e) : null
    }
    function Nf(r, e) {
        if (!e(r))
            return !1;
        for (let t of r.children)
            if (!Nf(t, e))
                return !1;
        return !0
    }
    function Um(r) {
        let e = null;
        return Nf(r, t=>{
            if (t.isMesh)
                for (let n of t.material)
                    return n.type === "MeshPhongMaterial" ? e = hn.Phong : n.type === "MeshStandardMaterial" && (e = hn.Physical),
                    !1;
            return !0
        }
        ),
        e
    }
    var mu = class {
        constructor() {
            this.eyeCenterDistance = 0,
            this.forceUpdate = !0
        }
        ForceUpdate() {
            this.forceUpdate = !0
        }
        ValidatePerspective() {
            return this.forceUpdate ? (this.forceUpdate = !1,
            !1) : !0
        }
        ValidateOrthographic(e) {
            return this.forceUpdate || !Ot(this.eyeCenterDistance, e) ? (this.eyeCenterDistance = e,
            this.forceUpdate = !1,
            !1) : !0
        }
    }
      , gu = class {
        constructor() {
            this.direction = lt.Y,
            this.isFixed = !0,
            this.isFlipped = !1
        }
        SetDirection(e, t) {
            this.direction = e,
            this.isFlipped = !1;
            let n = Lf(this.direction)
              , i = vn(n.eye, n.center)
              , s = ti(t.center, t.eye)
              , o = t.center.Clone().Offset(i, s)
              , a = t.Clone();
            return this.direction === lt.X ? (a.up = new ze(1,0,0),
            a.eye = o) : this.direction === lt.Y ? (a.up = new ze(0,1,0),
            a.eye = o) : this.direction === lt.Z && (a.up = new ze(0,0,1),
            a.eye = o),
            a
        }
        SetFixed(e, t) {
            return this.isFixed = e,
            this.isFixed ? this.SetDirection(this.direction, t) : null
        }
        Flip(e) {
            this.isFlipped = !this.isFlipped;
            let t = e.Clone();
            return t.up.MultiplyScalar(-1),
            t
        }
    }
      , Kr = class {
        constructor() {
            Li.enabled = !1,
            this.canvas = null,
            this.renderer = null,
            this.scene = null,
            this.mainModel = null,
            this.extraModel = null,
            this.camera = null,
            this.cameraMode = null,
            this.cameraValidator = null,
            this.shadingModel = null,
            this.navigation = null,
            this.upVector = null,
            this.settings = {
                animationSteps: 40
            }
        }
        Init(e) {
            this.canvas = e,
            this.canvas.id = "viewer";
            let t = {
                canvas: this.canvas,
                antialias: !0
            };
            this.renderer = new Oo(t),
            this.renderer.outputColorSpace = di,
            window.devicePixelRatio && this.renderer.setPixelRatio(window.devicePixelRatio),
            this.renderer.setClearColor("#ffffff", 1),
            this.renderer.setSize(this.canvas.width, this.canvas.height),
            this.scene = new Or,
            this.mainModel = new nl(this.scene),
            this.extraModel = new eo(this.scene),
            this.InitNavigation(),
            this.InitShading(),
            this.Render()
        }
        SetMouseClickHandler(e) {
            this.navigation.SetMouseClickHandler(e)
        }
        SetMouseMoveHandler(e) {
            this.navigation.SetMouseMoveHandler(e)
        }
        SetContextMenuHandler(e) {
            this.navigation.SetContextMenuHandler(e)
        }
        SetEdgeSettings(e) {
            let t = e.Clone();
            this.mainModel.SetEdgeSettings(t),
            this.Render()
        }
        SetEnvironmentMapSettings(e) {
            let t = e.Clone();
            this.shadingModel.SetEnvironmentMapSettings(t, ()=>{
                this.Render()
            }
            ),
            this.shadingModel.UpdateShading(),
            this.Render()
        }
        SetBackgroundColor(e) {
            let t = new $e(ns(e.r),ns(e.g),ns(e.b))
              , n = ns(e.a);
            this.renderer.setClearColor(t, n),
            this.Render()
        }
        GetCanvas() {
            return this.canvas
        }
        GetCamera() {
            return this.navigation.GetCamera()
        }
        GetCameraMode() {
            return this.cameraMode
        }
        SetCamera(e) {
            this.navigation.SetCamera(e),
            this.cameraValidator.ForceUpdate(),
            this.Render()
        }
        SetCameraMode(e) {
            this.cameraMode !== e && (this.scene.remove(this.camera),
            e === un.Perspective ? this.camera = new Qt(45,1,.1,1e3) : e === un.Orthographic && (this.camera = new Dr(-1,1,1,-1,.1,1e3)),
            this.scene.add(this.camera),
            this.cameraMode = e,
            this.shadingModel.SetCameraMode(e),
            this.cameraValidator.ForceUpdate(),
            this.AdjustClippingPlanes(),
            this.Render())
        }
        Resize(e, t) {
            let n = If(this.canvas, e, t);
            this.ResizeRenderer(n.width, n.height)
        }
        ResizeRenderer(e, t) {
            window.devicePixelRatio && this.renderer.setPixelRatio(window.devicePixelRatio),
            this.renderer.setSize(e, t),
            this.cameraValidator.ForceUpdate(),
            this.Render()
        }
        FitSphereToWindow(e, t) {
            if (e === null)
                return;
            let n = new ze(e.center.x,e.center.y,e.center.z)
              , i = e.radius
              , s = this.navigation.GetFitToSphereCamera(n, i);
            this.navigation.MoveCamera(s, t ? this.settings.animationSteps : 0)
        }
        AdjustClippingPlanes() {
            let e = this.GetBoundingSphere(t=>!0);
            this.AdjustClippingPlanesToSphere(e)
        }
        AdjustClippingPlanesToSphere(e) {
            e !== null && (e.radius < 10 ? (this.camera.near = .01,
            this.camera.far = 100) : e.radius < 100 ? (this.camera.near = .1,
            this.camera.far = 1e3) : e.radius < 1e3 ? (this.camera.near = 10,
            this.camera.far = 1e4) : (this.camera.near = 100,
            this.camera.far = 1e6),
            this.cameraValidator.ForceUpdate(),
            this.Render())
        }
        IsFixUpVector() {
            return this.navigation.IsFixUpVector()
        }
        SetFixUpVector(e) {
            let t = this.navigation.GetCamera()
              , n = this.upVector.SetFixed(e, t);
            this.navigation.SetFixUpVector(e),
            n !== null && this.navigation.MoveCamera(n, this.settings.animationSteps),
            this.Render()
        }
        SetUpVector(e, t) {
            let n = this.navigation.GetCamera()
              , i = this.upVector.SetDirection(e, n)
              , s = t ? this.settings.animationSteps : 0;
            this.navigation.MoveCamera(i, s),
            this.Render()
        }
        FlipUpVector() {
            let e = this.navigation.GetCamera()
              , t = this.upVector.Flip(e);
            this.navigation.MoveCamera(t, 0),
            this.Render()
        }
        Render() {
            let e = this.navigation.GetCamera();
            if (this.camera.position.set(e.eye.x, e.eye.y, e.eye.z),
            this.camera.up.set(e.up.x, e.up.y, e.up.z),
            this.camera.lookAt(new ue(e.center.x,e.center.y,e.center.z)),
            this.cameraMode === un.Perspective)
                this.cameraValidator.ValidatePerspective() || (this.camera.aspect = this.canvas.width / this.canvas.height,
                this.camera.fov = e.fov,
                this.camera.updateProjectionMatrix());
            else if (this.cameraMode === un.Orthographic) {
                let t = ti(e.eye, e.center);
                if (!this.cameraValidator.ValidateOrthographic(t)) {
                    let n = this.canvas.width / this.canvas.height
                      , s = ti(e.eye, e.center) * Math.tan(.5 * e.fov * Cr);
                    this.camera.left = -s * n,
                    this.camera.right = s * n,
                    this.camera.top = s,
                    this.camera.bottom = -s,
                    this.camera.updateProjectionMatrix()
                }
            }
            this.shadingModel.UpdateByCamera(e),
            this.renderer.render(this.scene, this.camera)
        }
        SetMainObject(e) {
            let t = Um(e);
            this.mainModel.SetMainObject(e),
            this.shadingModel.SetShadingType(t),
            this.Render()
        }
        AddExtraObject(e) {
            this.extraModel.AddObject(e),
            this.Render()
        }
        Clear() {
            this.mainModel.Clear(),
            this.extraModel.Clear(),
            this.Render()
        }
        ClearExtra() {
            this.extraModel.Clear(),
            this.Render()
        }
        SetMeshesVisibility(e) {
            this.mainModel.EnumerateMeshes(t=>{
                let n = e(t.userData);
                t.visible !== n && (t.visible = n)
            }
            ),
            this.mainModel.EnumerateEdges(t=>{
                let n = e(t.userData);
                t.visible !== n && (t.visible = n)
            }
            ),
            this.Render()
        }
        SetMeshesHighlight(e, t) {
            function n(s, o) {
                let a = [];
                for (let l = 0; l < s.length; l++)
                    a.push(o);
                return a
            }
            let i = this.CreateHighlightMaterial(e);
            this.mainModel.EnumerateMeshes(s=>{
                t(s.userData) ? s.userData.threeMaterials === null && (s.userData.threeMaterials = s.material,
                s.material = n(s.material, i)) : s.userData.threeMaterials !== null && (s.material = s.userData.threeMaterials,
                s.userData.threeMaterials = null)
            }
            ),
            this.Render()
        }
        CreateHighlightMaterial(e) {
            let t = this.mainModel.edgeSettings.showEdges;
            return this.shadingModel.CreateHighlightMaterial(e, t)
        }
        GetMeshUserDataUnderMouse(e) {
            let t = this.GetMeshIntersectionUnderMouse(e);
            return t === null ? null : t.object.userData
        }
        GetMeshIntersectionUnderMouse(e) {
            let t = this.GetCanvasSize()
              , n = this.mainModel.GetMeshIntersectionUnderMouse(e, this.camera, t.width, t.height);
            return n === null ? null : n
        }
        GetBoundingBox(e) {
            return this.mainModel.GetBoundingBox(e)
        }
        GetBoundingSphere(e) {
            return this.mainModel.GetBoundingSphere(e)
        }
        EnumerateMeshesUserData(e) {
            this.mainModel.EnumerateMeshes(t=>{
                e(t.userData)
            }
            )
        }
        InitNavigation() {
            let e = Lf(lt.Y);
            this.camera = new Qt(45,1,.1,1e3),
            this.cameraMode = un.Perspective,
            this.cameraValidator = new mu,
            this.scene.add(this.camera);
            let t = this.renderer.domElement;
            this.navigation = new kl(t,e,{
                onUpdate: ()=>{
                    this.Render()
                }
            }),
            this.upVector = new gu
        }
        InitShading() {
            this.shadingModel = new Ul(this.scene)
        }
        GetShadingType() {
            return this.shadingModel.type
        }
        GetImageSize() {
            let e = new Ie;
            return this.renderer.getSize(e),
            {
                width: parseInt(e.x, 10),
                height: parseInt(e.y, 10)
            }
        }
        GetCanvasSize() {
            let e = this.canvas.width
              , t = this.canvas.height;
            return window.devicePixelRatio && (e /= window.devicePixelRatio,
            t /= window.devicePixelRatio),
            {
                width: e,
                height: t
            }
        }
        GetImageAsDataUrl(e, t) {
            let n = this.GetImageSize()
              , i = e
              , s = t;
            window.devicePixelRatio && (i /= window.devicePixelRatio,
            s /= window.devicePixelRatio),
            this.ResizeRenderer(i, s),
            this.Render();
            let o = this.renderer.domElement.toDataURL();
            return this.ResizeRenderer(n.width, n.height),
            o
        }
        Destroy() {
            this.Clear(),
            this.renderer.dispose()
        }
    }
    ;
    var Bl = class {
        constructor() {
            this.skipNextEvent = !1,
            this.eventListener = null
        }
        SetEventListener(e) {
            this.eventListener = e,
            window.onhashchange = this.OnChange.bind(this)
        }
        SkipNextEventHandler() {
            this.skipNextEvent = !0
        }
        HasHash() {
            return this.GetHash().length > 0
        }
        ClearHash() {
            this.SetHash("")
        }
        GetModelFilesFromHash() {
            return Br(this.GetHash()).GetModelUrls()
        }
        SetModelFilesToHash(e) {
            let t = rl(e);
            this.SetHash(t)
        }
        GetCameraFromHash() {
            return Br(this.GetHash()).GetCamera()
        }
        GetCameraModeFromHash() {
            return Br(this.GetHash()).GetCameraMode()
        }
        GetBackgroundFromHash() {
            return Br(this.GetHash()).GetBackgroundColor()
        }
        GetEnvironmentSettingsFromHash() {
            return Br(this.GetHash()).GetEnvironmentSettings()
        }
        GetDefaultColorFromHash() {
            return Br(this.GetHash()).GetDefaultColor()
        }
        GetEdgeSettingsFromHash() {
            return Br(this.GetHash()).GetEdgeSettings()
        }
        GetHash() {
            return window.location.hash.substring(1)
        }
        SetHash(e) {
            window.location.hash = e
        }
        OnChange() {
            if (this.skipNextEvent) {
                this.skipNextEvent = !1;
                return
            }
            this.eventListener()
        }
    }
    ;
    var Gl = class {
        constructor() {
            this.forceMediumpForMaterials = !1
        }
    }
      , Vl = class {
        constructor() {
            this.defaultMaterial = null,
            this.objectUrls = []
        }
    }
      , vu = class {
        constructor(e) {
            this.callbacks = e,
            this.texturesNeeded = 0,
            this.texturesLoaded = 0,
            this.threeObject = null
        }
        OnTextureNeeded() {
            this.texturesNeeded += 1
        }
        OnTextureLoaded() {
            this.texturesLoaded += 1,
            this.callbacks.onTextureLoaded(),
            this.Finish()
        }
        OnModelLoaded(e) {
            this.threeObject = e,
            this.Finish()
        }
        Finish() {
            this.threeObject !== null && this.texturesNeeded === this.texturesLoaded && this.callbacks.onModelLoaded(this.threeObject)
        }
    }
      , yu = class {
        constructor(e, t) {
            this.model = e,
            this.threeNodeItems = [],
            this.AddNode(e.GetRootNode(), t)
        }
        AddNode(e, t) {
            let n = e.GetTransformation().GetMatrix()
              , i = new je().fromArray(n.Get());
            t.applyMatrix4(i);
            for (let s of e.GetChildNodes()) {
                let o = new bt;
                t.add(o),
                this.AddNode(s, o)
            }
            for (let s of e.GetMeshIndices()) {
                let o = new gi(e.GetId(),s)
                  , a = this.model.GetMesh(s);
                this.threeNodeItems.push({
                    meshInstance: new Ts(o,e,a),
                    threeNode: t
                })
            }
        }
        GetNodeItems() {
            return this.threeNodeItems
        }
    }
    ;
    function Df(r, e, t, n) {
        function i(f, m, g, v, p, d) {
            function x(M, R) {
                R.wrapS = rn,
                R.wrapT = rn,
                R.rotation = M.rotation,
                R.offset.x = M.offset.x,
                R.offset.y = M.offset.y,
                R.repeat.x = M.scale.x,
                R.repeat.y = M.scale.y
            }
            function y(M, R, q, k, B) {
                if (q === null || !q.IsValid())
                    return;
                let P = new Zi;
                M.OnTextureNeeded();
                let C = null;
                q.mimeType !== null ? C = af(q.buffer, q.mimeType) : C = Ms(q.buffer),
                k.objectUrls.push(C),
                P.load(C, L=>{
                    x(q, L),
                    R.needsUpdate = !0,
                    B(L),
                    M.OnTextureLoaded()
                }
                , null, L=>{
                    M.OnTextureLoaded()
                }
                )
            }
            let _ = m.GetMaterial(g)
              , S = Xn(_.color);
            _.vertexColors && S.setRGB(1, 1, 1);
            let N = {
                color: S,
                vertexColors: _.vertexColors,
                opacity: _.opacity,
                transparent: _.transparent,
                alphaTest: _.alphaTest,
                side: On
            };
            p.forceMediumpForMaterials && (N.precision = "mediump");
            let I = null;
            if (v === hn.Phong) {
                if (I = new sn(N),
                _.type === nn.Phong) {
                    let M = Xn(_.specular);
                    Ot(_.shininess, 0) && M.setRGB(0, 0, 0),
                    I.specular = M,
                    I.shininess = _.shininess * 100,
                    y(f, I, _.specularMap, d, R=>{
                        I.specularMap = R
                    }
                    )
                }
            } else
                v === hn.Physical && (I = new Ks(N),
                _.type === nn.Physical && (I.metalness = _.metalness,
                I.roughness = _.roughness,
                y(f, I, _.metalnessMap, d, M=>{
                    I.metalness = 1,
                    I.roughness = 1,
                    I.metalnessMap = M,
                    I.roughnessMap = M
                }
                )));
            let O = Xn(_.emissive);
            return I.emissive = O,
            y(f, I, _.diffuseMap, d, M=>{
                _.multiplyDiffuseMap || I.color.setRGB(1, 1, 1),
                I.map = M
            }
            ),
            y(f, I, _.bumpMap, d, M=>{
                I.bumpMap = M
            }
            ),
            y(f, I, _.normalMap, d, M=>{
                I.normalMap = M
            }
            ),
            y(f, I, _.emissiveMap, d, M=>{
                I.emissiveMap = M
            }
            ),
            _.isDefault && (d.defaultMaterial = I),
            I
        }
        function s(f, m) {
            let g = f.mesh
              , v = g.TriangleCount()
              , p = [];
            for (let B = 0; B < v; B++)
                p.push(B);
            p.sort((B,P)=>{
                let C = g.GetTriangle(B)
                  , L = g.GetTriangle(P);
                return C.mat - L.mat
            }
            );
            let d = new wt
              , x = []
              , y = []
              , _ = new Map
              , S = []
              , N = []
              , I = []
              , O = []
              , M = [];
            M.push({
                start: 0,
                end: -1
            });
            let R = g.VertexColorCount() > 0
              , q = g.TextureUVCount() > 0;
            for (let B = 0; B < p.length; B++) {
                let P = p[B]
                  , C = g.GetTriangle(P)
                  , L = g.GetVertex(C.v0)
                  , F = g.GetVertex(C.v1)
                  , U = g.GetVertex(C.v2);
                if (S.push(L.x, L.y, L.z, F.x, F.y, F.z, U.x, U.y, U.z),
                C.HasVertexColors()) {
                    let j = Xn(g.GetVertexColor(C.c0))
                      , w = Xn(g.GetVertexColor(C.c1))
                      , b = Xn(g.GetVertexColor(C.c2));
                    N.push(j.r, j.g, j.b, w.r, w.g, w.b, b.r, b.g, b.b)
                } else
                    R && N.push(0, 0, 0, 0, 0, 0, 0, 0, 0);
                let W = g.GetNormal(C.n0)
                  , K = g.GetNormal(C.n1)
                  , re = g.GetNormal(C.n2);
                if (I.push(W.x, W.y, W.z, K.x, K.y, K.z, re.x, re.y, re.z),
                C.HasTextureUVs()) {
                    let j = g.GetTextureUV(C.u0)
                      , w = g.GetTextureUV(C.u1)
                      , b = g.GetTextureUV(C.u2);
                    O.push(j.x, j.y, w.x, w.y, b.x, b.y)
                } else
                    q && O.push(0, 0, 0, 0, 0, 0);
                let oe = C.mat;
                _.has(oe) || (_.set(oe, x.length),
                x.push(m[oe]),
                y.push(oe),
                B > 0 && (M[M.length - 1].end = B - 1,
                M.push({
                    start: M[M.length - 1].end + 1,
                    end: -1
                })))
            }
            M[M.length - 1].end = v - 1,
            d.setAttribute("position", new qe(S,3)),
            N.length !== 0 && d.setAttribute("color", new qe(N,3)),
            d.setAttribute("normal", new qe(I,3)),
            O.length !== 0 && d.setAttribute("uv", new qe(O,2));
            for (let B = 0; B < M.length; B++) {
                let P = M[B];
                d.addGroup(P.start * 3, (P.end - P.start + 1) * 3, B)
            }
            let k = new Ht(d,x);
            return k.name = g.GetName(),
            k.userData = {
                originalMeshInstance: f,
                originalMaterials: y,
                threeMaterials: null
            },
            k
        }
        function o(f, m, g) {
            if (io(m.mesh) === Gr.TriangleMesh) {
                let p = s(m, g);
                f.add(p)
            }
        }
        function a(f, m, g, v) {
            let d = new yu(m,f).GetNodeItems();
            Jh(d.length, 100, {
                runTask: (x,y,_)=>{
                    for (let S = x; S <= y; S++) {
                        let N = d[S];
                        o(N.threeNode, N.meshInstance, g)
                    }
                    _()
                }
                ,
                onReady: ()=>{
                    v.OnModelLoaded(f)
                }
            })
        }
        let l = new vu(n)
          , c = Wh(r)
          , u = [];
        for (let f = 0; f < r.MaterialCount(); f++) {
            let m = i(l, r, f, c, e, t);
            u.push(m)
        }
        let h = new bt;
        a(h, r, u, l)
    }
    var uo = class {
        constructor() {
            this.importer = new Ll,
            this.inProgress = !1,
            this.defaultMaterial = null,
            this.objectUrls = null,
            this.hasHighpDriverIssue = Hh()
        }
        InProgress() {
            return this.inProgress
        }
        LoadModel(e, t, n) {
            this.inProgress || (this.inProgress = !0,
            this.RevokeObjectUrls(),
            this.importer.ImportFiles(e, t, {
                onLoadStart: ()=>{
                    n.onLoadStart()
                }
                ,
                onFileListProgress: (i,s)=>{
                    n.onFileListProgress(i, s)
                }
                ,
                onFileLoadProgress: (i,s)=>{
                    n.onFileLoadProgress(i, s)
                }
                ,
                onImportStart: ()=>{
                    n.onImportStart()
                }
                ,
                onSelectMainFile: (i,s)=>{
                    n.onSelectMainFile ? n.onSelectMainFile(i, s) : s(0)
                }
                ,
                onImportSuccess: i=>{
                    n.onVisualizationStart();
                    let s = new Gl;
                    s.forceMediumpForMaterials = this.hasHighpDriverIssue;
                    let o = new Vl;
                    Df(i.model, s, o, {
                        onTextureLoaded: ()=>{
                            n.onTextureLoaded()
                        }
                        ,
                        onModelLoaded: a=>{
                            if (this.defaultMaterial = o.defaultMaterial,
                            this.objectUrls = o.objectUrls,
                            i.upVector === lt.X) {
                                let l = new Sn().setFromAxisAngle(new ue(0,0,1), Math.PI / 2);
                                a.quaternion.multiply(l)
                            } else if (i.upVector === lt.Z) {
                                let l = new Sn().setFromAxisAngle(new ue(1,0,0), -Math.PI / 2);
                                a.quaternion.multiply(l)
                            }
                            n.onModelFinished(i, a),
                            this.inProgress = !1
                        }
                    })
                }
                ,
                onImportError: i=>{
                    n.onLoadError(i),
                    this.inProgress = !1
                }
            }))
        }
        GetImporter() {
            return this.importer
        }
        GetDefaultMaterial() {
            return this.defaultMaterial
        }
        ReplaceDefaultMaterialColor(e) {
            this.defaultMaterial !== null && !this.defaultMaterial.vertexColors && (this.defaultMaterial.color = Xn(e))
        }
        RevokeObjectUrls() {
            if (this.objectUrls !== null) {
                for (let e of this.objectUrls)
                    lf(e);
                this.objectUrls = null
            }
        }
        Destroy() {
            this.RevokeObjectUrls(),
            this.importer = null
        }
    }
    ;
    function Bm(r, e) {
        return r.length > 0 ? r : e
    }
    function Iy(r) {
        return Bm(r, "No Name")
    }
    function Of(r, e) {
        let t = r.length > 0 ? r : e;
        return Bm(t, "No Name")
    }
    function Ff(r) {
        return Bm(r, "No Name")
    }
    function Gm() {
        return window.matchMedia("(hover: hover)").matches
    }
    function Ry() {
        return window.matchMedia("(max-width: 800px)").matches
    }
    function kf(r, e) {
        function t(i, s) {
            let o = window.innerWidth
              , a = i.getBoundingClientRect()
              , l = i.offsetWidth
              , c = i.offsetHeight
              , u = s.offsetWidth
              , h = 10
              , f = a.left + l / 2 - u / 2;
            return f + u > o - h && (f = o - u - h),
            f < h && (f = h),
            f = Math.max(f, 0),
            {
                left: f,
                top: a.top + c + h
            }
        }
        if (!Gm())
            return;
        let n = null;
        r.addEventListener("mouseover", ()=>{
            n = Ce(document.body, "ov_tooltip", e);
            let i = t(r, n);
            n.style.left = i.left + "px",
            n.style.top = i.top + "px"
        }
        ),
        r.addEventListener("mouseout", ()=>{
            n.remove()
        }
        )
    }
    function Py(r) {
        let e = document.createElement("input");
        e.style.position = "absolute",
        e.style.left = "0",
        e.style.top = "0",
        e.setAttribute("value", r),
        document.body.appendChild(e),
        e.select(),
        document.execCommand("copy"),
        document.body.removeChild(e)
    }
    function Vm(r, e) {
        let t = document.createElement("a");
        t.href = r,
        t.download = e,
        document.body.appendChild(t),
        t.click(),
        document.body.removeChild(t)
    }
    function xu(r, e) {
        let t = Ms(r);
        Vm(t, e)
    }
    function _u(r, e) {
        let t = Jn("ov_svg_icon");
        return e && t.classList.add(e),
        Jt(t, "i", "icon icon-" + r),
        t
    }
    function $n(r, e, t) {
        let n = _u(e, t);
        return r.appendChild(n),
        n
    }
    function Is(r, e) {
        let t = r.firstChild;
        t.className = "icon icon-" + e
    }
    function Uf(r) {
        let e = "#" + ci(r)
          , t = new rt(Math.max(0, r.r - 50),Math.max(0, r.g - 50),Math.max(0, r.b - 50))
          , n = "#" + ci(t)
          , i = Jn("ov_color_circle");
        return i.style.background = e,
        i.style.border = "1px solid " + n,
        i
    }
    function Ly(r) {
        return r.r * .299 + r.g * .587 + r.b * .114 > 186
    }
    function Ny(r, e) {
        async function t(s, o) {
            let a = s.createReader();
            return new Promise((l,c)=>{
                a.readEntries(async u=>{
                    for (let h of u)
                        h.isFile ? o.push(h) : h.isDirectory && await t(h, o);
                    l()
                }
                , u=>{
                    c(u)
                }
                )
            }
            )
        }
        async function n(s, o) {
            let a = [];
            for (let c of s)
                c.isFile ? a.push(c) : c.isDirectory && await t(c, a);
            let l = await Promise.all(a.map(c=>new Promise((u,h)=>{
                c.file(f=>{
                    u(f)
                }
                , f=>{
                    h(f)
                }
                )
            }
            )));
            o(l)
        }
        let i = null;
        if (DataTransferItem && (DataTransferItem.prototype.getAsEntry ? i = DataTransferItem.prototype.getAsEntry : DataTransferItem.prototype.webkitGetAsEntry && (i = DataTransferItem.prototype.webkitGetAsEntry)),
        i !== null) {
            let s = [];
            for (let o of r.items) {
                let a = i.call(o);
                a !== null && s.push(a)
            }
            n(s, o=>{
                e(o)
            }
            )
        } else
            e(r.files)
    }
    function Dy(r, e, t) {
        let n = Jt(r, "input", e);
        n.setAttribute("type", "text");
        let i = null;
        return n.addEventListener("input", ()=>{
            n.value = n.value.replace(/[^0-9]/g, ""),
            t && (i !== null && clearTimeout(i),
            i = setTimeout(()=>{
                t(n.value)
            }
            , 1e3))
        }
        ),
        n
    }
    function Bf(r, e, t, n, i) {
        let s = Jt(r, "label");
        s.setAttribute("for", e);
        let o = Jt(s, "input", "ov_checkbox");
        return o.setAttribute("type", "checkbox"),
        o.setAttribute("id", e),
        o.checked = n,
        Jt(s, "span", null, t),
        i && o.addEventListener("change", i),
        o
    }
    function Oy(r, e, t, n, i, s) {
        let o = Jt(r, "label");
        o.setAttribute("for", e);
        let a = Jt(o, "input", "ov_radio_button");
        return a.setAttribute("type", "radio"),
        a.setAttribute("id", e),
        a.setAttribute("name", t),
        a.checked = i,
        Jt(o, "span", null, n),
        s && a.addEventListener("change", s),
        a
    }
    function Fy(r, e, t) {
        let n = Jt(r, "input", "ov_slider");
        return n.setAttribute("type", "range"),
        n.setAttribute("min", e.toString()),
        n.setAttribute("max", t.toString()),
        n
    }
    function ky(r, e, t, n) {
        let i = Ce(r, "ov_select_container")
          , s = Jt(i, "select", "ov_select");
        for (let o of e)
            Jt(s, "option", null, o);
        return s.selectedIndex = t,
        n && s.addEventListener("change", ()=>{
            n(s.selectedIndex)
        }
        ),
        s
    }
    function zm(r, e) {
        function t(a, l) {
            l ? a.classList.add("on") : a.classList.remove("on")
        }
        let n = !1
          , i = null
          , s = "ov_toggle";
        e && (s += " " + e);
        let o = Ce(r, s);
        return Ce(o, "ov_toggle_slider"),
        o.addEventListener("click", ()=>{
            n = !n,
            t(o, n),
            i && i()
        }
        ),
        {
            element: o,
            GetStatus: ()=>n,
            SetStatus: a=>{
                n = a,
                t(o, n)
            }
            ,
            OnChange: a=>{
                i = a
            }
        }
    }
    var Tu = null;
    function Hm() {
        Tu !== null && (Tu.Close(),
        Tu = null)
    }
    function yA() {
        Tu = null
    }
    function xA(r) {
        Hm(),
        Tu = r
    }
    var bu = class {
        constructor() {
            this.modalDiv = Jn("ov_modal"),
            this.modalDiv.addEventListener("mousemove", e=>{
                e.stopPropagation()
            }
            ),
            this.overlayDiv = null,
            this.resizeHandler = null,
            this.positionCalculator = null,
            this.closeHandler = null,
            this.isOpen = !1,
            this.closeable = !0
        }
        GetContentDiv() {
            return this.modalDiv
        }
        SetCloseable(e) {
            this.closeable = e
        }
        SetPositionCalculator(e) {
            this.positionCalculator = e
        }
        SetCloseHandler(e) {
            this.closeHandler = e
        }
        Open() {
            this.isOpen || (xA(this),
            this.overlayDiv = Ce(document.body, "ov_modal_overlay"),
            document.body.appendChild(this.modalDiv),
            this.resizeHandler = this.Resize.bind(this),
            window.addEventListener("resize", this.resizeHandler),
            this.closeable && (this.overlayDiv.addEventListener("click", e=>{
                e.preventDefault(),
                this.Close()
            }
            ),
            this.overlayDiv.addEventListener("mousemove", e=>{
                e.stopPropagation()
            }
            ),
            this.overlayDiv.addEventListener("contextmenu", e=>{
                e.preventDefault(),
                this.Close()
            }
            )),
            this.isOpen = !0,
            this.Resize())
        }
        Close() {
            this.isOpen && (yA(),
            window.removeEventListener("resize", this.resizeHandler),
            this.closeHandler !== null && this.closeHandler(),
            this.modalDiv.remove(),
            this.overlayDiv.remove(),
            this.overlayDiv = null,
            this.resizeHandler = null,
            this.isOpen = !1)
        }
        Resize() {
            let e = window.innerWidth
              , t = window.innerHeight
              , n = (e - this.modalDiv.offsetWidth) / 2
              , i = (t - this.modalDiv.offsetHeight) / 3;
            if (this.positionCalculator !== null) {
                let s = this.positionCalculator();
                n = s.x,
                i = s.y
            }
            this.modalDiv.style.left = n + "px",
            this.modalDiv.style.top = i + "px"
        }
    }
      , ho = class extends bu {
        constructor() {
            super(),
            this.SetCloseable(!1),
            this.textDiv = null
        }
        Init(e) {
            let t = this.GetContentDiv();
            t.classList.add("ov_progress"),
            Ce(t, "ov_progress_img", '<svg><use href="assets/images/3dviewer_net_logo.svg#logo"></use></svg>'),
            this.textDiv = Ce(t, "ov_progress_text"),
            this.SetText(e)
        }
        SetText(e) {
            this.textDiv.innerHTML = e
        }
    }
      , Qn = class extends bu {
        constructor() {
            super()
        }
        Init(e, t) {
            function n(l, c) {
                let u = Ce(c, "ov_button ov_dialog_button", l.name);
                l.subClass && u.classList.add(l.subClass),
                u.addEventListener("click", ()=>{
                    l.onClick()
                }
                )
            }
            let i = this.GetContentDiv();
            i.classList.add("ov_dialog"),
            Ce(i, "ov_dialog_title", e);
            let s = Ce(i, "ov_dialog_content")
              , o = Ce(i, "ov_dialog_buttons")
              , a = Ce(o, "ov_dialog_buttons_inner");
            for (let l = 0; l < t.length; l++)
                n(t[l], a);
            return s
        }
    }
      , Mu = class extends bu {
        constructor() {
            super()
        }
        Init(e) {
            let t = this.GetContentDiv();
            return t.classList.add("ov_popup"),
            this.SetPositionCalculator(e),
            t
        }
    }
      , Gf = class extends Mu {
        constructor() {
            super(),
            this.listDiv = null
        }
        Init(e) {
            let t = super.Init(e);
            return this.listDiv = Ce(t, "ov_popup_list ov_thin_scrollbar"),
            t
        }
        AddListItem(e, t) {
            let n = Ce(this.listDiv, "ov_popup_list_item");
            if (e.icon && $n(n, e.icon, "left_inline"),
            e.color) {
                let i = Ce(n, "ov_popup_list_item_icon")
                  , s = Uf(e.color);
                i.appendChild(s)
            }
            Ce(n, "ov_popup_list_item_name", e.name),
            n.addEventListener("click", t.onClick),
            Gm() && t.onHoverStart && t.onHoverStop && (n.addEventListener("mouseover", ()=>{
                t.onHoverStart()
            }
            ),
            n.addEventListener("mouseout", ()=>{
                t.onHoverStop()
            }
            ))
        }
    }
    ;
    function Er(r, e, t) {
        let n = new Qn
          , i = n.Init(r, [{
            name: "OK",
            onClick() {
                n.Close()
            }
        }]);
        return Ce(i, "ov_dialog_message", e),
        t !== null && Ce(i, "ov_dialog_submessage", t),
        n.Open(),
        n
    }
    function zl(r, e) {
        if (r.length === 0)
            return null;
        let t = new Gf;
        t.Init(()=>e.calculatePosition(t.GetContentDiv()));
        for (let n = 0; n < r.length; n++) {
            let i = r[n];
            t.AddListItem(i, {
                onHoverStart: function() {
                    e.onHoverStart && e.onHoverStart(n)
                },
                onHoverStop: function() {
                    e.onHoverStop && e.onHoverStop(n)
                },
                onClick: function() {
                    t.Close(),
                    e.onClick(n)
                }
            })
        }
        return t.Open(),
        t
    }
    function Uy(r, e) {
        let t = r.getBoundingClientRect();
        return {
            x: t.left - e.offsetWidth,
            y: t.top
        }
    }
    function Vf(r, e) {
        let t = r.getBoundingClientRect();
        return {
            x: t.left + r.offsetWidth,
            y: t.top + r.offsetHeight - e.offsetHeight
        }
    }
    function By(r, e) {
        let t = window.innerWidth
          , n = window.innerHeight
          , i = r.x
          , s = r.y
          , o = i + e.offsetWidth
          , a = s + e.offsetHeight;
        return o > t && (i = i - (o - t)),
        a > n && (s = s - (a - n)),
        {
            x: i,
            y: s
        }
    }
    var Hl = class {
        constructor() {
            this.modelLoader = new uo,
            this.modalDialog = null
        }
        LoadModel(e, t, n) {
            if (this.modelLoader.InProgress())
                return;
            let i = null;
            this.modelLoader.LoadModel(e, t, {
                onLoadStart: ()=>{
                    this.CloseDialogIfOpen(),
                    n.onStart(),
                    i = new ho,
                    i.Init("Loading Model"),
                    i.Open()
                }
                ,
                onFileListProgress: (s,o)=>{}
                ,
                onFileLoadProgress: (s,o)=>{}
                ,
                onSelectMainFile: (s,o)=>{
                    i.Close(),
                    this.modalDialog = this.ShowFileSelectorDialog(s, a=>{
                        i.Open(),
                        o(a)
                    }
                    )
                }
                ,
                onImportStart: ()=>{
                    i.SetText("Importing Model")
                }
                ,
                onVisualizationStart: ()=>{
                    i.SetText("Visualizing Model")
                }
                ,
                onModelFinished: (s,o)=>{
                    i.Close(),
                    n.onFinish(s, o)
                }
                ,
                onTextureLoaded: ()=>{
                    n.onRender()
                }
                ,
                onLoadError: s=>{
                    i.Close(),
                    n.onError(s),
                    this.modalDialog = this.ShowErrorDialog(s)
                }
            })
        }
        GetModelLoader() {
            return this.modelLoader
        }
        GetImporter() {
            return this.modelLoader.GetImporter()
        }
        ShowErrorDialog(e) {
            return e.code === Un.NoImportableFile ? Er("Something went wrong", "No importable file found.", null) : e.code === Un.FailedToLoadFile ? Er("Something went wrong", "Failed to load file for import.", "The remote server refused to fulfill the request. Check if the url is correct, and make sure that CORS requests are allowed on the remote server.") : e.code === Un.ImportFailed ? Er("Something went wrong", "Failed to import model.", e.message) : Er("Something went wrong", "Unknown error.", null)
        }
        ShowFileSelectorDialog(e, t) {
            let n = new Qn
              , i = n.Init("Select Model", [{
                name: "Cancel",
                subClass: "outline",
                onClick() {
                    n.Close()
                }
            }]);
            n.SetCloseHandler(()=>{
                t(null)
            }
            ),
            Ce(i, "ov_dialog_message", "Multiple importable models found. Select the model you would like to import from the list below.");
            let o = Ce(i, "ov_dialog_section")
              , a = Ce(o, "ov_dialog_import_file_list ov_thin_scrollbar");
            for (let l = 0; l < e.length; l++) {
                let c = e[l]
                  , u = Ce(a, "ov_dialog_file_link");
                $n(u, "meshes", "ov_file_link_img"),
                Ce(u, "ov_dialog_file_link_text", c),
                u.addEventListener("click", ()=>{
                    n.SetCloseHandler(null),
                    n.Close(),
                    t(l)
                }
                )
            }
            return n.Open(),
            n
        }
        CloseDialogIfOpen() {
            this.modalDialog !== null && (this.modalDialog.Close(),
            this.modalDialog = null)
        }
    }
    ;
    var zf = class {
        constructor(e) {
            this.parameters = e,
            this.viewer = new Kr,
            this.hashHandler = new Bl,
            this.modelLoaderUI = new Hl
        }
        Load() {
            let e = Jt(this.parameters.viewerDiv, "canvas");
            if (this.viewer.Init(e),
            this.Resize(),
            this.hashHandler.HasHash()) {
                let t = this.hashHandler.GetModelFilesFromHash();
                if (t === null)
                    return;
                to(t);
                let n = "fishermans_bastion"
                  , i = !1
                  , s = this.hashHandler.GetEnvironmentSettingsFromHash();
                s !== null && (n = s.environmentMapName,
                i = s.backgroundIsEnvMap);
                let o = "assets/envmaps/" + n + "/"
                  , a = [o + "posx.jpg", o + "negx.jpg", o + "posy.jpg", o + "negy.jpg", o + "posz.jpg", o + "negz.jpg"]
                  , l = new Bi(a,i);
                this.viewer.SetEnvironmentMapSettings(l);
                let c = this.hashHandler.GetCameraModeFromHash();
                c !== null && this.viewer.SetCameraMode(c);
                let u = this.hashHandler.GetBackgroundFromHash();
                u !== null && this.viewer.SetBackgroundColor(u);
                let h = this.hashHandler.GetEdgeSettingsFromHash();
                h !== null && this.viewer.SetEdgeSettings(h);
                let f = new br
                  , m = this.hashHandler.GetDefaultColorFromHash();
                m !== null && (f.defaultColor = m);
                let g = no(t);
                this.modelLoaderUI.LoadModel(g, f, {
                    onStart: ()=>{}
                    ,
                    onFinish: (d,x)=>{
                        this.OnModelFinished(x)
                    }
                    ,
                    onRender: ()=>{
                        this.viewer.Render()
                    }
                    ,
                    onError: d=>{}
                });
                let v = rl(t)
                  , p = this.parameters.websiteLinkDiv.getAttribute("href") + "#" + v;
                this.parameters.websiteLinkDiv.setAttribute("href", p)
            }
            window.addEventListener("resize", ()=>{
                this.Resize()
            }
            )
        }
        Resize() {
            let e = window.innerWidth
              , t = window.innerHeight;
            this.viewer.Resize(e, t)
        }
        OnModelFinished(e) {
            this.viewer.SetMainObject(e);
            let t = this.viewer.GetBoundingSphere(i=>!0);
            this.viewer.AdjustClippingPlanesToSphere(t);
            let n = this.hashHandler.GetCameraFromHash();
            n !== null ? this.viewer.SetCamera(n) : (this.viewer.SetUpVector(lt.Y, !1),
            this.viewer.FitSphereToWindow(t, !1))
        }
    }
    ;
    var Hf = null;
    function Gy(r) {
        Hf = r
    }
    function dn(r, e, t) {
        Hf?.(r, e, t)
    }
    var Wl = class {
        constructor(e) {
            this.parentDiv = e,
            this.panelDiv = Ce(e),
            It(this.panelDiv, !1),
            this.visible = !1
        }
        GetName() {
            return null
        }
        GetIcon() {
            return null
        }
        IsVisible() {
            return this.visible
        }
        Show(e) {
            this.visible !== e && (this.visible = e,
            It(this.panelDiv, this.visible))
        }
        Resize() {}
        Clear() {}
    }
      , Xl = class {
        constructor(e) {
            this.parentDiv = e,
            this.menuDiv = Ce(e, "ov_panel_set_menu"),
            this.contentDiv = Ce(e, "ov_panel_set_content ov_thin_scrollbar"),
            this.panels = [],
            this.panelButtons = [],
            this.panelsVisible = !0,
            this.panelsPrevWidth = null,
            this.callbacks = null
        }
        Init(e) {
            this.callbacks = e
        }
        GetContentDiv() {
            return this.contentDiv
        }
        AddPanel(e) {
            this.panels.push(e);
            let t = $n(this.menuDiv, e.GetIcon(), "ov_panel_set_menu_button");
            t.setAttribute("alt", e.GetName()),
            t.setAttribute("title", e.GetName()),
            this.panelButtons.push(t),
            t.addEventListener("click", ()=>{
                e === this.GetVisiblePanel() ? this.ShowPanels(!1) : (this.ShowPanels(!0),
                this.ShowPanel(e))
            }
            )
        }
        IsPanelsVisible() {
            return this.panelsVisible
        }
        ShowPanels(e) {
            if (this.IsParentVisible() && this.panelsVisible !== e) {
                if (this.panelsVisible = e,
                this.panelsVisible)
                    It(this.contentDiv, !0),
                    Dl(this.parentDiv, this.menuDiv.offsetWidth + this.panelsPrevWidth);
                else {
                    for (let t of this.panelButtons)
                        t.classList.remove("selected");
                    for (let t of this.panels)
                        t.Show(!1);
                    this.panelsPrevWidth = this.contentDiv.offsetWidth,
                    Dl(this.parentDiv, this.menuDiv.offsetWidth),
                    It(this.contentDiv, !1)
                }
                this.callbacks.onShowHidePanels(this.panelsVisible),
                this.callbacks.onResizeRequested()
            }
        }
        ShowPanel(e) {
            if (e === this.GetVisiblePanel())
                return;
            let t = this.GetPanelButton(e);
            for (let n of this.panelButtons)
                n !== t && n.classList.remove("selected");
            t.classList.add("selected");
            for (let n of this.panels)
                n !== e && n.Show(!1);
            e.Show(!0),
            e.Resize()
        }
        GetVisiblePanel() {
            if (!this.panelsVisible)
                return null;
            for (let e of this.panels)
                if (e.IsVisible())
                    return e;
            return null
        }
        SetPanelIcon(e, t) {
            let n = this.GetPanelButton(e);
            Is(n, t)
        }
        GetPanelButton(e) {
            let t = this.panels.indexOf(e);
            return this.panelButtons[t]
        }
        Resize() {
            let e = this.parentDiv.offsetHeight;
            if ($i(this.menuDiv, e),
            $i(this.contentDiv, e),
            this.panelsVisible)
                for (let t of this.panels)
                    t.IsVisible() && t.Resize()
        }
        IsParentVisible() {
            return Nl(this.parentDiv)
        }
        Clear() {
            for (let e of this.panels)
                e.Clear()
        }
    }
    ;
    function Vy(r) {
        r.scrollIntoView({
            behavior: "smooth",
            block: "nearest"
        })
    }
    var Rs = class {
        constructor(e) {
            this.imagePath = e,
            this.mainElement = _u(this.imagePath, "ov_tree_item_button"),
            this.mainElement.setAttribute("src", this.imagePath)
        }
        SetImage(e) {
            this.imagePath = e,
            Is(this.mainElement, this.imagePath)
        }
        OnClick(e) {
            this.mainElement.addEventListener("click", t=>{
                t.stopPropagation(),
                e(t)
            }
            )
        }
        GetDomElement() {
            return this.mainElement
        }
    }
      , Wf = class {
        constructor(e, t) {
            if (this.name = e,
            this.parent = null,
            this.mainElement = Jn("ov_tree_item"),
            this.mainElement.setAttribute("title", this.name),
            this.nameElement = Ce(this.mainElement, "ov_tree_item_name", this.name),
            Hr(t)) {
                let n = _u(t, "ov_tree_item_icon");
                Cs(n, this.nameElement)
            }
        }
        OnClick(e) {
            this.mainElement.classList.add("clickable"),
            this.mainElement.style.cursor = "pointer",
            this.mainElement.addEventListener("click", e)
        }
        SetParent(e) {
            this.parent = e
        }
        AddDomElements(e) {
            e.appendChild(this.mainElement)
        }
    }
      , fo = class extends Wf {
        constructor(e, t) {
            super(e, t),
            this.selected = !1
        }
        SetSelected(e) {
            if (this.selected = e,
            this.selected) {
                this.mainElement.classList.add("selected");
                let t = this.parent;
                if (t === null)
                    Vy(this.mainElement);
                else
                    for (; t !== null; )
                        t.ShowChildren(!0),
                        Vy(this.mainElement),
                        t = t.parent
            } else
                this.mainElement.classList.remove("selected")
        }
    }
      , jl = class extends fo {
        constructor(e, t) {
            super(e, t),
            this.buttonsDiv = Jn("ov_tree_item_button_container"),
            Cs(this.buttonsDiv, this.nameElement)
        }
        AppendButton(e) {
            this.buttonsDiv.appendChild(e.GetDomElement())
        }
    }
      , po = class extends Wf {
        constructor(e, t) {
            super(e, t),
            this.children = [],
            this.isVisible = !0,
            this.isChildrenVisible = !1,
            this.childrenDiv = null,
            this.openButtonIcon = "arrow_down",
            this.closeButtonIcon = "arrow_right",
            this.openCloseButton = _u(this.openButtonIcon, "ov_tree_item_icon"),
            Cs(this.openCloseButton, this.nameElement)
        }
        AddChild(e) {
            this.CreateChildrenDiv(),
            this.children.push(e),
            e.SetParent(this),
            e.AddDomElements(this.childrenDiv)
        }
        ExpandAll(e) {
            for (let t of this.children)
                t instanceof po && (t.ShowChildren(e),
                t.ExpandAll(e))
        }
        Show(e) {
            this.isVisible = e,
            this.childrenDiv !== null && (this.isVisible ? (It(this.mainElement, !0),
            this.childrenDiv.classList.add("ov_tree_view_children")) : (It(this.mainElement, !1),
            this.childrenDiv.classList.remove("ov_tree_view_children")))
        }
        ShowChildren(e) {
            this.isChildrenVisible = e,
            this.childrenDiv !== null && (e ? (Is(this.openCloseButton, this.openButtonIcon),
            It(this.childrenDiv, !0)) : (Is(this.openCloseButton, this.closeButtonIcon),
            It(this.childrenDiv, !1)))
        }
        CreateChildrenDiv() {
            return this.childrenDiv === null && (this.childrenDiv = Jn("ov_tree_view_children"),
            Rf(this.childrenDiv, this.mainElement),
            this.Show(this.isVisible),
            this.ShowChildren(this.isChildrenVisible),
            this.OnClick(e=>{
                this.isChildrenVisible = !this.isChildrenVisible,
                this.ShowChildren(this.isChildrenVisible)
            }
            )),
            this.childrenDiv
        }
    }
      , Xf = class extends po {
        constructor(e, t) {
            super(e, t),
            this.buttonsDiv = Jn("ov_tree_item_button_container"),
            Cs(this.buttonsDiv, this.nameElement)
        }
        AppendButton(e) {
            this.buttonsDiv.appendChild(e.GetDomElement())
        }
    }
      , jf = class {
        constructor(e) {
            this.mainDiv = Ce(e, "ov_tree_view"),
            this.children = []
        }
        AddClass(e) {
            this.mainDiv.classList.add(e)
        }
        AddChild(e) {
            e.AddDomElements(this.mainDiv),
            this.children.push(e)
        }
        Clear() {
            Zn(this.mainDiv),
            this.children = []
        }
    }
    ;
    var ql = class {
        constructor(e) {
            this.parentDiv = e,
            this.callbacks = null,
            this.popup = null,
            this.button = Ce(this.parentDiv, "ov_panel_button"),
            this.buttonText = Ce(this.button, "ov_panel_button_text"),
            $n(this.button, "arrow_right", "ov_panel_button_icon"),
            this.button.addEventListener("click", ()=>{
                this.OnButtonClick()
            }
            )
        }
        Init(e) {
            this.callbacks = e
        }
        OnButtonClick() {}
        Clear() {
            this.popup !== null && (this.popup.Close(),
            this.popup = null)
        }
    }
      , mo = class extends Wl {
        constructor(e) {
            super(e),
            this.callbacks = null,
            this.titleDiv = Ce(this.panelDiv, "ov_navigator_tree_title"),
            this.treeDiv = Ce(this.panelDiv, "ov_navigator_tree_panel ov_thin_scrollbar"),
            this.treeView = new jf(this.treeDiv);
            let t = this.GetName();
            this.titleDiv.innerHTML = t,
            this.titleDiv.setAttribute("title", t)
        }
        Clear() {
            this.treeView.Clear()
        }
        GetName() {
            return null
        }
        Init(e) {
            this.callbacks = e
        }
        Fill(e) {}
    }
    ;
    var qf = class extends mo {
        constructor(e) {
            super(e)
        }
        GetName() {
            return "Files"
        }
        GetIcon() {
            return "files"
        }
        Resize() {
            let e = Mr(this.titleDiv)
              , t = this.parentDiv.offsetHeight;
            $i(this.treeDiv, t - e)
        }
        Clear() {
            super.Clear()
        }
        Fill(e) {
            super.Fill(e);
            let t = e.usedFiles
              , n = e.missingFiles;
            if (n.length > 0) {
                let i = new po("Missing Files",null);
                i.ShowChildren(!0),
                this.treeView.AddChild(i);
                for (let o = 0; o < n.length; o++) {
                    let a = n[o]
                      , l = new jl(a)
                      , c = new Rs("open");
                    c.OnClick(()=>{
                        this.callbacks.onFileBrowseButtonClicked()
                    }
                    ),
                    l.AppendButton(c),
                    i.AddChild(l)
                }
                let s = new po("Available Files",null);
                s.ShowChildren(!0),
                this.treeView.AddChild(s);
                for (let o = 0; o < t.length; o++) {
                    let a = t[o]
                      , l = new fo(a);
                    s.AddChild(l)
                }
            } else
                for (let i = 0; i < t.length; i++) {
                    let s = t[i]
                      , o = new fo(s);
                    this.treeView.AddChild(o)
                }
        }
    }
    ;
    var Si = {
        No: 0,
        Parents: 1,
        Children: 2,
        All: 3
    }
      , Yf = class extends fo {
        constructor(e, t, n) {
            super(e),
            this.OnClick(()=>{
                n.onSelected(t)
            }
            )
        }
    }
      , Zo = class extends jl {
        constructor(e, t, n, i) {
            super(e, t),
            this.meshInstanceId = n,
            this.visible = !0,
            this.fitToWindowButton = new Rs("fit"),
            this.fitToWindowButton.OnClick(()=>{
                i.onFitToWindow(this.meshInstanceId)
            }
            ),
            this.AppendButton(this.fitToWindowButton),
            this.showHideButton = new Rs("visible"),
            this.showHideButton.OnClick(()=>{
                i.onShowHide(this.meshInstanceId)
            }
            ),
            this.AppendButton(this.showHideButton),
            this.OnClick(()=>{
                i.onSelected(this.meshInstanceId)
            }
            )
        }
        GetMeshInstanceId() {
            return this.meshInstanceId
        }
        IsVisible() {
            return this.visible
        }
        SetVisible(e, t) {
            if (this.visible !== e && (this.visible = e,
            this.visible ? this.showHideButton.SetImage("visible") : this.showHideButton.SetImage("hidden"),
            t === Si.Parents && this.parent instanceof Sr)) {
                let n = this.parent.CalculateIsVisible();
                this.parent.SetVisible(n, Si.Parents)
            }
        }
    }
      , Sr = class extends Xf {
        constructor(e, t, n) {
            super(e, null),
            this.nodeId = t,
            this.callbacks = n,
            this.visible = !0,
            this.fitToWindowButton = new Rs("fit"),
            this.fitToWindowButton.OnClick(()=>{
                this.callbacks.onFitToWindow(t)
            }
            ),
            this.AppendButton(this.fitToWindowButton),
            this.showHideButton = new Rs("visible"),
            this.showHideButton.OnClick(()=>{
                this.callbacks.onShowHide(t)
            }
            ),
            this.AppendButton(this.showHideButton)
        }
        GetNodeId() {
            return this.nodeId
        }
        IsVisible() {
            return this.visible
        }
        CalculateIsVisible() {
            let e = !1;
            for (let t of this.children)
                if ((t instanceof Sr || t instanceof Zo) && t.IsVisible()) {
                    e = !0;
                    break
                }
            return e
        }
        SetVisible(e, t) {
            if (this.visible !== e) {
                if (this.visible = e,
                this.visible ? this.showHideButton.SetImage("visible") : this.showHideButton.SetImage("hidden"),
                Hr(this.callbacks.onVisibilityChanged) && this.callbacks.onVisibilityChanged(this.visible),
                t === Si.Children || t === Si.All)
                    for (let n of this.children)
                        (n instanceof Sr || n instanceof Zo) && n.SetVisible(this.visible, Si.Children);
                if ((t === Si.Parents || t === Si.All) && this.parent instanceof Sr) {
                    let n = this.parent.CalculateIsVisible();
                    this.parent.SetVisible(n, Si.Parents)
                }
            }
        }
        EnumerateMeshItems(e) {
            for (let t of this.children)
                t instanceof Sr ? t.EnumerateMeshItems(e) : t instanceof Zo && e(t)
        }
    }
    ;
    var Wm = class extends ql {
        constructor(e) {
            super(e),
            this.meshInstanceArray = null
        }
        Update(e) {
            if (this.meshInstanceArray = e,
            this.meshInstanceArray === null)
                return;
            let t = "Meshes (" + this.meshInstanceArray.length + ")";
            this.buttonText.innerHTML = t
        }
        OnButtonClick() {
            if (this.meshInstanceArray === null)
                return;
            let e = [];
            for (let t = 0; t < this.meshInstanceArray.length; t++) {
                let n = this.meshInstanceArray[t];
                e.push({
                    name: Of(n.node.GetName(), n.mesh.GetName())
                })
            }
            e.length !== 0 && (this.popup = zl(e, {
                calculatePosition: t=>Vf(this.button, t),
                onHoverStart: t=>{
                    let n = this.meshInstanceArray[t];
                    this.callbacks.onMeshHover(n.id)
                }
                ,
                onHoverStop: t=>{
                    this.callbacks.onMeshHover(null)
                }
                ,
                onClick: t=>{
                    let n = this.meshInstanceArray[t];
                    this.callbacks.onMeshSelected(n.id)
                }
            }))
        }
    }
      , Kf = class extends mo {
        constructor(e) {
            super(e),
            this.callbacks = null,
            this.materialIndexToItem = new Map,
            this.popupDiv = Ce(this.panelDiv, "ov_navigator_info_panel"),
            this.meshesButton = new Wm(this.popupDiv)
        }
        GetName() {
            return "Materials"
        }
        GetIcon() {
            return "materials"
        }
        Resize() {
            let e = Mr(this.titleDiv)
              , t = Mr(this.popupDiv)
              , n = this.parentDiv.offsetHeight;
            $i(this.treeDiv, n - e - t)
        }
        Clear() {
            super.Clear(),
            this.meshesButton.Clear(),
            this.materialIndexToItem = new Map
        }
        Init(e) {
            super.Init(e),
            this.meshesButton.Init({
                onMeshHover: t=>{
                    this.callbacks.onMeshTemporarySelected(t)
                }
                ,
                onMeshSelected: t=>{
                    this.callbacks.onMeshSelected(t)
                }
            })
        }
        Fill(e) {
            super.Fill(e);
            let t = e.model;
            for (let n = 0; n < t.MaterialCount(); n++) {
                let i = t.GetMaterial(n)
                  , s = Ff(i.name)
                  , o = new Yf(s,n,{
                    onSelected: a=>{
                        this.callbacks.onMaterialSelected(a)
                    }
                });
                this.materialIndexToItem.set(n, o),
                this.treeView.AddChild(o)
            }
        }
        GetMaterialItem(e) {
            return this.materialIndexToItem.get(e)
        }
        SelectMaterialItem(e, t) {
            this.GetMaterialItem(e).SetSelected(t)
        }
        UpdateMeshList(e) {
            this.meshesButton.Update(e)
        }
    }
    ;
    var wi = {
        Simple: 0,
        FlatList: 1,
        TreeView: 2
    }
      , Xm = class extends ql {
        constructor(e) {
            super(e),
            this.materialInfoArray = null
        }
        Update(e) {
            if (this.materialInfoArray = e,
            this.materialInfoArray === null)
                return;
            let t = "Materials (" + this.materialInfoArray.length + ")";
            this.buttonText.innerHTML = t
        }
        OnButtonClick() {
            if (this.materialInfoArray === null)
                return;
            let e = [];
            for (let t = 0; t < this.materialInfoArray.length; t++) {
                let n = this.materialInfoArray[t];
                e.push({
                    name: Ff(n.name),
                    color: n.color
                })
            }
            e.length !== 0 && (this.popup = zl(e, {
                calculatePosition: t=>Vf(this.button, t),
                onClick: t=>{
                    let n = this.materialInfoArray[t];
                    this.callbacks.onMaterialSelected(n.index)
                }
            }))
        }
    }
      , Zf = class extends mo {
        constructor(e) {
            super(e),
            this.callbacks = null,
            this.nodeIdToItem = new Map,
            this.meshInstanceIdToItem = new Map,
            this.rootItem = null,
            this.mode = wi.Simple,
            this.buttons = null,
            this.treeView.AddClass("tight"),
            this.titleButtonsDiv = Ce(this.titleDiv, "ov_navigator_tree_title_buttons"),
            this.buttonsDiv = Jn("ov_navigator_buttons"),
            Cs(this.buttonsDiv, this.treeDiv),
            this.popupDiv = Ce(this.panelDiv, "ov_navigator_info_panel"),
            this.materialsButton = new Xm(this.popupDiv)
        }
        GetName() {
            return "Meshes"
        }
        GetIcon() {
            return "meshes"
        }
        Resize() {
            let e = Mr(this.titleDiv)
              , t = 0;
            Nl(this.buttonsDiv) && (t = Mr(this.buttonsDiv));
            let n = Mr(this.popupDiv)
              , i = this.parentDiv.offsetHeight;
            $i(this.treeDiv, i - e - t - n)
        }
        Clear() {
            this.ClearMeshTree(),
            Zn(this.titleButtonsDiv),
            Zn(this.buttonsDiv),
            this.buttons = null
        }
        ClearMeshTree() {
            super.Clear(),
            this.materialsButton.Clear(),
            this.nodeIdToItem = new Map,
            this.meshInstanceIdToItem = new Map,
            this.rootItem = null
        }
        Init(e) {
            super.Init(e),
            this.materialsButton.Init({
                onMeshHover: t=>{
                    this.callbacks.onMeshTemporarySelected(t)
                }
                ,
                onMeshSelected: t=>{
                    this.callbacks.onMeshSelected(t)
                }
                ,
                onMaterialSelected: t=>{
                    this.callbacks.onMaterialSelected(t)
                }
            })
        }
        Fill(e) {
            super.Fill(e);
            let t = e.model.GetRootNode()
              , n = !1;
            for (let i of t.GetChildNodes())
                if (i.ChildNodeCount() > 0 || i.MeshIndexCount() > 1) {
                    n = !0;
                    break
                }
            this.mode === wi.Simple && n ? this.mode = wi.TreeView : this.mode !== wi.Simple && !n && (this.mode = wi.Simple),
            this.FillButtons(e),
            this.mode === wi.Simple ? (It(this.buttonsDiv, !1),
            this.titleDiv.classList.add("withbuttons"),
            this.titleDiv.classList.remove("nomargin")) : (It(this.buttonsDiv, !0),
            this.titleDiv.classList.remove("withbuttons"),
            this.titleDiv.classList.add("nomargin")),
            this.FillMeshTree(e.model),
            this.Resize()
        }
        FillButtons(e) {
            function t(s, o, a, l) {
                o.div = Ce(s, "ov_navigator_button"),
                o.div.setAttribute("alt", o.name),
                o.div.setAttribute("title", o.name),
                a && o.div.classList.add(a),
                o.iconDiv = $n(o.div, o.icon),
                o.div.addEventListener("click", ()=>{
                    l()
                }
                )
            }
            function n(s, o) {
                let a = o === wi.TreeView;
                a ? (s.flatList.iconDiv.classList.remove("selected"),
                s.treeView.iconDiv.classList.add("selected")) : (s.flatList.iconDiv.classList.add("selected"),
                s.treeView.iconDiv.classList.remove("selected")),
                It(s.separator, a),
                It(s.expandAll.div, a),
                It(s.collapseAll.div, a)
            }
            function i(s, o) {
                let a = [];
                s.EnumerateMeshItems(l=>(l.IsVisible() || a.push(l.GetMeshInstanceId()),
                !0)),
                s.ClearMeshTree(),
                s.FillMeshTree(o.model);
                for (let l of a)
                    s.GetMeshItem(l).SetVisible(!1, Si.Parents);
                n(s.buttons, s.mode),
                s.callbacks.onViewTypeChanged()
            }
            this.buttons = {
                flatList: {
                    name: "Flat list",
                    icon: "flat_list",
                    div: null,
                    iconDiv: null
                },
                treeView: {
                    name: "Tree view",
                    icon: "tree_view",
                    div: null,
                    iconDiv: null
                },
                separator: null,
                expandAll: {
                    name: "Expand all",
                    icon: "expand",
                    div: null,
                    iconDiv: null
                },
                collapseAll: {
                    name: "Collapse all",
                    icon: "collapse",
                    div: null,
                    iconDiv: null
                },
                showHideMeshes: {
                    name: "Show/hide meshes",
                    icon: "visible",
                    div: null,
                    iconDiv: null
                },
                fitToWindow: {
                    name: "Fit meshes to window",
                    icon: "fit",
                    div: null,
                    iconDiv: null
                }
            },
            this.mode === wi.Simple ? (t(this.titleButtonsDiv, this.buttons.showHideMeshes, "right", ()=>{
                let s = this.rootItem.GetNodeId();
                this.callbacks.onNodeShowHide(s)
            }
            ),
            t(this.titleButtonsDiv, this.buttons.fitToWindow, "right", ()=>{
                let s = this.rootItem.GetNodeId();
                this.callbacks.onNodeFitToWindow(s)
            }
            )) : (t(this.buttonsDiv, this.buttons.flatList, null, ()=>{
                this.mode !== wi.FlatList && (this.mode = wi.FlatList,
                i(this, e))
            }
            ),
            t(this.buttonsDiv, this.buttons.treeView, null, ()=>{
                this.mode !== wi.TreeView && (this.mode = wi.TreeView,
                i(this, e))
            }
            ),
            this.buttons.separator = Ce(this.buttonsDiv, "ov_navigator_buttons_separator"),
            t(this.buttonsDiv, this.buttons.expandAll, null, ()=>{
                this.rootItem.ExpandAll(!0)
            }
            ),
            t(this.buttonsDiv, this.buttons.collapseAll, null, ()=>{
                this.rootItem.ExpandAll(!1)
            }
            ),
            t(this.buttonsDiv, this.buttons.showHideMeshes, "right", ()=>{
                let s = this.rootItem.GetNodeId();
                this.callbacks.onNodeShowHide(s)
            }
            ),
            t(this.buttonsDiv, this.buttons.fitToWindow, "right", ()=>{
                let s = this.rootItem.GetNodeId();
                this.callbacks.onNodeFitToWindow(s)
            }
            ),
            n(this.buttons, this.mode))
        }
        FillMeshTree(e) {
            function t(a, l, c, u, h, f) {
                let m = Of(l.GetName(), c.GetName())
                  , g = new gi(l.GetId(),u)
                  , v = f === wi.TreeView ? "tree_mesh" : null
                  , p = new Zo(m,v,g,{
                    onShowHide: d=>{
                        a.callbacks.onMeshShowHide(d)
                    }
                    ,
                    onFitToWindow: d=>{
                        a.callbacks.onMeshFitToWindow(d)
                    }
                    ,
                    onSelected: d=>{
                        a.callbacks.onMeshSelected(d)
                    }
                });
                a.meshInstanceIdToItem.set(g.GetKey(), p),
                h.AddChild(p)
            }
            function n(a, l) {
                let c = Iy(l.GetName())
                  , u = l.GetId()
                  , h = new Sr(c,u,{
                    onShowHide: f=>{
                        a.callbacks.onNodeShowHide(f)
                    }
                    ,
                    onFitToWindow: f=>{
                        a.callbacks.onNodeFitToWindow(f)
                    }
                });
                return a.nodeIdToItem.set(u, h),
                h
            }
            function i(a, l) {
                let c = l.GetId()
                  , u = new Sr(null,c,{
                    onVisibilityChanged: h=>{
                        h ? Is(a.buttons.showHideMeshes.iconDiv, "visible") : Is(a.buttons.showHideMeshes.iconDiv, "hidden")
                    }
                });
                return u.Show(!1),
                u.ShowChildren(!0),
                a.treeView.AddChild(u),
                a.nodeIdToItem.set(c, u),
                u
            }
            function s(a, l, c, u, h) {
                let f = [];
                for (let m of c.GetChildNodes())
                    if (h === wi.TreeView)
                        if (m.IsMeshNode())
                            f.push(m);
                        else {
                            let g = n(a, m);
                            u.AddChild(g),
                            s(a, l, m, g, h)
                        }
                    else
                        s(a, l, m, u, h);
                for (let m of f)
                    s(a, l, m, u, h);
                for (let m of c.GetMeshIndices()) {
                    let g = l.GetMesh(m);
                    t(a, c, g, m, u, h)
                }
            }
            let o = e.GetRootNode();
            this.rootItem = i(this, o),
            s(this, e, o, this.rootItem, this.mode)
        }
        UpdateMaterialList(e) {
            this.materialsButton.Update(e)
        }
        GetNodeItem(e) {
            return this.nodeIdToItem.get(e)
        }
        MeshItemCount() {
            return this.meshInstanceIdToItem.size
        }
        GetMeshItem(e) {
            return this.meshInstanceIdToItem.get(e.GetKey())
        }
        EnumerateNodeItems(e) {
            for (let t of this.nodeIdToItem.values())
                if (!e(t))
                    break
        }
        EnumerateMeshItems(e) {
            for (let t of this.meshInstanceIdToItem.values())
                if (!e(t))
                    break
        }
        IsMeshVisible(e) {
            return this.GetMeshItem(e).IsVisible()
        }
        HasHiddenMesh() {
            let e = !1;
            return this.EnumerateMeshItems(t=>t.IsVisible() ? !0 : (e = !0,
            !1)),
            e
        }
        ShowAllMeshes(e) {
            this.EnumerateNodeItems(t=>(t.SetVisible(e, Si.No),
            !0)),
            this.EnumerateMeshItems(t=>(t.SetVisible(e, Si.No),
            !0))
        }
        ToggleNodeVisibility(e) {
            let t = this.GetNodeItem(e);
            t.SetVisible(!t.IsVisible(), Si.All)
        }
        ToggleMeshVisibility(e) {
            let t = this.GetMeshItem(e);
            t.SetVisible(!t.IsVisible(), Si.Parents)
        }
        IsMeshIsolated(e) {
            let t = !0;
            return this.EnumerateMeshItems(n=>!n.GetMeshInstanceId().IsEqual(e) && n.IsVisible() ? (t = !1,
            !1) : !0),
            t
        }
        IsolateMesh(e) {
            this.ShowAllMeshes(!1),
            this.ToggleMeshVisibility(e)
        }
    }
    ;
    var qn = {
        Material: 1,
        Mesh: 2
    }
      , go = class {
        constructor(e, t) {
            this.type = e,
            this.materialIndex = null,
            this.meshInstanceId = null,
            this.type === qn.Material ? this.materialIndex = t : this.type === qn.Mesh && (this.meshInstanceId = t)
        }
        IsEqual(e) {
            if (this.type !== e.type)
                return !1;
            if (this.type === qn.Material)
                return this.materialIndex === e.materialIndex;
            if (this.type === qn.Mesh)
                return this.meshInstanceId.IsEqual(e.meshInstanceId)
        }
    }
      , Jf = class {
        constructor(e) {
            this.mainDiv = e,
            this.panelSet = new Xl(e),
            this.callbacks = null,
            this.selection = null,
            this.tempSelectedMeshId = null,
            this.filesPanel = new qf(this.panelSet.GetContentDiv()),
            this.materialsPanel = new Kf(this.panelSet.GetContentDiv()),
            this.meshesPanel = new Zf(this.panelSet.GetContentDiv()),
            this.panelSet.AddPanel(this.filesPanel),
            this.panelSet.AddPanel(this.materialsPanel),
            this.panelSet.AddPanel(this.meshesPanel),
            this.panelSet.ShowPanel(this.meshesPanel)
        }
        IsPanelsVisible() {
            return this.panelSet.IsPanelsVisible()
        }
        ShowPanels(e) {
            this.panelSet.ShowPanels(e)
        }
        Init(e) {
            this.callbacks = e,
            this.panelSet.Init({
                onResizeRequested: ()=>{
                    this.callbacks.onResizeRequested()
                }
                ,
                onShowHidePanels: t=>{
                    this.callbacks.onShowHidePanels(t)
                }
            }),
            this.filesPanel.Init({
                onFileBrowseButtonClicked: ()=>{
                    this.callbacks.openFileBrowserDialog()
                }
            }),
            this.materialsPanel.Init({
                onMaterialSelected: t=>{
                    this.SetSelection(new go(qn.Material,t))
                }
                ,
                onMeshTemporarySelected: t=>{
                    this.tempSelectedMeshId = t,
                    this.callbacks.onMeshSelectionChanged()
                }
                ,
                onMeshSelected: t=>{
                    this.SetSelection(new go(qn.Mesh,t))
                }
            }),
            this.meshesPanel.Init({
                onMeshSelected: t=>{
                    this.SetSelection(new go(qn.Mesh,t))
                }
                ,
                onMeshShowHide: t=>{
                    this.ToggleMeshVisibility(t)
                }
                ,
                onMeshFitToWindow: t=>{
                    this.FitMeshToWindow(t)
                }
                ,
                onNodeShowHide: t=>{
                    this.ToggleNodeVisibility(t)
                }
                ,
                onNodeFitToWindow: t=>{
                    this.FitNodeToWindow(t)
                }
                ,
                onMaterialSelected: t=>{
                    this.SetSelection(new go(qn.Material,t))
                }
                ,
                onViewTypeChanged: ()=>{
                    this.SetSelection(null)
                }
            })
        }
        GetWidth() {
            return Ei(this.mainDiv)
        }
        SetWidth(e) {
            Ol(this.mainDiv, e)
        }
        Resize(e) {
            Qi(this.mainDiv, e),
            this.panelSet.Resize()
        }
        FillTree(e) {
            this.filesPanel.Fill(e),
            e.missingFiles.length === 0 ? this.panelSet.SetPanelIcon(this.filesPanel, "files") : this.panelSet.SetPanelIcon(this.filesPanel, "missing_files"),
            this.materialsPanel.Fill(e),
            this.meshesPanel.Fill(e),
            this.OnSelectionChanged()
        }
        MeshItemCount() {
            return this.meshesPanel.MeshItemCount()
        }
        IsMeshVisible(e) {
            return this.meshesPanel.IsMeshVisible(e)
        }
        HasHiddenMesh() {
            return this.meshesPanel.HasHiddenMesh()
        }
        ShowAllMeshes(e) {
            this.meshesPanel.ShowAllMeshes(e),
            this.callbacks.onMeshVisibilityChanged()
        }
        ToggleNodeVisibility(e) {
            this.meshesPanel.ToggleNodeVisibility(e),
            this.callbacks.onMeshVisibilityChanged()
        }
        ToggleMeshVisibility(e) {
            this.meshesPanel.ToggleMeshVisibility(e),
            this.callbacks.onMeshVisibilityChanged()
        }
        IsMeshIsolated(e) {
            return this.meshesPanel.IsMeshIsolated(e)
        }
        IsolateMesh(e) {
            this.meshesPanel.IsolateMesh(e),
            this.callbacks.onMeshVisibilityChanged()
        }
        GetSelectedMeshId() {
            return this.tempSelectedMeshId !== null ? this.tempSelectedMeshId : this.selection === null || this.selection.type !== qn.Mesh ? null : this.selection.meshInstanceId
        }
        SetSelection(e) {
            function t(s, o, a) {
                o.type === qn.Material ? (a && s.panelSet.IsPanelsVisible() && s.panelSet.ShowPanel(s.materialsPanel),
                s.materialsPanel.SelectMaterialItem(o.materialIndex, a)) : o.type === qn.Mesh && (a && s.panelSet.IsPanelsVisible() && s.panelSet.ShowPanel(s.meshesPanel),
                s.meshesPanel.GetMeshItem(o.meshInstanceId).SetSelected(a))
            }
            function n(s, o) {
                s.selection = o,
                s.OnSelectionChanged()
            }
            let i = this.selection;
            i !== null && t(this, i, !1),
            n(this, e),
            this.tempSelectedMeshId = null,
            this.selection !== null && (i !== null && i.IsEqual(this.selection) ? (t(this, this.selection, !1),
            n(this, null)) : t(this, this.selection, !0)),
            this.callbacks.onMeshSelectionChanged()
        }
        OnSelectionChanged() {
            this.selection === null ? this.callbacks.onSelectionCleared() : this.selection.type === qn.Material ? this.callbacks.onMaterialSelected(this.selection.materialIndex) : this.selection.type === qn.Mesh && this.callbacks.onMeshSelected(this.selection.meshInstanceId),
            this.UpdatePanels()
        }
        UpdatePanels() {
            let e = null
              , t = null;
            this.selection !== null && (this.selection.type === qn.Material ? e = this.selection.materialIndex : this.selection.type === qn.Mesh && (t = this.selection.meshInstanceId));
            let n = this.callbacks.getMeshesForMaterial(e);
            this.materialsPanel.UpdateMeshList(n);
            let i = this.callbacks.getMaterialsForMesh(t);
            this.meshesPanel.UpdateMaterialList(i)
        }
        FitNodeToWindow(e) {
            let t = new Set;
            this.meshesPanel.GetNodeItem(e).EnumerateMeshItems(i=>{
                t.add(i.GetMeshInstanceId())
            }
            ),
            this.callbacks.fitMeshesToWindow(t)
        }
        FitMeshToWindow(e) {
            this.callbacks.fitMeshToWindow(e)
        }
        Clear() {
            this.panelSet.Clear(),
            this.selection = null
        }
    }
    ;
    function Zr(r, e) {
        let t = new Date
          , n = 365;
        t.setTime(t.getTime() + n * 24 * 60 * 60 * 1e3),
        document.cookie = r + "=" + e + "; expires=" + t.toUTCString() + ";"
    }
    function Jr(r, e) {
        let n = decodeURIComponent(document.cookie).split(";");
        for (let i = 0; i < n.length; i++) {
            let s = n[i].trim();
            if (s.startsWith(r + "="))
                return s.substring(r.length + 1)
        }
        return e
    }
    function Jo(r, e) {
        let t = Jr(r, null);
        return t === null ? e : t === "true"
    }
    function $o(r, e) {
        Zr(r, e ? "true" : "false")
    }
    function Yl(r, e) {
        let t = Jr(r, null);
        return t === null ? e : parseInt(t, 10)
    }
    function Kl(r, e) {
        Zr(r, e.toString())
    }
    function jm(r, e) {
        let t = Jr(r, null);
        return t === null ? e : Yt.StringToRGBColor(t)
    }
    function zy(r, e) {
        let t = Jr(r, null);
        return t === null ? e : Yt.StringToRGBAColor(t)
    }
    function qm(r, e) {
        Zr(r, Yt.RGBColorToString(e))
    }
    function Hy(r, e) {
        Zr(r, Yt.RGBAColorToString(e))
    }
    var ai = {
        Light: 1,
        Dark: 2
    }
      , Zl = class {
        constructor() {
            this.environmentMapName = "fishermans_bastion",
            this.backgroundIsEnvMap = !1,
            this.backgroundColor = new Nn(255,255,255,255),
            this.defaultColor = new rt(200,200,200),
            this.edgeSettings = new pr(!1,new rt(0,0,0),1),
            this.themeId = ai.Light
        }
        LoadFromCookies() {
            this.environmentMapName = Jr("ov_environment_map", "fishermans_bastion"),
            this.backgroundIsEnvMap = Jo("ov_background_is_envmap", !1),
            this.backgroundColor = zy("ov_background_color", new Nn(255,255,255,255)),
            this.defaultColor = jm("ov_default_color", new rt(200,200,200)),
            this.edgeSettings.showEdges = Jo("ov_show_edges", !1),
            this.edgeSettings.edgeColor = jm("ov_edge_color", new rt(0,0,0)),
            this.edgeSettings.edgeThreshold = Yl("ov_edge_threshold", 1),
            this.themeId = Yl("ov_theme_id", ai.Light)
        }
        SaveToCookies() {
            Zr("ov_environment_map", this.environmentMapName),
            $o("ov_background_is_envmap", this.backgroundIsEnvMap),
            Hy("ov_background_color", this.backgroundColor),
            qm("ov_default_color", this.defaultColor),
            $o("ov_show_edges", this.edgeSettings.showEdges),
            qm("ov_edge_color", this.edgeSettings.edgeColor),
            Kl("ov_edge_threshold", this.edgeSettings.edgeThreshold),
            Kl("ov_theme_id", this.themeId)
        }
    }
    ;
    function Ym(r, e, t) {
        let n = ti(r, e)
          , i = ti(e, t)
          , s = ti(r, t)
          , o = (n + i + s) / 2
          , a = o * (o - n) * (o - i) * (o - s);
        return a < 0 ? 0 : Math.sqrt(a)
    }
    function Km(r, e, t) {
        return dc(r, nr(e, t)) / 6
    }
    function Eu(r) {
        if (r instanceof zr) {
            let e = 0;
            return r.EnumerateMeshInstances(t=>{
                e += Eu(t)
            }
            ),
            e
        } else {
            let e = 0;
            return r.EnumerateTriangleVertices((t,n,i)=>{
                e += Km(t, n, i)
            }
            ),
            e
        }
    }
    function $f(r) {
        let e = 0;
        return r.EnumerateTriangleVertices((t,n,i)=>{
            e += Ym(t, n, i)
        }
        ),
        e
    }
    var Jl = class extends Wl {
        constructor(e) {
            super(e),
            this.callbacks = null,
            this.titleDiv = null,
            this.HasTitle() && (this.titleDiv = Ce(this.panelDiv, "ov_sidebar_title"),
            Ce(this.titleDiv, "ov_sidebar_title_text", this.GetName()),
            this.titleDiv.setAttribute("title", this.GetName())),
            this.contentDiv = Ce(this.panelDiv, "ov_sidebar_content ov_thin_scrollbar")
        }
        GetName() {
            return null
        }
        HasTitle() {
            return !0
        }
        Clear() {
            Zn(this.contentDiv)
        }
        Init(e) {
            this.callbacks = e
        }
    }
    ;
    var Qf = class extends Jl {
        constructor(e) {
            super(e)
        }
        GetName() {
            return "Details"
        }
        GetIcon() {
            return "details"
        }
        AddObject3DProperties(e) {
            this.Clear();
            let t = Ce(this.contentDiv, "ov_property_table")
              , n = Jc(e)
              , i = vn(n.max, n.min);
            if (this.AddProperty(t, new yt(dt.Integer,"Vertices",e.VertexCount())),
            this.AddProperty(t, new yt(dt.Integer,"Triangles",e.TriangleCount())),
            this.AddProperty(t, new yt(dt.Number,"Size X",i.x)),
            this.AddProperty(t, new yt(dt.Number,"Size Y",i.y)),
            this.AddProperty(t, new yt(dt.Number,"Size Z",i.z)),
            this.AddCalculatedProperty(t, "Volume", ()=>{
                if (!$c(e))
                    return null;
                let s = Eu(e);
                return new yt(dt.Number,null,s)
            }
            ),
            this.AddCalculatedProperty(t, "Surface", ()=>{
                let s = $f(e);
                return new yt(dt.Number,null,s)
            }
            ),
            e.PropertyGroupCount() > 0) {
                let s = Ce(this.contentDiv, "ov_property_table ov_property_table_custom");
                for (let o = 0; o < e.PropertyGroupCount(); o++) {
                    let a = e.GetPropertyGroup(o);
                    this.AddPropertyGroup(s, a);
                    for (let l = 0; l < a.PropertyCount(); l++) {
                        let c = a.GetProperty(l);
                        this.AddPropertyInGroup(s, c)
                    }
                }
            }
            this.Resize()
        }
        AddMaterialProperties(e) {
            function t(s, o, a, l) {
                if (l === null || l.name === null)
                    return;
                let c = pn(l.name);
                s.AddProperty(o, new yt(dt.Text,a,c))
            }
            this.Clear();
            let n = Ce(this.contentDiv, "ov_property_table")
              , i = null;
            e.type === nn.Phong ? i = "Phong" : e.type === nn.Physical && (i = "Physical"),
            this.AddProperty(n, new yt(dt.Text,"Source",e.isDefault ? "Default" : "Model")),
            this.AddProperty(n, new yt(dt.Text,"Type",i)),
            e.vertexColors ? this.AddProperty(n, new yt(dt.Text,"Color","Vertex colors")) : (this.AddProperty(n, new yt(dt.Color,"Color",e.color)),
            e.type === nn.Phong && (this.AddProperty(n, new yt(dt.Color,"Ambient",e.ambient)),
            this.AddProperty(n, new yt(dt.Color,"Specular",e.specular)))),
            e.type === nn.Physical && (this.AddProperty(n, new yt(dt.Percent,"Metalness",e.metalness)),
            this.AddProperty(n, new yt(dt.Percent,"Roughness",e.roughness))),
            this.AddProperty(n, new yt(dt.Percent,"Opacity",e.opacity)),
            t(this, n, "Diffuse Map", e.diffuseMap),
            t(this, n, "Bump Map", e.bumpMap),
            t(this, n, "Normal Map", e.normalMap),
            t(this, n, "Emissive Map", e.emissiveMap),
            e.type === nn.Phong ? t(this, n, "Specular Map", e.specularMap) : e.type === nn.Physical && t(this, n, "Metallic Map", e.metalnessMap),
            this.Resize()
        }
        AddPropertyGroup(e, t) {
            Ce(e, "ov_property_table_row group", t.name).setAttribute("title", t.name)
        }
        AddProperty(e, t) {
            let n = Ce(e, "ov_property_table_row")
              , i = Ce(n, "ov_property_table_cell ov_property_table_name", t.name + ":")
              , s = Ce(n, "ov_property_table_cell ov_property_table_value");
            return i.setAttribute("title", t.name),
            this.DisplayPropertyValue(t, s),
            n
        }
        AddPropertyInGroup(e, t) {
            this.AddProperty(e, t).classList.add("ingroup")
        }
        AddCalculatedProperty(e, t, n) {
            let i = Ce(e, "ov_property_table_row")
              , s = Ce(i, "ov_property_table_cell ov_property_table_name", t + ":")
              , o = Ce(i, "ov_property_table_cell ov_property_table_value");
            s.setAttribute("title", t),
            Ce(o, "ov_property_table_button", "Calculate...").addEventListener("click", ()=>{
                Zn(o),
                o.innerHTML = "Please wait...",
                _s(()=>{
                    let l = n();
                    l === null ? o.innerHTML = "-" : this.DisplayPropertyValue(l, o)
                }
                )
            }
            )
        }
        DisplayPropertyValue(e, t) {
            Zn(t);
            let n = null
              , i = null;
            if (e.type === dt.Text)
                Kh(e.value) ? (n = '<a target="_blank" href="' + e.value + '">' + e.value + "</a>",
                i = e.value) : n = jo(e);
            else if (e.type === dt.Color) {
                let s = "#" + ci(e.value)
                  , o = Uf(e.value);
                t.appendChild(o),
                Jt(t, "span", null, s)
            } else
                n = jo(e);
            n !== null && (t.innerHTML = n,
            t.setAttribute("title", i !== null ? i : n))
        }
    }
    ;
    var Xy = yx(Wy(), 1);
    function Jm(r, e, t, n, i) {
        let s = Xy.create({
            el: r,
            theme: "monolith",
            position: "left-start",
            swatches: n,
            comparison: !1,
            default: t,
            components: {
                preview: !1,
                opacity: e,
                hue: !0,
                interaction: {
                    hex: !1,
                    rgba: !1,
                    hsla: !1,
                    hsva: !1,
                    cmyk: !1,
                    input: !0,
                    clear: !1,
                    save: !1
                }
            }
        });
        return s.on("change", (o,a,l)=>{
            let c = o.toRGBA();
            i(parseInt(c[0], 10), parseInt(c[1], 10), parseInt(c[2], 10), yn(c[3]))
        }
        ),
        s
    }
    var td = class extends Mu {
        constructor() {
            super()
        }
        ShowPopup(e, t, n, i) {
            let s = super.Init(()=>Uy(e, s))
              , o = [{
                element: null,
                name: "fishermans_bastion"
            }, {
                element: null,
                name: "citadella"
            }, {
                element: null,
                name: "maskonaive"
            }, {
                element: null,
                name: "teide"
            }, {
                element: null,
                name: "ice_river"
            }, {
                element: null,
                name: "park"
            }];
            if (t === hn.Phong) {
                o.unshift({
                    element: null,
                    name: "noimage"
                });
                for (let a of o) {
                    a.element = Jt(s, "img", "ov_environment_map_preview"),
                    a.element.setAttribute("src", "assets/envmaps/" + a.name + ".jpg");
                    let l = !1;
                    n.backgroundIsEnvMap ? l = a.name === n.environmentMapName : l = a.name === "noimage",
                    l && a.element.classList.add("selected"),
                    a.element.addEventListener("click", ()=>{
                        for (let c of o)
                            c.element.classList.remove("selected");
                        a.element.classList.add("selected"),
                        a.name === "noimage" ? (n.backgroundIsEnvMap = !1,
                        n.environmentMapName = "fishermans_bastion") : (n.backgroundIsEnvMap = !0,
                        n.environmentMapName = a.name),
                        i.onEnvironmentMapChanged()
                    }
                    )
                }
            } else if (t === hn.Physical) {
                if (i.getCameraMode() === un.Perspective) {
                    let l = Ce(s, "ov_environment_map_checkbox")
                      , c = Bf(l, "use_as_background", "Use as background image", n.backgroundIsEnvMap, ()=>{
                        n.backgroundIsEnvMap = c.checked,
                        i.onEnvironmentMapChanged()
                    }
                    )
                }
                for (let l of o)
                    l.element = Jt(s, "img", "ov_environment_map_preview"),
                    l.element.setAttribute("src", "assets/envmaps/" + l.name + ".jpg"),
                    l.name === n.environmentMapName && l.element.classList.add("selected"),
                    l.element.addEventListener("click", ()=>{
                        for (let c of o)
                            c.element.classList.remove("selected");
                        l.element.classList.add("selected"),
                        n.environmentMapName = l.name,
                        i.onEnvironmentMapChanged()
                    }
                    )
            }
            s.classList.add("sidebar"),
            this.Open()
        }
        Update() {}
    }
      , Su = class {
        constructor(e, t, n) {
            this.parentDiv = e,
            this.contentDiv = Ce(this.parentDiv, "ov_sidebar_settings_section"),
            Ce(this.contentDiv, "ov_sidebar_title", t),
            this.settings = n,
            this.callbacks = null
        }
        Init(e) {
            this.callbacks = e
        }
        Update() {}
        UpdateVisibility() {}
        Clear() {}
    }
      , $m = class extends Su {
        constructor(e, t) {
            super(e, "Model Display", t),
            this.backgroundColorPicker = null,
            this.environmentMapPhongDiv = null,
            this.environmentMapPhongInput = null,
            this.environmentMapPbrDiv = null,
            this.environmentMapPbrInput = null,
            this.environmentMapPopup = null,
            this.edgeDisplayToggle = null,
            this.edgeColorPicker = null,
            this.thresholdSlider = null,
            this.thresholdSliderValue = null,
            this.edgeSettingsDiv = null
        }
        Init(e) {
            super.Init(e);
            let t = Ce(this.contentDiv, "ov_sidebar_parameter")
              , n = Ce(t, "ov_color_picker");
            Ce(t, null, "Background Color");
            let i = ["#ffffffff", "#e3e3e3ff", "#c9c9c9ff", "#898989ff", "#5f5f5fff", "#494949ff", "#383838ff", "#0f0f0fff"]
              , s = "#" + pc(this.settings.backgroundColor);
            this.backgroundColorPicker = Jm(n, !0, s, i, (f,m,g,v)=>{
                this.settings.backgroundColor = new Nn(f,m,g,v),
                this.callbacks.onBackgroundColorChanged()
            }
            ),
            this.environmentMapPhongDiv = Ce(this.contentDiv, "ov_sidebar_parameter"),
            this.environmentMapPhongInput = Ce(this.environmentMapPhongDiv, "ov_sidebar_image_picker"),
            Ce(this.environmentMapPhongDiv, null, "Background Image"),
            this.environmentMapPhongInput.addEventListener("click", ()=>{
                this.environmentMapPopup = new td,
                this.environmentMapPopup.ShowPopup(this.environmentMapPhongInput, hn.Phong, this.settings, {
                    getCameraMode: ()=>this.callbacks.getCameraMode(),
                    onEnvironmentMapChanged: ()=>{
                        this.UpdateEnvironmentMap(),
                        this.callbacks.onEnvironmentMapChanged()
                    }
                })
            }
            ),
            this.environmentMapPbrDiv = Ce(this.contentDiv, "ov_sidebar_parameter"),
            this.environmentMapPbrInput = Ce(this.environmentMapPbrDiv, "ov_sidebar_image_picker"),
            Ce(this.environmentMapPbrDiv, null, "Environment"),
            this.environmentMapPbrInput.addEventListener("click", ()=>{
                this.environmentMapPopup = new td,
                this.environmentMapPopup.ShowPopup(this.environmentMapPbrInput, hn.Physical, this.settings, {
                    getCameraMode: ()=>this.callbacks.getCameraMode(),
                    onEnvironmentMapChanged: ()=>{
                        this.UpdateEnvironmentMap(),
                        this.callbacks.onEnvironmentMapChanged()
                    }
                })
            }
            ),
            this.UpdateEnvironmentMap();
            let o = Ce(this.contentDiv, "ov_sidebar_parameter");
            this.edgeDisplayToggle = zm(o, "ov_sidebar_parameter_toggle"),
            Ce(o, "ov_sidebar_parameter_text", "Show Edges"),
            this.edgeSettingsDiv = Ce(this.contentDiv, "ov_sidebar_settings_padded"),
            this.edgeDisplayToggle.OnChange(()=>{
                It(this.edgeSettingsDiv, this.edgeDisplayToggle.GetStatus()),
                this.settings.edgeSettings.showEdges = this.edgeDisplayToggle.GetStatus(),
                this.callbacks.onShowEdgesChange()
            }
            );
            let a = Ce(this.edgeSettingsDiv, "ov_sidebar_settings_row")
              , l = ["#ffffff", "#e3e3e3", "#c9c9c9", "#898989", "#5f5f5f", "#494949", "#383838", "#0f0f0f"]
              , c = Ce(a, "ov_color_picker")
              , u = "#" + ci(this.settings.edgeSettings.edgeColor);
            this.edgeColorPicker = Jm(c, !1, u, l, (f,m,g,v)=>{
                this.settings.edgeSettings.edgeColor = new rt(f,m,g),
                this.callbacks.onEdgeColorChange()
            }
            ),
            Ce(a, null, "Edge Color");
            let h = Ce(this.edgeSettingsDiv, "ov_sidebar_settings_row large");
            this.thresholdSlider = Fy(h, 0, 90),
            this.thresholdSlider.setAttribute("title", "Edge Angle Threshold"),
            this.thresholdSliderValue = Jt(h, "span", "ov_slider_label"),
            this.thresholdSlider.addEventListener("input", ()=>{
                this.thresholdSliderValue.innerHTML = this.thresholdSlider.value
            }
            ),
            this.thresholdSlider.addEventListener("change", ()=>{
                this.settings.edgeSettings.edgeThreshold = this.thresholdSlider.value,
                this.callbacks.onEdgeThresholdChange()
            }
            ),
            this.thresholdSlider.value = this.settings.edgeSettings.edgeThreshold,
            this.thresholdSliderValue.innerHTML = this.settings.edgeSettings.edgeThreshold,
            this.edgeDisplayToggle.SetStatus(this.settings.edgeSettings.showEdges),
            It(this.edgeSettingsDiv, this.settings.edgeSettings.showEdges)
        }
        UpdateEnvironmentMap() {
            function e(t, n) {
                t.style.backgroundImage = "url('assets/envmaps/" + n + ".jpg')"
            }
            this.environmentMapPhongDiv !== null && (this.settings.backgroundIsEnvMap ? (e(this.environmentMapPhongInput, this.settings.environmentMapName),
            this.environmentMapPhongInput.classList.remove("ov_environment_map_preview_no_color")) : (this.environmentMapPhongInput.style.backgroundImage = null,
            this.environmentMapPhongInput.classList.add("ov_environment_map_preview_no_color"))),
            this.environmentMapPbrDiv !== null && e(this.environmentMapPbrInput, this.settings.environmentMapName)
        }
        Update() {
            this.backgroundColorPicker !== null && this.backgroundColorPicker.setColor("#" + pc(this.settings.backgroundColor)),
            (this.environmentMapPbrInput !== null || this.environmentMapPhongDiv !== null) && this.UpdateEnvironmentMap(),
            this.edgeDisplayToggle !== null && (this.edgeDisplayToggle.SetStatus(this.settings.edgeSettings.showEdges),
            It(this.edgeSettingsDiv, this.settings.edgeSettings.showEdges),
            this.edgeColorPicker.setColor("#" + ci(this.settings.edgeSettings.edgeColor)),
            this.thresholdSlider.value = this.settings.edgeSettings.edgeThreshold,
            this.thresholdSliderValue.innerHTML = this.settings.edgeSettings.edgeThreshold)
        }
        UpdateVisibility() {
            let e = this.callbacks.getShadingType() === hn.Physical;
            if (this.environmentMapPhongDiv !== null) {
                let t = this.callbacks.getCameraMode() === un.Perspective;
                It(this.environmentMapPhongDiv, !e && t)
            }
            this.environmentMapPbrDiv !== null && It(this.environmentMapPbrDiv, e)
        }
        Clear() {
            this.environmentMapPopup !== null && (this.environmentMapPopup.Close(),
            this.environmentMapPopup = null),
            this.backgroundColorPicker !== null && this.backgroundColorPicker.hide(),
            this.edgeColorPicker !== null && this.edgeColorPicker.hide()
        }
    }
      , Qm = class extends Su {
        constructor(e, t) {
            super(e, "Import Settings", t),
            this.defaultColorPicker = null
        }
        Init(e) {
            super.Init(e);
            let t = Ce(this.contentDiv, "ov_sidebar_parameter")
              , n = Ce(t, "ov_color_picker");
            Ce(t, null, "Default Color");
            let i = ["#ffffff", "#e3e3e3", "#cc3333", "#fac832", "#4caf50", "#3393bd", "#9b27b0", "#fda4b8"]
              , s = "#" + ci(this.settings.defaultColor);
            this.defaultColorPicker = Jm(n, !1, s, i, (o,a,l,c)=>{
                this.settings.defaultColor = new rt(o,a,l),
                this.callbacks.onDefaultColorChanged()
            }
            )
        }
        Update() {
            this.defaultColorPicker !== null && this.defaultColorPicker.setColor("#" + ci(this.settings.defaultColor))
        }
        UpdateVisibility() {
            if (this.contentDiv !== null) {
                let e = this.callbacks.hasDefaultMaterial();
                It(this.contentDiv, e)
            }
        }
        Clear() {
            this.defaultColorPicker !== null && this.defaultColorPicker.hide()
        }
    }
      , eg = class extends Su {
        constructor(e, t) {
            super(e, "Appearance", t),
            this.darkModeToggle = null
        }
        Init(e) {
            super.Init(e);
            let t = Ce(this.contentDiv, "ov_sidebar_parameter");
            this.darkModeToggle = zm(t, "ov_sidebar_parameter_toggle"),
            this.darkModeToggle.OnChange(()=>{
                this.settings.themeId = this.darkModeToggle.GetStatus() ? ai.Dark : ai.Light,
                this.callbacks.onThemeChanged()
            }
            ),
            Ce(t, null, "Dark Mode");
            let n = this.settings.themeId === ai.Dark;
            this.darkModeToggle.SetStatus(n)
        }
        Update() {
            if (this.darkModeToggle !== null) {
                let e = this.settings.themeId === ai.Dark;
                this.darkModeToggle.SetStatus(e)
            }
        }
        UpdateVisibility() {}
    }
      , nd = class extends Jl {
        constructor(e, t) {
            super(e),
            this.settings = t,
            this.sectionsDiv = Ce(this.contentDiv, "ov_sidebar_settings_sections ov_thin_scrollbar"),
            this.modelDisplaySection = new $m(this.sectionsDiv,this.settings),
            this.importParametersSection = new Qm(this.sectionsDiv,this.settings),
            this.appearanceSection = new eg(this.sectionsDiv,this.settings),
            this.resetToDefaultsButton = Ce(this.contentDiv, "ov_button ov_panel_button outline", "Reset to Default"),
            this.resetToDefaultsButton.addEventListener("click", ()=>{
                this.ResetToDefaults()
            }
            )
        }
        GetName() {
            return "Settings"
        }
        HasTitle() {
            return !1
        }
        GetIcon() {
            return "settings"
        }
        Clear() {
            this.modelDisplaySection.Clear(),
            this.importParametersSection.Clear(),
            this.appearanceSection.Clear()
        }
        Init(e) {
            super.Init(e),
            this.modelDisplaySection.Init({
                getShadingType: ()=>this.callbacks.getShadingType(),
                getCameraMode: ()=>this.callbacks.getCameraMode(),
                onEnvironmentMapChanged: ()=>{
                    this.callbacks.onEnvironmentMapChanged()
                }
                ,
                onBackgroundColorChanged: ()=>{
                    this.callbacks.onBackgroundColorChanged()
                }
                ,
                onShowEdgesChange: ()=>{
                    this.callbacks.onEdgeDisplayChanged()
                }
                ,
                onEdgeColorChange: ()=>{
                    this.callbacks.onEdgeDisplayChanged()
                }
                ,
                onEdgeThresholdChange: ()=>{
                    this.callbacks.onEdgeDisplayChanged()
                }
            }),
            this.importParametersSection.Init({
                hasDefaultMaterial: ()=>this.callbacks.hasDefaultMaterial(),
                onDefaultColorChanged: ()=>{
                    this.callbacks.onDefaultColorChanged()
                }
            }),
            this.appearanceSection.Init({
                onThemeChanged: ()=>{
                    this.settings.themeId === ai.Light ? (this.settings.backgroundColor = new Nn(255,255,255,255),
                    this.settings.defaultColor = new rt(200,200,200)) : this.settings.themeId === ai.Dark && (this.settings.backgroundColor = new Nn(42,43,46,255),
                    this.settings.defaultColor = new rt(200,200,200)),
                    this.modelDisplaySection.Update(),
                    this.importParametersSection.Update(),
                    e.onThemeChanged()
                }
            })
        }
        UpdateControlsVisibility() {
            this.modelDisplaySection.UpdateVisibility(),
            this.importParametersSection.UpdateVisibility(),
            this.Resize()
        }
        ResetToDefaults() {
            let e = new Zl;
            this.settings.environmentMapName = e.environmentMapName,
            this.settings.backgroundIsEnvMap = e.backgroundIsEnvMap,
            this.settings.backgroundColor = e.backgroundColor,
            this.settings.defaultColor = e.defaultColor,
            this.settings.edgeSettings = e.edgeSettings,
            this.settings.themeId = e.themeId,
            this.modelDisplaySection.Update(),
            this.importParametersSection.Update(),
            this.appearanceSection.Update(),
            this.callbacks.onEnvironmentMapChanged(),
            this.callbacks.onThemeChanged()
        }
        Resize() {
            let e = this.resetToDefaultsButton.offsetHeight
              , t = this.parentDiv.offsetHeight;
            Qi(this.sectionsDiv, t - e)
        }
    }
    ;
    var id = class {
        constructor(e, t) {
            this.mainDiv = e,
            this.panelSet = new Xl(e),
            this.detailsPanel = new Qf(this.panelSet.GetContentDiv()),
            this.settingsPanel = new nd(this.panelSet.GetContentDiv(),t),
            this.panelSet.AddPanel(this.detailsPanel),
            this.panelSet.AddPanel(this.settingsPanel),
            this.panelSet.ShowPanel(this.detailsPanel)
        }
        IsPanelsVisible() {
            return this.panelSet.IsPanelsVisible()
        }
        ShowPanels(e) {
            this.panelSet.ShowPanels(e)
        }
        Init(e) {
            this.callbacks = e,
            this.panelSet.Init({
                onResizeRequested: ()=>{
                    this.callbacks.onResizeRequested()
                }
                ,
                onShowHidePanels: t=>{
                    this.callbacks.onShowHidePanels(t)
                }
            }),
            this.settingsPanel.Init({
                getShadingType: ()=>this.callbacks.getShadingType(),
                getCameraMode: ()=>this.callbacks.getCameraMode(),
                hasDefaultMaterial: ()=>this.callbacks.hasDefaultMaterial(),
                onEnvironmentMapChanged: ()=>{
                    this.callbacks.onEnvironmentMapChanged()
                }
                ,
                onBackgroundColorChanged: ()=>{
                    this.callbacks.onBackgroundColorChanged()
                }
                ,
                onDefaultColorChanged: ()=>{
                    this.callbacks.onDefaultColorChanged()
                }
                ,
                onEdgeDisplayChanged: ()=>{
                    this.callbacks.onEdgeDisplayChanged()
                }
                ,
                onThemeChanged: ()=>{
                    this.callbacks.onThemeChanged()
                }
            })
        }
        UpdateControlsVisibility() {
            this.settingsPanel.UpdateControlsVisibility()
        }
        Resize(e) {
            Qi(this.mainDiv, e),
            this.panelSet.Resize()
        }
        GetWidth() {
            return Ei(this.mainDiv)
        }
        SetWidth(e) {
            Ol(this.mainDiv, e)
        }
        Clear() {
            this.panelSet.Clear()
        }
        AddObject3DProperties(e) {
            this.detailsPanel.AddObject3DProperties(e)
        }
        AddMaterialProperties(e) {
            this.detailsPanel.AddMaterialProperties(e)
        }
    }
    ;
    var rd = class {
        constructor() {
            this.css = {
                "--ov_foreground_color": {},
                "--ov_background_color": {},
                "--ov_disabled_foreground_color": {},
                "--ov_button_color": {},
                "--ov_button_hover_color": {},
                "--ov_button_text_color": {},
                "--ov_outline_button_color": {},
                "--ov_outline_button_hover_color": {},
                "--ov_outline_button_text_color": {},
                "--ov_icon_color": {},
                "--ov_light_icon_color": {},
                "--ov_selected_icon_color": {},
                "--ov_disabled_icon_color": {},
                "--ov_hover_color": {},
                "--ov_hover_text_color": {},
                "--ov_logo_text_color": {},
                "--ov_logo_border_color": {},
                "--ov_toolbar_background_color": {},
                "--ov_toolbar_selected_color": {},
                "--ov_toolbar_separator_color": {},
                "--ov_treeview_selected_color": {},
                "--ov_dialog_foreground_color": {},
                "--ov_dialog_background_color": {},
                "--ov_border_color": {},
                "--ov_shadow": {}
            };
            let e = document.querySelector(":root")
              , t = window.getComputedStyle(e);
            for (let n in this.css)
                Object.prototype.hasOwnProperty.call(this.css, n) && (this.css[n].light = t.getPropertyValue(n),
                this.css[n].dark = t.getPropertyValue(n + "_dark"))
        }
        SwitchTheme(e) {
            let t = null;
            if (e === ai.Light)
                t = "light";
            else if (e === ai.Dark)
                t = "dark";
            else
                return;
            let n = document.querySelector(":root");
            for (let i in this.css)
                if (Object.prototype.hasOwnProperty.call(this.css, i)) {
                    let s = this.css[i][t];
                    s !== void 0 && n.style.setProperty(i, s)
                }
        }
    }
    ;
    var sd = class {
        constructor(e, t, n) {
            this.image = e,
            this.imageTitle = t,
            this.selected = !1,
            this.buttonDiv = Jn("ov_toolbar_button"),
            this.buttonImg = $n(this.buttonDiv, this.image),
            n !== null && this.buttonDiv.addEventListener("click", n),
            this.buttonDiv.setAttribute("alt", this.imageTitle),
            kf(this.buttonDiv, this.imageTitle)
        }
        AddDomElements(e) {
            e.appendChild(this.buttonDiv)
        }
        AddClass(e) {
            this.buttonDiv.classList.add(e)
        }
        RemoveClass(e) {
            this.buttonDiv.classList.remove(e)
        }
        AddImageClass(e) {
            this.buttonImg.classList.add(e)
        }
        RemoveImageClass(e) {
            this.buttonImg.classList.remove(e)
        }
        IsSelected() {
            return this.selected
        }
        SetSelected(e) {
            this.selected = e,
            this.selected ? this.buttonDiv.classList.add("selected") : this.buttonDiv.classList.remove("selected")
        }
    }
      , od = class {
        constructor(e) {
            this.mainDiv = Ce(e, "ov_toolbar")
        }
        AddImageButton(e, t, n) {
            let i = new sd(e,t,n);
            return i.AddDomElements(this.mainDiv),
            i
        }
        AddImagePushButton(e, t, n, i) {
            let s = new sd(e,t,()=>{
                s.SetSelected(!s.IsSelected()),
                i(s.IsSelected())
            }
            );
            return s.AddDomElements(this.mainDiv),
            s.SetSelected(n),
            s
        }
        AddImageRadioButton(e, t, n) {
            let i = [];
            for (let s = 0; s < e.length; s++) {
                let o = e[s]
                  , a = this.AddImageButton(o.image, o.title, ()=>{
                    for (let l = 0; l < i.length; l++) {
                        let c = i[l];
                        l === s ? c.SetSelected(!0) : c.SetSelected(!1)
                    }
                    n(s)
                }
                );
                t === s && a.SetSelected(!0),
                i.push(a)
            }
            return i
        }
        AddSeparator() {
            return Ce(this.mainDiv, "ov_toolbar_separator")
        }
    }
    ;
    var wu = class {
        constructor() {
            this.indices = [],
            this.vertices = [],
            this.colors = [],
            this.normals = [],
            this.uvs = [],
            this.material = null
        }
        GetBounds() {
            let e = [1 / 0, 1 / 0, 1 / 0]
              , t = [-1 / 0, -1 / 0, -1 / 0];
            for (let n = 0; n < this.vertices.length / 3; n++)
                for (let i = 0; i < 3; i++)
                    e[i] = Math.min(e[i], this.vertices[n * 3 + i]),
                    t[i] = Math.max(t[i], this.vertices[n * 3 + i]);
            return {
                min: e,
                max: t
            }
        }
        GetByteLength(e, t) {
            let n = this.indices.length
              , i = this.vertices.length + this.colors.length + this.normals.length + this.uvs.length;
            return n * e + i * t
        }
    }
      , Au = class {
        constructor() {
            this.primitives = []
        }
        PrimitiveCount() {
            return this.primitives.length
        }
        GetPrimitive(e) {
            return this.primitives[e]
        }
        GetByteLength(e, t) {
            let n = 0;
            for (let i = 0; i < this.primitives.length; i++) {
                let s = this.primitives[i];
                n += s.GetByteLength(e, t)
            }
            return n
        }
    }
    ;
    function $l(r) {
        function e(a, l, c, u) {
            function h(v, p, d) {
                return p !== null ? v.GetVertexColor(p) : d ? new rt(0,0,0) : null
            }
            function f(v, p, d) {
                return p !== null ? v.GetTextureUV(p) : d ? new Pt(0,0) : null
            }
            function m(v, p, d) {
                let x = v.VertexColorCount() > 0
                  , y = v.TextureUVCount() > 0
                  , _ = v.GetVertex(p.vertex)
                  , S = v.GetNormal(p.normal)
                  , N = d.vertices.length / 3;
                d.indices.push(N),
                d.vertices.push(_.x, _.y, _.z);
                let I = h(v, p.color, x);
                I !== null && d.colors.push(I.r / 255, I.g / 255, I.b / 255),
                d.normals.push(S.x, S.y, S.z);
                let O = f(v, p.uv, y);
                return O !== null && d.uvs.push(O.x, O.y),
                {
                    index: N,
                    color: I,
                    normal: S,
                    uv: O
                }
            }
            function g(v, p, d) {
                function x(S, N, I) {
                    if (I === null && N === null)
                        return !0;
                    let O = h(S, N, !0);
                    return is(I, O)
                }
                function y(S, N, I) {
                    let O = S.GetNormal(N);
                    return Ci(I, O)
                }
                function _(S, N, I) {
                    if (I === null && N === null)
                        return !0;
                    let O = f(S, N, !0);
                    return ir(I, O)
                }
                for (let S = 0; S < p.length; S++) {
                    let N = p[S]
                      , I = x(v, d.color, N.color)
                      , O = y(v, d.normal, N.normal)
                      , M = _(v, d.uv, N.uv);
                    if (I && O && M)
                        return N
                }
                return null
            }
            if (u.has(l.vertex)) {
                let v = u.get(l.vertex)
                  , p = g(a, v, l);
                if (p !== null)
                    c.indices.push(p.index);
                else {
                    let d = m(a, l, c);
                    v.push(d)
                }
            } else {
                let v = m(a, l, c);
                u.set(l.vertex, [v])
            }
        }
        let t = new Au
          , n = r.TriangleCount();
        if (n === 0)
            return null;
        let i = [];
        for (let a = 0; a < n; a++)
            i.push(a);
        i.sort((a,l)=>{
            let c = r.GetTriangle(a)
              , u = r.GetTriangle(l);
            return c.mat - u.mat
        }
        );
        let s = null
          , o = null;
        for (let a = 0; a < i.length; a++) {
            let l = i[a]
              , c = r.GetTriangle(l);
            (s === null || s.material !== c.mat) && (s = new wu,
            s.material = c.mat,
            o = new Map,
            t.primitives.push(s));
            let u = {
                vertex: c.v0,
                color: c.c0,
                normal: c.n0,
                uv: c.u0
            }
              , h = {
                vertex: c.v1,
                color: c.c1,
                normal: c.n1,
                uv: c.u1
            }
              , f = {
                vertex: c.v2,
                color: c.c2,
                normal: c.n2,
                uv: c.u2
            };
            e(r, u, s, o),
            e(r, h, s, o),
            e(r, f, s, o)
        }
        return t
    }
    var tn = class {
        constructor(e) {
            this.name = e,
            this.content = null
        }
        GetName() {
            return this.name
        }
        SetName(e) {
            this.name = e
        }
        GetTextContent() {
            return wn(this.content)
        }
        GetBufferContent() {
            return this.content
        }
        SetTextContent(e) {
            let t = gl(e);
            this.content = t
        }
        SetBufferContent(e) {
            this.content = e
        }
    }
      , Gn = class {
        constructor() {}
        CanExport(e, t) {
            return !1
        }
        Export(e, t, n) {
            let i = [];
            this.ExportContent(e, t, i, ()=>{
                n(i)
            }
            )
        }
        ExportContent(e, t, n, i) {}
        GetExportedMaterialName(e) {
            return this.GetExportedName(e, "Material")
        }
        GetExportedMeshName(e) {
            return this.GetExportedName(e, "Mesh")
        }
        GetExportedName(e, t) {
            return e.length === 0 ? t : e
        }
    }
    ;
    var Ql = class extends Gn {
        constructor() {
            super(),
            this.rhino = null
        }
        CanExport(e, t) {
            return e === Dt.Binary && t === "3dm"
        }
        ExportContent(e, t, n, i) {
            this.rhino === null ? Ar("loaders/rhino3dm.min.js").then(()=>{
                rhino3dm().then(s=>{
                    this.rhino = s,
                    this.ExportRhinoContent(e, n, i)
                }
                )
            }
            ).catch(()=>{
                i()
            }
            ) : this.ExportRhinoContent(e, n, i)
        }
        ExportRhinoContent(e, t, n) {
            function i(c) {
                return {
                    r: c.r,
                    g: c.g,
                    b: c.b,
                    a: 255
                }
            }
            let s = new tn("model.3dm");
            t.push(s);
            let o = new this.rhino.File3dm;
            e.EnumerateTransformedMeshInstances(c=>{
                let u = $l(c);
                for (let h = 0; h < u.PrimitiveCount(); h++) {
                    let f = u.GetPrimitive(h)
                      , m = {
                        data: {
                            attributes: {
                                position: {
                                    itemSize: 3,
                                    type: "Float32Array",
                                    array: f.vertices
                                },
                                normal: {
                                    itemSize: 3,
                                    type: "Float32Array",
                                    array: f.normals
                                }
                            },
                            index: {
                                type: "Uint16Array",
                                array: f.indices
                            }
                        }
                    }
                      , g = e.GetMaterial(f.material)
                      , v = new this.rhino.Material;
                    v.name = this.GetExportedMaterialName(g.name),
                    g.type === nn.Phong && (v.ambientColor = i(g.ambient),
                    v.specularColor = i(g.specular)),
                    v.diffuseColor = i(g.color),
                    v.transparency = 1 - g.opacity;
                    let p = o.materials().count();
                    o.materials().add(v);
                    let d = new this.rhino.Mesh.createFromThreejsJSON(m)
                      , x = new this.rhino.ObjectAttributes;
                    x.name = this.GetExportedMeshName(c.GetName()),
                    x.materialSource = this.rhino.ObjectMaterialSource.MaterialFromObject,
                    x.materialIndex = p,
                    o.objects().add(d, x)
                }
            }
            );
            let a = new this.rhino.File3dmWriteOptions;
            a.version = 6;
            let l = o.toByteArray(a);
            s.SetBufferContent(l),
            n()
        }
    }
    ;
    function _A() {
        return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, e=>{
            let t = Math.random() * 16 | 0;
            return (e === "x" ? t : t & 3 | 8).toString(16)
        }
        )
    }
    var ec = class extends Gn {
        constructor() {
            super()
        }
        CanExport(e, t) {
            return e === Dt.Text && t === "bim"
        }
        ExportContent(e, t, n, i) {
            let s = {
                schema_version: "1.1.0",
                meshes: [],
                elements: [],
                info: {}
            };
            this.ExportProperties(e.GetModel(), s.info);
            let o = 0;
            e.EnumerateTransformedMeshInstances(l=>{
                let c = {
                    mesh_id: o,
                    coordinates: [],
                    indices: []
                };
                l.EnumerateVertices(g=>{
                    c.coordinates.push(g.x, g.y, g.z)
                }
                ),
                l.EnumerateTriangleVertexIndices((g,v,p)=>{
                    c.indices.push(g, v, p)
                }
                );
                let u = {
                    mesh_id: o,
                    type: "Other",
                    color: {
                        r: 200,
                        g: 200,
                        b: 200,
                        a: 255
                    },
                    vector: {
                        x: 0,
                        y: 0,
                        z: 0
                    },
                    rotation: {
                        qx: 0,
                        qy: 0,
                        qz: 0,
                        qw: 1
                    },
                    guid: _A(),
                    info: {}
                }
                  , h = null
                  , f = !0
                  , m = [];
                for (let g = 0; g < l.TriangleCount(); g++) {
                    let v = l.GetTriangle(g)
                      , p = e.GetMaterial(v.mat)
                      , d = {
                        r: p.color.r,
                        g: p.color.g,
                        b: p.color.b,
                        a: yn(p.opacity)
                    };
                    m.push(d.r, d.g, d.b, d.a),
                    f && (h === null ? h = d : (h.r !== d.r || h.g !== d.g || h.b !== d.b || h.a !== d.a) && (f = !1,
                    h = null))
                }
                f ? u.color = h : u.face_colors = m,
                u.info.Name = l.GetName(),
                this.ExportProperties(l, u.info),
                s.meshes.push(c),
                s.elements.push(u),
                o += 1
            }
            );
            let a = new tn("model.bim");
            a.SetTextContent(JSON.stringify(s, null, 4)),
            n.push(a),
            i()
        }
        ExportProperties(e, t) {
            for (let n = 0; n < e.PropertyGroupCount(); n++) {
                let i = e.GetPropertyGroup(n);
                for (let s = 0; s < i.PropertyCount(); s++) {
                    let o = i.GetProperty(s);
                    t[o.name] = jo(o)
                }
            }
        }
    }
    ;
    var wr = class {
        constructor(e, t) {
            this.arrayBuffer = new ArrayBuffer(e),
            this.dataView = new DataView(this.arrayBuffer),
            this.isLittleEndian = t,
            this.position = 0
        }
        GetPosition() {
            return this.position
        }
        SetPosition(e) {
            this.position = e
        }
        End() {
            return this.position >= this.arrayBuffer.byteLength
        }
        GetBuffer() {
            return this.arrayBuffer
        }
        WriteArrayBuffer(e) {
            let t = new Uint8Array(e);
            new Uint8Array(this.arrayBuffer).set(t, this.position),
            this.position += e.byteLength
        }
        WriteBoolean8(e) {
            this.dataView.setInt8(this.position, e ? 1 : 0),
            this.position = this.position + 1
        }
        WriteCharacter8(e) {
            this.dataView.setInt8(this.position, e),
            this.position = this.position + 1
        }
        WriteUnsignedCharacter8(e) {
            this.dataView.setUint8(this.position, e),
            this.position = this.position + 1
        }
        WriteInteger16(e) {
            this.dataView.setInt16(this.position, e, this.isLittleEndian),
            this.position = this.position + 2
        }
        WriteUnsignedInteger16(e) {
            this.dataView.setUint16(this.position, e, this.isLittleEndian),
            this.position = this.position + 2
        }
        WriteInteger32(e) {
            this.dataView.setInt32(this.position, e, this.isLittleEndian),
            this.position = this.position + 4
        }
        WriteUnsignedInteger32(e) {
            this.dataView.setUint32(this.position, e, this.isLittleEndian),
            this.position = this.position + 4
        }
        WriteFloat32(e) {
            this.dataView.setFloat32(this.position, e, this.isLittleEndian),
            this.position = this.position + 4
        }
        WriteDouble64(e) {
            this.dataView.setFloat64(this.position, e, this.isLittleEndian),
            this.position = this.position + 8
        }
    }
    ;
    var jy = {
        UNSIGNED_INT: 5125,
        FLOAT: 5126
    }
      , Cu = {
        ARRAY_BUFFER: 34962,
        ELEMENT_ARRAY_BUFFER: 34963
    }
      , tc = class extends Gn {
        constructor() {
            super(),
            this.components = {
                index: {
                    type: jy.UNSIGNED_INT,
                    size: 4
                },
                number: {
                    type: jy.FLOAT,
                    size: 4
                }
            }
        }
        CanExport(e, t) {
            return e === Dt.Text && t === "gltf" || e === Dt.Binary && t === "glb"
        }
        ExportContent(e, t, n, i) {
            t === Dt.Text ? this.ExportAsciiContent(e, n) : t === Dt.Binary && this.ExportBinaryContent(e, n),
            i()
        }
        ExportAsciiContent(e, t) {
            let n = new tn("model.gltf")
              , i = new tn("model.bin");
            t.push(n),
            t.push(i);
            let s = this.GetMeshData(e)
              , o = this.GetMainBuffer(s)
              , a = this.GetMainJson(e, s);
            a.buffers.push({
                uri: i.GetName(),
                byteLength: o.byteLength
            });
            let l = new Map;
            this.ExportMaterials(e, a, c=>{
                let u = pn(c.name);
                if (l.has(u))
                    return l.get(u);
                {
                    let h = new tn(u);
                    h.SetBufferContent(c.buffer),
                    t.push(h);
                    let f = a.textures.length;
                    return l.set(u, f),
                    a.images.push({
                        uri: u
                    }),
                    a.textures.push({
                        source: f
                    }),
                    f
                }
            }
            ),
            n.SetTextContent(JSON.stringify(a, null, 4)),
            i.SetBufferContent(o)
        }
        ExportBinaryContent(e, t) {
            function n(_) {
                let S = _ % 4;
                return S === 0 ? _ : _ + (4 - S)
            }
            function i(_, S, N) {
                for (let I = 0; I < N; I++)
                    _.WriteUnsignedCharacter8(S)
            }
            let s = new tn("model.glb");
            t.push(s);
            let o = this.GetMeshData(e)
              , a = this.GetMainBuffer(o)
              , l = this.GetMainJson(e, o)
              , c = []
              , u = a.byteLength
              , h = new Map;
            this.ExportMaterials(e, l, _=>{
                let S = pn(_.name)
                  , N = Oi(_.name);
                if (h.has(S))
                    return h.get(S);
                {
                    let I = l.bufferViews.length
                      , O = l.textures.length;
                    h.set(S, O);
                    let M = _.buffer;
                    return c.push(M),
                    l.bufferViews.push({
                        buffer: 0,
                        byteOffset: u,
                        byteLength: M.byteLength
                    }),
                    u += M.byteLength,
                    l.images.push({
                        bufferView: I,
                        mimeType: "image/" + N
                    }),
                    l.textures.push({
                        source: O
                    }),
                    O
                }
            }
            );
            let f = a.byteLength;
            for (let _ = 0; _ < c.length; _++) {
                let S = c[_];
                f += S.byteLength
            }
            let m = n(f);
            l.buffers.push({
                byteLength: m
            });
            let g = JSON.stringify(l)
              , v = gl(g)
              , p = v.byteLength
              , d = n(p)
              , x = 12 + 8 + d + 8 + m
              , y = new wr(x,!0);
            y.WriteUnsignedInteger32(1179937895),
            y.WriteUnsignedInteger32(2),
            y.WriteUnsignedInteger32(x),
            y.WriteUnsignedInteger32(d),
            y.WriteUnsignedInteger32(1313821514),
            y.WriteArrayBuffer(v),
            i(y, 32, d - p),
            y.WriteUnsignedInteger32(m),
            y.WriteUnsignedInteger32(5130562),
            y.WriteArrayBuffer(a);
            for (let _ = 0; _ < c.length; _++) {
                let S = c[_];
                y.WriteArrayBuffer(S)
            }
            i(y, 0, m - f),
            s.SetBufferContent(y.GetBuffer())
        }
        GetMeshData(e) {
            let t = [];
            return e.EnumerateMeshes(n=>{
                let i = $l(n);
                t.push({
                    name: n.GetName(),
                    buffer: i,
                    offsets: [],
                    sizes: []
                })
            }
            ),
            t
        }
        GetMainBuffer(e) {
            let t = 0;
            for (let i of e)
                t += i.buffer.GetByteLength(this.components.index.size, this.components.number.size);
            let n = new wr(t,!0);
            for (let i of e)
                for (let s = 0; s < i.buffer.PrimitiveCount(); s++) {
                    let o = i.buffer.GetPrimitive(s)
                      , a = n.GetPosition();
                    for (let l = 0; l < o.indices.length; l++)
                        n.WriteUnsignedInteger32(o.indices[l]);
                    for (let l = 0; l < o.vertices.length; l++)
                        n.WriteFloat32(o.vertices[l]);
                    for (let l = 0; l < o.colors.length; l++)
                        n.WriteFloat32(Ir(o.colors[l]));
                    for (let l = 0; l < o.normals.length; l++)
                        n.WriteFloat32(o.normals[l]);
                    for (let l = 0; l < o.uvs.length; l++) {
                        let c = o.uvs[l];
                        l % 2 === 1 && (c *= -1),
                        n.WriteFloat32(c)
                    }
                    i.offsets.push(a),
                    i.sizes.push(n.GetPosition() - a)
                }
            return n.GetBuffer()
        }
        GetMainJson(e, t) {
            class n {
                constructor(h, f) {
                    this.mainJson = h,
                    this.byteOffset = f
                }
                AddBufferView(h, f) {
                    let m = {
                        buffer: 0,
                        byteOffset: this.byteOffset,
                        byteLength: h,
                        target: f
                    };
                    return this.mainJson.bufferViews.push(m),
                    this.byteOffset += h,
                    this.mainJson.bufferViews.length - 1
                }
            }
            function i(u, h) {
                for (let f of h.GetMeshIndices()) {
                    let m = new gi(h.GetId(),f);
                    if (u.IsMeshInstanceVisible(m))
                        return !0
                }
                for (let f of h.GetChildNodes())
                    if (i(u, f))
                        return !0;
                return !1
            }
            function s(u, h, f, m) {
                if (m.IsMeshNode())
                    for (let g of m.GetMeshIndices())
                        o(u, h, f, m, g, !0);
                else if (i(u, m)) {
                    let g = {}
                      , v = m.GetName();
                    v.length > 0 && (g.name = v),
                    m.GetTransformation().IsIdentity() || (g.matrix = m.GetTransformation().GetMatrix().Get()),
                    f.push(g),
                    h.push(f.length - 1),
                    g.children = [],
                    a(u, g.children, f, m)
                }
            }
            function o(u, h, f, m, g, v) {
                let p = new gi(m.GetId(),g);
                if (!u.IsMeshInstanceVisible(p))
                    return;
                let d = {
                    mesh: u.MapMeshIndex(g)
                };
                v && (m.GetTransformation().IsIdentity() || (d.matrix = m.GetTransformation().GetMatrix().Get())),
                f.push(d),
                h.push(f.length - 1)
            }
            function a(u, h, f, m) {
                for (let g of m.GetChildNodes())
                    s(u, h, f, g);
                for (let g of m.GetMeshIndices())
                    o(u, h, f, m, g, !1)
            }
            let l = {
                asset: {
                    generator: "https://3dviewer.net",
                    version: "2.0"
                },
                scene: 0,
                scenes: [{
                    nodes: []
                }],
                nodes: [],
                materials: [],
                meshes: [],
                buffers: [],
                bufferViews: [],
                accessors: []
            }
              , c = e.GetModel().GetRootNode();
            a(e, l.scenes[0].nodes, l.nodes, c);
            for (let u of t) {
                let h = {
                    name: this.GetExportedMeshName(u.name),
                    primitives: []
                }
                  , f = u.buffer.primitives;
                for (let m = 0; m < f.length; m++) {
                    let g = f[m]
                      , v = new n(l,u.offsets[m])
                      , p = v.AddBufferView(g.indices.length * this.components.index.size, Cu.ELEMENT_ARRAY_BUFFER)
                      , d = v.AddBufferView(g.vertices.length * this.components.number.size, Cu.ARRAY_BUFFER)
                      , x = null;
                    g.colors.length > 0 && (x = v.AddBufferView(g.colors.length * this.components.number.size, Cu.ARRAY_BUFFER));
                    let y = v.AddBufferView(g.normals.length * this.components.number.size, Cu.ARRAY_BUFFER)
                      , _ = null;
                    g.uvs.length > 0 && (_ = v.AddBufferView(g.uvs.length * this.components.number.size, Cu.ARRAY_BUFFER));
                    let S = {
                        attributes: {},
                        mode: 4,
                        material: g.material
                    }
                      , N = g.GetBounds();
                    l.accessors.push({
                        bufferView: p,
                        byteOffset: 0,
                        componentType: this.components.index.type,
                        count: g.indices.length,
                        type: "SCALAR"
                    }),
                    S.indices = l.accessors.length - 1,
                    l.accessors.push({
                        bufferView: d,
                        byteOffset: 0,
                        componentType: this.components.number.type,
                        count: g.vertices.length / 3,
                        min: N.min,
                        max: N.max,
                        type: "VEC3"
                    }),
                    S.attributes.POSITION = l.accessors.length - 1,
                    x !== null && (l.accessors.push({
                        bufferView: x,
                        byteOffset: 0,
                        componentType: this.components.number.type,
                        count: g.colors.length / 3,
                        type: "VEC3"
                    }),
                    S.attributes.COLOR_0 = l.accessors.length - 1),
                    l.accessors.push({
                        bufferView: y,
                        byteOffset: 0,
                        componentType: this.components.number.type,
                        count: g.normals.length / 3,
                        type: "VEC3"
                    }),
                    S.attributes.NORMAL = l.accessors.length - 1,
                    _ !== null && (l.accessors.push({
                        bufferView: _,
                        byteOffset: 0,
                        componentType: this.components.number.type,
                        count: g.uvs.length / 2,
                        type: "VEC2"
                    }),
                    S.attributes.TEXCOORD_0 = l.accessors.length - 1),
                    h.primitives.push(S)
                }
                l.meshes.push(h)
            }
            return l
        }
        ExportMaterials(e, t, n) {
            function i(s, o, a, l) {
                function c(p, d) {
                    return [Ir(p.r / 255), Ir(p.g / 255), Ir(p.b / 255), d]
                }
                function u(p) {
                    return [Ir(p.r / 255), Ir(p.g / 255), Ir(p.b / 255)]
                }
                function h(p, d, x) {
                    if (d === null || !d.IsValid())
                        return null;
                    p.images === void 0 && (p.images = []),
                    p.textures === void 0 && (p.textures = []);
                    let _ = {
                        index: x(d)
                    };
                    if (d.HasTransformation()) {
                        let S = "KHR_texture_transform";
                        p.extensionsUsed === void 0 && (p.extensionsUsed = []),
                        p.extensionsUsed.indexOf(S) === -1 && p.extensionsUsed.push(S),
                        _.extensions = {
                            KHR_texture_transform: {
                                offset: [d.offset.x, -d.offset.y],
                                scale: [d.scale.x, d.scale.y],
                                rotation: -d.rotation
                            }
                        }
                    }
                    return _
                }
                let f = {
                    name: s.GetExportedMaterialName(a.name),
                    pbrMetallicRoughness: {
                        baseColorFactor: c(a.color, a.opacity)
                    },
                    emissiveFactor: u(a.emissive),
                    doubleSided: !0,
                    alphaMode: "OPAQUE"
                };
                a.transparent && (f.alphaMode = "BLEND");
                let m = h(o, a.diffuseMap, l);
                if (m !== null && (a.multiplyDiffuseMap || (f.pbrMetallicRoughness.baseColorFactor = c(new rt(255,255,255), a.opacity)),
                f.pbrMetallicRoughness.baseColorTexture = m),
                a.type === nn.Physical) {
                    let p = h(o, a.metalnessMap, l);
                    p !== null ? f.pbrMetallicRoughness.metallicRoughnessTexture = p : (f.pbrMetallicRoughness.metallicFactor = a.metalness,
                    f.pbrMetallicRoughness.roughnessFactor = a.roughness)
                }
                let g = h(o, a.normalMap, l);
                g !== null && (f.normalTexture = g);
                let v = h(o, a.emissiveMap, l);
                v !== null && (f.emissiveTexture = v),
                o.materials.push(f)
            }
            for (let s = 0; s < e.MaterialCount(); s++) {
                let o = e.GetMaterial(s);
                i(this, t, o, n)
            }
        }
    }
    ;
    var Qo = class {
        constructor(e) {
            this.transformation = new en,
            this.isMeshVisible = t=>!0,
            dl(e, this)
        }
    }
      , vo = class {
        constructor(e, t) {
            this.model = e,
            this.settings = t || new Qo,
            this.visibleMeshes = null,
            this.meshToVisibleMeshIndex = null
        }
        GetModel() {
            return this.model
        }
        MaterialCount() {
            return this.model.MaterialCount()
        }
        GetMaterial(e) {
            return this.model.GetMaterial(e)
        }
        VertexCount() {
            let e = 0;
            return this.EnumerateMeshInstances(t=>{
                e += t.VertexCount()
            }
            ),
            e
        }
        TriangleCount() {
            let e = 0;
            return this.EnumerateMeshInstances(t=>{
                e += t.TriangleCount()
            }
            ),
            e
        }
        MeshCount() {
            let e = 0;
            return this.EnumerateMeshes(t=>{
                e += 1
            }
            ),
            e
        }
        EnumerateMeshes(e) {
            this.FillVisibleMeshCache();
            for (let t = 0; t < this.model.MeshCount(); t++)
                if (this.visibleMeshes.has(t)) {
                    let n = this.model.GetMesh(t);
                    e(n)
                }
        }
        MapMeshIndex(e) {
            return this.FillVisibleMeshCache(),
            this.meshToVisibleMeshIndex.get(e)
        }
        IsMeshInstanceVisible(e) {
            return this.settings.isMeshVisible(e)
        }
        MeshInstanceCount() {
            let e = 0;
            return this.EnumerateMeshInstances(t=>{
                e += 1
            }
            ),
            e
        }
        EnumerateMeshInstances(e) {
            this.model.EnumerateMeshInstances(t=>{
                this.settings.isMeshVisible(t.GetId()) && e(t)
            }
            )
        }
        EnumerateTransformedMeshInstances(e) {
            this.EnumerateMeshInstances(t=>{
                let n = t.GetTransformation();
                this.settings.transformation.IsIdentity() || n.Append(this.settings.transformation);
                let s = t.GetMesh().Clone();
                n.IsIdentity() || Vr(s, n),
                e(s)
            }
            )
        }
        EnumerateVerticesAndTriangles(e) {
            let t = [];
            this.EnumerateTransformedMeshInstances(i=>{
                t.push(i)
            }
            );
            for (let i of t)
                i.EnumerateVertices(s=>{
                    e.onVertex(s.x, s.y, s.z)
                }
                );
            let n = 0;
            for (let i of t)
                i.EnumerateTriangleVertexIndices((s,o,a)=>{
                    e.onTriangle(s + n, o + n, a + n)
                }
                ),
                n += i.VertexCount()
        }
        EnumerateTrianglesWithNormals(e) {
            this.EnumerateTransformedMeshInstances(t=>{
                t.EnumerateTriangleVertices((n,i,s)=>{
                    let o = Ho(n, i, s);
                    e(n, i, s, o)
                }
                )
            }
            )
        }
        FillVisibleMeshCache() {
            if (this.visibleMeshes !== null && this.meshToVisibleMeshIndex !== null)
                return;
            this.visibleMeshes = new Set,
            this.model.EnumerateMeshInstances(t=>{
                let n = t.GetId();
                this.settings.isMeshVisible(n) && this.visibleMeshes.add(n.meshIndex)
            }
            ),
            this.meshToVisibleMeshIndex = new Map;
            let e = 0;
            for (let t = 0; t < this.model.MeshCount(); t++)
                this.visibleMeshes.has(t) && (this.meshToVisibleMeshIndex.set(t, e),
                e += 1)
        }
    }
    ;
    var Ai = class {
        constructor() {
            this.text = "",
            this.indentation = 0
        }
        GetText() {
            return this.text
        }
        Indent(e) {
            this.indentation += e
        }
        WriteArrayLine(e) {
            this.WriteLine(e.join(" "))
        }
        WriteLine(e) {
            this.WriteIndentation(),
            this.Write(e + `
`)
        }
        WriteIndentation() {
            for (let e = 0; e < this.indentation; e++)
                this.Write("  ")
        }
        Write(e) {
            this.text += e
        }
    }
    ;
    var nc = class extends Gn {
        constructor() {
            super()
        }
        CanExport(e, t) {
            return e === Dt.Text && t === "obj"
        }
        ExportContent(e, t, n, i) {
            function s(g, v, p, d) {
                if (p === null || !p.IsValid())
                    return;
                let x = pn(p.name);
                if (g.WriteArrayLine([v, x]),
                d.findIndex(_=>_.GetName() === x) === -1) {
                    let _ = new tn(x);
                    _.SetBufferContent(p.buffer),
                    d.push(_)
                }
            }
            let o = new tn("model.mtl")
              , a = new tn("model.obj");
            n.push(o),
            n.push(a);
            let l = new Ai;
            l.WriteLine(this.GetHeaderText());
            for (let g = 0; g < e.MaterialCount(); g++) {
                let v = e.GetMaterial(g);
                l.WriteArrayLine(["newmtl", this.GetExportedMaterialName(v.name)]),
                l.WriteArrayLine(["Kd", v.color.r / 255, v.color.g / 255, v.color.b / 255]),
                l.WriteArrayLine(["d", v.opacity]),
                v.type === nn.Phong && (l.WriteArrayLine(["Ka", v.ambient.r / 255, v.ambient.g / 255, v.ambient.b / 255]),
                l.WriteArrayLine(["Ks", v.specular.r / 255, v.specular.g / 255, v.specular.b / 255]),
                l.WriteArrayLine(["Ns", v.shininess * 1e3])),
                s(l, "map_Kd", v.diffuseMap, n),
                v.type === nn.Phong && s(l, "map_Ks", v.specularMap, n),
                s(l, "bump", v.bumpMap, n)
            }
            o.SetTextContent(l.GetText());
            let c = new Ai;
            c.WriteLine(this.GetHeaderText()),
            c.WriteArrayLine(["mtllib", o.GetName()]);
            let u = 0
              , h = 0
              , f = 0
              , m = null;
            e.EnumerateTransformedMeshInstances(g=>{
                c.WriteArrayLine(["g", this.GetExportedMeshName(g.GetName())]);
                for (let v = 0; v < g.VertexCount(); v++) {
                    let p = g.GetVertex(v);
                    c.WriteArrayLine(["v", p.x, p.y, p.z])
                }
                for (let v = 0; v < g.NormalCount(); v++) {
                    let p = g.GetNormal(v);
                    c.WriteArrayLine(["vn", p.x, p.y, p.z])
                }
                for (let v = 0; v < g.TextureUVCount(); v++) {
                    let p = g.GetTextureUV(v);
                    c.WriteArrayLine(["vt", p.x, p.y])
                }
                for (let v = 0; v < g.TriangleCount(); v++) {
                    let p = g.GetTriangle(v)
                      , d = p.v0 + u + 1
                      , x = p.v1 + u + 1
                      , y = p.v2 + u + 1
                      , _ = p.n0 + h + 1
                      , S = p.n1 + h + 1
                      , N = p.n2 + h + 1;
                    if (p.mat !== null) {
                        let R = e.GetMaterial(p.mat)
                          , q = this.GetExportedMaterialName(R.name);
                        q !== m && (c.WriteArrayLine(["usemtl", q]),
                        m = q)
                    }
                    let I = ""
                      , O = ""
                      , M = "";
                    p.HasTextureUVs() && (I = p.u0 + f + 1,
                    O = p.u1 + f + 1,
                    M = p.u2 + f + 1),
                    c.WriteArrayLine(["f", [d, I, _].join("/"), [x, O, S].join("/"), [y, M, N].join("/")])
                }
                u += g.VertexCount(),
                h += g.NormalCount(),
                f += g.TextureUVCount()
            }
            ),
            a.SetTextContent(c.GetText()),
            i()
        }
        GetHeaderText() {
            return "# exported by https://3dviewer.net"
        }
    }
    ;
    var ic = class extends Gn {
        constructor() {
            super()
        }
        CanExport(e, t) {
            return e === Dt.Text && t === "off"
        }
        ExportContent(e, t, n, i) {
            let s = new tn("model.off");
            n.push(s);
            let o = new Ai;
            o.WriteLine("OFF"),
            o.WriteArrayLine([e.VertexCount(), e.TriangleCount(), 0]),
            e.EnumerateVerticesAndTriangles({
                onVertex: function(a, l, c) {
                    o.WriteArrayLine([a, l, c])
                },
                onTriangle: function(a, l, c) {
                    o.WriteArrayLine([3, a, l, c])
                }
            }),
            s.SetTextContent(o.GetText()),
            i()
        }
    }
    ;
    var rc = class extends Gn {
        constructor() {
            super()
        }
        CanExport(e, t) {
            return (e === Dt.Text || e === Dt.Binary) && t === "ply"
        }
        ExportContent(e, t, n, i) {
            t === Dt.Text ? this.ExportText(e, n) : this.ExportBinary(e, n),
            i()
        }
        ExportText(e, t) {
            let n = new tn("model.ply");
            t.push(n);
            let i = new Ai
              , s = e.VertexCount()
              , o = e.TriangleCount()
              , a = this.GetHeaderText("ascii", s, o);
            i.Write(a),
            e.EnumerateVerticesAndTriangles({
                onVertex: function(l, c, u) {
                    i.WriteArrayLine([l, c, u])
                },
                onTriangle: function(l, c, u) {
                    i.WriteArrayLine([3, l, c, u])
                }
            }),
            n.SetTextContent(i.GetText())
        }
        ExportBinary(e, t) {
            let n = new tn("model.ply");
            t.push(n);
            let i = e.VertexCount()
              , s = e.TriangleCount()
              , o = this.GetHeaderText("binary_little_endian", i, s)
              , a = o.length + i * 3 * 4 + s * (1 + 3 * 4)
              , l = new wr(a,!0);
            for (let c = 0; c < o.length; c++)
                l.WriteUnsignedCharacter8(o.charCodeAt(c));
            e.EnumerateVerticesAndTriangles({
                onVertex: function(c, u, h) {
                    l.WriteFloat32(c),
                    l.WriteFloat32(u),
                    l.WriteFloat32(h)
                },
                onTriangle: function(c, u, h) {
                    l.WriteUnsignedCharacter8(3),
                    l.WriteInteger32(c),
                    l.WriteInteger32(u),
                    l.WriteInteger32(h)
                }
            }),
            n.SetBufferContent(l.GetBuffer())
        }
        GetHeaderText(e, t, n) {
            let i = new Ai;
            return i.WriteLine("ply"),
            i.WriteLine("format " + e + " 1.0"),
            i.WriteLine("element vertex " + t),
            i.WriteLine("property float x"),
            i.WriteLine("property float y"),
            i.WriteLine("property float z"),
            i.WriteLine("element face " + n),
            i.WriteLine("property list uchar int vertex_index"),
            i.WriteLine("end_header"),
            i.GetText()
        }
    }
    ;
    var sc = class extends Gn {
        constructor() {
            super()
        }
        CanExport(e, t) {
            return (e === Dt.Text || e === Dt.Binary) && t === "stl"
        }
        ExportContent(e, t, n, i) {
            t === Dt.Text ? this.ExportText(e, n) : this.ExportBinary(e, n),
            i()
        }
        ExportText(e, t) {
            let n = new tn("model.stl");
            t.push(n);
            let i = new Ai;
            i.WriteLine("solid Model"),
            e.EnumerateTrianglesWithNormals((s,o,a,l)=>{
                i.WriteArrayLine(["facet", "normal", l.x, l.y, l.z]),
                i.Indent(1),
                i.WriteLine("outer loop"),
                i.Indent(1),
                i.WriteArrayLine(["vertex", s.x, s.y, s.z]),
                i.WriteArrayLine(["vertex", o.x, o.y, o.z]),
                i.WriteArrayLine(["vertex", a.x, a.y, a.z]),
                i.Indent(-1),
                i.WriteLine("endloop"),
                i.Indent(-1),
                i.WriteLine("endfacet")
            }
            ),
            i.WriteLine("endsolid Model"),
            n.SetTextContent(i.GetText())
        }
        ExportBinary(e, t) {
            let n = new tn("model.stl");
            t.push(n);
            let i = e.TriangleCount()
              , s = 80
              , o = s + 4 + i * 50
              , a = new wr(o,!0);
            for (let l = 0; l < s; l++)
                a.WriteUnsignedCharacter8(0);
            a.WriteUnsignedInteger32(i),
            e.EnumerateTrianglesWithNormals((l,c,u,h)=>{
                a.WriteFloat32(h.x),
                a.WriteFloat32(h.y),
                a.WriteFloat32(h.z),
                a.WriteFloat32(l.x),
                a.WriteFloat32(l.y),
                a.WriteFloat32(l.z),
                a.WriteFloat32(c.x),
                a.WriteFloat32(c.y),
                a.WriteFloat32(c.z),
                a.WriteFloat32(u.x),
                a.WriteFloat32(u.y),
                a.WriteFloat32(u.z),
                a.WriteUnsignedInteger16(0)
            }
            ),
            n.SetBufferContent(a.GetBuffer())
        }
    }
    ;
    var oc = class {
        constructor() {
            this.exporters = [new nc, new sc, new rc, new ic, new tc, new Ql, new ec]
        }
        AddExporter(e) {
            this.exporters.push(e)
        }
        Export(e, t, n, i, s) {
            let o = null;
            for (let l = 0; l < this.exporters.length; l++) {
                let c = this.exporters[l];
                if (c.CanExport(n, i)) {
                    o = c;
                    break
                }
            }
            if (o === null) {
                s.onError();
                return
            }
            let a = new vo(e,t);
            o.Export(a, n, l=>{
                l.length === 0 ? s.onError() : s.onSuccess(l)
            }
            )
        }
    }
    ;
    function qy(r, e, t, n, i) {
        let s = Jr(e, null)
          , o = t.indexOf(s);
        return ky(r, t, o !== -1 ? o : n, l=>{
            Zr(e, t[l]),
            i && i(l)
        }
        )
    }
    var er = class {
        constructor(e, t, n) {
            this.name = e,
            this.format = t,
            this.extension = n,
            this.visibleOnlySelect = null,
            this.rotationSelect = null
        }
        GetName() {
            return this.name
        }
        GenerateParametersUI(e) {
            function t(n, i, s, o, a) {
                let l = Ce(n, "ov_dialog_row");
                Ce(l, "ov_dialog_row_name", i);
                let c = Ce(l, "ov_dialog_row_value");
                return qy(c, s, o, a)
            }
            this.visibleOnlySelect = t(e, "Scope", "ov_last_scope", ["Entire Model", "Visible Only"], 1),
            this.rotationSelect = t(e, "Rotation", "ov_last_rotation", ["No Rotation", "-90 Degrees", "90 Degrees"], 0)
        }
        ExportModel(e, t) {
            let n = new Qo;
            if (this.visibleOnlySelect.selectedIndex === 1 && (n.isMeshVisible = o=>t.isMeshVisible(o)),
            this.rotationSelect.selectedIndex === 1) {
                let o = new Ut().CreateRotationAxisAngle(new ze(1,0,0), -Math.PI / 2);
                n.transformation.SetMatrix(o)
            } else if (this.rotationSelect.selectedIndex === 2) {
                let o = new Ut().CreateRotationAxisAngle(new ze(1,0,0), Math.PI / 2);
                n.transformation.SetMatrix(o)
            }
            if (new vo(e,n).MeshInstanceCount() === 0) {
                Er("Export Failed", "The model doesn't contain any meshes.", null);
                return
            }
            let s = new ho;
            s.Init("Exporting Model"),
            s.Open(),
            _s(()=>{
                new oc().Export(e, n, this.format, this.extension, {
                    onError: ()=>{
                        s.Close()
                    }
                    ,
                    onSuccess: a=>{
                        if (a.length === 0)
                            s.Close();
                        else if (a.length === 1) {
                            s.Close();
                            let l = a[0];
                            xu(l.GetBufferContent(), l.GetName())
                        } else if (a.length > 1) {
                            let l = {};
                            for (let h of a)
                                l[h.name] = new Uint8Array(h.content);
                            let u = Nm(l).buffer;
                            s.Close(),
                            xu(u, "model.zip")
                        }
                    }
                })
            }
            )
        }
    }
      , tg = class {
        constructor(e) {
            this.callbacks = e,
            this.selectedExporter = null,
            this.parametersDiv = null,
            this.exporters = [new er("Wavefront (.obj)",Dt.Text,"obj"), new er("Stereolithography Text (.stl)",Dt.Text,"stl"), new er("Stereolithography Binary (.stl)",Dt.Binary,"stl"), new er("Polygon File Format Text (.ply)",Dt.Text,"ply"), new er("Polygon File Format Binary (.ply)",Dt.Binary,"ply"), new er("glTF Text (.gltf)",Dt.Text,"gltf"), new er("glTF Binary (.glb)",Dt.Binary,"glb"), new er("Object File Format Text (.off)",Dt.Text,"off"), new er("Rhinoceros 3D (.3dm)",Dt.Binary,"3dm"), new er("Dotbim (.bim)",Dt.Text,"bim")]
        }
        Open(e, t) {
            let n = new Qn
              , i = n.Init("Export", [{
                name: "Close",
                subClass: "outline",
                onClick() {
                    n.Close()
                }
            }, {
                name: "Export",
                onClick: ()=>{
                    n.Close(),
                    this.ExportFormat(e, t)
                }
            }]);
            Ce(i, "ov_dialog_section", "Select the format from the list below, and adjust the settings of the selected format.");
            let o = Ce(i, "ov_dialog_row");
            this.parametersDiv = Ce(i);
            let a = this.exporters.map(c=>c.GetName())
              , l = qy(o, "ov_last_export_format", a, 6, c=>{
                this.OnFormatSelected(c)
            }
            );
            this.OnFormatSelected(l.selectedIndex),
            n.Open()
        }
        OnFormatSelected(e) {
            Zn(this.parametersDiv),
            this.selectedExporter = this.exporters[e],
            this.selectedExporter.GenerateParametersUI(this.parametersDiv)
        }
        ExportFormat(e, t) {
            this.selectedExporter.ExportModel(e, {
                isMeshVisible: n=>this.callbacks.isMeshVisible(n)
            }),
            dn("model_exported", this.selectedExporter.GetName())
        }
    }
    ;
    function Yy(r, e, t) {
        new tg(t).Open(r, e)
    }
    function Ky(r) {
        let e = r.GetFileList().GetFiles();
        if (e.length !== 0)
            if (e.length === 1) {
                let t = e[0];
                xu(t.content, t.name)
            } else {
                let t = {};
                for (let i of e)
                    t[i.name] = new Uint8Array(i.content);
                let n = Nm(t);
                xu(n.buffer, "model.zip")
            }
    }
    function Zy(r) {
        function e(p, d, x, y, _) {
            let S = Ce(p, "ov_dialog_row");
            Oy(S, d, "snapshot_size", x, y, _)
        }
        function t(p, d) {
            let x = parseInt(d[0], 10)
              , y = parseInt(d[1], 10);
            return x < 1 || y < 1 ? null : p.GetImageAsDataUrl(d[0], d[1])
        }
        function n(p, d, x) {
            let y = t(p, x);
            d.src = y
        }
        function i(p, d, x) {
            let y = p[d];
            y.widthInput.disabled = x !== d,
            y.heightInput.disabled = x !== d
        }
        function s(p, d) {
            let x = p[d];
            return x.size !== null ? x.size : [x.widthInput.value, x.heightInput.value]
        }
        function o(p, d, x) {
            let y = Ce(p, "ov_dialog_row");
            Ce(y, "ov_snapshot_dialog_param_name", d);
            let _ = Dy(y, "ov_dialog_text", x);
            return _.classList.add("ov_snapshot_dialog_param_value"),
            _.addEventListener("focus", ()=>{
                _.setSelectionRange(0, _.value.length)
            }
            ),
            _
        }
        let a = 0
          , l = 3
          , c = [{
            name: "Small (1280x720)",
            size: [1280, 720]
        }, {
            name: "Medium (1920x1080)",
            size: [1920, 1080]
        }, {
            name: "Large (2560x1440)",
            size: [2560, 1440]
        }, {
            name: "Custom",
            size: null,
            widthInput: null,
            heightInput: null
        }]
          , u = new Qn
          , h = u.Init("Create Snapshot", [{
            name: "Cancel",
            subClass: "outline",
            onClick() {
                u.Close()
            }
        }, {
            name: "Create",
            onClick() {
                u.Close(),
                dn("snapshot_created", c[a].name);
                let p = t(r, s(c, a));
                p !== null && Vm(p, "model.png")
            }
        }])
          , f = Ce(h, "ov_snapshot_dialog_left")
          , m = Yr("img", "ov_snapshot_dialog_preview")
          , g = Jr("ov_last_snapshot_size", c[1].name);
        for (let p = 0; p < c.length; p++)
            if (g === c[p].name) {
                a = p;
                break
            }
        let v = c[l];
        for (let p = 0; p < c.length; p++) {
            let d = c[p]
              , x = p === a;
            e(f, "snapshot_" + p.toString(), d.name, x, ()=>{
                a = p,
                Zr("ov_last_snapshot_size", d.name),
                n(r, m, s(c, p)),
                i(c, l, a)
            }
            )
        }
        return v.widthInput = o(f, "Width", p=>{
            n(r, m, s(c, a)),
            Kl("ov_snapshot_custom_width", p)
        }
        ),
        v.heightInput = o(f, "Height", p=>{
            n(r, m, s(c, a)),
            Kl("ov_snapshot_custom_height", p)
        }
        ),
        v.widthInput.value = Yl("ov_snapshot_custom_width", 1e3),
        v.heightInput.value = Yl("ov_snapshot_custom_height", 1e3),
        i(c, l, a),
        h.appendChild(m),
        n(r, m, s(c, a)),
        u.Open(),
        u
    }
    function Jy(r) {
        let e = new Qn
          , t = Yr("textarea", "ov_dialog_textarea")
          , n = e.Init("Open from url", [{
            name: "Cancel",
            subClass: "outline",
            onClick() {
                e.Close()
            }
        }, {
            name: "OK",
            onClick() {
                let s = [];
                yi(t.value, o=>{
                    s.push(o)
                }
                ),
                e.Close(),
                r(s)
            }
        }]);
        return Ce(n, "ov_dialog_section", "Here you can load models based on their urls. You can add more lines if your model builds up from multiple files."),
        n.appendChild(t),
        e.Open(),
        t.focus(),
        e
    }
    function $y(r, e, t) {
        function n(h, f, m, g) {
            let v = Ce(h, "ov_dialog_row")
              , p = Bf(v, m, f, !0, ()=>{
                g(p.checked)
            }
            )
        }
        function i(h, f) {
            let m = "Copy"
              , g = "Copied"
              , v = Ce(h, "ov_dialog_copyable_input")
              , p = Jt(v, "input", null);
            p.setAttribute("type", "text"),
            p.readOnly = !0;
            let d = Ce(v, "ov_button outline ov_dialog_copyable_input_button", m);
            return d.addEventListener("click", ()=>{
                Py(f()),
                d.innerHTML = g,
                setTimeout(()=>{
                    d.innerHTML = m
                }
                , 2e3)
            }
            ),
            p
        }
        function s(h, f) {
            function m(p) {
                let d = il();
                return d.AddModelUrls(p),
                "https://3dviewer.net/#" + d.GetParameterList()
            }
            let g = Ce(h, "ov_dialog_section");
            Ce(g, "ov_dialog_inner_title", "Sharing Link");
            let v = i(g, ()=>(dn("model_shared", "sharing_link"),
            m(f)));
            v.value = m(f)
        }
        function o(h, f, m, g) {
            function v(_, S, N, I) {
                let O = il();
                if (O.AddModelUrls(_),
                S) {
                    O.AddCamera(I.GetCamera()),
                    O.AddCameraMode(I.GetCameraMode());
                    let q = {
                        environmentMapName: N.environmentMapName,
                        backgroundIsEnvMap: N.backgroundIsEnvMap
                    };
                    O.AddEnvironmentSettings(q),
                    O.AddBackgroundColor(N.backgroundColor),
                    O.AddDefaultColor(N.defaultColor),
                    O.AddEdgeSettings(N.edgeSettings)
                }
                let M = O.GetParameterList()
                  , R = "";
                return R += "<iframe",
                R += ' width="640" height="480"',
                R += ' style="border:1px solid #eeeeee;"',
                R += ' src="https://3dviewer.net/embed.html#' + M + '">',
                R += "</iframe>",
                R
            }
            let p = !0
              , d = Ce(h, "ov_dialog_section");
            d.style.marginTop = "20px",
            Ce(d, "ov_dialog_inner_title", "Embedding Code");
            let x = Ce(d, "ov_dialog_section")
              , y = i(d, ()=>(dn("model_shared", "embedding_code"),
            v(f, p, m, g)));
            n(x, "Use customized settings", "embed_current_settings", _=>{
                p = _,
                y.value = v(f, p, m, g)
            }
            ),
            y.value = v(f, p, m, g)
        }
        if (!r.IsOnlyUrlSource())
            return Er("Sharing Failed", "Sharing works only if you load files by url. Please upload your model files to a web server, open them by url, and try embedding again.", null);
        let a = r.GetFiles()
          , l = [];
        for (let h = 0; h < a.length; h++) {
            let f = a[h];
            f.source === Di.Url && l.push(f.data)
        }
        let c = new Qn
          , u = c.Init("Share", [{
            name: "Close",
            onClick() {
                c.Close()
            }
        }]);
        return s(u, l),
        o(u, l, e, t),
        c.Open(),
        c
    }
    function ng(r) {
        let e = new je;
        r.object.updateWorldMatrix(!0, !1),
        e.extractRotation(r.object.matrixWorld);
        let t = r.face.normal.clone();
        return t.applyMatrix4(e),
        t
    }
    function Qy() {
        return new pi({
            color: 2503224,
            depthTest: !1
        })
    }
    function ad(r, e) {
        let t = new wt().setFromPoints(r);
        return new gs(t,e)
    }
    var ig = class {
        constructor(e, t) {
            this.intersection = null,
            this.markerObject = new bt;
            let n = Qy()
              , i = new Fo(0,0,t,t,0,2 * Math.PI,!1,0);
            this.markerObject.add(ad(i.getPoints(50), n)),
            this.markerObject.add(ad([new ue(-t,0,0), new ue(t,0,0)], n)),
            this.markerObject.add(ad([new ue(0,-t,0), new ue(0,t,0)], n)),
            this.UpdatePosition(e)
        }
        UpdatePosition(e) {
            this.intersection = e;
            let t = ng(this.intersection);
            this.markerObject.updateMatrixWorld(!0),
            this.markerObject.position.set(0, 0, 0),
            this.markerObject.lookAt(t),
            this.markerObject.position.set(this.intersection.point.x, this.intersection.point.y, this.intersection.point.z)
        }
        Show(e) {
            this.markerObject.visible = e
        }
        GetIntersection() {
            return this.intersection
        }
        GetObject() {
            return this.markerObject
        }
    }
    ;
    function TA(r, e) {
        let t = r.GetIntersection()
          , n = e.GetIntersection()
          , i = {
            pointsDistance: null,
            parallelFacesDistance: null,
            facesAngle: null
        }
          , s = ng(t)
          , o = ng(n);
        if (i.pointsDistance = t.point.distanceTo(n.point),
        i.facesAngle = s.angleTo(o),
        fc(i.facesAngle, 0, 1e-4) || fc(i.facesAngle, Math.PI, 1e-4)) {
            let a = new ar().setFromNormalAndCoplanarPoint(s, t.point);
            i.parallelFacesDistance = Math.abs(a.distanceToPoint(n.point))
        }
        return i
    }
    var ld = class {
        constructor(e, t) {
            this.viewer = e,
            this.settings = t,
            this.isActive = !1,
            this.markers = [],
            this.tempMarker = null,
            this.panel = null,
            this.button = null
        }
        SetButton(e) {
            this.button = e
        }
        IsActive() {
            return this.isActive
        }
        SetActive(e) {
            this.isActive !== e && (this.isActive = e,
            this.button.SetSelected(e),
            this.isActive ? (this.panel = Ce(document.body, "ov_measure_panel"),
            this.UpdatePanel(),
            this.Resize()) : (this.ClearMarkers(),
            this.panel.remove()))
        }
        Click(e) {
            let t = this.viewer.GetMeshIntersectionUnderMouse(e);
            if (t === null) {
                this.ClearMarkers(),
                this.UpdatePanel();
                return
            }
            this.markers.length === 2 && this.ClearMarkers(),
            this.AddMarker(t),
            this.UpdatePanel()
        }
        MouseMove(e) {
            let t = this.viewer.GetMeshIntersectionUnderMouse(e);
            if (t === null) {
                this.tempMarker !== null && (this.tempMarker.Show(!1),
                this.viewer.Render());
                return
            }
            this.tempMarker === null && (this.tempMarker = this.GenerateMarker(t)),
            this.tempMarker.UpdatePosition(t),
            this.tempMarker.Show(!0),
            this.viewer.Render()
        }
        AddMarker(e) {
            let t = this.GenerateMarker(e);
            if (this.markers.push(t),
            this.markers.length === 2) {
                let n = Qy()
                  , i = this.markers[0].GetIntersection().point
                  , s = this.markers[1].GetIntersection().point;
                this.viewer.AddExtraObject(ad([i, s], n))
            }
        }
        GenerateMarker(e) {
            let n = this.viewer.GetBoundingSphere(s=>!0).radius / 20
              , i = new ig(e,n);
            return this.viewer.AddExtraObject(i.GetObject()),
            i
        }
        UpdatePanel() {
            function e(n) {
                let s = window.getComputedStyle(document.body, null).backgroundColor.match(/\d+/g);
                if (s.length < 3)
                    return new rt(n.r,n.g,n.b);
                let o = ns(n.a);
                return new rt(parseInt(s[0], 10) * (1 - o) + n.r * o,parseInt(s[1], 10) * (1 - o) + n.g * o,parseInt(s[2], 10) * (1 - o) + n.b * o)
            }
            function t(n, i, s, o) {
                let a = $n(n, i, "left_inline");
                a.title = s,
                Ce(n, "ov_measure_value", o)
            }
            if (Zn(this.panel),
            this.settings.backgroundIsEnvMap)
                this.panel.style.color = "#ffffff",
                this.panel.style.backgroundColor = "rgba(0,0,0,0.5)";
            else {
                let n = e(this.settings.backgroundColor);
                Ly(n) ? this.panel.style.color = "#000000" : this.panel.style.color = "#ffffff",
                this.panel.style.backgroundColor = "transparent"
            }
            if (this.markers.length === 0)
                this.panel.innerHTML = "Select a point.";
            else if (this.markers.length === 1)
                this.panel.innerHTML = "Select another point.";
            else {
                let n = TA(this.markers[0], this.markers[1]);
                if (n.pointsDistance !== null && t(this.panel, "measure_distance", "Distance of points", n.pointsDistance.toFixed(3)),
                n.parallelFacesDistance !== null && t(this.panel, "measure_distance_parallel", "Distance of parallel faces", n.parallelFacesDistance.toFixed(3)),
                n.facesAngle !== null) {
                    let i = n.facesAngle * Uu;
                    t(this.panel, "measure_angle", "Angle of faces", i.toFixed(1) + "\xB0")
                }
            }
            this.Resize()
        }
        Resize() {
            if (!this.isActive)
                return;
            let t = this.viewer.GetCanvas().getBoundingClientRect()
              , n = this.panel.getBoundingClientRect()
              , i = t.right - t.left
              , s = n.right - n.left;
            this.panel.style.left = t.left + (i - s) / 2 + "px",
            this.panel.style.top = t.top + 10 + "px"
        }
        ClearMarkers() {
            this.viewer.ClearExtra(),
            this.markers = [],
            this.tempMarker = null
        }
    }
    ;
    function ex(r, e) {
        let t = null
          , n = s=>{
            s.preventDefault();
            let o = s.clientX - t;
            e.onSplit(o)
        }
          , i = ()=>{
            document.removeEventListener("mousemove", n),
            document.removeEventListener("mouseup", i),
            document.removeEventListener("mouseleave", i),
            t = null
        }
        ;
        r.addEventListener("mousedown", s=>{
            t = s.clientX,
            e.onSplitStart(),
            document.addEventListener("mousemove", n),
            document.addEventListener("mouseup", i),
            document.addEventListener("mouseleave", i)
        }
        )
    }
    var Iu = new Map
      , ac = {
        Header: 1,
        Toolbar: 2
    };
    function rg(r, e) {
        Iu.has(r) || Iu.set(r, []),
        Iu.get(r).push(e)
    }
    function sg(r, e) {
        if (!Iu.has(r))
            return;
        let t = Iu.get(r);
        for (let n of t)
            e(n)
    }
    var Ps = {
        Undefined: 0,
        Intro: 1,
        Model: 2,
        Loading: 3
    }
      , og = class {
        constructor(e, t, n, i, s) {
            this.parameters = e,
            this.navigator = t,
            this.sidebar = n,
            this.viewer = i,
            this.measureTool = s,
            this.limits = {
                minPanelWidth: 290,
                minCanvasWidth: 100
            }
        }
        Init() {
            this.InstallSplitter(this.parameters.navigatorSplitterDiv, this.parameters.navigatorDiv, (e,t)=>{
                let n = e + t;
                this.OnSplitterDragged(n - this.navigator.GetWidth(), 0)
            }
            ),
            this.InstallSplitter(this.parameters.sidebarSplitterDiv, this.parameters.sidebarDiv, (e,t)=>{
                let n = e - t;
                this.OnSplitterDragged(0, n - this.sidebar.GetWidth())
            }
            ),
            this.Resize()
        }
        InstallSplitter(e, t, n) {
            let i = null;
            ex(e, {
                onSplitStart: ()=>{
                    i = Ei(t)
                }
                ,
                onSplit: s=>{
                    n(i, s)
                }
            })
        }
        OnSplitterDragged(e, t) {
            let n = window.innerWidth
              , i = this.navigator.GetWidth()
              , s = this.sidebar.GetWidth()
              , o = Ei(this.parameters.leftContainerDiv)
              , a = Ei(this.parameters.rightContainerDiv)
              , l = o + e
              , c = a + t
              , u = n - l - c
              , h = this.navigator.IsPanelsVisible()
              , f = this.sidebar.IsPanelsVisible();
            if (h && l < this.limits.minPanelWidth && (l = this.limits.minPanelWidth),
            f && c < this.limits.minPanelWidth && (c = this.limits.minPanelWidth),
            u < this.limits.minCanvasWidth && (e > 0 ? l = n - c - this.limits.minCanvasWidth : t > 0 && (c = n - l - this.limits.minCanvasWidth)),
            h) {
                let m = i + (l - o);
                this.navigator.SetWidth(m)
            }
            if (f) {
                let m = s + (c - a);
                this.sidebar.SetWidth(m)
            }
            this.Resize()
        }
        Resize() {
            let e = window.innerWidth
              , t = window.innerHeight
              , n = this.parameters.headerDiv.offsetHeight
              , i = 0
              , s = 0
              , o = 0;
            Ry() || (i = Ei(this.parameters.leftContainerDiv),
            s = Ei(this.parameters.rightContainerDiv),
            o = 1);
            let a = e - i - s
              , l = t - n;
            if (a < this.limits.minCanvasWidth) {
                let c = this.limits.minCanvasWidth - a
                  , u = this.navigator.IsPanelsVisible()
                  , h = this.sidebar.IsPanelsVisible();
                if (c > 0 && u) {
                    let f = Math.min(c, i - this.limits.minPanelWidth);
                    this.navigator.SetWidth(this.navigator.GetWidth() - f),
                    c = c - f
                }
                if (c > 0 && h) {
                    let f = Math.min(c, s - this.limits.minPanelWidth);
                    this.sidebar.SetWidth(this.sidebar.GetWidth() - f)
                }
                i = Ei(this.parameters.leftContainerDiv),
                s = Ei(this.parameters.rightContainerDiv),
                a = e - i - s
            }
            this.navigator.Resize(l),
            Qi(this.parameters.navigatorSplitterDiv, l),
            this.sidebar.Resize(l),
            Qi(this.parameters.sidebarSplitterDiv, l),
            Qi(this.parameters.introDiv, l),
            this.viewer.Resize(a - o, l),
            this.measureTool.Resize()
        }
    }
      , cd = class {
        constructor(e) {
            this.parameters = e,
            this.settings = new Zl,
            this.viewer = new Kr,
            this.measureTool = new ld(this.viewer,this.settings),
            this.hashHandler = new Bl,
            this.toolbar = new od(this.parameters.toolbarDiv),
            this.navigator = new Jf(this.parameters.navigatorDiv),
            this.sidebar = new id(this.parameters.sidebarDiv,this.settings),
            this.modelLoaderUI = new Hl,
            this.themeHandler = new rd,
            this.highlightColor = new rt(142,201,240),
            this.uiState = Ps.Undefined,
            this.layouter = new og(this.parameters,this.navigator,this.sidebar,this.viewer,this.measureTool),
            this.model = null
        }
        Load() {
            this.settings.LoadFromCookies(),
            this.SwitchTheme(this.settings.themeId, !1),
            dn("theme_on_load", this.settings.themeId === ai.Light ? "light" : "dark"),
            sg(ac.Header, e=>{
                e.registerButtons({
                    createHeaderButton: (t,n,i)=>{
                        this.CreateHeaderButton(t, n, i)
                    }
                })
            }
            ),
            this.InitViewer(),
            this.InitToolbar(),
            this.InitDragAndDrop(),
            this.InitSidebar(),
            this.InitNavigator(),
            this.viewer.SetMouseClickHandler(this.OnModelClicked.bind(this)),
            this.viewer.SetMouseMoveHandler(this.OnModelMouseMoved.bind(this)),
            this.viewer.SetContextMenuHandler(this.OnModelContextMenu.bind(this)),
            this.layouter.Init(),
            this.SetUIState(Ps.Intro),
            this.hashHandler.SetEventListener(this.OnHashChange.bind(this)),
            this.OnHashChange(),
            window.addEventListener("resize", ()=>{
                this.layouter.Resize()
            }
            )
        }
        HasLoadedModel() {
            return this.model !== null
        }
        SetUIState(e) {
            function t(n) {
                document.querySelector(":root").style.setProperty("--ov_only_on_model_display", n ? "inherit" : "none")
            }
            this.uiState !== e && (this.uiState = e,
            this.uiState === Ps.Intro ? (It(this.parameters.introDiv, !0),
            It(this.parameters.headerDiv, !0),
            It(this.parameters.mainDiv, !1),
            t(!1)) : this.uiState === Ps.Model ? (It(this.parameters.introDiv, !1),
            It(this.parameters.headerDiv, !0),
            It(this.parameters.mainDiv, !0),
            t(!0),
            this.UpdatePanelsVisibility()) : this.uiState === Ps.Loading && (It(this.parameters.introDiv, !1),
            It(this.parameters.headerDiv, !0),
            It(this.parameters.mainDiv, !1),
            t(!1)),
            this.layouter.Resize())
        }
        ClearModel() {
            Hm(),
            this.model = null,
            this.viewer.Clear(),
            this.parameters.fileNameDiv.innerHTML = "",
            this.navigator.Clear(),
            this.sidebar.Clear(),
            this.measureTool.SetActive(!1)
        }
        OnModelLoaded(e, t) {
            this.model = e.model,
            this.parameters.fileNameDiv.innerHTML = e.mainFile,
            this.viewer.SetMainObject(t),
            this.viewer.SetUpVector(lt.Y, !1),
            this.navigator.FillTree(e),
            this.sidebar.UpdateControlsVisibility(),
            this.FitModelToWindow(!0)
        }
        OnModelClicked(e, t) {
            if (e !== 1)
                return;
            if (this.measureTool.IsActive()) {
                this.measureTool.Click(t);
                return
            }
            let n = this.viewer.GetMeshUserDataUnderMouse(t);
            n === null ? this.navigator.SetSelection(null) : this.navigator.SetSelection(new go(qn.Mesh,n.originalMeshInstance.id))
        }
        OnModelMouseMoved(e) {
            this.measureTool.IsActive() && this.measureTool.MouseMove(e)
        }
        OnModelContextMenu(e, t) {
            let n = this.viewer.GetMeshUserDataUnderMouse(t)
              , i = [];
            if (n === null)
                i.push({
                    name: "Fit model to window",
                    icon: "fit",
                    onClick: ()=>{
                        this.FitModelToWindow(!1)
                    }
                }),
                this.navigator.HasHiddenMesh() && i.push({
                    name: "Show all meshes",
                    icon: "visible",
                    onClick: ()=>{
                        this.navigator.ShowAllMeshes(!0)
                    }
                });
            else if (i.push({
                name: "Hide mesh",
                icon: "hidden",
                onClick: ()=>{
                    this.navigator.ToggleMeshVisibility(n.originalMeshInstance.id)
                }
            }),
            i.push({
                name: "Fit mesh to window",
                icon: "fit",
                onClick: ()=>{
                    this.navigator.FitMeshToWindow(n.originalMeshInstance.id)
                }
            }),
            this.navigator.MeshItemCount() > 1) {
                let s = this.navigator.IsMeshIsolated(n.originalMeshInstance.id);
                i.push({
                    name: s ? "Remove isolation" : "Isolate mesh",
                    icon: s ? "deisolate" : "isolate",
                    onClick: ()=>{
                        s ? this.navigator.ShowAllMeshes(!0) : this.navigator.IsolateMesh(n.originalMeshInstance.id)
                    }
                })
            }
            zl(i, {
                calculatePosition: s=>By(e, s),
                onClick: s=>{
                    i[s].onClick()
                }
            })
        }
        OnHashChange() {
            if (this.hashHandler.HasHash()) {
                let e = this.hashHandler.GetModelFilesFromHash();
                if (e === null)
                    return;
                to(e);
                let t = new br;
                t.defaultColor = this.settings.defaultColor;
                let n = this.hashHandler.GetDefaultColorFromHash();
                n !== null && (t.defaultColor = n),
                dn("model_load_started", "hash"),
                this.LoadModelFromUrlList(e, t)
            } else
                this.ClearModel(),
                this.SetUIState(Ps.Intro)
        }
        OpenFileBrowserDialog() {
            this.parameters.fileInput.click()
        }
        FitModelToWindow(e) {
            let t = !e
              , n = this.viewer.GetBoundingSphere(i=>this.navigator.IsMeshVisible(i.originalMeshInstance.id));
            e && this.viewer.AdjustClippingPlanesToSphere(n),
            this.viewer.FitSphereToWindow(n, t)
        }
        FitMeshToWindow(e) {
            let t = this.viewer.GetBoundingSphere(n=>n.originalMeshInstance.id.IsEqual(e));
            this.viewer.FitSphereToWindow(t, !0)
        }
        FitMeshesToWindow(e) {
            let t = new Set;
            for (let i of e)
                t.add(i.GetKey());
            let n = this.viewer.GetBoundingSphere(i=>t.has(i.originalMeshInstance.id.GetKey()));
            this.viewer.FitSphereToWindow(n, !0)
        }
        UpdateMeshesVisibility() {
            this.viewer.SetMeshesVisibility(e=>this.navigator.IsMeshVisible(e.originalMeshInstance.id))
        }
        UpdateMeshesSelection() {
            let e = this.navigator.GetSelectedMeshId();
            this.viewer.SetMeshesHighlight(this.highlightColor, t=>!!(e !== null && t.originalMeshInstance.id.IsEqual(e)))
        }
        LoadModelFromUrlList(e, t) {
            let n = no(e);
            this.LoadModelFromInputFiles(n, t),
            this.ClearHashIfNotOnlyUrlList()
        }
        LoadModelFromFileList(e) {
            let t = new br;
            t.defaultColor = this.settings.defaultColor;
            let n = al(e);
            this.LoadModelFromInputFiles(n, t),
            this.ClearHashIfNotOnlyUrlList()
        }
        LoadModelFromInputFiles(e, t) {
            this.modelLoaderUI.LoadModel(e, t, {
                onStart: ()=>{
                    this.SetUIState(Ps.Loading),
                    this.ClearModel()
                }
                ,
                onFinish: (n,i)=>{
                    this.SetUIState(Ps.Model),
                    this.OnModelLoaded(n, i);
                    let s = Oi(n.mainFile);
                    dn("model_loaded", s)
                }
                ,
                onRender: ()=>{
                    this.viewer.Render()
                }
                ,
                onError: n=>{
                    this.SetUIState(Ps.Intro);
                    let i = null;
                    if (n.mainFile !== null)
                        i = Oi(n.mainFile);
                    else {
                        let s = []
                          , a = this.modelLoaderUI.GetImporter().GetFileList().GetFiles();
                        for (let l = 0; l < a.length; l++) {
                            let c = a[l].extension;
                            s.push(c)
                        }
                        i = s.join(",")
                    }
                    n.code === Un.NoImportableFile ? dn("no_importable_file", i) : n.code === Un.FailedToLoadFile ? dn("failed_to_load_file", i) : n.code === Un.ImportFailed && dn("import_failed", i, {
                        error_message: n.message
                    })
                }
            })
        }
        ClearHashIfNotOnlyUrlList() {
            !this.modelLoaderUI.GetImporter().GetFileList().IsOnlyUrlSource() && this.hashHandler.HasHash() && (this.hashHandler.SkipNextEventHandler(),
            this.hashHandler.ClearHash())
        }
        UpdateEdgeDisplay() {
            this.settings.SaveToCookies(),
            this.viewer.SetEdgeSettings(this.settings.edgeSettings)
        }
        UpdateEnvironmentMap() {
            let e = "assets/envmaps/" + this.settings.environmentMapName + "/"
              , t = [e + "posx.jpg", e + "negx.jpg", e + "posy.jpg", e + "negy.jpg", e + "posz.jpg", e + "negz.jpg"]
              , n = new Bi(t,this.settings.backgroundIsEnvMap);
            this.viewer.SetEnvironmentMapSettings(n)
        }
        SwitchTheme(e, t) {
            if (this.settings.themeId = e,
            this.themeHandler.SwitchTheme(this.settings.themeId),
            this.settings.SaveToCookies(),
            t) {
                this.viewer.SetBackgroundColor(this.settings.backgroundColor);
                let n = this.modelLoaderUI.GetModelLoader();
                n.GetDefaultMaterial() !== null && (Qc(this.model, this.settings.defaultColor),
                n.ReplaceDefaultMaterialColor(this.settings.defaultColor))
            }
        }
        InitViewer() {
            let e = Jt(this.parameters.viewerDiv, "canvas");
            this.viewer.Init(e),
            this.viewer.SetEdgeSettings(this.settings.edgeSettings),
            this.viewer.SetBackgroundColor(this.settings.backgroundColor),
            this.UpdateEnvironmentMap()
        }
        InitToolbar() {
            function e(a, l, c, u, h) {
                let f = a.AddImageButton(l, c, ()=>{
                    h()
                }
                );
                for (let m of u)
                    f.AddClass(m);
                return f
            }
            function t(a, l, c, u, h) {
                let f = a.AddImagePushButton(l, c, !1, m=>{
                    h(m)
                }
                );
                for (let m of u)
                    f.AddClass(m);
                return f
            }
            function n(a, l, c, u, h, f) {
                let m = [];
                for (let v = 0; v < l.length; v++) {
                    let p = l[v]
                      , d = c[v];
                    m.push({
                        image: p,
                        title: d
                    })
                }
                let g = a.AddImageRadioButton(m, u, v=>{
                    f(v)
                }
                );
                for (let v of h)
                    for (let p of g)
                        p.AddClass(v)
            }
            function i(a, l) {
                let c = a.AddSeparator();
                if (l !== null)
                    for (let u of l)
                        c.classList.add(u)
            }
            let s = this.modelLoaderUI.GetImporter();
            // e(this.toolbar, "open", "Open from your device", [], ()=>{
            //     this.OpenFileBrowserDialog()
            // }
            // ),
            // e(this.toolbar, "open_url", "Open from url", [], ()=>{
            //     Jy(a=>{
            //         a.length > 0 && this.hashHandler.SetModelFilesToHash(a)
            //     }
            //     )
            // }
            // ),
            // i(this.toolbar, ["only_on_model"]),
            e(this.toolbar, "fit", "Fit model to window", ["only_on_model"], ()=>{
                this.FitModelToWindow(!1)
            }
            ),
            e(this.toolbar, "up_y", "Set Y axis as up vector", ["only_on_model"], ()=>{
                this.viewer.SetUpVector(lt.Y, !0)
            }
            ),
            e(this.toolbar, "up_z", "Set Z axis as up vector", ["only_on_model"], ()=>{
                this.viewer.SetUpVector(lt.Z, !0)
            }
            ),
            e(this.toolbar, "flip", "Flip up vector", ["only_on_model"], ()=>{
                this.viewer.FlipUpVector()
            }
            ),
            i(this.toolbar, ["only_on_model"]),
            n(this.toolbar, ["fix_up_on", "fix_up_off"], ["Fixed up vector", "Free orbit"], 0, ["only_full_width", "only_on_model"], a=>{
                a === 0 ? this.viewer.SetFixUpVector(!0) : a === 1 && this.viewer.SetFixUpVector(!1)
            }
            ),
            i(this.toolbar, ["only_full_width", "only_on_model"]),
            n(this.toolbar, ["camera_perspective", "camera_orthographic"], ["Perspective camera", "Orthographic camera"], 0, ["only_on_model"], a=>{
                a === 0 ? this.viewer.SetCameraMode(un.Perspective) : a === 1 && this.viewer.SetCameraMode(un.Orthographic),
                this.sidebar.UpdateControlsVisibility()
            }
            ),
            i(this.toolbar, ["only_full_width", "only_on_model"]);
            let o = t(this.toolbar, "measure", "Measure", ["only_full_width", "only_on_model"], a=>{
                dn("measure_tool_activated", a ? "on" : "off"),
                this.navigator.SetSelection(null),
                this.measureTool.SetActive(a)
            }
            );
            this.measureTool.SetButton(o),
            i(this.toolbar, ["only_full_width", "only_on_model"]),
            // e(this.toolbar, "download", "Download", ["only_full_width", "only_on_model"], ()=>{
            //     dn("model_downloaded", "");
            //     let a = this.modelLoaderUI.GetImporter();
            //     Ky(a)
            // }
            // ),
            e(this.toolbar, "export", "Export", ["only_full_width", "only_on_model"], ()=>{
                Yy(this.model, this.viewer, {
                    isMeshVisible: a=>this.navigator.IsMeshVisible(a)
                })
            }
            ),
            // e(this.toolbar, "share", "Share", ["only_full_width", "only_on_model"], ()=>{
            //     $y(s.GetFileList(), this.settings, this.viewer)
            // }
            // ),
            i(this.toolbar, ["only_full_width", "only_on_model"]),
            e(this.toolbar, "snapshot", "Create snapshot", ["only_full_width", "only_on_model"], ()=>{
                Zy(this.viewer)
            }
            ),
            sg(ac.Toolbar, a=>{
                a.registerButtons({
                    createSeparator: l=>{
                        i(this.toolbar, l)
                    }
                    ,
                    createButton: (l,c,u,h)=>{
                        e(this.toolbar, l, c, u, h)
                    }
                    ,
                    getModel: ()=>this.model
                })
            }
            ),
            this.parameters.fileInput.addEventListener("change", a=>{
                a.target.files.length > 0 && (dn("model_load_started", "open_file"),
                this.LoadModelFromFileList(a.target.files))
            }
            )
        }
        InitDragAndDrop() {
            window.addEventListener("dragstart", e=>{
                e.preventDefault()
            }
            , !1),
            window.addEventListener("dragover", e=>{
                e.stopPropagation(),
                e.preventDefault(),
                e.dataTransfer.dropEffect = "copy"
            }
            , !1),
            window.addEventListener("drop", e=>{
                e.stopPropagation(),
                e.preventDefault(),
                Ny(e.dataTransfer, t=>{
                    t.length > 0 && (dn("model_load_started", "drop"),
                    this.LoadModelFromFileList(t))
                }
                )
            }
            , !1)
        }
        InitSidebar() {
            this.sidebar.Init({
                getShadingType: ()=>this.viewer.GetShadingType(),
                getCameraMode: ()=>this.viewer.GetCameraMode(),
                hasDefaultMaterial: ()=>nf(this.model),
                onEnvironmentMapChanged: ()=>{
                    this.settings.SaveToCookies(),
                    this.UpdateEnvironmentMap(),
                    this.measureTool.IsActive() && this.measureTool.UpdatePanel()
                }
                ,
                onBackgroundColorChanged: ()=>{
                    this.settings.SaveToCookies(),
                    this.viewer.SetBackgroundColor(this.settings.backgroundColor),
                    this.measureTool.IsActive() && this.measureTool.UpdatePanel()
                }
                ,
                onDefaultColorChanged: ()=>{
                    this.settings.SaveToCookies();
                    let e = this.modelLoaderUI.GetModelLoader();
                    e.GetDefaultMaterial() !== null && (Qc(this.model, this.settings.defaultColor),
                    e.ReplaceDefaultMaterialColor(this.settings.defaultColor)),
                    this.viewer.Render()
                }
                ,
                onEdgeDisplayChanged: ()=>{
                    dn("edge_display_changed", this.settings.showEdges ? "on" : "off"),
                    this.UpdateEdgeDisplay()
                }
                ,
                onThemeChanged: ()=>{
                    dn("theme_changed", this.settings.themeId === ai.Light ? "light" : "dark"),
                    this.SwitchTheme(this.settings.themeId, !0)
                }
                ,
                onResizeRequested: ()=>{
                    this.layouter.Resize()
                }
                ,
                onShowHidePanels: e=>{
                    It(this.parameters.sidebarSplitterDiv, e),
                    $o("ov_show_sidebar", e)
                }
            })
        }
        InitNavigator() {
            function e(s, o) {
                let a = null;
                return s.EnumerateMeshesUserData(l=>{
                    l.originalMeshInstance.id.IsEqual(o) && (a = l)
                }
                ),
                a
            }
            function t(s, o) {
                let a = [];
                return s.EnumerateMeshesUserData(l=>{
                    (o === null || l.originalMaterials.indexOf(o) !== -1) && a.push(l.originalMeshInstance)
                }
                ),
                a
            }
            function n(s, o) {
                let a = s.GetMaterial(o);
                return {
                    index: o,
                    name: a.name,
                    color: a.color.Clone()
                }
            }
            function i(s, o, a) {
                let l = [];
                if (a === null)
                    for (let c = 0; c < o.MaterialCount(); c++)
                        l.push(n(o, c));
                else {
                    let c = e(s, a);
                    for (let u = 0; u < c.originalMaterials.length; u++) {
                        let h = c.originalMaterials[u];
                        l.push(n(o, h))
                    }
                }
                return l.sort((c,u)=>c.index - u.index),
                l
            }
            this.navigator.Init({
                openFileBrowserDialog: ()=>{
                    this.OpenFileBrowserDialog()
                }
                ,
                fitMeshToWindow: s=>{
                    this.FitMeshToWindow(s)
                }
                ,
                fitMeshesToWindow: s=>{
                    this.FitMeshesToWindow(s)
                }
                ,
                getMeshesForMaterial: s=>t(this.viewer, s),
                getMaterialsForMesh: s=>i(this.viewer, this.model, s),
                onMeshVisibilityChanged: ()=>{
                    this.UpdateMeshesVisibility()
                }
                ,
                onMeshSelectionChanged: ()=>{
                    this.UpdateMeshesSelection()
                }
                ,
                onSelectionCleared: ()=>{
                    this.sidebar.AddObject3DProperties(this.model)
                }
                ,
                onMeshSelected: s=>{
                    let o = this.model.GetMeshInstance(s);
                    this.sidebar.AddObject3DProperties(o)
                }
                ,
                onMaterialSelected: s=>{
                    this.sidebar.AddMaterialProperties(this.model.GetMaterial(s))
                }
                ,
                onResizeRequested: ()=>{
                    this.layouter.Resize()
                }
                ,
                onShowHidePanels: s=>{
                    It(this.parameters.navigatorSplitterDiv, s),
                    $o("ov_show_navigator", s)
                }
            })
        }
        UpdatePanelsVisibility() {
            let e = Jo("ov_show_navigator", !0)
              , t = Jo("ov_show_sidebar", !0);
            this.navigator.ShowPanels(e),
            this.sidebar.ShowPanels(t)
        }
        CreateHeaderButton(e, t, n) {
            let i = Yr("a");
            return i.setAttribute("href", n),
            i.setAttribute("target", "_blank"),
            i.setAttribute("rel", "noopener noreferrer"),
            kf(i, t),
            $n(i, e, "header_button"),
            this.parameters.headerButtonsDiv.appendChild(i),
            i
        }
    }
    ;
    var cg = {};
    mg(cg, {
        AddCoord2D: ()=>bg,
        AddCoord3D: ()=>Gu,
        AddDiv: ()=>Ce,
        AddDomElement: ()=>Jt,
        ArrayBufferToAsciiString: ()=>Bv,
        ArrayBufferToUtf8String: ()=>wn,
        ArrayToCoord3D: ()=>Ns,
        ArrayToQuaternion: ()=>ll,
        ArrayToRGBColor: ()=>Tg,
        AsciiStringToArrayBuffer: ()=>Gv,
        Base64DataURIToArrayBuffer: ()=>qo,
        BezierTweenFunction: ()=>Ay,
        BigEps: ()=>hc,
        BinaryReader: ()=>si,
        BinaryWriter: ()=>wr,
        BoundingBoxCalculator3D: ()=>cl,
        Box3D: ()=>Wo,
        CalculateSurfaceArea: ()=>$f,
        CalculateTriangleNormal: ()=>Ho,
        CalculateVolume: ()=>Eu,
        Camera: ()=>Hi,
        CameraIsEqual3D: ()=>zu,
        CameraMode: ()=>un,
        CameraValidator: ()=>mu,
        CheckModel: ()=>kv,
        ClearDomElement: ()=>Zn,
        ClickDetector: ()=>pu,
        ColorComponentFromFloat: ()=>yn,
        ColorComponentToFloat: ()=>ns,
        ColorToMaterialConverter: ()=>vi,
        ConvertColorToThreeColor: ()=>Xn,
        ConvertMeshToMeshBuffer: ()=>$l,
        ConvertModelToThreeObject: ()=>Df,
        ConvertThreeColorToColor: ()=>Wc,
        ConvertThreeGeometryToMesh: ()=>dr,
        Coord2D: ()=>Pt,
        Coord3D: ()=>ze,
        Coord4D: ()=>Fi,
        CoordDistance2D: ()=>gc,
        CoordDistance3D: ()=>ti,
        CoordIsEqual2D: ()=>ir,
        CoordIsEqual3D: ()=>Ci,
        CopyObjectAttributes: ()=>dl,
        CreateDiv: ()=>Jn,
        CreateDomElement: ()=>Yr,
        CreateModelUrlParameters: ()=>rl,
        CreateObjectUrl: ()=>Ms,
        CreateObjectUrlWithMimeType: ()=>af,
        CreateUrlBuilder: ()=>il,
        CreateUrlParser: ()=>Br,
        CrossVector3D: ()=>nr,
        DegRad: ()=>Cr,
        Direction: ()=>lt,
        DisposeThreeObjects: ()=>Xh,
        DotVector3D: ()=>dc,
        EdgeSettings: ()=>pr,
        EmbeddedViewer: ()=>cc,
        EnvironmentSettings: ()=>Bi,
        Eps: ()=>yg,
        EscapeHtmlChars: ()=>sf,
        EventNotifier: ()=>ud,
        ExportedFile: ()=>tn,
        Exporter: ()=>oc,
        Exporter3dm: ()=>Ql,
        ExporterBase: ()=>Gn,
        ExporterBim: ()=>ec,
        ExporterGltf: ()=>tc,
        ExporterModel: ()=>vo,
        ExporterObj: ()=>nc,
        ExporterOff: ()=>ic,
        ExporterPly: ()=>rc,
        ExporterSettings: ()=>Qo,
        ExporterStl: ()=>sc,
        FaceMaterial: ()=>ua,
        FileFormat: ()=>Dt,
        FileSource: ()=>Di,
        FinalizeModel: ()=>of,
        FlipMeshTrianglesOrientation: ()=>tf,
        GenerateCone: ()=>ag,
        GenerateCuboid: ()=>nx,
        GenerateCylinder: ()=>ix,
        GeneratePlatonicSolid: ()=>sx,
        GenerateSphere: ()=>rx,
        Generator: ()=>yo,
        GeneratorHelper: ()=>lc,
        GeneratorParams: ()=>Ru,
        GetBoundingBox: ()=>Jc,
        GetDefaultCamera: ()=>Lf,
        GetDomElementClientCoordinates: ()=>As,
        GetDomElementExternalHeight: ()=>Cf,
        GetDomElementExternalWidth: ()=>Af,
        GetDomElementInnerDimensions: ()=>If,
        GetDomElementOuterHeight: ()=>Mr,
        GetDomElementOuterWidth: ()=>Ei,
        GetExternalLibPath: ()=>_o,
        GetFileExtension: ()=>Oi,
        GetFileExtensionFromMimeType: ()=>ro,
        GetFileName: ()=>pn,
        GetIntegerFromStyle: ()=>Bn,
        GetMeshType: ()=>io,
        GetShadingType: ()=>Wh,
        GetShadingTypeOfObject: ()=>Um,
        GetTetrahedronSignedVolume: ()=>Km,
        GetTopology: ()=>Vp,
        GetTriangleArea: ()=>Ym,
        HasDefaultMaterial: ()=>nf,
        HasHighpDriverIssue: ()=>Hh,
        HexStringToRGBAColor: ()=>_g,
        HexStringToRGBColor: ()=>xg,
        ImportError: ()=>co,
        ImportErrorCode: ()=>Un,
        ImportResult: ()=>uu,
        ImportSettings: ()=>br,
        Importer: ()=>Ll,
        Importer3dm: ()=>pl,
        Importer3ds: ()=>ml,
        ImporterBase: ()=>Kt,
        ImporterBim: ()=>El,
        ImporterFcstd: ()=>Pl,
        ImporterFile: ()=>Vo,
        ImporterFileAccessor: ()=>hu,
        ImporterFileList: ()=>zo,
        ImporterGltf: ()=>vl,
        ImporterIfc: ()=>yl,
        ImporterObj: ()=>xl,
        ImporterOcct: ()=>bl,
        ImporterOff: ()=>_l,
        ImporterPly: ()=>Tl,
        ImporterStl: ()=>Ml,
        ImporterThree3mf: ()=>Rl,
        ImporterThreeBase: ()=>Xr,
        ImporterThreeDae: ()=>Cl,
        ImporterThreeFbx: ()=>Al,
        ImporterThreeSvg: ()=>hd,
        ImporterThreeWrl: ()=>Il,
        Init3DViewerElements: ()=>ax,
        Init3DViewerFromFileList: ()=>ox,
        Init3DViewerFromUrlList: ()=>lg,
        InputFile: ()=>ol,
        InputFilesFromFileObjects: ()=>al,
        InputFilesFromUrls: ()=>no,
        InsertDomElementAfter: ()=>Rf,
        InsertDomElementBefore: ()=>Cs,
        IntegerToHexString: ()=>Cn,
        IsDefined: ()=>Hr,
        IsDomElementVisible: ()=>Nl,
        IsEqual: ()=>Ot,
        IsEqualEps: ()=>fc,
        IsGreater: ()=>Bu,
        IsGreaterOrEqual: ()=>la,
        IsLower: ()=>oa,
        IsLowerOrEqual: ()=>aa,
        IsModelEmpty: ()=>fl,
        IsNegative: ()=>ts,
        IsObjectEmpty: ()=>rf,
        IsPositive: ()=>zi,
        IsPowerOfTwo: ()=>Hp,
        IsTwoManifold: ()=>$c,
        IsUrl: ()=>Kh,
        IsZero: ()=>To,
        LinearToSRGB: ()=>bo,
        LinearTweenFunction: ()=>Cy,
        LoadExternalLibrary: ()=>Ar,
        MaterialBase: ()=>vc,
        MaterialType: ()=>nn,
        Matrix: ()=>Ut,
        MatrixIsEqual: ()=>ef,
        Mesh: ()=>$t,
        MeshBuffer: ()=>Au,
        MeshInstance: ()=>Ts,
        MeshInstanceId: ()=>gi,
        MeshPrimitiveBuffer: ()=>wu,
        MeshType: ()=>Gr,
        Model: ()=>zr,
        ModelObject3D: ()=>Rr,
        ModelToThreeConversionOutput: ()=>Vl,
        ModelToThreeConversionParams: ()=>Gl,
        MouseInteraction: ()=>fu,
        NameFromLine: ()=>bs,
        Navigation: ()=>kl,
        NavigationType: ()=>oi,
        NextPowerOfTwo: ()=>Uv,
        Node: ()=>Fn,
        Object3D: ()=>yc,
        Octree: ()=>ul,
        OctreeNode: ()=>Xo,
        ParabolicTweenFunction: ()=>Pf,
        ParameterConverter: ()=>Yt,
        ParameterListBuilder: ()=>Xc,
        ParameterListParser: ()=>jc,
        ParametersFromLine: ()=>mr,
        PhongMaterial: ()=>xn,
        PhysicalMaterial: ()=>Os,
        Property: ()=>yt,
        PropertyGroup: ()=>kn,
        PropertyToString: ()=>jo,
        PropertyType: ()=>dt,
        Quaternion: ()=>ri,
        QuaternionFromAxisAngle: ()=>Qh,
        QuaternionFromXYZ: ()=>Dv,
        QuaternionIsEqual: ()=>Nv,
        RGBAColor: ()=>Nn,
        RGBAColorToHexString: ()=>pc,
        RGBColor: ()=>rt,
        RGBColorFromFloatComponents: ()=>Ii,
        RGBColorIsEqual: ()=>is,
        RGBColorToHexString: ()=>ci,
        RadDeg: ()=>Uu,
        ReadFile: ()=>Yh,
        ReadLines: ()=>yi,
        ReplaceDefaultMaterialColor: ()=>Qc,
        RequestUrl: ()=>qh,
        RevokeObjectUrl: ()=>lf,
        RunTaskAsync: ()=>_s,
        RunTasks: ()=>Zh,
        RunTasksBatch: ()=>Jh,
        SRGBToLinear: ()=>Ir,
        SetDomElementHeight: ()=>$i,
        SetDomElementOuterHeight: ()=>Qi,
        SetDomElementOuterWidth: ()=>Ol,
        SetDomElementWidth: ()=>Dl,
        SetExternalLibLocation: ()=>uc,
        SetThreeMeshPolygonOffset: ()=>jh,
        ShadingModel: ()=>Ul,
        ShadingType: ()=>hn,
        ShowDomElement: ()=>It,
        SubCoord2D: ()=>mc,
        SubCoord3D: ()=>vn,
        TaskRunner: ()=>sl,
        TextWriter: ()=>Ai,
        TextureIsEqual: ()=>Mg,
        TextureMap: ()=>ui,
        TextureMapIsEqual: ()=>Ds,
        ThreeColorConverter: ()=>Qa,
        ThreeConversionStateHandler: ()=>vu,
        ThreeLinearToSRGBColorConverter: ()=>el,
        ThreeModelLoader: ()=>uo,
        ThreeNodeTree: ()=>yu,
        ThreeSRGBToLinearColorConverter: ()=>tl,
        Topology: ()=>hl,
        TopologyEdge: ()=>Yc,
        TopologyTriangle: ()=>Zc,
        TopologyTriangleEdge: ()=>Kc,
        TopologyVertex: ()=>qc,
        TouchInteraction: ()=>du,
        TransformFileHostUrls: ()=>to,
        TransformMesh: ()=>Vr,
        Transformation: ()=>en,
        TransformationIsEqual: ()=>Ov,
        TraverseThreeObject: ()=>Nf,
        Triangle: ()=>jt,
        TweenCoord3D: ()=>Fl,
        UpVector: ()=>gu,
        UpdateMaterialTransparency: ()=>xi,
        Utf8StringToArrayBuffer: ()=>gl,
        ValueOrDefault: ()=>Fv,
        VectorAngle3D: ()=>Vu,
        VectorLength3D: ()=>ca,
        Viewer: ()=>Kr,
        ViewerMainModel: ()=>nl,
        ViewerModel: ()=>eo,
        WaitWhile: ()=>$h
    });
    var ud = class {
        constructor() {
            this.eventListeners = new Map
        }
        AddEventListener(e, t) {
            this.eventListeners.has(e) || this.eventListeners.set(e, []),
            this.eventListeners.get(e).push(t)
        }
        HasEventListener(e) {
            return this.eventListeners.has(e)
        }
        GetEventNotifier(e) {
            return ()=>{
                this.NotifyEventListeners(e)
            }
        }
        NotifyEventListeners(e, ...t) {
            if (!this.eventListeners.has(e))
                return;
            let n = this.eventListeners.get(e);
            for (let i of n)
                i(...t)
        }
    }
    ;
    var bA = ct
      , ea = class extends Hn {
        constructor(e) {
            super(e),
            this.defaultDPI = 90,
            this.defaultUnit = "px"
        }
        load(e, t, n, i) {
            let s = this
              , o = new Ni(s.manager);
            o.setPath(s.path),
            o.setRequestHeader(s.requestHeader),
            o.setWithCredentials(s.withCredentials),
            o.load(e, function(a) {
                try {
                    t(s.parse(a))
                } catch (l) {
                    i ? i(l) : console.error(l),
                    s.manager.itemError(e)
                }
            }, n, i)
        }
        parse(e) {
            let t = this;
            function n(w, b) {
                if (w.nodeType !== 1)
                    return;
                let E = _(w)
                  , T = !1
                  , H = null;
                switch (w.nodeName) {
                case "svg":
                    b = g(w, b);
                    break;
                case "style":
                    s(w);
                    break;
                case "g":
                    b = g(w, b);
                    break;
                case "path":
                    b = g(w, b),
                    w.hasAttribute("d") && (H = i(w));
                    break;
                case "rect":
                    b = g(w, b),
                    H = l(w);
                    break;
                case "polygon":
                    b = g(w, b),
                    H = c(w);
                    break;
                case "polyline":
                    b = g(w, b),
                    H = u(w);
                    break;
                case "circle":
                    b = g(w, b),
                    H = h(w);
                    break;
                case "ellipse":
                    b = g(w, b),
                    H = f(w);
                    break;
                case "line":
                    b = g(w, b),
                    H = m(w);
                    break;
                case "defs":
                    T = !0;
                    break;
                case "use":
                    b = g(w, b);
                    let ce = (w.getAttributeNS("http://www.w3.org/1999/xlink", "href") || "").substring(1)
                      , J = w.viewportElement.getElementById(ce);
                    J ? n(J, b) : console.warn("SVGLoader: 'use node' references non-existent node id: " + ce);
                    break;
                default:
                }
                H && (b.fill !== void 0 && b.fill !== "none" && H.color.setStyle(b.fill, bA),
                N(H, re),
                k.push(H),
                H.userData = {
                    node: w,
                    style: b
                });
                let Y = w.childNodes;
                for (let X = 0; X < Y.length; X++) {
                    let ce = Y[X];
                    T && ce.nodeName !== "style" && ce.nodeName !== "defs" || n(ce, b)
                }
                E && (P.pop(),
                P.length > 0 ? re.copy(P[P.length - 1]) : re.identity())
            }
            function i(w) {
                let b = new Ur
                  , E = new Ie
                  , T = new Ie
                  , H = new Ie
                  , Y = !0
                  , X = !1
                  , ce = w.getAttribute("d");
                if (ce === "" || ce === "none")
                    return null;
                let J = ce.match(/[a-df-z][^a-df-z]*/ig);
                for (let ae = 0, ie = J.length; ae < ie; ae++) {
                    let me = J[ae]
                      , ve = me.charAt(0)
                      , be = me.slice(1).trim();
                    Y === !0 && (X = !0,
                    Y = !1);
                    let fe;
                    switch (ve) {
                    case "M":
                        fe = p(be);
                        for (let te = 0, Ee = fe.length; te < Ee; te += 2)
                            E.x = fe[te + 0],
                            E.y = fe[te + 1],
                            T.x = E.x,
                            T.y = E.y,
                            te === 0 ? b.moveTo(E.x, E.y) : b.lineTo(E.x, E.y),
                            te === 0 && H.copy(E);
                        break;
                    case "H":
                        fe = p(be);
                        for (let te = 0, Ee = fe.length; te < Ee; te++)
                            E.x = fe[te],
                            T.x = E.x,
                            T.y = E.y,
                            b.lineTo(E.x, E.y),
                            te === 0 && X === !0 && H.copy(E);
                        break;
                    case "V":
                        fe = p(be);
                        for (let te = 0, Ee = fe.length; te < Ee; te++)
                            E.y = fe[te],
                            T.x = E.x,
                            T.y = E.y,
                            b.lineTo(E.x, E.y),
                            te === 0 && X === !0 && H.copy(E);
                        break;
                    case "L":
                        fe = p(be);
                        for (let te = 0, Ee = fe.length; te < Ee; te += 2)
                            E.x = fe[te + 0],
                            E.y = fe[te + 1],
                            T.x = E.x,
                            T.y = E.y,
                            b.lineTo(E.x, E.y),
                            te === 0 && X === !0 && H.copy(E);
                        break;
                    case "C":
                        fe = p(be);
                        for (let te = 0, Ee = fe.length; te < Ee; te += 6)
                            b.bezierCurveTo(fe[te + 0], fe[te + 1], fe[te + 2], fe[te + 3], fe[te + 4], fe[te + 5]),
                            T.x = fe[te + 2],
                            T.y = fe[te + 3],
                            E.x = fe[te + 4],
                            E.y = fe[te + 5],
                            te === 0 && X === !0 && H.copy(E);
                        break;
                    case "S":
                        fe = p(be);
                        for (let te = 0, Ee = fe.length; te < Ee; te += 4)
                            b.bezierCurveTo(v(E.x, T.x), v(E.y, T.y), fe[te + 0], fe[te + 1], fe[te + 2], fe[te + 3]),
                            T.x = fe[te + 0],
                            T.y = fe[te + 1],
                            E.x = fe[te + 2],
                            E.y = fe[te + 3],
                            te === 0 && X === !0 && H.copy(E);
                        break;
                    case "Q":
                        fe = p(be);
                        for (let te = 0, Ee = fe.length; te < Ee; te += 4)
                            b.quadraticCurveTo(fe[te + 0], fe[te + 1], fe[te + 2], fe[te + 3]),
                            T.x = fe[te + 0],
                            T.y = fe[te + 1],
                            E.x = fe[te + 2],
                            E.y = fe[te + 3],
                            te === 0 && X === !0 && H.copy(E);
                        break;
                    case "T":
                        fe = p(be);
                        for (let te = 0, Ee = fe.length; te < Ee; te += 2) {
                            let Le = v(E.x, T.x)
                              , D = v(E.y, T.y);
                            b.quadraticCurveTo(Le, D, fe[te + 0], fe[te + 1]),
                            T.x = Le,
                            T.y = D,
                            E.x = fe[te + 0],
                            E.y = fe[te + 1],
                            te === 0 && X === !0 && H.copy(E)
                        }
                        break;
                    case "A":
                        fe = p(be, [3, 4], 7);
                        for (let te = 0, Ee = fe.length; te < Ee; te += 7) {
                            if (fe[te + 5] == E.x && fe[te + 6] == E.y)
                                continue;
                            let Le = E.clone();
                            E.x = fe[te + 5],
                            E.y = fe[te + 6],
                            T.x = E.x,
                            T.y = E.y,
                            o(b, fe[te], fe[te + 1], fe[te + 2], fe[te + 3], fe[te + 4], Le, E),
                            te === 0 && X === !0 && H.copy(E)
                        }
                        break;
                    case "m":
                        fe = p(be);
                        for (let te = 0, Ee = fe.length; te < Ee; te += 2)
                            E.x += fe[te + 0],
                            E.y += fe[te + 1],
                            T.x = E.x,
                            T.y = E.y,
                            te === 0 ? b.moveTo(E.x, E.y) : b.lineTo(E.x, E.y),
                            te === 0 && H.copy(E);
                        break;
                    case "h":
                        fe = p(be);
                        for (let te = 0, Ee = fe.length; te < Ee; te++)
                            E.x += fe[te],
                            T.x = E.x,
                            T.y = E.y,
                            b.lineTo(E.x, E.y),
                            te === 0 && X === !0 && H.copy(E);
                        break;
                    case "v":
                        fe = p(be);
                        for (let te = 0, Ee = fe.length; te < Ee; te++)
                            E.y += fe[te],
                            T.x = E.x,
                            T.y = E.y,
                            b.lineTo(E.x, E.y),
                            te === 0 && X === !0 && H.copy(E);
                        break;
                    case "l":
                        fe = p(be);
                        for (let te = 0, Ee = fe.length; te < Ee; te += 2)
                            E.x += fe[te + 0],
                            E.y += fe[te + 1],
                            T.x = E.x,
                            T.y = E.y,
                            b.lineTo(E.x, E.y),
                            te === 0 && X === !0 && H.copy(E);
                        break;
                    case "c":
                        fe = p(be);
                        for (let te = 0, Ee = fe.length; te < Ee; te += 6)
                            b.bezierCurveTo(E.x + fe[te + 0], E.y + fe[te + 1], E.x + fe[te + 2], E.y + fe[te + 3], E.x + fe[te + 4], E.y + fe[te + 5]),
                            T.x = E.x + fe[te + 2],
                            T.y = E.y + fe[te + 3],
                            E.x += fe[te + 4],
                            E.y += fe[te + 5],
                            te === 0 && X === !0 && H.copy(E);
                        break;
                    case "s":
                        fe = p(be);
                        for (let te = 0, Ee = fe.length; te < Ee; te += 4)
                            b.bezierCurveTo(v(E.x, T.x), v(E.y, T.y), E.x + fe[te + 0], E.y + fe[te + 1], E.x + fe[te + 2], E.y + fe[te + 3]),
                            T.x = E.x + fe[te + 0],
                            T.y = E.y + fe[te + 1],
                            E.x += fe[te + 2],
                            E.y += fe[te + 3],
                            te === 0 && X === !0 && H.copy(E);
                        break;
                    case "q":
                        fe = p(be);
                        for (let te = 0, Ee = fe.length; te < Ee; te += 4)
                            b.quadraticCurveTo(E.x + fe[te + 0], E.y + fe[te + 1], E.x + fe[te + 2], E.y + fe[te + 3]),
                            T.x = E.x + fe[te + 0],
                            T.y = E.y + fe[te + 1],
                            E.x += fe[te + 2],
                            E.y += fe[te + 3],
                            te === 0 && X === !0 && H.copy(E);
                        break;
                    case "t":
                        fe = p(be);
                        for (let te = 0, Ee = fe.length; te < Ee; te += 2) {
                            let Le = v(E.x, T.x)
                              , D = v(E.y, T.y);
                            b.quadraticCurveTo(Le, D, E.x + fe[te + 0], E.y + fe[te + 1]),
                            T.x = Le,
                            T.y = D,
                            E.x = E.x + fe[te + 0],
                            E.y = E.y + fe[te + 1],
                            te === 0 && X === !0 && H.copy(E)
                        }
                        break;
                    case "a":
                        fe = p(be, [3, 4], 7);
                        for (let te = 0, Ee = fe.length; te < Ee; te += 7) {
                            if (fe[te + 5] == 0 && fe[te + 6] == 0)
                                continue;
                            let Le = E.clone();
                            E.x += fe[te + 5],
                            E.y += fe[te + 6],
                            T.x = E.x,
                            T.y = E.y,
                            o(b, fe[te], fe[te + 1], fe[te + 2], fe[te + 3], fe[te + 4], Le, E),
                            te === 0 && X === !0 && H.copy(E)
                        }
                        break;
                    case "Z":
                    case "z":
                        b.currentPath.autoClose = !0,
                        b.currentPath.curves.length > 0 && (E.copy(H),
                        b.currentPath.currentPoint.copy(E),
                        Y = !0);
                        break;
                    default:
                        console.warn(me)
                    }
                    X = !1
                }
                return b
            }
            function s(w) {
                if (!(!w.sheet || !w.sheet.cssRules || !w.sheet.cssRules.length))
                    for (let b = 0; b < w.sheet.cssRules.length; b++) {
                        let E = w.sheet.cssRules[b];
                        if (E.type !== 1)
                            continue;
                        let T = E.selectorText.split(/,/gm).filter(Boolean).map(H=>H.trim());
                        for (let H = 0; H < T.length; H++) {
                            let Y = Object.fromEntries(Object.entries(E.style).filter(([,X])=>X !== ""));
                            B[T[H]] = Object.assign(B[T[H]] || {}, Y)
                        }
                    }
            }
            function o(w, b, E, T, H, Y, X, ce) {
                if (b == 0 || E == 0) {
                    w.lineTo(ce.x, ce.y);
                    return
                }
                T = T * Math.PI / 180,
                b = Math.abs(b),
                E = Math.abs(E);
                let J = (X.x - ce.x) / 2
                  , ae = (X.y - ce.y) / 2
                  , ie = Math.cos(T) * J + Math.sin(T) * ae
                  , me = -Math.sin(T) * J + Math.cos(T) * ae
                  , ve = b * b
                  , be = E * E
                  , fe = ie * ie
                  , te = me * me
                  , Ee = fe / ve + te / be;
                if (Ee > 1) {
                    let le = Math.sqrt(Ee);
                    b = le * b,
                    E = le * E,
                    ve = b * b,
                    be = E * E
                }
                let Le = ve * te + be * fe
                  , D = (ve * be - Le) / Le
                  , A = Math.sqrt(Math.max(0, D));
                H === Y && (A = -A);
                let G = A * b * me / E
                  , ne = -A * E * ie / b
                  , Q = Math.cos(T) * G - Math.sin(T) * ne + (X.x + ce.x) / 2
                  , he = Math.sin(T) * G + Math.cos(T) * ne + (X.y + ce.y) / 2
                  , de = a(1, 0, (ie - G) / b, (me - ne) / E)
                  , ge = a((ie - G) / b, (me - ne) / E, (-ie - G) / b, (-me - ne) / E) % (Math.PI * 2);
                w.currentPath.absellipse(Q, he, b, E, de, de + ge, Y === 0, T)
            }
            function a(w, b, E, T) {
                let H = w * E + b * T
                  , Y = Math.sqrt(w * w + b * b) * Math.sqrt(E * E + T * T)
                  , X = Math.acos(Math.max(-1, Math.min(1, H / Y)));
                return w * T - b * E < 0 && (X = -X),
                X
            }
            function l(w) {
                let b = y(w.getAttribute("x") || 0)
                  , E = y(w.getAttribute("y") || 0)
                  , T = y(w.getAttribute("rx") || w.getAttribute("ry") || 0)
                  , H = y(w.getAttribute("ry") || w.getAttribute("rx") || 0)
                  , Y = y(w.getAttribute("width"))
                  , X = y(w.getAttribute("height"))
                  , ce = 1 - .551915024494
                  , J = new Ur;
                return J.moveTo(b + T, E),
                J.lineTo(b + Y - T, E),
                (T !== 0 || H !== 0) && J.bezierCurveTo(b + Y - T * ce, E, b + Y, E + H * ce, b + Y, E + H),
                J.lineTo(b + Y, E + X - H),
                (T !== 0 || H !== 0) && J.bezierCurveTo(b + Y, E + X - H * ce, b + Y - T * ce, E + X, b + Y - T, E + X),
                J.lineTo(b + T, E + X),
                (T !== 0 || H !== 0) && J.bezierCurveTo(b + T * ce, E + X, b, E + X - H * ce, b, E + X - H),
                J.lineTo(b, E + H),
                (T !== 0 || H !== 0) && J.bezierCurveTo(b, E + H * ce, b + T * ce, E, b + T, E),
                J
            }
            function c(w) {
                function b(Y, X, ce) {
                    let J = y(X)
                      , ae = y(ce);
                    H === 0 ? T.moveTo(J, ae) : T.lineTo(J, ae),
                    H++
                }
                let E = /([+-]?\d*\.?\d+(?:e[+-]?\d+)?)(?:,|\s)([+-]?\d*\.?\d+(?:e[+-]?\d+)?)/g
                  , T = new Ur
                  , H = 0;
                return w.getAttribute("points").replace(E, b),
                T.currentPath.autoClose = !0,
                T
            }
            function u(w) {
                function b(Y, X, ce) {
                    let J = y(X)
                      , ae = y(ce);
                    H === 0 ? T.moveTo(J, ae) : T.lineTo(J, ae),
                    H++
                }
                let E = /([+-]?\d*\.?\d+(?:e[+-]?\d+)?)(?:,|\s)([+-]?\d*\.?\d+(?:e[+-]?\d+)?)/g
                  , T = new Ur
                  , H = 0;
                return w.getAttribute("points").replace(E, b),
                T.currentPath.autoClose = !1,
                T
            }
            function h(w) {
                let b = y(w.getAttribute("cx") || 0)
                  , E = y(w.getAttribute("cy") || 0)
                  , T = y(w.getAttribute("r") || 0)
                  , H = new vs;
                H.absarc(b, E, T, 0, Math.PI * 2);
                let Y = new Ur;
                return Y.subPaths.push(H),
                Y
            }
            function f(w) {
                let b = y(w.getAttribute("cx") || 0)
                  , E = y(w.getAttribute("cy") || 0)
                  , T = y(w.getAttribute("rx") || 0)
                  , H = y(w.getAttribute("ry") || 0)
                  , Y = new vs;
                Y.absellipse(b, E, T, H, 0, Math.PI * 2);
                let X = new Ur;
                return X.subPaths.push(Y),
                X
            }
            function m(w) {
                let b = y(w.getAttribute("x1") || 0)
                  , E = y(w.getAttribute("y1") || 0)
                  , T = y(w.getAttribute("x2") || 0)
                  , H = y(w.getAttribute("y2") || 0)
                  , Y = new Ur;
                return Y.moveTo(b, E),
                Y.lineTo(T, H),
                Y.currentPath.autoClose = !1,
                Y
            }
            function g(w, b) {
                b = Object.assign({}, b);
                let E = {};
                if (w.hasAttribute("class")) {
                    let X = w.getAttribute("class").split(/\s/).filter(Boolean).map(ce=>ce.trim());
                    for (let ce = 0; ce < X.length; ce++)
                        E = Object.assign(E, B["." + X[ce]])
                }
                w.hasAttribute("id") && (E = Object.assign(E, B["#" + w.getAttribute("id")]));
                function T(X, ce, J) {
                    J === void 0 && (J = function(ie) {
                        return ie.startsWith("url") && console.warn("SVGLoader: url access in attributes is not implemented."),
                        ie
                    }
                    ),
                    w.hasAttribute(X) && (b[ce] = J(w.getAttribute(X))),
                    E[X] && (b[ce] = J(E[X])),
                    w.style && w.style[X] !== "" && (b[ce] = J(w.style[X]))
                }
                function H(X) {
                    return Math.max(0, Math.min(1, y(X)))
                }
                function Y(X) {
                    return Math.max(0, y(X))
                }
                return T("fill", "fill"),
                T("fill-opacity", "fillOpacity", H),
                T("fill-rule", "fillRule"),
                T("opacity", "opacity", H),
                T("stroke", "stroke"),
                T("stroke-opacity", "strokeOpacity", H),
                T("stroke-width", "strokeWidth", Y),
                T("stroke-linejoin", "strokeLineJoin"),
                T("stroke-linecap", "strokeLineCap"),
                T("stroke-miterlimit", "strokeMiterLimit", Y),
                T("visibility", "visibility"),
                b
            }
            function v(w, b) {
                return w - (b - w)
            }
            function p(w, b, E) {
                if (typeof w != "string")
                    throw new TypeError("Invalid input: " + typeof w);
                let T = {
                    SEPARATOR: /[ \t\r\n\,.\-+]/,
                    WHITESPACE: /[ \t\r\n]/,
                    DIGIT: /[\d]/,
                    SIGN: /[-+]/,
                    POINT: /\./,
                    COMMA: /,/,
                    EXP: /e/i,
                    FLAGS: /[01]/
                }
                  , H = 0
                  , Y = 1
                  , X = 2
                  , ce = 3
                  , J = H
                  , ae = !0
                  , ie = ""
                  , me = ""
                  , ve = [];
                function be(Le, D, A) {
                    let G = new SyntaxError('Unexpected character "' + Le + '" at index ' + D + ".");
                    throw G.partial = A,
                    G
                }
                function fe() {
                    ie !== "" && (me === "" ? ve.push(Number(ie)) : ve.push(Number(ie) * Math.pow(10, Number(me)))),
                    ie = "",
                    me = ""
                }
                let te, Ee = w.length;
                for (let Le = 0; Le < Ee; Le++) {
                    if (te = w[Le],
                    Array.isArray(b) && b.includes(ve.length % E) && T.FLAGS.test(te)) {
                        J = Y,
                        ie = te,
                        fe();
                        continue
                    }
                    if (J === H) {
                        if (T.WHITESPACE.test(te))
                            continue;
                        if (T.DIGIT.test(te) || T.SIGN.test(te)) {
                            J = Y,
                            ie = te;
                            continue
                        }
                        if (T.POINT.test(te)) {
                            J = X,
                            ie = te;
                            continue
                        }
                        T.COMMA.test(te) && (ae && be(te, Le, ve),
                        ae = !0)
                    }
                    if (J === Y) {
                        if (T.DIGIT.test(te)) {
                            ie += te;
                            continue
                        }
                        if (T.POINT.test(te)) {
                            ie += te,
                            J = X;
                            continue
                        }
                        if (T.EXP.test(te)) {
                            J = ce;
                            continue
                        }
                        T.SIGN.test(te) && ie.length === 1 && T.SIGN.test(ie[0]) && be(te, Le, ve)
                    }
                    if (J === X) {
                        if (T.DIGIT.test(te)) {
                            ie += te;
                            continue
                        }
                        if (T.EXP.test(te)) {
                            J = ce;
                            continue
                        }
                        T.POINT.test(te) && ie[ie.length - 1] === "." && be(te, Le, ve)
                    }
                    if (J === ce) {
                        if (T.DIGIT.test(te)) {
                            me += te;
                            continue
                        }
                        if (T.SIGN.test(te)) {
                            if (me === "") {
                                me += te;
                                continue
                            }
                            me.length === 1 && T.SIGN.test(me) && be(te, Le, ve)
                        }
                    }
                    T.WHITESPACE.test(te) ? (fe(),
                    J = H,
                    ae = !1) : T.COMMA.test(te) ? (fe(),
                    J = H,
                    ae = !0) : T.SIGN.test(te) ? (fe(),
                    J = Y,
                    ie = te) : T.POINT.test(te) ? (fe(),
                    J = X,
                    ie = te) : be(te, Le, ve)
                }
                return fe(),
                ve
            }
            let d = ["mm", "cm", "in", "pt", "pc", "px"]
              , x = {
                mm: {
                    mm: 1,
                    cm: .1,
                    in: 1 / 25.4,
                    pt: 72 / 25.4,
                    pc: 6 / 25.4,
                    px: -1
                },
                cm: {
                    mm: 10,
                    cm: 1,
                    in: 1 / 2.54,
                    pt: 72 / 2.54,
                    pc: 6 / 2.54,
                    px: -1
                },
                in: {
                    mm: 25.4,
                    cm: 2.54,
                    in: 1,
                    pt: 72,
                    pc: 6,
                    px: -1
                },
                pt: {
                    mm: 25.4 / 72,
                    cm: 2.54 / 72,
                    in: 1 / 72,
                    pt: 1,
                    pc: 6 / 72,
                    px: -1
                },
                pc: {
                    mm: 25.4 / 6,
                    cm: 2.54 / 6,
                    in: 1 / 6,
                    pt: 72 / 6,
                    pc: 1,
                    px: -1
                },
                px: {
                    px: 1
                }
            };
            function y(w) {
                let b = "px";
                if (typeof w == "string" || w instanceof String)
                    for (let T = 0, H = d.length; T < H; T++) {
                        let Y = d[T];
                        if (w.endsWith(Y)) {
                            b = Y,
                            w = w.substring(0, w.length - Y.length);
                            break
                        }
                    }
                let E;
                return b === "px" && t.defaultUnit !== "px" ? E = x.in[t.defaultUnit] / t.defaultDPI : (E = x[b][t.defaultUnit],
                E < 0 && (E = x[b].in * t.defaultDPI)),
                E * parseFloat(w)
            }
            function _(w) {
                if (!(w.hasAttribute("transform") || w.nodeName === "use" && (w.hasAttribute("x") || w.hasAttribute("y"))))
                    return null;
                let b = S(w);
                return P.length > 0 && b.premultiply(P[P.length - 1]),
                re.copy(b),
                P.push(b),
                b
            }
            function S(w) {
                let b = new vt
                  , E = C;
                if (w.nodeName === "use" && (w.hasAttribute("x") || w.hasAttribute("y"))) {
                    let T = y(w.getAttribute("x"))
                      , H = y(w.getAttribute("y"));
                    b.translate(T, H)
                }
                if (w.hasAttribute("transform")) {
                    let T = w.getAttribute("transform").split(")");
                    for (let H = T.length - 1; H >= 0; H--) {
                        let Y = T[H].trim();
                        if (Y === "")
                            continue;
                        let X = Y.indexOf("(")
                          , ce = Y.length;
                        if (X > 0 && X < ce) {
                            let J = Y.slice(0, X)
                              , ae = p(Y.slice(X + 1));
                            switch (E.identity(),
                            J) {
                            case "translate":
                                if (ae.length >= 1) {
                                    let ie = ae[0]
                                      , me = 0;
                                    ae.length >= 2 && (me = ae[1]),
                                    E.translate(ie, me)
                                }
                                break;
                            case "rotate":
                                if (ae.length >= 1) {
                                    let ie = 0
                                      , me = 0
                                      , ve = 0;
                                    ie = ae[0] * Math.PI / 180,
                                    ae.length >= 3 && (me = ae[1],
                                    ve = ae[2]),
                                    L.makeTranslation(-me, -ve),
                                    F.makeRotation(ie),
                                    U.multiplyMatrices(F, L),
                                    L.makeTranslation(me, ve),
                                    E.multiplyMatrices(L, U)
                                }
                                break;
                            case "scale":
                                if (ae.length >= 1) {
                                    let ie = ae[0]
                                      , me = ie;
                                    ae.length >= 2 && (me = ae[1]),
                                    E.scale(ie, me)
                                }
                                break;
                            case "skewX":
                                ae.length === 1 && E.set(1, Math.tan(ae[0] * Math.PI / 180), 0, 0, 1, 0, 0, 0, 1);
                                break;
                            case "skewY":
                                ae.length === 1 && E.set(1, 0, 0, Math.tan(ae[0] * Math.PI / 180), 1, 0, 0, 0, 1);
                                break;
                            case "matrix":
                                ae.length === 6 && E.set(ae[0], ae[2], ae[4], ae[1], ae[3], ae[5], 0, 0, 1);
                                break
                            }
                        }
                        b.premultiply(E)
                    }
                }
                return b
            }
            function N(w, b) {
                function E(X) {
                    K.set(X.x, X.y, 1).applyMatrix3(b),
                    X.set(K.x, K.y)
                }
                function T(X) {
                    let ce = X.xRadius
                      , J = X.yRadius
                      , ae = Math.cos(X.aRotation)
                      , ie = Math.sin(X.aRotation)
                      , me = new ue(ce * ae,ce * ie,0)
                      , ve = new ue(-J * ie,J * ae,0)
                      , be = me.applyMatrix3(b)
                      , fe = ve.applyMatrix3(b)
                      , te = C.set(be.x, fe.x, 0, be.y, fe.y, 0, 0, 0, 1)
                      , Ee = L.copy(te).invert()
                      , A = F.copy(Ee).transpose().multiply(Ee).elements
                      , G = q(A[0], A[1], A[4])
                      , ne = Math.sqrt(G.rt1)
                      , Q = Math.sqrt(G.rt2);
                    if (X.xRadius = 1 / ne,
                    X.yRadius = 1 / Q,
                    X.aRotation = Math.atan2(G.sn, G.cs),
                    !((X.aEndAngle - X.aStartAngle) % (2 * Math.PI) < Number.EPSILON)) {
                        let de = L.set(ne, 0, 0, 0, Q, 0, 0, 0, 1)
                          , ge = F.set(G.cs, G.sn, 0, -G.sn, G.cs, 0, 0, 0, 1)
                          , le = de.multiply(ge).multiply(te)
                          , xe = Me=>{
                            let {x: Ne, y: De} = new ue(Math.cos(Me),Math.sin(Me),0).applyMatrix3(le);
                            return Math.atan2(De, Ne)
                        }
                        ;
                        X.aStartAngle = xe(X.aStartAngle),
                        X.aEndAngle = xe(X.aEndAngle),
                        I(b) && (X.aClockwise = !X.aClockwise)
                    }
                }
                function H(X) {
                    let ce = M(b)
                      , J = R(b);
                    X.xRadius *= ce,
                    X.yRadius *= J;
                    let ae = ce > Number.EPSILON ? Math.atan2(b.elements[1], b.elements[0]) : Math.atan2(-b.elements[3], b.elements[4]);
                    X.aRotation += ae,
                    I(b) && (X.aStartAngle *= -1,
                    X.aEndAngle *= -1,
                    X.aClockwise = !X.aClockwise)
                }
                let Y = w.subPaths;
                for (let X = 0, ce = Y.length; X < ce; X++) {
                    let ae = Y[X].curves;
                    for (let ie = 0; ie < ae.length; ie++) {
                        let me = ae[ie];
                        me.isLineCurve ? (E(me.v1),
                        E(me.v2)) : me.isCubicBezierCurve ? (E(me.v0),
                        E(me.v1),
                        E(me.v2),
                        E(me.v3)) : me.isQuadraticBezierCurve ? (E(me.v0),
                        E(me.v1),
                        E(me.v2)) : me.isEllipseCurve && (W.set(me.aX, me.aY),
                        E(W),
                        me.aX = W.x,
                        me.aY = W.y,
                        O(b) ? T(me) : H(me))
                    }
                }
            }
            function I(w) {
                let b = w.elements;
                return b[0] * b[4] - b[1] * b[3] < 0
            }
            function O(w) {
                let b = w.elements
                  , E = b[0] * b[3] + b[1] * b[4];
                if (E === 0)
                    return !1;
                let T = M(w)
                  , H = R(w);
                return Math.abs(E / (T * H)) > Number.EPSILON
            }
            function M(w) {
                let b = w.elements;
                return Math.sqrt(b[0] * b[0] + b[1] * b[1])
            }
            function R(w) {
                let b = w.elements;
                return Math.sqrt(b[3] * b[3] + b[4] * b[4])
            }
            function q(w, b, E) {
                let T, H, Y, X, ce, J = w + E, ae = w - E, ie = Math.sqrt(ae * ae + 4 * b * b);
                return J > 0 ? (T = .5 * (J + ie),
                ce = 1 / T,
                H = w * ce * E - b * ce * b) : J < 0 ? H = .5 * (J - ie) : (T = .5 * ie,
                H = -.5 * ie),
                ae > 0 ? Y = ae + ie : Y = ae - ie,
                Math.abs(Y) > 2 * Math.abs(b) ? (ce = -2 * b / Y,
                X = 1 / Math.sqrt(1 + ce * ce),
                Y = ce * X) : Math.abs(b) === 0 ? (Y = 1,
                X = 0) : (ce = -.5 * Y / b,
                Y = 1 / Math.sqrt(1 + ce * ce),
                X = ce * Y),
                ae > 0 && (ce = Y,
                Y = -X,
                X = ce),
                {
                    rt1: T,
                    rt2: H,
                    cs: Y,
                    sn: X
                }
            }
            let k = []
              , B = {}
              , P = []
              , C = new vt
              , L = new vt
              , F = new vt
              , U = new vt
              , W = new Ie
              , K = new ue
              , re = new vt
              , oe = new DOMParser().parseFromString(e, "image/svg+xml");
            return n(oe.documentElement, {
                fill: "#000",
                fillOpacity: 1,
                strokeOpacity: 1,
                strokeWidth: 1,
                strokeLineJoin: "miter",
                strokeLineCap: "butt",
                strokeMiterLimit: 4
            }),
            {
                paths: k,
                xml: oe.documentElement
            }
        }
        static createShapes(e) {
            let n = {
                ORIGIN: 0,
                DESTINATION: 1,
                BETWEEN: 2,
                LEFT: 3,
                RIGHT: 4,
                BEHIND: 5,
                BEYOND: 6
            }
              , i = {
                loc: n.ORIGIN,
                t: 0
            };
            function s(v, p, d, x) {
                let y = v.x
                  , _ = p.x
                  , S = d.x
                  , N = x.x
                  , I = v.y
                  , O = p.y
                  , M = d.y
                  , R = x.y
                  , q = (N - S) * (I - M) - (R - M) * (y - S)
                  , k = (_ - y) * (I - M) - (O - I) * (y - S)
                  , B = (R - M) * (_ - y) - (N - S) * (O - I)
                  , P = q / B
                  , C = k / B;
                if (B === 0 && q !== 0 || P <= 0 || P >= 1 || C < 0 || C > 1)
                    return null;
                if (q === 0 && B === 0) {
                    for (let L = 0; L < 2; L++)
                        if (o(L === 0 ? d : x, v, p),
                        i.loc == n.ORIGIN) {
                            let F = L === 0 ? d : x;
                            return {
                                x: F.x,
                                y: F.y,
                                t: i.t
                            }
                        } else if (i.loc == n.BETWEEN) {
                            let F = +(y + i.t * (_ - y)).toPrecision(10)
                              , U = +(I + i.t * (O - I)).toPrecision(10);
                            return {
                                x: F,
                                y: U,
                                t: i.t
                            }
                        }
                    return null
                } else {
                    for (let U = 0; U < 2; U++)
                        if (o(U === 0 ? d : x, v, p),
                        i.loc == n.ORIGIN) {
                            let W = U === 0 ? d : x;
                            return {
                                x: W.x,
                                y: W.y,
                                t: i.t
                            }
                        }
                    let L = +(y + P * (_ - y)).toPrecision(10)
                      , F = +(I + P * (O - I)).toPrecision(10);
                    return {
                        x: L,
                        y: F,
                        t: P
                    }
                }
            }
            function o(v, p, d) {
                let x = d.x - p.x
                  , y = d.y - p.y
                  , _ = v.x - p.x
                  , S = v.y - p.y
                  , N = x * S - _ * y;
                if (v.x === p.x && v.y === p.y) {
                    i.loc = n.ORIGIN,
                    i.t = 0;
                    return
                }
                if (v.x === d.x && v.y === d.y) {
                    i.loc = n.DESTINATION,
                    i.t = 1;
                    return
                }
                if (N < -Number.EPSILON) {
                    i.loc = n.LEFT;
                    return
                }
                if (N > Number.EPSILON) {
                    i.loc = n.RIGHT;
                    return
                }
                if (x * _ < 0 || y * S < 0) {
                    i.loc = n.BEHIND;
                    return
                }
                if (Math.sqrt(x * x + y * y) < Math.sqrt(_ * _ + S * S)) {
                    i.loc = n.BEYOND;
                    return
                }
                let I;
                x !== 0 ? I = _ / x : I = S / y,
                i.loc = n.BETWEEN,
                i.t = I
            }
            function a(v, p) {
                let d = []
                  , x = [];
                for (let y = 1; y < v.length; y++) {
                    let _ = v[y - 1]
                      , S = v[y];
                    for (let N = 1; N < p.length; N++) {
                        let I = p[N - 1]
                          , O = p[N]
                          , M = s(_, S, I, O);
                        M !== null && d.find(R=>R.t <= M.t + Number.EPSILON && R.t >= M.t - Number.EPSILON) === void 0 && (d.push(M),
                        x.push(new Ie(M.x,M.y)))
                    }
                }
                return x
            }
            function l(v, p, d) {
                let x = new Ie;
                p.getCenter(x);
                let y = [];
                return d.forEach(_=>{
                    _.boundingBox.containsPoint(x) && a(v, _.points).forEach(N=>{
                        y.push({
                            identifier: _.identifier,
                            isCW: _.isCW,
                            point: N
                        })
                    }
                    )
                }
                ),
                y.sort((_,S)=>_.point.x - S.point.x),
                y
            }
            function c(v, p, d, x, y) {
                (y == null || y === "") && (y = "nonzero");
                let _ = new Ie;
                v.boundingBox.getCenter(_);
                let S = [new Ie(d,_.y), new Ie(x,_.y)]
                  , N = l(S, v.boundingBox, p);
                N.sort((k,B)=>k.point.x - B.point.x);
                let I = []
                  , O = [];
                N.forEach(k=>{
                    k.identifier === v.identifier ? I.push(k) : O.push(k)
                }
                );
                let M = I[0].point.x
                  , R = []
                  , q = 0;
                for (; q < O.length && O[q].point.x < M; )
                    R.length > 0 && R[R.length - 1] === O[q].identifier ? R.pop() : R.push(O[q].identifier),
                    q++;
                if (R.push(v.identifier),
                y === "evenodd") {
                    let k = R.length % 2 === 0
                      , B = R[R.length - 2];
                    return {
                        identifier: v.identifier,
                        isHole: k,
                        for: B
                    }
                } else if (y === "nonzero") {
                    let k = !0
                      , B = null
                      , P = null;
                    for (let C = 0; C < R.length; C++) {
                        let L = R[C];
                        k ? (P = p[L].isCW,
                        k = !1,
                        B = L) : P !== p[L].isCW && (P = p[L].isCW,
                        k = !0)
                    }
                    return {
                        identifier: v.identifier,
                        isHole: k,
                        for: B
                    }
                } else
                    console.warn('fill-rule: "' + y + '" is currently not implemented.')
            }
            let u = 999999999
              , h = -999999999
              , f = e.subPaths.map(v=>{
                let p = v.getPoints()
                  , d = -999999999
                  , x = 999999999
                  , y = -999999999
                  , _ = 999999999;
                for (let S = 0; S < p.length; S++) {
                    let N = p[S];
                    N.y > d && (d = N.y),
                    N.y < x && (x = N.y),
                    N.x > y && (y = N.x),
                    N.x < _ && (_ = N.x)
                }
                return h <= y && (h = y + 1),
                u >= _ && (u = _ - 1),
                {
                    curves: v.curves,
                    points: p,
                    isCW: ji.isClockWise(p),
                    identifier: -1,
                    boundingBox: new kh(new Ie(_,x),new Ie(y,d))
                }
            }
            );
            f = f.filter(v=>v.points.length > 1);
            for (let v = 0; v < f.length; v++)
                f[v].identifier = v;
            let m = f.map(v=>c(v, f, u, h, e.userData ? e.userData.style.fillRule : void 0))
              , g = [];
            return f.forEach(v=>{
                if (!m[v.identifier].isHole) {
                    let d = new Hs;
                    d.curves = v.curves,
                    m.filter(y=>y.isHole && y.for === v.identifier).forEach(y=>{
                        let _ = f[y.identifier]
                          , S = new vs;
                        S.curves = _.curves,
                        d.holes.push(S)
                    }
                    ),
                    g.push(d)
                }
            }
            ),
            g
        }
        static getStrokeStyle(e, t, n, i, s) {
            return e = e !== void 0 ? e : 1,
            t = t !== void 0 ? t : "#000",
            n = n !== void 0 ? n : "miter",
            i = i !== void 0 ? i : "butt",
            s = s !== void 0 ? s : 4,
            {
                strokeColor: t,
                strokeWidth: e,
                strokeLineJoin: n,
                strokeLineCap: i,
                strokeMiterLimit: s
            }
        }
        static pointsToStroke(e, t, n, i) {
            let s = []
              , o = []
              , a = [];
            if (ea.pointsToStrokeWithBuffers(e, t, n, i, s, o, a) === 0)
                return null;
            let l = new wt;
            return l.setAttribute("position", new qe(s,3)),
            l.setAttribute("normal", new qe(o,3)),
            l.setAttribute("uv", new qe(a,2)),
            l
        }
        static pointsToStrokeWithBuffers(e, t, n, i, s, o, a, l) {
            let c = new Ie
              , u = new Ie
              , h = new Ie
              , f = new Ie
              , m = new Ie
              , g = new Ie
              , v = new Ie
              , p = new Ie
              , d = new Ie
              , x = new Ie
              , y = new Ie
              , _ = new Ie
              , S = new Ie
              , N = new Ie
              , I = new Ie
              , O = new Ie
              , M = new Ie;
            n = n !== void 0 ? n : 12,
            i = i !== void 0 ? i : .001,
            l = l !== void 0 ? l : 0,
            e = ae(e);
            let R = e.length;
            if (R < 2)
                return 0;
            let q = e[0].equals(e[R - 1]), k, B = e[0], P, C = t.strokeWidth / 2, L = 1 / (R - 1), F = 0, U, W, K, re, oe = !1, j = 0, w = l * 3, b = l * 2;
            E(e[0], e[1], c).multiplyScalar(C),
            p.copy(e[0]).sub(c),
            d.copy(e[0]).add(c),
            x.copy(p),
            y.copy(d);
            for (let ie = 1; ie < R; ie++) {
                k = e[ie],
                ie === R - 1 ? q ? P = e[1] : P = void 0 : P = e[ie + 1];
                let me = c;
                if (E(B, k, me),
                h.copy(me).multiplyScalar(C),
                _.copy(k).sub(h),
                S.copy(k).add(h),
                U = F + L,
                W = !1,
                P !== void 0) {
                    E(k, P, u),
                    h.copy(u).multiplyScalar(C),
                    N.copy(k).sub(h),
                    I.copy(k).add(h),
                    K = !0,
                    h.subVectors(P, B),
                    me.dot(h) < 0 && (K = !1),
                    ie === 1 && (oe = K),
                    h.subVectors(P, k),
                    h.normalize();
                    let ve = Math.abs(me.dot(h));
                    if (ve > Number.EPSILON) {
                        let be = C / ve;
                        h.multiplyScalar(-be),
                        f.subVectors(k, B),
                        m.copy(f).setLength(be).add(h),
                        O.copy(m).negate();
                        let fe = m.length()
                          , te = f.length();
                        f.divideScalar(te),
                        g.subVectors(P, k);
                        let Ee = g.length();
                        switch (g.divideScalar(Ee),
                        f.dot(O) < te && g.dot(O) < Ee && (W = !0),
                        M.copy(m).add(k),
                        O.add(k),
                        re = !1,
                        W ? K ? (I.copy(O),
                        S.copy(O)) : (N.copy(O),
                        _.copy(O)) : Y(),
                        t.strokeLineJoin) {
                        case "bevel":
                            X(K, W, U);
                            break;
                        case "round":
                            ce(K, W),
                            K ? H(k, _, N, U, 0) : H(k, I, S, U, 1);
                            break;
                        case "miter":
                        case "miter-clip":
                        default:
                            let Le = C * t.strokeMiterLimit / fe;
                            if (Le < 1)
                                if (t.strokeLineJoin !== "miter-clip") {
                                    X(K, W, U);
                                    break
                                } else
                                    ce(K, W),
                                    K ? (g.subVectors(M, _).multiplyScalar(Le).add(_),
                                    v.subVectors(M, N).multiplyScalar(Le).add(N),
                                    T(_, U, 0),
                                    T(g, U, 0),
                                    T(k, U, .5),
                                    T(k, U, .5),
                                    T(g, U, 0),
                                    T(v, U, 0),
                                    T(k, U, .5),
                                    T(v, U, 0),
                                    T(N, U, 0)) : (g.subVectors(M, S).multiplyScalar(Le).add(S),
                                    v.subVectors(M, I).multiplyScalar(Le).add(I),
                                    T(S, U, 1),
                                    T(g, U, 1),
                                    T(k, U, .5),
                                    T(k, U, .5),
                                    T(g, U, 1),
                                    T(v, U, 1),
                                    T(k, U, .5),
                                    T(v, U, 1),
                                    T(I, U, 1));
                            else
                                W ? (K ? (T(d, F, 1),
                                T(p, F, 0),
                                T(M, U, 0),
                                T(d, F, 1),
                                T(M, U, 0),
                                T(O, U, 1)) : (T(d, F, 1),
                                T(p, F, 0),
                                T(M, U, 1),
                                T(p, F, 0),
                                T(O, U, 0),
                                T(M, U, 1)),
                                K ? N.copy(M) : I.copy(M)) : K ? (T(_, U, 0),
                                T(M, U, 0),
                                T(k, U, .5),
                                T(k, U, .5),
                                T(M, U, 0),
                                T(N, U, 0)) : (T(S, U, 1),
                                T(M, U, 1),
                                T(k, U, .5),
                                T(k, U, .5),
                                T(M, U, 1),
                                T(I, U, 1)),
                                re = !0;
                            break
                        }
                    } else
                        Y()
                } else
                    Y();
                !q && ie === R - 1 && J(e[0], x, y, K, !0, F),
                F = U,
                B = k,
                p.copy(N),
                d.copy(I)
            }
            if (!q)
                J(k, _, S, K, !1, U);
            else if (W && s) {
                let ie = M
                  , me = O;
                oe !== K && (ie = O,
                me = M),
                K ? (re || oe) && (me.toArray(s, 0 * 3),
                me.toArray(s, 3 * 3),
                re && ie.toArray(s, 1 * 3)) : (re || !oe) && (me.toArray(s, 1 * 3),
                me.toArray(s, 3 * 3),
                re && ie.toArray(s, 0 * 3))
            }
            return j;
            function E(ie, me, ve) {
                return ve.subVectors(me, ie),
                ve.set(-ve.y, ve.x).normalize()
            }
            function T(ie, me, ve) {
                s && (s[w] = ie.x,
                s[w + 1] = ie.y,
                s[w + 2] = 0,
                o && (o[w] = 0,
                o[w + 1] = 0,
                o[w + 2] = 1),
                w += 3,
                a && (a[b] = me,
                a[b + 1] = ve,
                b += 2)),
                j += 3
            }
            function H(ie, me, ve, be, fe) {
                c.copy(me).sub(ie).normalize(),
                u.copy(ve).sub(ie).normalize();
                let te = Math.PI
                  , Ee = c.dot(u);
                Math.abs(Ee) < 1 && (te = Math.abs(Math.acos(Ee))),
                te /= n,
                h.copy(me);
                for (let Le = 0, D = n - 1; Le < D; Le++)
                    f.copy(h).rotateAround(ie, te),
                    T(h, be, fe),
                    T(f, be, fe),
                    T(ie, be, .5),
                    h.copy(f);
                T(f, be, fe),
                T(ve, be, fe),
                T(ie, be, .5)
            }
            function Y() {
                T(d, F, 1),
                T(p, F, 0),
                T(_, U, 0),
                T(d, F, 1),
                T(_, U, 1),
                T(S, U, 0)
            }
            function X(ie, me, ve) {
                me ? ie ? (T(d, F, 1),
                T(p, F, 0),
                T(_, U, 0),
                T(d, F, 1),
                T(_, U, 0),
                T(O, U, 1),
                T(_, ve, 0),
                T(N, ve, 0),
                T(O, ve, .5)) : (T(d, F, 1),
                T(p, F, 0),
                T(S, U, 1),
                T(p, F, 0),
                T(O, U, 0),
                T(S, U, 1),
                T(S, ve, 1),
                T(I, ve, 0),
                T(O, ve, .5)) : ie ? (T(_, ve, 0),
                T(N, ve, 0),
                T(k, ve, .5)) : (T(S, ve, 1),
                T(I, ve, 0),
                T(k, ve, .5))
            }
            function ce(ie, me) {
                me && (ie ? (T(d, F, 1),
                T(p, F, 0),
                T(_, U, 0),
                T(d, F, 1),
                T(_, U, 0),
                T(O, U, 1),
                T(_, F, 0),
                T(k, U, .5),
                T(O, U, 1),
                T(k, U, .5),
                T(N, F, 0),
                T(O, U, 1)) : (T(d, F, 1),
                T(p, F, 0),
                T(S, U, 1),
                T(p, F, 0),
                T(O, U, 0),
                T(S, U, 1),
                T(S, F, 1),
                T(O, U, 0),
                T(k, U, .5),
                T(k, U, .5),
                T(O, U, 0),
                T(I, F, 1)))
            }
            function J(ie, me, ve, be, fe, te) {
                switch (t.strokeLineCap) {
                case "round":
                    fe ? H(ie, ve, me, te, .5) : H(ie, me, ve, te, .5);
                    break;
                case "square":
                    if (fe)
                        c.subVectors(me, ie),
                        u.set(c.y, -c.x),
                        h.addVectors(c, u).add(ie),
                        f.subVectors(u, c).add(ie),
                        be ? (h.toArray(s, 1 * 3),
                        f.toArray(s, 0 * 3),
                        f.toArray(s, 3 * 3)) : (h.toArray(s, 1 * 3),
                        h.toArray(s, 3 * 3),
                        f.toArray(s, 0 * 3));
                    else {
                        c.subVectors(ve, ie),
                        u.set(c.y, -c.x),
                        h.addVectors(c, u).add(ie),
                        f.subVectors(u, c).add(ie);
                        let Ee = s.length;
                        be ? (h.toArray(s, Ee - 1 * 3),
                        f.toArray(s, Ee - 2 * 3),
                        f.toArray(s, Ee - 4 * 3)) : (h.toArray(s, Ee - 2 * 3),
                        f.toArray(s, Ee - 1 * 3),
                        f.toArray(s, Ee - 4 * 3))
                    }
                    break;
                case "butt":
                default:
                    break
                }
            }
            function ae(ie) {
                let me = !1;
                for (let be = 1, fe = ie.length - 1; be < fe; be++)
                    if (ie[be].distanceTo(ie[be + 1]) < i) {
                        me = !0;
                        break
                    }
                if (!me)
                    return ie;
                let ve = [];
                ve.push(ie[0]);
                for (let be = 1, fe = ie.length - 1; be < fe; be++)
                    ie[be].distanceTo(ie[be + 1]) >= i && ve.push(ie[be]);
                return ve.push(ie[ie.length - 1]),
                ve
            }
        }
    }
    ;
    var hd = class extends Xr {
        constructor() {
            super()
        }
        CanImportExtension(e) {
            return e === "svg"
        }
        GetUpDirection() {
            return lt.Z
        }
        CreateLoader(e) {
            return new ea(e)
        }
        GetMainObject(e) {
            function t(o) {
                let a = o.userData.style;
                return !(a.fill === void 0 || a.fill === "none")
            }
            function n(o, a, l) {
                let c = null;
                for (let u of o)
                    if (u.style === a && u.opacity === l) {
                        c = u.material;
                        break
                    }
                return c === null && (c = new sn({
                    color: new $e().setStyle(a),
                    opacity: l,
                    transparent: l < 1
                }),
                o.push({
                    style: a,
                    opacity: l,
                    material: c
                })),
                c
            }
            let i = []
              , s = new bt;
            s.rotation.x = Math.PI;
            for (let o of e.paths) {
                let a = ea.createShapes(o);
                if (t(o)) {
                    let l = o.userData.style
                      , c = n(i, l.fill, l.opacity);
                    for (let u of a) {
                        let h = new qa(u,{
                            depth: 10,
                            bevelEnabled: !1
                        })
                          , f = new Ht(h,c);
                        f.name = o.userData.node.id,
                        s.add(f)
                    }
                }
            }
            return s
        }
    }
    ;
    var Ru = class {
        constructor() {
            this.name = null,
            this.material = null
        }
        SetName(e) {
            return this.name = e,
            this
        }
        SetMaterial(e) {
            return this.material = e,
            this
        }
    }
      , yo = class {
        constructor(e) {
            this.params = e || new Ru,
            this.mesh = new $t,
            this.params.name !== null && this.mesh.SetName(this.params.name),
            this.curve = null
        }
        GetMesh() {
            return this.mesh
        }
        AddVertex(e, t, n) {
            let i = new ze(e,t,n);
            return this.mesh.AddVertex(i)
        }
        AddVertices(e) {
            let t = [];
            for (let n = 0; n < e.length; n++) {
                let i = e[n];
                t.push(this.AddVertex(i.x, i.y, i.z))
            }
            return t
        }
        SetCurve(e) {
            this.curve = e
        }
        ResetCurve() {
            this.curve = null
        }
        AddTriangle(e, t, n) {
            let i = new jt(e,t,n);
            return this.params.material !== null && (i.mat = this.params.material),
            this.curve !== null && i.SetCurve(this.curve),
            this.mesh.AddTriangle(i)
        }
        AddTriangleInverted(e, t, n) {
            this.AddTriangle(e, n, t)
        }
        AddConvexPolygon(e) {
            for (let t = 0; t < e.length - 2; t++)
                this.AddTriangle(e[0], e[t + 1], e[t + 2])
        }
        AddConvexPolygonInverted(e) {
            for (let t = 0; t < e.length - 2; t++)
                this.AddTriangleInverted(e[0], e[t + 1], e[t + 2])
        }
    }
      , lc = class {
        constructor(e) {
            this.generator = e
        }
        GenerateSurfaceBetweenPolygons(e, t) {
            if (e.length !== t.length)
                return;
            let n = e.length;
            for (let i = 0; i < n; i++) {
                let s = i
                  , o = i < n - 1 ? s + 1 : 0;
                this.generator.AddConvexPolygon([e[s], e[o], t[o], t[s]])
            }
        }
        GenerateTriangleFan(e, t) {
            let n = e.length;
            for (let i = 0; i < n; i++) {
                let s = i
                  , o = i < n - 1 ? s + 1 : 0;
                this.generator.AddTriangle(t, e[s], e[o])
            }
        }
    }
    ;
    function tx(r, e) {
        return new Pt(r * Math.cos(e),r * Math.sin(e))
    }
    function nx(r, e, t, n) {
        if (!zi(e) || !zi(t) || !zi(n))
            return null;
        let i = new yo(r);
        return i.AddVertex(0, 0, 0),
        i.AddVertex(e, 0, 0),
        i.AddVertex(e, t, 0),
        i.AddVertex(0, t, 0),
        i.AddVertex(0, 0, n),
        i.AddVertex(e, 0, n),
        i.AddVertex(e, t, n),
        i.AddVertex(0, t, n),
        i.AddConvexPolygon([0, 3, 2, 1]),
        i.AddConvexPolygon([0, 1, 5, 4]),
        i.AddConvexPolygon([1, 2, 6, 5]),
        i.AddConvexPolygon([2, 3, 7, 6]),
        i.AddConvexPolygon([3, 0, 4, 7]),
        i.AddConvexPolygon([4, 5, 6, 7]),
        i.GetMesh()
    }
    function ag(r, e, t, n, i, s) {
        if (ts(e) || ts(t) || !zi(n) || i < 3)
            return null;
        let o = To(e)
          , a = To(t);
        if (o && a)
            return null;
        let l = new yo(r)
          , c = new lc(l)
          , u = 2 * Math.PI / i
          , h = s ? 1 : null
          , f = [];
        if (o)
            f.push(l.AddVertex(0, 0, n));
        else
            for (let g = 0; g < i; g++) {
                let v = tx(e, g * u);
                f.push(l.AddVertex(v.x, v.y, n))
            }
        let m = [];
        if (a)
            m.push(l.AddVertex(0, 0, 0));
        else
            for (let g = 0; g < i; g++) {
                let v = tx(t, g * u);
                m.push(l.AddVertex(v.x, v.y, 0))
            }
        return o ? (l.SetCurve(h),
        c.GenerateTriangleFan(m, f[0]),
        l.ResetCurve(),
        l.AddConvexPolygonInverted(m)) : a ? (l.SetCurve(h),
        c.GenerateTriangleFan(f.slice().reverse(), m[0]),
        l.ResetCurve(),
        l.AddConvexPolygon(f)) : (l.SetCurve(h),
        c.GenerateSurfaceBetweenPolygons(m, f),
        l.ResetCurve(),
        l.AddConvexPolygonInverted(m),
        l.AddConvexPolygon(f)),
        l.GetMesh()
    }
    function ix(r, e, t, n, i) {
        return ag(r, e, e, t, n, i)
    }
    function rx(r, e, t, n) {
        function i(m, g, v) {
            return new ze(m * Math.sin(g) * Math.cos(v),m * Math.sin(g) * Math.sin(v),m * Math.cos(g))
        }
        if (!zi(e) || t < 3)
            return null;
        let s = new yo(r)
          , o = new lc(s);
        s.SetCurve(n ? 1 : null);
        let a = []
          , l = t + 1
          , c = Math.PI / t
          , u = 2 * Math.PI / t;
        for (let m = 1; m < l - 1; m++) {
            let g = []
              , v = m * c;
            for (let p = 0; p < t; p++) {
                let d = p * u
                  , x = i(e, v, -d);
                g.push(s.AddVertex(x.x, x.y, x.z))
            }
            m > 1 && o.GenerateSurfaceBetweenPolygons(a[a.length - 1], g),
            a.push(g)
        }
        let h = s.AddVertex(0, 0, e)
          , f = s.AddVertex(0, 0, -e);
        return o.GenerateTriangleFan(a[0].slice().reverse(), h),
        o.GenerateTriangleFan(a[a.length - 1], f),
        s.ResetCurve(),
        s.GetMesh()
    }
    function sx(r, e, t) {
        function n(s, o, a, l, c) {
            let u = new ze(a,l,c);
            u.MultiplyScalar(o / u.Length()),
            s.AddVertex(u.x, u.y, u.z)
        }
        if (!zi(t))
            return null;
        let i = new yo(r);
        if (e === "tetrahedron") {
            let s = 1;
            n(i, t, +s, +s, +s),
            n(i, t, -s, -s, +s),
            n(i, t, -s, +s, -s),
            n(i, t, +s, -s, -s),
            i.AddTriangle(0, 1, 3),
            i.AddTriangle(0, 2, 1),
            i.AddTriangle(0, 3, 2),
            i.AddTriangle(1, 2, 3)
        } else if (e === "hexahedron") {
            let s = 1;
            n(i, t, +s, +s, +s),
            n(i, t, +s, +s, -s),
            n(i, t, +s, -s, +s),
            n(i, t, +s, -s, -s),
            n(i, t, -s, +s, +s),
            n(i, t, -s, +s, -s),
            n(i, t, -s, -s, +s),
            n(i, t, -s, -s, -s),
            i.AddConvexPolygon([0, 1, 5, 4]),
            i.AddConvexPolygon([0, 2, 3, 1]),
            i.AddConvexPolygon([0, 4, 6, 2]),
            i.AddConvexPolygon([1, 3, 7, 5]),
            i.AddConvexPolygon([2, 6, 7, 3]),
            i.AddConvexPolygon([4, 5, 7, 6])
        } else if (e === "octahedron") {
            let s = 1
              , o = 0;
            n(i, t, +s, +o, +o),
            n(i, t, -s, +o, +o),
            n(i, t, +o, +s, +o),
            n(i, t, +o, -s, +o),
            n(i, t, +o, +o, +s),
            n(i, t, +o, +o, -s),
            i.AddTriangle(0, 2, 4),
            i.AddTriangle(0, 3, 5),
            i.AddTriangle(0, 4, 3),
            i.AddTriangle(0, 5, 2),
            i.AddTriangle(1, 2, 5),
            i.AddTriangle(1, 3, 4),
            i.AddTriangle(1, 4, 2),
            i.AddTriangle(1, 5, 3)
        } else if (e === "dodecahedron") {
            let s = 1
              , o = 0
              , a = (1 + Math.sqrt(5)) / 2
              , l = 1 / a;
            n(i, t, +s, +s, +s),
            n(i, t, +s, +s, -s),
            n(i, t, +s, -s, +s),
            n(i, t, -s, +s, +s),
            n(i, t, +s, -s, -s),
            n(i, t, -s, +s, -s),
            n(i, t, -s, -s, +s),
            n(i, t, -s, -s, -s),
            n(i, t, +o, +l, +a),
            n(i, t, +o, +l, -a),
            n(i, t, +o, -l, +a),
            n(i, t, +o, -l, -a),
            n(i, t, +l, +a, +o),
            n(i, t, +l, -a, +o),
            n(i, t, -l, +a, +o),
            n(i, t, -l, -a, +o),
            n(i, t, +a, +o, +l),
            n(i, t, -a, +o, +l),
            n(i, t, +a, +o, -l),
            n(i, t, -a, +o, -l),
            i.AddConvexPolygon([0, 8, 10, 2, 16]),
            i.AddConvexPolygon([0, 16, 18, 1, 12]),
            i.AddConvexPolygon([0, 12, 14, 3, 8]),
            i.AddConvexPolygon([1, 9, 5, 14, 12]),
            i.AddConvexPolygon([1, 18, 4, 11, 9]),
            i.AddConvexPolygon([2, 10, 6, 15, 13]),
            i.AddConvexPolygon([2, 13, 4, 18, 16]),
            i.AddConvexPolygon([3, 14, 5, 19, 17]),
            i.AddConvexPolygon([3, 17, 6, 10, 8]),
            i.AddConvexPolygon([4, 13, 15, 7, 11]),
            i.AddConvexPolygon([5, 9, 11, 7, 19]),
            i.AddConvexPolygon([6, 17, 19, 7, 15])
        } else if (e === "icosahedron") {
            let s = 1
              , o = 0
              , a = (1 + Math.sqrt(5)) / 2;
            n(i, t, +o, +s, +a),
            n(i, t, +o, +s, -a),
            n(i, t, +o, -s, +a),
            n(i, t, +o, -s, -a),
            n(i, t, +s, +a, +o),
            n(i, t, +s, -a, +o),
            n(i, t, -s, +a, +o),
            n(i, t, -s, -a, +o),
            n(i, t, +a, +o, +s),
            n(i, t, +a, +o, -s),
            n(i, t, -a, +o, +s),
            n(i, t, -a, +o, -s),
            i.AddTriangle(0, 2, 8),
            i.AddTriangle(0, 4, 6),
            i.AddTriangle(0, 6, 10),
            i.AddTriangle(0, 8, 4),
            i.AddTriangle(0, 10, 2),
            i.AddTriangle(1, 3, 11),
            i.AddTriangle(1, 4, 9),
            i.AddTriangle(1, 6, 4),
            i.AddTriangle(1, 9, 3),
            i.AddTriangle(1, 11, 6),
            i.AddTriangle(2, 5, 8),
            i.AddTriangle(2, 7, 5),
            i.AddTriangle(2, 10, 7),
            i.AddTriangle(3, 5, 7),
            i.AddTriangle(3, 7, 11),
            i.AddTriangle(3, 9, 5),
            i.AddTriangle(4, 8, 9),
            i.AddTriangle(5, 9, 8),
            i.AddTriangle(6, 11, 10),
            i.AddTriangle(7, 10, 11)
        }
        return i.GetMesh()
    }
    var cc = class {
        constructor(e, t) {
            this.parentElement = e,
            this.parameters = {},
            Hr(t) && (this.parameters = t),
            this.canvas = document.createElement("canvas"),
            this.parentElement.appendChild(this.canvas),
            this.viewer = new Kr,
            this.viewer.Init(this.canvas);
            let n = this.parentElement.clientWidth
              , i = this.parentElement.clientHeight;
            this.viewer.Resize(n, i),
            this.parameters.cameraMode && this.viewer.SetCameraMode(this.parameters.cameraMode),
            this.parameters.backgroundColor && this.viewer.SetBackgroundColor(this.parameters.backgroundColor),
            this.parameters.edgeSettings && this.viewer.SetEdgeSettings(this.parameters.edgeSettings),
            this.parameters.environmentSettings && this.viewer.SetEnvironmentMapSettings(this.parameters.environmentSettings),
            this.model = null,
            this.modelLoader = new uo,
            window.addEventListener("resize", ()=>{
                this.Resize()
            }
            )
        }
        LoadModelFromUrlList(e) {
            to(e);
            let t = no(e);
            this.LoadModelFromInputFiles(t)
        }
        LoadModelFromFileList(e) {
            let t = al(e);
            this.LoadModelFromInputFiles(t)
        }
        LoadModelFromInputFiles(e) {
            if (e === null || e.length === 0)
                return;
            this.viewer.Clear();
            let t = new br;
            this.parameters.defaultColor && (t.defaultColor = this.parameters.defaultColor),
            this.model = null;
            let n = null;
            this.modelLoader.LoadModel(e, t, {
                onLoadStart: ()=>{
                    this.canvas.style.display = "none",
                    n = document.createElement("div"),
                    n.innerHTML = "Loading model...",
                    this.parentElement.appendChild(n)
                }
                ,
                onFileListProgress: (i,s)=>{}
                ,
                onFileLoadProgress: (i,s)=>{}
                ,
                onImportStart: ()=>{
                    n.innerHTML = "Importing model..."
                }
                ,
                onVisualizationStart: ()=>{
                    n.innerHTML = "Visualizing model..."
                }
                ,
                onModelFinished: (i,s)=>{
                    this.parentElement.removeChild(n),
                    this.canvas.style.display = "inherit",
                    this.viewer.SetMainObject(s);
                    let o = this.viewer.GetBoundingSphere(a=>!0);
                    this.viewer.AdjustClippingPlanesToSphere(o),
                    this.parameters.camera ? this.viewer.SetCamera(this.parameters.camera) : (this.viewer.SetUpVector(lt.Y, !1),
                    this.viewer.FitSphereToWindow(o, !1)),
                    this.model = i.model,
                    this.parameters.onModelLoaded && this.parameters.onModelLoaded()
                }
                ,
                onTextureLoaded: ()=>{
                    this.viewer.Render()
                }
                ,
                onLoadError: i=>{
                    let s = "Unknown error.";
                    i.code === Un.NoImportableFile ? s = "No importable file found." : i.code === Un.FailedToLoadFile ? s = "Failed to load file for import." : i.code === Un.ImportFailed && (s = "Failed to import model."),
                    i.message !== null && (s += " (" + i.message + ")"),
                    n.innerHTML = s
                }
            })
        }
        GetViewer() {
            return this.viewer
        }
        GetModel() {
            return this.model
        }
        Resize() {
            let e = this.parentElement.clientWidth
              , t = this.parentElement.clientHeight;
            this.viewer.Resize(e, t)
        }
        Destroy() {
            this.modelLoader.Destroy(),
            this.viewer.Destroy(),
            this.model = null
        }
    }
    ;
    function lg(r, e, t) {
        let n = new cc(r,t);
        return n.LoadModelFromUrlList(e),
        n
    }
    function ox(r, e, t) {
        let n = new cc(r,t);
        return n.LoadModelFromFileList(e),
        n
    }
    function ax(r) {
        function e(i) {
            let s = null
              , o = i.getAttribute("camera");
            o && (s = Yt.StringToCamera(o));
            let a = null
              , l = i.getAttribute("cameramode");
            l && (a = Yt.StringToCameraMode(l));
            let c = null
              , u = i.getAttribute("backgroundcolor");
            u && (c = Yt.StringToRGBAColor(u));
            let h = null
              , f = i.getAttribute("defaultcolor");
            f && (h = Yt.StringToRGBColor(f));
            let m = null
              , g = i.getAttribute("edgesettings");
            g && (m = Yt.StringToEdgeSettings(g));
            let v = null
              , p = i.getAttribute("environmentmap");
            if (p) {
                let y = p.split(",");
                if (y.length === 6) {
                    let _ = !1
                      , S = i.getAttribute("environmentmapbg");
                    S && S === "true" && (_ = !0),
                    v = new Bi(y,_)
                }
            }
            let d = null
              , x = i.getAttribute("model");
            return x && (d = Yt.StringToModelUrls(x)),
            lg(i, d, {
                camera: s,
                cameraMode: a,
                backgroundColor: c,
                defaultColor: h,
                edgeSettings: m,
                environmentSettings: v
            })
        }
        let t = []
          , n = document.getElementsByClassName("online_3d_viewer");
        for (let i = 0; i < n.length; i++) {
            let s = n[i]
              , o = e(s);
            t.push(o)
        }
        return t
    }
    var MA = {
        ButtonDialog: Qn,
        ProgressDialog: ho,
        ShowMessageDialog: Er,
        HandleEvent: dn
    };
    function EA(r) {
        Gy(r)
    }
    function SA(r) {
        rg(ac.Header, r)
    }
    function wA(r) {
        rg(ac.Toolbar, r)
    }
    function AA(r) {
        uc(r),
        window.addEventListener("load", ()=>{
            new cd({
                headerDiv: document.getElementById("header"),
                headerButtonsDiv: document.getElementById("header_buttons"),
                toolbarDiv: document.getElementById("toolbar"),
                mainDiv: document.getElementById("main"),
                introDiv: document.getElementById("intro"),
                fileNameDiv: document.getElementById("main_file_name"),
                leftContainerDiv: document.getElementById("main_left_container"),
                navigatorDiv: document.getElementById("main_navigator"),
                navigatorSplitterDiv: document.getElementById("main_navigator_splitter"),
                rightContainerDiv: document.getElementById("main_right_container"),
                sidebarDiv: document.getElementById("main_sidebar"),
                sidebarSplitterDiv: document.getElementById("main_sidebar_splitter"),
                viewerDiv: document.getElementById("main_viewer"),
                fileInput: document.getElementById("open_file")
            }).Load()
        }
        )
    }
    function CA(r) {
        uc(r),
        window.addEventListener("load", ()=>{
            new zf({
                viewerDiv: document.getElementById("embed_viewer"),
                websiteLinkDiv: document.getElementById("website_link")
            }).Load()
        }
        )
    }
    return xx(IA);
}
)();
